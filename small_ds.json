[
  {
    "language": "Go",
    "code": "func (r *ReplicaSet) rollbackCmd(evt *tcell.EventKey) *tcell.EventKey {path := r.GetTable().GetSelectedItem()if path == \"\" {return evt}"
  },
  {
    "language": "Go",
    "code": "r.showModal(fmt.Sprintf(\"Rollback %s %s?\", r.GVR(), path), func(_ int, button string) {defer r.dismissModal()if button != \"OK\" {"
  },
  {
    "language": "Go",
    "code": "},// NewLiveView returns a live viewer.func NewLiveView(app *App, title string, m model.ResourceViewer) *LiveView {v := LiveView{"
  },
  {
    "language": "Go",
    "code": "return &sts, nil}// ScanSA scans for serviceaccount refs.func (s *StatefulSet) ScanSA(ctx context.Context, fqn string, wait bool) (Refs, error) {"
  },
  {
    "language": "Go",
    "code": "return nil, errors.New(\"NYI!!\")}// Ensure makes sure alias are loaded.func (a *Alias) Ensure() (config.Alias, error) {"
  },
  {
    "language": "Go",
    "code": "package daoimport (\"errors\"\"fmt\""
  },
  {
    "language": "Go",
    "code": "}rb, err := polymorphichelpers.RollbackerFor(schema.GroupKind{Group: apiGroup,Kind:  kind},"
  },
  {
    "language": "Go",
    "code": "package daoimport (\"fmt\""
  },
  {
    "language": "Go",
    "code": "\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\"k8s.io/apimachinery/pkg/runtime\")func mustMap(o runtime.Object, field string) map[string]interface{} {"
  },
  {
    "language": "Go",
    "code": "var (escPattern = regexp.MustCompile(`(\\[[a-zA-Z0-9_,;: \\-\\.\"#]+\\[*)\\]`)matcher    = []byte(\"$1[]\"))"
  },
  {
    "language": "Go",
    "code": "if IsFuzzySelector(q) {mm, ii := l.fuzzyFilter(strings.TrimSpace(q[2:]), showTime)return mm, ii, nil}matches, indices, err := l.filterLogs(q, showTime)"
  },
  {
    "language": "Go",
    "code": "// WaitForCacheSync synchronize the cache.WaitForCacheSync()// DeleteForwarder deletes a pod forwarder.DeleteForwarder(path string)"
  },
  {
    "language": "Go",
    "code": "// Logs tails a resource logs.Logs(path string, opts *v1.PodLogOptions) (*restclient.Request, error)}// ContainsPodSpec represents a resource with a pod template."
  },
  {
    "language": "Go",
    "code": "Scope: RestMapping,}}// Name protocol returns rest scope name."
  },
  {
    "language": "Go",
    "code": "GVR string}// Checks represents a collection of health checks."
  },
  {
    "language": "Go",
    "code": "package health_testimport (\"testing\""
  },
  {
    "language": "Go",
    "code": "Run:   run,})func init() {"
  },
  {
    "language": "Go",
    "code": "}}// Execute root commandfunc Execute() {"
  },
  {
    "language": "Go",
    "code": "if *k9sFlags.RefreshRate != config.DefaultRefreshRate {k9sCfg.K9s.OverrideRefreshRate(*k9sFlags.RefreshRate)}k9sCfg.K9s.OverrideHeadless(*k9sFlags.Headless)"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\n procedure Doors is\n    type Door_State is (Closed, Open);\n    type Door_List is array(Positive range 1..100) of Door_State;\n    The_Doors : Door_List := (others => Closed);\n begin\n    for I in 1..100 loop\n       for J in The_Doors'range loop\n          if J mod I = 0 then\n             if The_Doors(J) = Closed then\n                 The_Doors(J) := Open;\n             else\n                The_Doors(J) := Closed;\n             end if;\n          end if;\n       end loop;\n    end loop;\n    for I in The_Doors'range loop\n       Put_Line(Integer'Image(I) & \" is \" & Door_State'Image(The_Doors(I)));\n    end loop;\n end Doors;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n with Ada.Numerics.Elementary_Functions; use Ada.Numerics.Elementary_Functions;\n\n procedure Doors_Optimized is\n    Num : Float;\n begin\n    for I in 1..100 loop\n       Num := Sqrt(Float(I));\n       Put(Integer'Image(I) & \" is \");\n       if Float'Floor(Num) = Num then\n          Put_Line(\"Opened\");\n       else\n          Put_Line(\"Closed\");\n       end if;\n    end loop;\n end Doors_Optimized;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\nprocedure Game_24 is\n   subtype Operation is Character;\n   type Op_Array is array (Positive range <>) of Operation;\n   type Digit is range 1 .. 9;\n   type Digit_Array is array (Positive range <>) of Digit;\n   package Digit_IO is new Ada.Text_IO.Integer_IO (Digit);\n   package Random_Digit is new Ada.Numerics.Discrete_Random (Digit);\n   Digit_Generator : Random_Digit.Generator;\n   Given_Digits : array (1 .. 4) of Digit;\nbegin\n   Ada.Text_IO.Put_Line (\"24 Game\");\n   Ada.Text_IO.Put_Line (\"Generating 4 digits...\");\n   Random_Digit.Reset (Digit_Generator);\n   for I in Given_Digits'Range loop\n      Given_Digits (I) := Random_Digit.Random (Digit_Generator);\n   end loop;\n   Ada.Text_IO.Put (\"Your Digits:\");\n   for I in Given_Digits'Range loop\n      Digit_IO.Put (Given_Digits (I));\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Enter your Expression: \");\n   declare\n      Value : Integer;\n      Input_Operations : Op_Array (1 .. 3);\n      Input_Digits : Digit_Array (1 .. 4);\n      Unused_Digits : array (Given_Digits'Range) of Boolean :=\n        (others => True);\n   begin\n      -- get input\n      for I in 1 .. 4 loop\n         Digit_IO.Get (Input_Digits (I));\n         exit when I = 4;\n         Ada.Text_IO.Get (Input_Operations (I));\n      end loop;\n      -- check input\n      for I in Input_Digits'Range loop\n         declare\n            Found : Boolean := False;\n         begin\n            for J in Given_Digits'Range loop\n               if Unused_Digits (J) and then\n                 Given_Digits (J) = Input_Digits (I) then\n                  Unused_Digits (J) := False;\n                  Found := True;\n                  exit;\n               end if;\n            end loop;\n            if not Found then\n               Ada.Text_IO.Put_Line (\"Illegal Number used:\" &\n                                     Digit'Image (Input_Digits (I)));\n               return;\n            end if;\n         end;\n      end loop;\n      -- check value\n      Value := Integer (Input_Digits (Input_Digits'First));\n      for I in Input_Operations'Range loop\n         case Input_Operations (I) is\n            when '+' =>\n               Value := Value + Integer (Input_Digits (I + 1));\n            when '-' =>\n               Value := Value - Integer (Input_Digits (I + 1));\n            when '*' =>\n               Value := Value * Integer (Input_Digits (I + 1));\n            when '/' =>\n               Value := Value / Integer (Input_Digits (I + 1));\n            when others =>\n               Ada.Text_IO.Put_Line (\"Illegal Op used:\" &\n                                     Input_Operations (I));\n               return;\n         end case;\n      end loop;\n      if Value /= 24 then\n         Ada.Text_IO.Put_Line (\"Value\" & Integer'Image (Value) &\n                               \" is not 24!\");\n      else\n         Ada.Text_IO.Put_Line (\"You won!\");\n      end if;\n   end;\nend Game_24;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\n procedure Bottles is\n begin\n    for X in reverse 1..99 loop\n       Put_Line(Integer'Image(X) & \" bottles of beer on the wall\");\n       Put_Line(Integer'Image(X) & \" bottles of beer\");\n       Put_Line(\"Take one down, pass it around\");\n       Put_Line(Integer'Image(X - 1) & \" bottles of beer on the wall\");\n       New_Line;\n    end loop;\n end Bottles;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Tasking_99_Bottles is\n   subtype Num_Bottles is Natural range 1..99;\n   task Print is\n      entry Set (Num_Bottles);\n   end Print;\n   task body Print is\n      Num : Natural;\n   begin\n      for I in reverse Num_Bottles'range loop\n         select\n         accept\n            Set(I) do -- Rendezvous with Counter task I\n               Num := I;\n            end Set;\n            Put_Line(Integer'Image(Num) & \" bottles of beer on the wall\");\n            Put_Line(Integer'Image(Num) & \" bottles of beer\");\n            Put_Line(\"Take one down, pass it around\");\n            Put_Line(Integer'Image(Num - 1) & \" bottles of beer on the wall\");\n            New_Line;\n         or terminate; -- end when all Counter tasks have completed\n         end select;\n      end loop;\n   end Print;\n   task type Counter(I : Num_Bottles);\n   task body Counter is\n   begin\n      Print.Set(I);\n   end Counter;\n   type Task_Access is access Counter;\n\n   Task_List : array(Num_Bottles) of Task_Access;\n\nbegin\n   for I in Task_List'range loop -- Create 99 Counter tasks\n      Task_List(I) := new Counter(I);\n   end loop;\nend Tasking_99_Bottles;\n"
  },
  {
    "language": "Ada",
    "code": "-- Standard I/O Streams\n\nwith Ada.Integer_Text_Io;\nprocedure APlusB is\n   A, B : Integer;\nbegin\n   Ada.Integer_Text_Io.Get (Item => A);\n   Ada.Integer_Text_Io.Get (Item => B);\n   Ada.Integer_Text_Io.Put (A+B);\nend APlusB;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\n\nprocedure A_Plus_B is\n   type Small_Integers is range -2_000 .. +2_000;\n   subtype Input_Values is Small_Integers range -1_000 .. +1_000;\n   package IO is new Ada.Text_IO.Integer_IO (Num => Small_Integers);\n   A, B : Input_Values;\nbegin\n   IO.Get (A);\n   IO.Get (B);\n   IO.Put (A + B, Width => 4, Base => 10);\nend A_Plus_B;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Characters.Handling;\nuse Ada.Characters.Handling;\n\n\npackage Abc is\n    type Block_Faces is array(1..2) of Character;\n    type Block_List is array(positive range <>) of Block_Faces;\n    function Can_Make_Word(W: String; Blocks: Block_List) return Boolean;\nend Abc;\n\n\npackage body Abc is\n\nfunction Can_Make_Word(W: String; Blocks: Block_List) return Boolean is\n    Used : array(Blocks'Range) of Boolean := (Others => False);\n    subtype wIndex is Integer range W'First..W'Last;\n    wPos : wIndex;\nbegin\n    if W'Length = 0 then\n        return True;\n    end if;\n    wPos := W'First;\n    while True loop\n        declare\n            C : Character := To_Upper(W(wPos));\n            X : constant wIndex := wPos;\n        begin\n            for I in Blocks'Range loop\n                if (not Used(I)) then\n                    if C = To_Upper(Blocks(I)(1)) or C = To_Upper(Blocks(I)(2)) then\n                        Used(I) := True;\n                        if wPos = W'Last then\n                            return True;\n                        end if;\n                        wPos := wIndex'Succ(wPos);\n                        exit;\n                    end if;\n                end if;\n            end loop;\n            if X = wPos then\n                return False;\n            end if;\n        end;\n    end loop;\n    return False;\nend Can_Make_Word;\n\nend Abc;\n\nwith Ada.Text_IO, Ada.Strings.Unbounded, Abc;\nuse Ada.Text_IO, Ada.Strings.Unbounded, Abc;\n\nprocedure Abc_Problem is\n    Blocks : Block_List := (\n          ('B','O'), ('X','K'), ('D','Q'), ('C','P')\n        , ('N','A'), ('G','T'), ('R','E'), ('T','G')\n        , ('Q','D'), ('F','S'), ('J','W'), ('H','U')\n        , ('V','I'), ('A','N'), ('O','B'), ('E','R')\n        , ('F','S'), ('L','Y'), ('P','C'), ('Z','M')\n    );\n    function \"+\" (S : String) return Unbounded_String renames To_Unbounded_String;\n    words : array(positive range <>) of Unbounded_String := (\n          +\"A\"\n        , +\"BARK\"\n        , +\"BOOK\"\n        , +\"TREAT\"\n        , +\"COMMON\"\n        , +\"SQUAD\"\n        , +\"CONFUSE\"\n        -- Border cases:\n        -- , +\"CONFUSE2\"\n        -- , +\"\"\n    );\nbegin\n    for I in words'Range loop\n        Put_Line ( To_String(words(I)) & \": \" & Boolean'Image(Can_Make_Word(To_String(words(I)),Blocks)) );\n    end loop;\nend Abc_Problem;\n"
  },
  {
    "language": "Ada",
    "code": "type Queue is limited interface;\nprocedure Enqueue (Lounge : in out Queue; Item : in out Element) is abstract;\nprocedure Dequeue (Lounge : in out Queue; Item : in out Element) is abstract;\n"
  },
  {
    "language": "Ada",
    "code": "type Scheduler is task interface;\nprocedure Plan (Manager : in out Scheduler; Activity : in out Job) is abstract;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Finalization;\n...\ntype Node is abstract new Ada.Finalization.Limited_Controlled and Queue with record\n   Previous : not null access Node'Class := Node'Unchecked_Access;\n   Next     : not null access Node'Class := Node'Unchecked_Access;\nend record;\noverriding procedure Finalize (X : in out Node); -- Removes the node from its list if any\noverriding procedure Dequeue (Lounge : in out Node; Item : in out Element);\noverriding procedure Enqueue (Lounge : in out Node; Item : in out Element);\nprocedure Process (X : in out Node) is abstract; -- To be implemented\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Generic_Divisors;\n\nprocedure ADB_Classification is\n   function Same(P: Positive) return Positive is (P);\n   package Divisor_Sum is new Generic_Divisors\n     (Result_Type => Natural, None => 0, One => Same, Add =>  \"+\");\n\n   type Class_Type is (Deficient, Perfect, Abundant);\n\n   function Class(D_Sum, N: Natural) return Class_Type is\n      (if D_Sum < N then Deficient\n       elsif D_Sum = N then Perfect\n       else Abundant);\n\n   Cls: Class_Type;\n   Results: array (Class_Type) of Natural := (others => 0);\n\n   package NIO is new Ada.Text_IO.Integer_IO(Natural);\n   package CIO is new Ada.Text_IO.Enumeration_IO(Class_Type);\nbegin\n   for N in 1 .. 20_000 loop\n      Cls := Class(Divisor_Sum.Process(N), N);\n      Results(Cls) := Results(Cls)+1;\n   end loop;\n   for Class in Results'Range loop\n      CIO.Put(Class, 12);\n      NIO.Put(Results(Class), 8);\n      Ada.Text_IO.New_Line;\n   end loop;\n   Ada.Text_IO.Put_Line(\"--------------------\");\n   Ada.Text_IO.Put(\"Sum         \");\n   NIO.Put(Results(Deficient)+Results(Perfect)+Results(Abundant), 8);\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put_Line(\"====================\");\nend ADB_Classification;\n"
  },
  {
    "language": "Ada",
    "code": "with Accumulator;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Example is\n   package A is new Accumulator;\n   package B is new Accumulator;\nbegin\n   Put_Line (Integer'Image (A.The_Function (5)));\n   Put_Line (Integer'Image (B.The_Function (3)));\n   Put_Line (Float'Image (A.The_Function (2.3)));\nend;\n"
  },
  {
    "language": "Ada",
    "code": "generic package Accumulator is\n\n--  This Ada generic package represents an accumulator factory.\n--  The required function is provided as The_Function.\n--  The first call to The_Function sets the initial value.\n--  (Marius Amado-Alves)\n\n   function The_Function (X : Integer) return Integer;\n   function The_Function (X : Integer) return Float;\n   function The_Function (X : Float) return Float;\nend;\n"
  },
  {
    "language": "Ada",
    "code": "package body Accumulator is\n\n--  The accumulator lives through three states. It is in Virgin_State\n--  before any use of The_Function. It changes to Integer_State or\n--  Float_State, according to the input type used. The accumulation is\n--  memorized in variable I or F, according to the state. Float_State,\n--  once reached, is never left. A Float output on an Integer_State is\n--  simply a conversion, sans effect on state. (Marius Amado-Alves)\n\n   type State_T is (Virgin_State, Integer_State, Float_State);\n   State : State_T := Virgin_State;\n   I : Integer;\n   F : Float;\n\n   function The_Function (X : Float) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Float_State;\n            F := X;\n            return F;\n         when Integer_State =>\n            State := Float_State;\n            F := Float (I) + X;\n            return F;\n         when Float_State =>\n            F := F + X;\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return Float (I);\n         when Integer_State =>\n            I := I + X;\n            return Float (I);\n         when Float_State =>\n            F := F + Float (X);\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Integer is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return I;\n         when Integer_State =>\n            I := I + X;\n            return I;\n         when Float_State =>\n            F := F + Float (X);\n            return Integer (F);\n      end case;\n   end;\n\nend;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Ackermann is\n   function Ackermann (M, N : Natural) return Natural is\n   begin\n      if M = 0 then\n         return N + 1;\n      elsif N = 0 then\n         return Ackermann (M - 1, 1);\n      else\n         return Ackermann (M - 1, Ackermann (M, N - 1));\n      end if;\n   end Ackermann;\nbegin\n   for M in 0..3 loop\n      for N in 0..6 loop\n         Put (Natural'Image (Ackermann (M, N)));\n      end loop;\n      New_Line;\n   end loop;\nend Test_Ackermann;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Calendar;                       use Ada.Calendar;\nwith Ada.Numerics;                       use Ada.Numerics;\nwith Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;\nwith Ada.Text_IO;                        use Ada.Text_IO;\n\nprocedure Test_Integrator is\n   type Func is access function (T : Time) return Float;\n\n   function Zero (T : Time) return Float is\n   begin\n      return 0.0;\n   end Zero;\n\n   Epoch : constant Time := Clock;\n\n   function Sine (T : Time) return Float is\n   begin\n      return Sin (Pi * Float (T - Epoch));\n   end Sine;\n\n   task type Integrator is\n      entry Input  (Value : Func);\n      entry Output (Value : out Float);\n      entry Shut_Down;\n   end Integrator;\n\n   task body Integrator is\n      K  : Func  := Zero'Access;\n      S  : Float := 0.0;\n      F0 : Float := 0.0;\n      F1 : Float;\n      T0 : Time  := Clock;\n      T1 : Time;\n   begin\n      loop\n         select\n            accept Input (Value : Func) do\n               K := Value;\n            end Input;\n         or accept Output (Value : out Float) do\n               Value := S;\n            end Output;\n         or accept Shut_Down;\n            exit;\n         else\n            T1 := Clock;\n            F1 := K (T1);\n            S  := S + 0.5 * (F1 + F0) * Float (T1 - T0);\n            T0 := T1;\n            F0 := F1;\n         end select;\n      end loop;\n   end Integrator;\n\n   I : Integrator;\n   S : Float;\nbegin\n   I.Input (Sine'Access);\n   delay 2.0;\n   I.Input (Zero'Access);\n   delay 0.5;\n   I.Output (S);\n   Put_Line (\"Integrated\" & Float'Image (S) & \"s\");\n   I.Shut_Down;\nend Test_Integrator;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Dynamic is\n   package Abstract_Class is\n      type Class is limited interface;\n      function Boo (X : Class) return String is abstract;\n   end Abstract_Class;\n   use Abstract_Class;\n\n   package Base_Class is\n      type Base is new Class with null record;\n      overriding function Boo (X : Base) return String;\n   end Base_Class;\n\n   package body Base_Class is\n      function Boo (X : Base) return String is\n      begin\n         return \"I am Class\";\n      end Boo;\n   end Base_Class;\n   use Base_Class;\n\n   E : aliased Base;  -- An instance of Base\n\nbegin\n   -- Gone run-time\n   declare\n      type Monkey_Patch (Root : access Base) is new Class with record\n         Foo : Integer := 1;\n      end record;\n      overriding function Boo (X : Monkey_Patch) return String;\n      function Boo (X : Monkey_Patch) return String is\n      begin -- Delegation to the base\n         return X.Root.Boo;\n      end Boo;\n      EE : Monkey_Patch (E'Access); -- Extend E\n   begin\n      Put_Line (EE.Boo & \" with\" & Integer'Image (EE.Foo));\n   end;\nend Dynamic;\n"
  },
  {
    "language": "Ada",
    "code": "The_Address : System.Address;\nI : Integer;\nThe_Address := I'Address;\n"
  },
  {
    "language": "Ada",
    "code": "I : Integer;\nfor I'Address use 16#A100#;\n"
  },
  {
    "language": "Ada",
    "code": "I : Integer;\nJ : Integer;\nfor I'Address use J'Address;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\n\nprocedure Test_For_Primes is\n\n   type Pascal_Triangle_Type is array (Natural range <>) of Long_Long_Integer;\n\n   function Calculate_Pascal_Triangle (N : in Natural) return Pascal_Triangle_Type is\n      Pascal_Triangle : Pascal_Triangle_Type (0 .. N);\n   begin\n      Pascal_Triangle (0) := 1;\n      for I in Pascal_Triangle'First .. Pascal_Triangle'Last - 1 loop\n         Pascal_Triangle (1 + I) := 1;\n         for J in reverse 1 .. I loop\n            Pascal_Triangle (J) := Pascal_Triangle (J - 1) - Pascal_Triangle (J);\n         end loop;\n         Pascal_Triangle (0) := -Pascal_Triangle (0);\n      end loop;\n      return Pascal_Triangle;\n   end Calculate_Pascal_Triangle;\n\n   function Is_Prime (N : Integer) return Boolean is\n      I      : Integer;\n      Result : Boolean := True;\n      Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n   begin\n      I := N / 2;\n      while Result and I > 1 loop\n         Result := Result and Pascal_Triangle (I) mod Long_Long_Integer (N) = 0;\n         I := I - 1;\n      end loop;\n      return Result;\n   end Is_Prime;\n\n   function Image (N    : in Long_Long_Integer;\n                   Sign : in Boolean := False) return String is\n      Image : constant String := N'Image;\n   begin\n      if N < 0 then\n         return Image;\n      else\n         if Sign then\n            return \"+\" & Image (Image'First + 1 .. Image'Last);\n         else\n            return Image (Image'First + 1 .. Image'Last);\n         end if;\n      end if;\n   end Image;\n\n   procedure Show (Triangle : in Pascal_Triangle_Type) is\n      use Ada.Text_IO;\n   Begin\n      for I in reverse Triangle'Range loop\n         Put (Image (Triangle (I), Sign => True));\n         Put (\"x^\");\n         Put (Image (Long_Long_Integer (I)));\n         Put (\" \");\n      end loop;\n   end Show;\n\n   procedure Show_Pascal_Triangles is\n      use Ada.Text_IO;\n   begin\n      for N in 0 .. 9 loop\n         declare\n            Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n         begin\n            Put (\"(x-1)^\" & Image (Long_Long_Integer (N)) & \" = \");\n            Show (Pascal_Triangle);\n            New_Line;\n         end;\n      end loop;\n   end Show_Pascal_Triangles;\n\n   procedure Show_Primes is\n      use Ada.Text_IO;\n   begin\n      for N in 2 .. 63 loop\n         if Is_Prime (N) then\n            Put (N'Image);\n         end if;\n      end loop;\n      New_Line;\n   end Show_Primes;\n\nbegin\n   Show_Pascal_Triangles;\n   Show_Primes;\nend Test_For_Primes;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Characters.Latin_1;  use Ada.Characters.Latin_1;\nwith Ada.Text_IO;             use Ada.Text_IO;\nwith Strings_Edit;            use Strings_Edit;\n\nprocedure Column_Aligner is\n   Text : constant String :=\n      \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & NUL &\n      \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & NUL &\n      \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & NUL &\n      \"column$are$separated$by$at$least$one$space.\" & NUL &\n      \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & NUL &\n      \"justified,$right$justified,$or$center$justified$within$its$column.\" & NUL;\n   File    : File_Type;\n   Width   : array (1..1_000) of Natural := (others => 0);\n   Line    : String (1..200);\n   Column  : Positive := 1;\n   Start   : Positive := 1;\n   Pointer : Positive;\nbegin\n   Create (File, Out_File, \"columned.txt\");\n      -- Determining the widths of columns\n   for I in Text'Range loop\n      case Text (I) is\n         when '$' | NUL =>\n            Width (Column) := Natural'Max (Width (Column), I - Start + 1);\n            Start  := I + 1;\n            if Text (I) = NUL then\n               Column := 1;\n            else\n               Column := Column + 1;\n            end if;\n         when others =>\n            null;\n      end case;\n   end loop;\n      -- Formatting\n   for Align in Alignment loop\n      Column  := 1;\n      Start   := 1;\n      Pointer := 1;\n      for I in Text'Range loop\n         case Text (I) is\n            when '$' | NUL =>\n               Put -- Formatted output of a word\n               (  Destination => Line,\n                  Pointer     => Pointer,\n                  Value       => Text (Start..I - 1),\n                  Field       => Width (Column),\n                  Justify     => Align\n               );\n               Start  := I + 1;\n               if Text (I) = NUL then\n                  Put_Line (File, Line (1..Pointer - 1));\n                  Pointer := 1;\n                  Column := 1;\n               else\n                  Column := Column + 1;\n               end if;\n            when others =>\n               null;\n         end case;\n      end loop;\n   end loop;\n   Close (File);\nend Column_Aligner;\n"
  },
  {
    "language": "Ada",
    "code": "with Prime_Numbers, Ada.Text_IO;\n\nprocedure Test_Kth_Prime is\n\n   package Integer_Numbers is new\n     Prime_Numbers (Natural, 0, 1, 2);\n   use Integer_Numbers;\n\n   Out_Length: constant Positive := 10; -- 10 k-th almost primes\n   N: Positive; -- the \"current number\" to be checked\n\nbegin\n   for K in 1 .. 5 loop\n      Ada.Text_IO.Put(\"K =\" & Integer'Image(K) &\":  \");\n      N := 2;\n      for I in 1 .. Out_Length loop\n\t while Decompose(N)'Length /= K loop\n\t    N := N + 1;\n\t end loop; -- now N is Kth almost prime;\n\t Ada.Text_IO.Put(Integer'Image(Integer(N)));\n\t N := N + 1;\n      end loop;\n      Ada.Text_IO.New_Line;\n   end loop;\nend Test_Kth_Prime;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;\nwith Ada.Text_IO;            use Ada.Text_IO;\n\nprocedure Test_Amb is\n   type Alternatives is array (Positive range <>) of Unbounded_String;\n\n   type Amb (Count : Positive) is record\n      This : Positive := 1;\n      Left : access Amb;\n      List : Alternatives (1..Count);\n   end record;\n\n   function Image (L : Amb) return String is\n   begin\n      return To_String (L.List (L.This));\n   end Image;\n\n   function \"/\" (L, R : String) return Amb is\n      Result : Amb (2);\n   begin\n      Append (Result.List (1), L);\n      Append (Result.List (2), R);\n      return Result;\n   end \"/\";\n\n   function \"/\" (L : Amb; R : String) return Amb is\n      Result : Amb (L.Count + 1);\n   begin\n      Result.List (1..L.Count) := L.List ;\n      Append (Result.List (Result.Count), R);\n      return Result;\n   end \"/\";\n\n   function \"=\" (L, R : Amb) return Boolean is\n      Left : Unbounded_String renames L.List (L.This);\n   begin\n      return Element (Left, Length (Left)) = Element (R.List (R.This), 1);\n   end \"=\";\n\n   procedure Failure (L : in out Amb) is\n   begin\n      loop\n         if L.This < L.Count then\n            L.This := L.This + 1;\n         else\n            L.This := 1;\n            Failure (L.Left.all);\n         end if;\n         exit when L.Left = null or else L.Left.all = L;\n      end loop;\n   end Failure;\n\n   procedure Join (L : access Amb; R : in out Amb) is\n   begin\n      R.Left := L;\n      while L.all /= R loop\n         Failure (R);\n      end loop;\n   end Join;\n\n   W_1 : aliased Amb := \"the\" / \"that\" / \"a\";\n   W_2 : aliased Amb := \"frog\" / \"elephant\" / \"thing\";\n   W_3 : aliased Amb := \"walked\" / \"treaded\" / \"grows\";\n   W_4 : aliased Amb := \"slowly\" / \"quickly\";\nbegin\n   Join (W_1'Access, W_2);\n   Join (W_2'Access, W_3);\n   Join (W_3'Access, W_4);\n   Put_Line (Image (W_1) & ' ' & Image (W_2) & ' ' & Image (W_3) & ' ' & Image (W_4));\nend Test_Amb;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Generic_Divisors; use Ada.Text_IO;\n\nprocedure Amicable_Pairs is\n\n   function Same(P: Positive) return Positive is (P);\n\n   package Divisor_Sum is new Generic_Divisors\n     (Result_Type => Natural, None => 0, One => Same, Add =>  \"+\");\n\n   Num2 : Integer;\nbegin\n   for Num1 in 4 .. 20_000 loop\n      Num2 := Divisor_Sum.Process(Num1);\n      if Num1 < Num2 then\n\t if Num1 = Divisor_Sum.Process(Num2) then\n\t   Put_Line(Integer'Image(Num1) & \",\" & Integer'Image(Num2));\n\t end if;\n      end if;\n   end loop;\nend Amicable_Pairs;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Generic_Array_Sort;\nwith Ada.Containers.Indefinite_Vectors;\nprocedure Danagrams is\n   package StringVector is new Ada.Containers.Indefinite_Vectors\n      (Positive, String);\n   procedure StrSort is new Ada.Containers.Generic_Array_Sort\n      (Index_Type => Positive,\n      Element_Type => Character,\n      Array_Type => String);\n   function Derange (s1 : String; s2 : String) return Boolean is begin\n      for i in s1'Range loop\n         if (s1 (i) = s2 (i)) then return False; end if;\n      end loop;\n      return True;\n   end Derange;\n   File : File_Type;\n   len, foundlen : Positive := 1;\n   Vect, SVect : StringVector.Vector;\n   index, p1, p2 : StringVector.Extended_Index := 0;\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   while not End_Of_File (File) loop\n      declare str : String := Get_Line (File);\n      begin\n         len := str'Length;\n         if len > foundlen then\n            Vect.Append (str);\n            StrSort (str);\n            index := 0;\n            loop --  Loop through anagrams by index in vector of sorted strings\n               index := SVect.Find_Index (str, index + 1);\n               exit when index = StringVector.No_Index;\n               if Derange (Vect.Last_Element, Vect.Element (index)) then\n                     p1 := Vect.Last_Index; p2 := index;\n                     foundlen := len;\n               end if;\n            end loop;\n            SVect.Append (str);\n         end if;\n      end;\n   end loop;\n   Close (File);\n   Put_Line (Vect.Element (p1) & \" \" & Vect.Element (p2));\nend Danagrams;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nwith Ada.Containers.Indefinite_Ordered_Maps;\nwith Ada.Containers.Indefinite_Ordered_Sets;\n\nprocedure Words_Of_Equal_Characters is\n   package Set_Of_Words is new Ada.Containers.Indefinite_Ordered_Sets (String);\n   use Ada.Containers, Set_Of_Words;\n   package Anagrams is new Ada.Containers.Indefinite_Ordered_Maps (String, Set);\n   use Anagrams;\n\n   File   : File_Type;\n   Result : Map;\n   Max    : Count_Type := 1;\n\n   procedure Put (Position : Anagrams.Cursor) is\n      First : Boolean := True;\n      List  : Set renames Element (Position);\n      procedure Put (Position : Set_Of_Words.Cursor) is\n      begin\n         if First then\n            First := False;\n         else\n            Put (',');\n         end if;\n         Put (Element (Position));\n      end Put;\n   begin\n      if List.Length = Max then\n         Iterate (List, Put'Access);\n         New_Line;\n      end if;\n   end Put;\n\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   loop\n      declare\n         Word : constant String     := Get_Line (File);\n         Key  : String (Word'Range) := (others => Character'Last);\n         List : Set;\n         Position : Anagrams.Cursor;\n      begin\n         for I in Word'Range loop\n            for J in Word'Range loop\n               if Key (J) > Word (I) then\n                  Key (J + 1..I) := Key (J..I - 1);\n                  Key (J) := Word (I);\n                  exit;\n               end if;\n            end loop;\n         end loop;\n         Position := Find (Result, Key);\n         if Has_Element (Position) then\n            List := Element (Position);\n            Insert (List, Word);\n            Replace_Element (Result, Position, List);\n         else\n            Insert (List, Word);\n            Include (Result, Key, List);\n         end if;\n         Max := Count_Type'Max (Max, Length (List));\n      end;\n   end loop;\nexception\n   when End_Error =>\n      Iterate (Result, Put'Access);\n      Close (File);\nend Words_Of_Equal_Characters;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   type Float_Type is digits <>;\n   Gravitation : Float_Type;\npackage Pendulums is\n   type Pendulum is private;\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum;\n   function Get_X (From : Pendulum) return Float_Type;\n   function Get_Y (From : Pendulum) return Float_Type;\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration);\nprivate\n   type Pendulum is record\n      Length   : Float_Type;\n      Theta    : Float_Type;\n      X        : Float_Type;\n      Y        : Float_Type;\n      Velocity : Float_Type;\n   end record;\nend Pendulums;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Elementary_Functions;\npackage body Pendulums is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float_Type);\n\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum is\n      Result : Pendulum;\n   begin\n      Result.Length   := Length;\n      Result.Theta    := Theta0 / 180.0 * Ada.Numerics.Pi;\n      Result.X        := Math.Sin (Theta0) * Length;\n      Result.Y        := Math.Cos (Theta0) * Length;\n      Result.Velocity := 0.0;\n      return Result;\n   end New_Pendulum;\n\n   function Get_X (From : Pendulum) return Float_Type is\n   begin\n      return From.X;\n   end Get_X;\n\n   function Get_Y (From : Pendulum) return Float_Type is\n   begin\n      return From.Y;\n   end Get_Y;\n\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration) is\n      Acceleration : constant Float_Type := Gravitation / Item.Length *\n                                            Math.Sin (Item.Theta);\n   begin\n         Item.X        := Math.Sin (Item.Theta) * Item.Length;\n         Item.Y        := Math.Cos (Item.Theta) * Item.Length;\n         Item.Velocity := Item.Velocity +\n                          Acceleration  * Float_Type (Time);\n         Item.Theta    := Item.Theta +\n                          Item.Velocity * Float_Type (Time);\n   end Update_Pendulum;\nend Pendulums;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Calendar;\nwith Pendulums;\n\nprocedure Main is\n   package Float_Pendulum is new Pendulums (Float, -9.81);\n   use Float_Pendulum;\n   use type Ada.Calendar.Time;\n\n   My_Pendulum : Pendulum := New_Pendulum (10.0, 30.0);\n   Now, Before : Ada.Calendar.Time;\nbegin\n   Before := Ada.Calendar.Clock;\n   loop\n      Delay 0.1;\n      Now := Ada.Calendar.Clock;\n      Update_Pendulum (My_Pendulum, Now - Before);\n      Before := Now;\n      -- output positions relative to origin\n      -- replace with graphical output if wanted\n      Ada.Text_IO.Put_Line (\" X: \" & Float'Image (Get_X (My_Pendulum)) &\n                            \" Y: \" & Float'Image (Get_Y (My_Pendulum)));\n   end loop;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Gtk.Main;\nwith Gtk.Handlers;\nwith Gtk.Label;\nwith Gtk.Button;\nwith Gtk.Window;\nwith Glib.Main;\n\nprocedure Animation is\n   Scroll_Forwards : Boolean := True;\n\n   package Button_Callbacks is new Gtk.Handlers.Callback\n     (Gtk.Button.Gtk_Button_Record);\n\n   package Label_Timeout is new Glib.Main.Generic_Sources\n     (Gtk.Label.Gtk_Label);\n\n   package Window_Callbacks is new Gtk.Handlers.Return_Callback\n     (Gtk.Window.Gtk_Window_Record, Boolean);\n\n   --  Callback for click event\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class);\n\n   --  Callback for delete event\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean;\n\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class)\n   is\n      pragma Unreferenced (Object);\n   begin\n      Scroll_Forwards := not Scroll_Forwards;\n   end On_Button_Click;\n\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean\n   is\n      pragma Unreferenced (Object);\n   begin\n      Gtk.Main.Main_Quit;\n      return True;\n   end On_Main_Window_Delete;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean is\n      Text : constant String := Gtk.Label.Get_Text (Data);\n   begin\n      if Scroll_Forwards then\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'First + 1 .. Text'Last) & Text (Text'First));\n      else\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'Last) & Text (Text'First .. Text'Last - 1));\n      end if;\n      return True;\n   end Scroll_Text;\n\n   Main_Window     : Gtk.Window.Gtk_Window;\n   Text_Button     : Gtk.Button.Gtk_Button;\n   Scrolling_Text  : Gtk.Label.Gtk_Label;\n   Timeout_ID      : Glib.Main.G_Source_Id;\n   pragma Unreferenced (Timeout_ID);\n\nbegin\n   Gtk.Main.Init;\n   Gtk.Window.Gtk_New (Window => Main_Window);\n   Gtk.Label.Gtk_New (Label => Scrolling_Text, Str => \"Hello World! \");\n   Gtk.Button.Gtk_New (Button => Text_Button);\n   Gtk.Button.Add (Container => Text_Button, Widget => Scrolling_Text);\n   Button_Callbacks.Connect\n     (Widget => Text_Button,\n      Name   => \"clicked\",\n      Marsh  => Button_Callbacks.To_Marshaller (On_Button_Click'Access));\n   Timeout_ID :=\n     Label_Timeout.Timeout_Add\n       (Interval => 125,\n        Func     => Scroll_Text'Access,\n        Data     => Scrolling_Text);\n   Gtk.Window.Add (Container => Main_Window, Widget => Text_Button);\n   Window_Callbacks.Connect\n     (Widget => Main_Window,\n      Name   => \"delete_event\",\n      Marsh  => Window_Callbacks.To_Marshaller (On_Main_Window_Delete'Access));\n   Gtk.Window.Show_All (Widget => Main_Window);\n   Gtk.Main.Main;\nend Animation;\n"
  },
  {
    "language": "Ada",
    "code": "   function Fib (X: in Integer) return Integer is\n      function Actual_Fib (N: in Integer) return Integer is\n      begin\n         if N < 2 then\n            return N;\n         else\n            return Actual_Fib (N-1) + Actual_Fib (N-2);\n         end if;\n      end Actual_Fib;\n   begin\n      if X < 0 then\n         raise Constraint_Error;\n      else\n         return Actual_Fib (X);\n      end if;\n   end Fib;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io;\n with Ada.Integer_text_IO;\n\n procedure Call_Back_Example is\n    -- Purpose: Apply a callback to an array\n    -- Output: Prints the squares of an integer array to the console\n\n    -- Define the callback procedure\n    procedure Display(Location : Positive; Value : Integer) is\n    begin\n       Ada.Text_Io.Put(\"array(\");\n       Ada.Integer_Text_Io.Put(Item => Location, Width => 1);\n       Ada.Text_Io.Put(\") = \");\n       Ada.Integer_Text_Io.Put(Item => Value * Value, Width => 1);\n       Ada.Text_Io.New_Line;\n    end Display;\n\n    -- Define an access type matching the signature of the callback procedure\n    type Call_Back_Access is access procedure(L : Positive; V : Integer);\n\n    -- Define an unconstrained array type\n    type Value_Array is array(Positive range <>) of Integer;\n\n    -- Define the procedure performing the callback\n    procedure Map(Values : Value_Array; Worker : Call_Back_Access) is\n    begin\n       for I in Values'range loop\n          Worker(I, Values(I));\n       end loop;\n    end Map;\n\n    -- Define and initialize the actual array\n    Sample : Value_Array := (5,4,3,2,1);\n\n begin\n    Map(Sample, Display'access);\n end Call_Back_Example;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith GNATCOLL.GMP; use GNATCOLL.GMP;\nwith GNATCOLL.GMP.Integers; use GNATCOLL.GMP.Integers;\nprocedure ArbitraryInt is\n   type stracc is access String;\n   BigInt : Big_Integer;\n   len : Natural;\n   str : stracc;\nbegin\n   Set (BigInt, 5);\n   Raise_To_N (BigInt, Unsigned_Long (4**(3**2)));\n   str := new String'(Image (BigInt));\n   len := str'Length;\n   Put_Line (\"Size is:\"& Natural'Image (len));\n   Put_Line (str (1 .. 20) & \".....\" & str (len - 19 .. len));\nend ArbitraryInt;\n"
  },
  {
    "language": "Ada",
    "code": "type My_Pointer is access My_Object;\nfor My_Pointer'Storage_Pool use My_Pool;\n"
  },
  {
    "language": "Ada",
    "code": "with System.Storage_Elements;  use System.Storage_Elements;\nwith System.Storage_Pools;     use System.Storage_Pools;\n\npackage Arena_Pools is\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with private;\n   overriding\n      procedure Allocate\n                (  Pool      : in out Arena;\n                   Address   : out System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                );\n   overriding\n      procedure Deallocate\n                (  Pool      : in out Arena;\n                   Address   : System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                )  is null;\n   overriding\n      function Storage_Size (Pool : Arena) return Storage_Count;\nprivate\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with record\n      Free : Storage_Offset := 1;\n      Core : Storage_Array (1..Size);\n   end record;\nend Arena_Pools;\n"
  },
  {
    "language": "Ada",
    "code": "package body Arena_Pools is\n   procedure Allocate\n             (  Pool      : in out Arena;\n                Address   : out System.Address;\n                Size      : Storage_Count;\n                Alignment : Storage_Count\n             )  is\n      Free : constant Storage_Offset :=\n         Pool.Free + Alignment - Pool.Core (Pool.Free)'Address mod Alignment + Size;\n   begin\n      if Free - 1 > Pool.Size then\n         raise Storage_Error;\n      end if;\n      Pool.Free := Free;\n      Address := Pool.Core (Pool.Free - Size)'Address;\n   end Allocate;\n\n   function Storage_Size (Pool : Arena) return Storage_Count is\n   begin\n      return Pool.Size;\n   end Storage_Size;\nend Arena_Pools;\n"
  },
  {
    "language": "Ada",
    "code": "with Arena_Pools;\nuse  Arena_Pools;\n\nprocedure Test_Allocator is\n   Pool : Arena_Pools.Arena (1024);\n   type Integer_Ptr is access Integer;\n   for Integer_Ptr'Storage_Pool use Pool;\n\n   X : Integer_Ptr := new Integer'(1);\n   Y : Integer_Ptr := new Integer'(2);\n   Z : Integer_Ptr;\nbegin\n   Z := new Integer;\n   Z.all := X.all + Y.all;\nend Test_Allocator;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Complex_Types;\nwith Ada.Text_IO.Complex_IO;\n\nprocedure Complex_Operations is\n   -- Ada provides a pre-defined generic package for complex types\n   -- That package contains definitions for composition,\n   -- negation, addition, subtraction, multiplication, division,\n   -- conjugation, exponentiation, and absolute value, as well as\n   -- basic comparison operations.\n   -- Ada provides a second pre-defined package for sin, cos, tan, cot,\n   -- arcsin, arccos, arctan, arccot, and the hyperbolic versions of\n   -- those trigonometric functions.\n\n   -- The package Ada.Numerics.Generic_Complex_Types requires definition\n   -- with the real type to be used in the complex type definition.\n\n   package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Long_Float);\n   use Complex_Types;\n   package Complex_IO is new Ada.Text_IO.Complex_IO (Complex_Types);\n   use Complex_IO;\n   use Ada.Text_IO;\n\n   A : Complex := Compose_From_Cartesian (Re => 1.0, Im => 1.0);\n   B : Complex := Compose_From_Polar (Modulus => 1.0, Argument => 3.14159);\n   C : Complex;\n\nbegin\n   -- Addition\n   C := A + B;\n   Put(\"A + B = \"); Put(C);\n   New_Line;\n   -- Multiplication\n   C := A * B;\n   Put(\"A * B = \"); Put(C);\n   New_Line;\n   -- Inversion\n   C := 1.0 / A;\n   Put(\"1.0 / A = \"); Put(C);\n   New_Line;\n   -- Negation\n   C := -A;\n   Put(\"-A = \"); Put(C);\n   New_Line;\n   -- Conjugation\n   C := Conjugate (C);\nend Complex_Operations;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Arith_Geom_Mean is\n\n   type Num is digits 18; -- the largest value gnat/gcc allows\n   package N_IO is new Ada.Text_IO.Float_IO(Num);\n   package Math is new Ada.Numerics.Generic_Elementary_Functions(Num);\n\n   function AGM(A, G: Num) return Num is\n      Old_G: Num;\n      New_G: Num := G;\n      New_A: Num := A;\n   begin\n      loop\n         Old_G := New_G;\n         New_G := Math.Sqrt(New_A*New_G);\n         New_A := (Old_G + New_A) * 0.5;\n         exit when (New_A - New_G) <= Num'Epsilon;\n         -- Num'Epsilon denotes the relative error when performing arithmetic over Num\n      end loop;\n      return New_G;\n   end AGM;\n\nbegin\n   N_IO.Put(AGM(1.0, 1.0/Math.Sqrt(2.0)), Fore => 1, Aft => 17, Exp => 0);\nend Arith_Geom_Mean;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io;\nwith Ada.Integer_Text_IO;\n\nprocedure Integer_Arithmetic is\n   use Ada.Text_IO;\n   use Ada.Integer_Text_Io;\n\n   A, B : Integer;\nbegin\n   Get(A);\n   Get(B);\n   Put_Line(\"a+b = \" & Integer'Image(A + B));\n   Put_Line(\"a-b = \" & Integer'Image(A - B));\n   Put_Line(\"a*b = \" & Integer'Image(A * B));\n   Put_Line(\"a/b = \" & Integer'Image(A / B));\n   Put_Line(\"a mod b = \" & Integer'Image(A mod B)); -- Sign matches B\n   Put_Line(\"remainder of a/b = \" & Integer'Image(A rem B)); -- Sign matches A\n   Put_Line(\"a**b = \" & Integer'Image(A ** B));\n\nend Integer_Arithmetic;\n"
  },
  {
    "language": "Ada",
    "code": "type T is array (Positive range <>) of Integer;\nX : T := (1, 2, 3);\nY : T := X & (4, 5, 6); -- Concatenate X and (4, 5, 6)\n"
  },
  {
    "language": "Ada",
    "code": "procedure Array_Test is\n\n   A, B : array (1..20) of Integer;\n\n   -- Ada array indices may begin at any value, not just 0 or 1\n   C : array (-37..20) of integer\n\n   -- Ada arrays may be indexed by enumerated types, which are\n   -- discrete non-numeric types\n   type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\n   type Activities is (Work, Fish);\n   type Daily_Activities is array(Days) of Activities;\n   This_Week : Daily_Activities := (Mon..Fri => Work, Others => Fish);\n\n   -- Or any numeric type\n   type Fingers is range 1..4; -- exclude thumb\n   type Fingers_Extended_Type is array(fingers) of Boolean;\n   Fingers_Extended : Fingers_Extended_Type;\n\n   -- Array types may be unconstrained. The variables of the type\n   -- must be constrained\n   type Arr is array (Integer range <>) of Integer;\n   Uninitialized : Arr (1 .. 10);\n   Initialized_1 : Arr (1 .. 20) := (others => 1);\n   Initialized_2 : Arr := (1 .. 30 => 2);\n   Const         : constant Arr := (1 .. 10 => 1, 11 .. 20 => 2, 21 | 22 => 3);\n   Centered      : Arr (-50..50) := (0 => 1, Others => 0);\n\n   Result        : Integer\nbegin\n\n   A := (others => 0);     -- Assign whole array\n   B := (1 => 1, 2 => 1, 3 => 2, others => 0);\n                           -- Assign whole array, different values\n   A (1) := -1;            -- Assign individual element\n   A (2..4) := B (1..3);   -- Assign a slice\n   A (3..5) := (2, 4, -1); -- Assign a constant slice\n   A (3..5) := A (4..6);   -- It is OK to overlap slices when assigned\n\n   Fingers_Extended'First := False; -- Set first element of array\n   Fingers_Extended'Last := False;  -- Set last element of array\n\nend Array_Test;\n"
  },
  {
    "language": "Ada",
    "code": "pragma Assert (A = 42, \"Oops!\");\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Assertions;  use Ada.Assertions;\n...\nAssert (A = 42, \"Oops!\");\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Ordered_Maps;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;\n\nprocedure Associative_Array is\n\n   -- Instantiate the generic package Ada.Containers.Ordered_Maps\n\n   package Associative_Int is new Ada.Containers.Ordered_Maps(Unbounded_String, Integer);\n   use Associative_Int;\n\n   Color_Map : Map;\n   Color_Cursor : Cursor;\n   Success : Boolean;\n   Value : Integer;\nbegin\n\n   -- Add values to the ordered map\n\n   Color_Map.Insert(To_Unbounded_String(\"Red\"), 10, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Blue\"), 20, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Yellow\"), 5, Color_Cursor, Success);\n\n   -- retrieve values from the ordered map and print the value and key\n   -- to the screen\n\n   Value := Color_Map.Element(To_Unbounded_String(\"Red\"));\n   Ada.Text_Io.Put_Line(\"Red:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Blue\"));\n   Ada.Text_IO.Put_Line(\"Blue:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Yellow\"));\n   Ada.Text_IO.Put_Line(\"Yellow:\" & Integer'Image(Value));\nend Associative_Array;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Containers.Indefinite_Ordered_Maps;\n\nprocedure Test_Iteration is\n   package String_Maps is\n      new Ada.Containers.Indefinite_Ordered_Maps (String, Integer);\n   use String_Maps;\n   A     : Map;\n   Index : Cursor;\nbegin\n   A.Insert (\"hello\", 1);\n   A.Insert (\"world\", 2);\n   A.Insert (\"!\",     3);\n   Index := A.First;\n   while Index /= No_Element loop\n      Put_Line (Key (Index) & Integer'Image (Element (Index)));\n      Index := Next (Index);\n   end loop;\nend Test_Iteration;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\n\nprocedure Test_Updates is\n\n   type Bucket_Index is range 1..13;\n   package Random_Index is new Ada.Numerics.Discrete_Random (Bucket_Index);\n   use Random_Index;\n   type Buckets is array (Bucket_Index) of Natural;\n\n   protected type Safe_Buckets is\n      procedure Initialize (Value : Buckets);\n      function Get (I : Bucket_Index) return Natural;\n      procedure Transfer (I, J : Bucket_Index; Amount : Integer);\n      function Snapshot return Buckets;\n   private\n      Data : Buckets := (others => 0);\n   end Safe_Buckets;\n\n   protected body Safe_Buckets is\n      procedure Initialize (Value : Buckets) is\n      begin\n         Data := Value;\n      end Initialize;\n\n      function Get (I : Bucket_Index) return Natural is\n      begin\n         return Data (I);\n      end Get;\n\n      procedure Transfer (I, J : Bucket_Index; Amount : Integer) is\n         Increment : constant Integer :=\n            Integer'Max (-Data (J), Integer'Min (Data (I), Amount));\n      begin\n         Data (I) := Data (I) - Increment;\n         Data (J) := Data (J) + Increment;\n      end Transfer;\n\n      function Snapshot return Buckets is\n      begin\n         return Data;\n      end Snapshot;\n   end Safe_Buckets;\n\n   Data : Safe_Buckets;\n\n   task Equalize;\n   task Mess_Up;\n\n   task body Equalize is\n      Dice : Generator;\n      I, J : Bucket_Index;\n   begin\n      loop\n         I := Random (Dice);\n         J := Random (Dice);\n         Data.Transfer (I, J, (Data.Get (I) - Data.Get (J)) / 2);\n      end loop;\n   end Equalize;\n\n   task body Mess_Up is\n      Dice : Generator;\n   begin\n      loop\n         Data.Transfer (Random (Dice), Random (Dice), 100);\n      end loop;\n   end Mess_Up;\n\nbegin\n   Data.Initialize ((1,2,3,4,5,6,7,8,9,10,11,12,13));\n   loop\n      delay 1.0;\n      declare\n         State : Buckets := Data.Snapshot;\n         Sum   : Natural := 0;\n      begin\n         for Index in State'Range loop\n            Sum := Sum + State (Index);\n            Put (Integer'Image (State (Index)));\n         end loop;\n         Put (\" =\" & Integer'Image (Sum));\n         New_Line;\n      end;\n   end loop;\nend Test_Updates;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Numerics.Generic_Elementary_Functions;\nwith Ada.Numerics.Discrete_Random;\nprocedure Avglen is\n   package IIO is new Ada.Text_IO.Integer_IO (Positive); use IIO;\n   package LFIO is new Ada.Text_IO.Float_IO (Long_Float); use LFIO;\n   subtype FactN is Natural range 0..20;\n   TESTS : constant Natural := 1_000_000;\n\n   function Factorial (N : FactN) return Long_Float is\n      Result : Long_Float := 1.0;\n   begin\n      for I in 2..N loop Result := Result * Long_Float(I); end loop;\n      return Result;\n   end Factorial;\n\n   function Analytical (N : FactN) return Long_Float is\n      Sum : Long_Float := 0.0;\n   begin\n      for I in 1..N loop\n         Sum := Sum + Factorial(N) / Factorial(N - I) / Long_Float(N)**I;\n      end loop;\n      return Sum;\n   end Analytical;\n\n   function Experimental (N : FactN) return Long_Float is\n      subtype RandInt is Natural range 1..N;\n      package Random is new Ada.Numerics.Discrete_Random(RandInt);\n      seed : Random.Generator;\n      Num : RandInt;\n      count : Natural := 0;\n      bits : array(RandInt'Range) of Boolean;\n   begin\n      Random.Reset(seed);\n      for run in 1..TESTS loop\n         bits := (others  => false);\n         for I in RandInt'Range loop\n            Num := Random.Random(seed); exit when bits(Num);\n            bits(Num) := True; count := count + 1;\n         end loop;\n      end loop;\n      return Long_Float(count)/Long_Float(TESTS);\n   end Experimental;\n\n   A, E, err : Long_Float;\nbegin\n   Put_Line(\" N  avg    calc   %diff\");\n   for I in 1..20 loop\n      A := Analytical(I);  E := Experimental(I); err := abs(E-A)/A*100.0;\n      Put(I, Width=>2); Put(E ,Aft=>4, exp=>0); Put(A, Aft=>4, exp=>0);\n      Put(err, Fore=>3, Aft=>3, exp=>0); New_line;\n   end loop;\nend Avglen;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Float_Text_Io; use Ada.Float_Text_Io;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Mean_Main is\n   type Vector is array (Positive range <>) of Float;\n   function Mean (Item : Vector) return float with pre => Item'length > 0;\n   function Mean (Item : Vector) return Float is\n      Sum : Float := 0.0;\n   begin\n      for I in Item'range loop\n         Sum := Sum + Item(I);\n      end loop;\n\t  return Sum / Float(Item'Length);\n   end Mean;\n   A : Vector := (3.0, 1.0, 4.0, 1.0, 5.0, 9.0);\nbegin\n    Put(Item => Mean (A), Fore => 1, Exp => 0);\n   New_Line;\n   -- test for zero length vector\n   Put(Item => Mean(A (1..0)), Fore => 1, Exp => 0);\n   New_Line;\nend Mean_Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Mean_Angles is\n\n   type X_Real is digits 4;      -- or more digits for improved precision\n   subtype Real is X_Real range 0.0 .. 360.0; -- the range of interest\n   type Angles is array(Positive range <>) of Real;\n\n   procedure Put(R: Real) is\n      package IO is new Ada.Text_IO.Float_IO(Real);\n   begin\n      IO.Put(R, Fore => 3, Aft => 2, Exp => 0);\n   end Put;\n\n   function Mean_Angle(A: Angles) return Real is\n      Sin_Sum, Cos_Sum: X_Real := 0.0; -- X_Real since sums might exceed 360.0\n      package Math is new Ada.Numerics.Generic_Elementary_Functions(Real);\n      use Math;\n   begin\n      for I in A'Range loop\n        Sin_Sum := Sin_Sum + Sin(A(I), Cycle => 360.0);\n        Cos_Sum := Cos_Sum + Cos(A(I), Cycle => 360.0);\n      end loop;\n      return Arctan(Sin_Sum / X_Real(A'Length), Cos_Sum / X_Real(A'Length),\n                    Cycle => 360.0);\n        -- may raise Ada.Numerics.Argument_Error if inputs are\n        -- numerically instable, e.g., when Cos_Sum is 0.0\n   end Mean_Angle;\n\nbegin\n   Put(Mean_Angle((10.0, 20.0, 30.0)));     Ada.Text_IO.New_Line;    -- 20.00\n   Put(Mean_Angle((10.0, 350.0)));          Ada.Text_IO.New_Line;    --  0.00\n   Put(Mean_Angle((90.0, 180.0, 270.0, 360.0))); -- Ada.Numerics.Argument_Error!\nend Mean_Angles;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Float_Text_IO;\n\nprocedure FindMedian is\n\n    f: array(1..10) of float := ( 4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5 );\n    min_idx: integer;\n    min_val, median_val, swap: float;\n\nbegin\n    for i in f'range loop\n        min_idx := i;\n        min_val := f(i);\n        for j in i+1 .. f'last loop\n            if f(j) < min_val then\n                min_idx := j;\n                min_val := f(j);\n            end if;\n        end loop;\n        swap := f(i); f(i) := f(min_idx); f(min_idx) := swap;\n    end loop;\n\n    if f'length mod 2 /= 0 then\n        median_val := f( f'length/2+1 );\n    else\n        median_val := ( f(f'length/2) + f(f'length/2+1) ) / 2.0;\n    end if;\n\n    Ada.Text_IO.Put( \"Median value: \" );\n    Ada.Float_Text_IO.Put( median_val );\n    Ada.Text_IO.New_line;\nend FindMedian;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   type Element_Type is private;\n   type Element_Array is array (Positive range <>) of Element_Type;\npackage Mode is\n\n   function Get_Mode (Set : Element_Array) return Element_Array;\n\nend Mode;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Indefinite_Vectors;\n\npackage body Mode is\n\n   -- map Count to Elements\n   package Count_Vectors is new Ada.Containers.Indefinite_Vectors\n     (Element_Type => Element_Array,\n      Index_Type => Positive);\n\n   procedure Add (To : in out Count_Vectors.Vector; Item : Element_Type) is\n      use type Count_Vectors.Cursor;\n      Position : Count_Vectors.Cursor := To.First;\n      Found    : Boolean              := False;\n   begin\n      while not Found and then Position /= Count_Vectors.No_Element loop\n         declare\n            Elements : Element_Array := Count_Vectors.Element (Position);\n         begin\n            for I in Elements'Range loop\n               if Elements (I) = Item then\n                  Found := True;\n               end if;\n            end loop;\n         end;\n         if not Found then\n            Position := Count_Vectors.Next (Position);\n         end if;\n      end loop;\n      if Position /= Count_Vectors.No_Element then\n         -- element found, remove it and insert to next count\n         declare\n            New_Position : Count_Vectors.Cursor :=\n               Count_Vectors.Next (Position);\n         begin\n            -- remove from old position\n            declare\n               Old_Elements : Element_Array :=\n                  Count_Vectors.Element (Position);\n               New_Elements : Element_Array (1 .. Old_Elements'Length - 1);\n               New_Index    : Positive      := New_Elements'First;\n            begin\n               for I in Old_Elements'Range loop\n                  if Old_Elements (I) /= Item then\n                     New_Elements (New_Index) := Old_Elements (I);\n                     New_Index                := New_Index + 1;\n                  end if;\n               end loop;\n               To.Replace_Element (Position, New_Elements);\n            end;\n            -- new position not already there?\n            if New_Position = Count_Vectors.No_Element then\n               declare\n                  New_Array : Element_Array (1 .. 1) := (1 => Item);\n               begin\n                  To.Append (New_Array);\n               end;\n            else\n               -- add to new position\n               declare\n                  Old_Elements : Element_Array :=\n                     Count_Vectors.Element (New_Position);\n                  New_Elements : Element_Array (1 .. Old_Elements'Length + 1);\n               begin\n                  New_Elements (1 .. Old_Elements'Length) := Old_Elements;\n                  New_Elements (New_Elements'Last)        := Item;\n                  To.Replace_Element (New_Position, New_Elements);\n               end;\n            end if;\n         end;\n      else\n         -- element not found, add to count 1\n         Position := To.First;\n         if Position = Count_Vectors.No_Element then\n            declare\n               New_Array : Element_Array (1 .. 1) := (1 => Item);\n            begin\n               To.Append (New_Array);\n            end;\n         else\n            declare\n               Old_Elements : Element_Array :=\n                  Count_Vectors.Element (Position);\n               New_Elements : Element_Array (1 .. Old_Elements'Length + 1);\n            begin\n               New_Elements (1 .. Old_Elements'Length) := Old_Elements;\n               New_Elements (New_Elements'Last)        := Item;\n               To.Replace_Element (Position, New_Elements);\n            end;\n         end if;\n      end if;\n   end Add;\n\n   function Get_Mode (Set : Element_Array) return Element_Array is\n      Counts : Count_Vectors.Vector;\n   begin\n      for I in Set'Range loop\n         Add (Counts, Set (I));\n      end loop;\n      return Counts.Last_Element;\n   end Get_Mode;\n\nend Mode;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Mode;\nprocedure Main is\n   type Int_Array is array (Positive range <>) of Integer;\n   package Int_Mode is new Mode (Integer, Int_Array);\n\n   Test_1 : Int_Array := (1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6);\n   Result : Int_Array := Int_Mode.Get_Mode (Test_1);\nbegin\n   Ada.Text_IO.Put (\"Input: \");\n   for I in Test_1'Range loop\n      Ada.Text_IO.Put (Integer'Image (Test_1 (I)));\n      if I /= Test_1'Last then\n         Ada.Text_IO.Put (\",\");\n      end if;\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Result:\");\n   for I in Result'Range loop\n      Ada.Text_IO.Put (Integer'Image (Result (I)));\n      if I /= Result'Last then\n         Ada.Text_IO.Put (\",\");\n      end if;\n   end loop;\n   Ada.Text_IO.New_Line;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "package Pythagorean_Means is\n   type Set is array (Positive range <>) of Float;\n   function Arithmetic_Mean (Data : Set) return Float;\n   function Geometric_Mean  (Data : Set) return Float;\n   function Harmonic_Mean   (Data : Set) return Float;\nend Pythagorean_Means;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Elementary_Functions;\npackage body Pythagorean_Means is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float);\n   function \"**\" (Left, Right : Float) return Float renames Math.\"**\";\n\n   function Arithmetic_Mean (Data : Set) return Float is\n      Sum : Float := 0.0;\n   begin\n      for I in Data'Range loop\n         Sum := Sum + Data (I);\n      end loop;\n      return Sum / Float (Data'Length);\n   end Arithmetic_Mean;\n\n   function Geometric_Mean (Data : Set) return Float is\n      Product : Float := 1.0;\n   begin\n      for I in Data'Range loop\n         Product := Product * Data (I);\n      end loop;\n      return Product**(1.0/Float(Data'Length));\n   end Geometric_Mean;\n\n   function Harmonic_Mean (Data : Set) return Float is\n      Reciprocal_Sum : Float := 0.0;\n   begin\n      for I in Data'Range loop\n         Reciprocal_Sum := Reciprocal_Sum + Data (I)**(-1);\n      end loop;\n      return Float (Data'Length) / Reciprocal_Sum;\n   end Harmonic_Mean;\n\nend Pythagorean_Means;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Pythagorean_Means;\nprocedure Main is\n   My_Set : Pythagorean_Means.Set := (1.0, 2.0, 3.0, 4.0,  5.0,\n                                      6.0, 7.0, 8.0, 9.0, 10.0);\n   Arithmetic_Mean : Float := Pythagorean_Means.Arithmetic_Mean (My_Set);\n   Geometric_Mean  : Float := Pythagorean_Means.Geometric_Mean  (My_Set);\n   Harmonic_Mean   : Float := Pythagorean_Means.Harmonic_Mean   (My_Set);\nbegin\n   Ada.Text_IO.Put_Line (Float'Image (Arithmetic_Mean) & \" >= \" &\n                         Float'Image (Geometric_Mean)  & \" >= \" &\n                         Float'Image (Harmonic_Mean));\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Float_Text_IO; use Ada.Float_Text_IO;\nwith Ada.Numerics.Elementary_Functions;\nuse Ada.Numerics.Elementary_Functions;\nprocedure calcrms is\n\ttype float_arr is array(1..10) of Float;\n\t\n\tfunction rms(nums : float_arr) return Float is\n\t\tsum : Float := 0.0;\n\t\tbegin\n\t\tfor p in nums'Range loop\n\t\t\tsum := sum + nums(p)**2;\n\t\tend loop;\n\t\treturn sqrt(sum/Float(nums'Length));\n\tend rms;\n\n\tlist : float_arr;\nbegin\nlist := (1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0);\nput( rms(list) , Exp=>0);\nend calcrms;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   Max_Elements : Positive;\n   type Number is digits <>;\npackage Moving is\n   procedure Add_Number (N : Number);\n   function Moving_Average (N : Number) return Number;\n   function Get_Average return Number;\nend Moving;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Vectors;\n\npackage body Moving is\n   use Ada.Containers;\n\n   package Number_Vectors is new Ada.Containers.Vectors\n     (Element_Type => Number,\n      Index_Type   => Natural);\n\n   Current_List : Number_Vectors.Vector := Number_Vectors.Empty_Vector;\n\n   procedure Add_Number (N : Number) is\n   begin\n      if Natural (Current_List.Length) >= Max_Elements then\n         Current_List.Delete_First;\n      end if;\n      Current_List.Append (N);\n   end Add_Number;\n\n   function Get_Average return Number is\n      Average : Number := 0.0;\n      procedure Sum (Position : Number_Vectors.Cursor) is\n      begin\n         Average := Average + Number_Vectors.Element (Position);\n      end Sum;\n   begin\n      Current_List.Iterate (Sum'Access);\n      if Current_List.Length > 1 then\n         Average := Average / Number (Current_List.Length);\n      end if;\n      return Average;\n   end Get_Average;\n\n   function Moving_Average (N : Number) return Number is\n   begin\n      Add_Number (N);\n      return Get_Average;\n   end Moving_Average;\n\nend Moving;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Moving;\nprocedure Main is\n   package Three_Average is new Moving (Max_Elements => 3, Number => Float);\n   package Five_Average is new Moving (Max_Elements => 5, Number => Float);\nbegin\n   for I in 1 .. 5 loop\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-3: \" & Float'Image (Three_Average.Moving_Average (Float (I))));\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-5: \" & Float'Image (Five_Average.Moving_Average (Float (I))));\n   end loop;\n   for I in reverse 1 .. 5 loop\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-3: \" & Float'Image (Three_Average.Moving_Average (Float (I))));\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-5: \" & Float'Image (Five_Average.Moving_Average (Float (I))));\n   end loop;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Discrete_Random;\nwith Ada.Text_IO;\nwith Ada.Strings.Fixed;\nprocedure Brackets is\n   package Random_Positive is new Ada.Numerics.Discrete_Random (Positive);\n   Positive_Generator : Random_Positive.Generator;\n   procedure Swap (Left, Right : in out Character) is\n      Temp : constant Character := Left;\n   begin\n      Left := Right;\n      Right := Temp;\n   end Swap;\n   function Generate_Brackets (Bracket_Count : Natural;\n                               Opening_Bracket : Character := '[';\n                               Closing_Bracket : Character := ']')\n            return String is\n      use Ada.Strings.Fixed;\n      All_Brackets : String := Bracket_Count * Opening_Bracket & Bracket_Count * Closing_Bracket;\n   begin\n      for I in All_Brackets'Range loop\n         Swap (All_Brackets (I), All_Brackets (Random_Positive.Random (Positive_Generator) mod (Bracket_Count * 2) + 1));\n      end loop;\n      return All_Brackets;\n   end Generate_Brackets;\n\n   function Check_Brackets (Test : String;\n                            Opening_Bracket : Character := '[';\n                            Closing_Bracket : Character := ']')\n            return Boolean is\n      Open : Natural := 0;\n   begin\n      for I in Test'Range loop\n         if Test (I) = Opening_Bracket then\n            Open := Open + 1;\n         elsif Test (I) = Closing_Bracket then\n            if Open = 0 then\n               return False;\n            else\n               Open := Open - 1;\n            end if;\n         end if;\n      end loop;\n      return True;\n   end Check_Brackets;\nbegin\n   Random_Positive.Reset (Positive_Generator);\n   Ada.Text_IO.Put_Line (\"Brackets\");\n   for I in 0 .. 4 loop\n      for J in 0 .. I loop\n         declare\n            My_String : constant String := Generate_Brackets (I);\n         begin\n            Ada.Text_IO.Put_Line (My_String & \": \" & Boolean'Image (Check_Brackets (My_String)));\n         end;\n      end loop;\n   end loop;\nend Brackets;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Finalization;\n\npackage BT is\n\n   type Balanced_Ternary is private;\n\n   -- conversions\n   function To_Balanced_Ternary (Num : Integer) return Balanced_Ternary;\n   function To_Balanced_Ternary (Str : String)  return Balanced_Ternary;\n   function To_Integer (Num : Balanced_Ternary)  return Integer;\n   function To_string (Num : Balanced_Ternary)   return String;\n\n   -- Arithmetics\n   -- unary minus\n   function \"-\" (Left : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n\n   -- subtraction\n   function \"-\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n\n   -- addition\n   function \"+\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n   -- multiplication\n   function \"*\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n\nprivate\n   -- a balanced ternary number is a unconstrained array of (1,0,-1)\n   -- dinamically allocated, least significant trit leftmost\n   type Trit is range -1..1;\n   type Trit_Array is array (Positive range <>) of Trit;\n   pragma Pack(Trit_Array);\n\n   type Trit_Access is access Trit_Array;\n\n   type Balanced_Ternary is new Ada.Finalization.Controlled\n     with record\n\tRef : Trit_access;\n   end record;\n\n   procedure Initialize (Object : in out Balanced_Ternary);\n   procedure Adjust     (Object : in out Balanced_Ternary);\n   procedure Finalize   (Object : in out Balanced_Ternary);\n\nend BT;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Unchecked_Deallocation;\n\npackage body BT is\n\n   procedure Free is new Ada.Unchecked_Deallocation (Trit_Array, Trit_Access);\n\n   -- Conversions\n   -- String to BT\n   function To_Balanced_Ternary (Str: String) return Balanced_Ternary is\n      J : Positive := 1;\n      Tmp : Trit_Access;\n   begin\n      Tmp := new Trit_Array (1..Str'Last);\n      for I in reverse Str'Range loop\n\t case Str(I) is\n\t    when '+' => Tmp (J) := 1;\n\t    when '-' => Tmp (J) := -1;\n\t    when '0' => Tmp (J) := 0;\n\t    when others => raise Constraint_Error;\n\t end case;\n\t J := J + 1;\n      end loop;\n      return (Ada.Finalization.Controlled with Ref => Tmp);\n   end To_Balanced_Ternary;\n\n   -- Integer to BT\n   function To_Balanced_Ternary (Num: Integer) return Balanced_Ternary is\n      K      : Integer := 0;\n      D      : Integer;\n      Value  : Integer := Num;\n      Tmp    : Trit_Array(1..19); -- 19 trits is enough to contain\n                                   -- a 32 bits signed integer\n   begin\n      loop\n\t D := (Value mod 3**(K+1))/3**K;\n\t if D = 2 then D := -1; end if;\n\t Value := Value - D*3**K;\n\t K := K + 1;\n\t Tmp(K) := Trit(D);\n\t exit when Value = 0;\n      end loop;\n      return (Ada.Finalization.Controlled\n\t\twith Ref => new Trit_Array'(Tmp(1..K)));\n   end To_Balanced_Ternary;\n\n   -- BT to Integer --\n   -- If the BT number is too large Ada will raise CONSTRAINT ERROR\n   function To_Integer (Num : Balanced_Ternary) return Integer is\n      Value : Integer := 0;\n      Pos : Integer := 1;\n   begin\n      for I in Num.Ref.all'Range loop\n\t Value := Value + Integer(Num.Ref(I)) * Pos;\n\t Pos := Pos * 3;\n      end loop;\n      return Value;\n   end To_Integer;\n\n   -- BT to String --\n   function To_String (Num : Balanced_Ternary) return String is\n      I : constant Integer := Num.Ref.all'Last;\n      Result : String (1..I);\n   begin\n      for J in Result'Range loop\n\t case Num.Ref(I-J+1) is\n\t    when 0  => Result(J) := '0';\n\t    when -1 => Result(J) := '-';\n\t    when 1  => Result(J) := '+';\n\t end case;\n      end loop;\n      return Result;\n   end To_String;\n\n   -- unary minus --\n   function \"-\" (Left : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n      Result : constant Balanced_Ternary := Left;\n   begin\n      for I in Result.Ref.all'Range loop\n\t Result.Ref(I) := - Result.Ref(I);\n      end loop;\n      return Result;\n   end \"-\";\n\n   -- addition --\n   Carry : Trit;\n\n   function Add (Left, Right : in Trit)\n\t\treturn Trit is\n   begin\n      if Left /= Right then\n\t Carry := 0;\n\t return Left + Right;\n      else\n\t Carry := Left;\n\t return -Right;\n      end if;\n   end Add;\n   pragma Inline (Add);\n\n   function \"+\" (Left, Right : in Trit_Array)\n\t\treturn Balanced_Ternary is\n      Max_Size : constant Integer :=\n\tInteger'Max(Left'Last, Right'Last);\n      Tmp_Left, Tmp_Right : Trit_Array(1..Max_Size) := (others => 0);\n      Result : Trit_Array(1..Max_Size+1) := (others => 0);\n   begin\n      Tmp_Left (1..Left'Last) := Left;\n      Tmp_Right(1..Right'Last) := Right;\n      for I in Tmp_Left'Range loop\n\t Result(I) := Add (Result(I), Tmp_Left(I));\n\t Result(I+1) := Carry;\n\t Result(I) := Add(Result(I), Tmp_Right(I));\n\t Result(I+1) := Add(Result(I+1), Carry);\n      end loop;\n      -- remove trailing zeros\n      for I in reverse Result'Range loop\n\t if Result(I) /= 0 then\n\t    return (Ada.Finalization.Controlled\n\t\t      with Ref => new Trit_Array'(Result(1..I)));\n\t end if;\n      end loop;\n      return (Ada.Finalization.Controlled\n\t\twith Ref => new Trit_Array'(1 => 0));\n   end \"+\";\n\n   function \"+\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n   begin\n      return Left.Ref.all + Right.Ref.all;\n   end \"+\";\n\n   -- Subtraction\n   function \"-\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n   begin\n      return Left + (-Right);\n   end \"-\";\n\n   -- multiplication\n   function \"*\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n      A, B : Trit_Access;\n      Result : Balanced_Ternary;\n   begin\n      if Left.Ref.all'Length > Right.Ref.all'Length then\n\t A := Right.Ref; B := Left.Ref;\n      else\n\t B := Right.Ref; A := Left.Ref;\n      end if;\n      for I in A.all'Range loop\n\t if A(I) /= 0 then\n\t    declare\n\t       Tmp_Result : Trit_Array (1..I+B.all'Length-1) := (others => 0);\n\t    begin\n\t       for J in B.all'Range loop\n\t\t  Tmp_Result(I+J-1) := B(J) * A(I);\n\t       end loop;\n\t       Result := Result.Ref.all + Tmp_Result;\n\t    end;\n\t end if;\n      end loop;\n      return Result;\n   end \"*\";\n\n   procedure Adjust (Object : in out Balanced_Ternary) is\n   begin\n      Object.Ref := new Trit_Array'(Object.Ref.all);\n   end Adjust;\n\n   procedure Finalize  (Object : in out Balanced_Ternary) is\n   begin\n      Free (Object.Ref);\n   end Finalize;\n\n   procedure Initialize (Object : in out Balanced_Ternary) is\n   begin\n      Object.Ref := new Trit_Array'(1 => 0);\n   end Initialize;\n\nend BT;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\nwith Ada.Integer_Text_Io; use Ada.Integer_Text_Io;\nwith BT; use BT;\n\nprocedure TestBT is\n   Result, A, B, C : Balanced_Ternary;\nbegin\n   A := To_Balanced_Ternary(\"+-0++0+\");\n   B := To_Balanced_Ternary(-436);\n   C := To_Balanced_Ternary(\"+-++-\");\n\n   Result := A * (B - C);\n\n   Put(\"a = \"); Put(To_integer(A), 4); New_Line;\n   Put(\"b = \"); Put(To_integer(B), 4); New_Line;\n   Put(\"c = \"); Put(To_integer(C), 4); New_Line;\n   Put(\"a * (b - c) = \"); Put(To_integer(Result), 4);\n   Put_Line (\" \" & To_String(Result));\nend TestBT;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Benford is\n\n   subtype Nonzero_Digit is Natural range 1 .. 9;\n   function First_Digit(S: String) return Nonzero_Digit is\n      (if S(S'First) in '1' .. '9'\n         then Nonzero_Digit'Value(S(S'First .. S'First))\n         else First_Digit(S(S'First+1 .. S'Last)));\n\n   package N_IO is new Ada.Text_IO.Integer_IO(Natural);\n\n   procedure Print(D: Nonzero_Digit; Counted, Sum: Natural) is\n      package Math is new Ada.Numerics.Generic_Elementary_Functions(Float);\n      package F_IO is new Ada.Text_IO.Float_IO(Float);\n      Actual: constant Float := Float(Counted) / Float(Sum);\n      Expected: constant Float := Math.Log(1.0 + 1.0 / Float(D), Base => 10.0);\n      Deviation: constant Float := abs(Expected-Actual);\n   begin\n      N_IO.Put(D, 5);\n      N_IO.Put(Counted, 14);\n      F_IO.Put(Float(Sum)*Expected, Fore => 16, Aft => 1, Exp => 0);\n      F_IO.Put(100.0*Actual, Fore => 9, Aft => 2, Exp => 0);\n      F_IO.Put(100.0*Expected, Fore => 11, Aft => 2, Exp => 0);\n      F_IO.Put(100.0*Deviation, Fore => 13, Aft => 2, Exp => 0);\n   end Print;\n\n   Cnt: array(Nonzero_Digit) of Natural := (1 .. 9 => 0);\n   D: Nonzero_Digit;\n   Sum: Natural := 0;\n   Counter: Positive;\n\nbegin\n   while not Ada.Text_IO.End_Of_File loop\n      -- each line in the input file holds Counter, followed by Fib(Counter)\n      N_IO.Get(Counter);\n        -- Counter and skip it, we just don't need it\n      D := First_Digit(Ada.Text_IO.Get_Line);\n        -- read the rest of the line and extract the first digit\n      Cnt(D) := Cnt(D)+1;\n      Sum := Sum + 1;\n   end loop;\n   Ada.Text_IO.Put_Line(\" Digit  Found[total]   Expected[total]    Found[%]\"\n                                          & \"   Expected[%]   Difference[%]\");\n   for I in Nonzero_Digit loop\n      Print(I, Cnt(I), Sum);\n      Ada.Text_IO.New_Line;\n   end loop;\nend Benford;\n"
  },
  {
    "language": "Ada",
    "code": "      -- N_IO.Get(Counter);\n"
  },
  {
    "language": "Ada",
    "code": "WITH GMP.Rationals, GMP.Integers, Ada.Text_IO, Ada.Strings.Fixed, Ada.Strings;\nUSE GMP.Rationals, GMP.Integers, Ada.Text_IO, Ada.Strings.Fixed, Ada.Strings;\n\nPROCEDURE Main IS\n\n   FUNCTION Bernoulli_Number (N : Natural) RETURN Unbounded_Fraction IS\n      FUNCTION \"/\" (Left, Right : Natural) RETURN Unbounded_Fraction IS\n        (To_Unbounded_Integer (Left) / To_Unbounded_Integer (Right));\n      A : ARRAY (0 .. N) OF Unbounded_Fraction;\n   BEGIN\n      FOR M IN 0 .. N LOOP\n         A (M) := 1 / (M + 1);\n         FOR J IN REVERSE 1 .. M LOOP\n            A (J - 1) := (J / 1 ) * (A (J - 1) - A (J));\n         END LOOP;\n      END LOOP;\n      RETURN A (0);\n   END Bernoulli_Number;\n\nBEGIN\n   FOR I IN 0 .. 60 LOOP\n      IF I MOD 2 = 0 OR I = 1 THEN\n         DECLARE\n            B : Unbounded_Fraction := Bernoulli_Number (I);\n            S : String := Image (GMP.Rationals.Numerator (B));\n         BEGIN\n            Put_Line (\"B (\" & (IF I < 10 THEN \" \" ELSE \"\") &  Trim (I'Img, Left)\n                      & \")=\" & (44 - S'Length) * \" \" & Image (B));\n         END;\n      END IF;\n   END LOOP;\nEND Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Strings.Unbounded;\n\nprocedure Best_Shuffle is\n\n   function Best_Shuffle (S : String) return String;\n\n   function Best_Shuffle (S : String) return String is\n      T : String (S'Range) := S;\n      Tmp : Character;\n   begin\n      for I in S'Range loop\n         for J in S'Range loop\n            if I /= J and S (I) /= T (J) and S (J) /= T (I) then\n               Tmp  := T (I);\n               T (I) := T (J);\n               T (J) := Tmp;\n            end if;\n         end loop;\n      end loop;\n      return T;\n   end Best_Shuffle;\n\n   Test_Cases : constant array (1 .. 6)\n     of Ada.Strings.Unbounded.Unbounded_String :=\n                  (Ada.Strings.Unbounded.To_Unbounded_String (\"abracadabra\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"seesaw\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"elk\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"grrrrrr\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"up\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"a\"));\n\nbegin -- main procedure\n   for Test_Case in Test_Cases'Range loop\n      declare\n         Original : constant String := Ada.Strings.Unbounded.To_String\n           (Test_Cases (Test_Case));\n         Shuffle  : constant String := Best_Shuffle (Original);\n         Score : Natural := 0;\n      begin\n         for I in Original'Range loop\n            if Original (I) = Shuffle (I) then\n               Score := Score + 1;\n            end if;\n         end loop;\n         Ada.Text_IO.Put_Line (Original & \", \" & Shuffle & \", (\" &\n                                Natural'Image (Score) & \" )\");\n      end;\n   end loop;\nend Best_Shuffle;\n"
  },
  {
    "language": "Ada",
    "code": "with ada.text_io; use ada.text_io;\nprocedure binary is\n  bit : array (0..1) of character := ('0','1');\n\n  function bin_image (n : Natural) return string is\n  (if n < 2 then (1 => bit (n)) else bin_image (n / 2) & bit (n mod 2));\n\n  test_values : array (1..3) of Natural := (5,50,9000);\nbegin\n  for test of test_values loop\n\tput_line (\"Output for\" & test'img & \" is \" & bin_image (test));\n  end loop;\nend binary;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Recursive_Binary_Search is\n   Not_Found : exception;\n\n   generic\n      type Index is range <>;\n      type Element is private;\n      type Array_Of_Elements is array (Index range <>) of Element;\n      with function \"<\" (L, R : Element) return Boolean is <>;\n   function Search (Container : Array_Of_Elements; Value : Element) return Index;\n\n   function Search (Container : Array_Of_Elements; Value : Element) return Index is\n      Mid : Index;\n   begin\n      if Container'Length > 0 then\n         Mid := (Container'First + Container'Last) / 2;\n         if Value < Container (Mid) then\n            if Container'First /= Mid then\n               return Search (Container (Container'First..Mid - 1), Value);\n            end if;\n         elsif Container (Mid) < Value then\n            if Container'Last /= Mid then\n               return Search (Container (Mid + 1..Container'Last), Value);\n            end if;\n         else\n            return Mid;\n         end if;\n      end if;\n      raise Not_Found;\n   end Search;\n\n   type Integer_Array is array (Positive range <>) of Integer;\n   function Find is new Search (Positive, Integer, Integer_Array);\n\n   procedure Test (X : Integer_Array; E : Integer) is\n   begin\n      New_Line;\n      for I in X'Range loop\n         Put (Integer'Image (X (I)));\n      end loop;\n      Put (\" contains\" & Integer'Image (E) & \" at\" & Integer'Image (Find (X, E)));\n   exception\n      when Not_Found =>\n         Put (\" does not contain\" & Integer'Image (E));\n   end Test;\nbegin\n   Test ((2, 4, 6, 8, 9), 2);\n   Test ((2, 4, 6, 8, 9), 1);\n   Test ((2, 4, 6, 8, 9), 8);\n   Test ((2, 4, 6, 8, 9), 10);\n   Test ((2, 4, 6, 8, 9), 9);\n   Test ((2, 4, 6, 8, 9), 5);\nend Test_Recursive_Binary_Search;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Binary_Search is\n   Not_Found : exception;\n\n   generic\n      type Index is range <>;\n      type Element is private;\n      type Array_Of_Elements is array (Index range <>) of Element;\n      with function \"<\" (L, R : Element) return Boolean is <>;\n   function Search (Container : Array_Of_Elements; Value : Element) return Index;\n\n   function Search (Container : Array_Of_Elements; Value : Element) return Index is\n      Low  : Index := Container'First;\n      High : Index := Container'Last;\n      Mid  : Index;\n   begin\n      if Container'Length > 0 then\n         loop\n            Mid := (Low + High) / 2;\n            if Value < Container (Mid) then\n               exit when Low = Mid;\n               High := Mid - 1;\n            elsif Container (Mid) < Value then\n               exit when High = Mid;\n               Low := Mid + 1;\n            else\n               return Mid;\n            end if;\n         end loop;\n      end if;\n      raise Not_Found;\n   end Search;\n\n   type Integer_Array is array (Positive range <>) of Integer;\n   function Find is new Search (Positive, Integer, Integer_Array);\n\n   procedure Test (X : Integer_Array; E : Integer) is\n   begin\n      New_Line;\n      for I in X'Range loop\n         Put (Integer'Image (X (I)));\n      end loop;\n      Put (\" contains\" & Integer'Image (E) & \" at\" & Integer'Image (Find (X, E)));\n   exception\n      when Not_Found =>\n         Put (\" does not contain\" & Integer'Image (E));\n   end Test;\nbegin\n   Test ((2, 4, 6, 8, 9), 2);\n   Test ((2, 4, 6, 8, 9), 1);\n   Test ((2, 4, 6, 8, 9), 8);\n   Test ((2, 4, 6, 8, 9), 10);\n   Test ((2, 4, 6, 8, 9), 9);\n   Test ((2, 4, 6, 8, 9), 5);\nend Test_Binary_Search;\n"
  },
  {
    "language": "Ada",
    "code": "declare\n   Data : Storage_Array (1..20); -- Data created\nbegin\n   Data := (others => 0); -- Assign all zeros\n   if Data = (1..10 => 0) then -- Compare with 10 zeros\n      declare\n         Copy : Storage_Array := Data; -- Copy Data\n      begin\n         if Data'Length = 0 then -- If empty\n            ...\n         end if;\n      end;\n   end if;\n   ... Data & 1 ...         -- The result is Data with byte 1 appended\n   ... Data & (1,2,3,4) ... -- The result is Data with bytes 1,2,3,4 appended\n   ... Data (3..5) ...      -- The result the substring of Data from 3 to 5\nend; -- Data destructed\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  char is_open[100] = { 0 };\n  int pass, door;\n\n  /* do the 100 passes */\n  for (pass = 0; pass < 100; ++pass)\n    for (door = pass; door < 100; door += pass+1)\n      is_open[door] = !is_open[door];\n\n  /* output the result */\n  for (door = 0; door < 100; ++door)\n    printf(\"door #%d is %s.\\n\", door+1, (is_open[door]? \"open\" : \"closed\"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NUM_DOORS 100\n\nint main(int argc, char *argv[])\n{\n  int is_open[NUM_DOORS] = { 0 } ;\n  int * doorptr, * doorlimit = is_open + NUM_DOORS ;\n  int pass ;\n\n  /* do the N passes, go backwards because the order is not important */\n  for ( pass= NUM_DOORS ; ( pass ) ; -- pass ) {\n    for ( doorptr= is_open + ( pass-1 ); ( doorptr < doorlimit ) ; doorptr += pass ) {\n      ( * doorptr ) ^= 1 ;\n    }\n  }\n\n  /* output results */\n  for ( doorptr= is_open ; ( doorptr != doorlimit ) ; ++ doorptr ) {\n    printf(\"door #%ld is %s\\n\", ( doorptr - is_open ) + 1, ( * doorptr ) ? \"open\" : \"closed\" ) ;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int square = 1, increment = 3, door;\n  for (door = 1; door <= 100; ++door)\n  {\n    printf(\"door #%d\", door);\n    if (door == square)\n    {\n      printf(\" is open.\\n\");\n      square += increment;\n      increment += 2;\n    }\n    else\n      printf(\" is closed.\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int door, square, increment;\n  for (door = 1, square = 1, increment = 1; door <= 100; door++ == square && (square += increment += 2))\n    printf(\"door #%d is %s.\\n\", door, (door == square? \"open\" : \"closed\"));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint i;\n\tfor (i = 1; i * i <= 100; i++)\n\t\tprintf(\"door %d open\\n\", i * i);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define n_cards 4\n#define solve_goal 24\n#define max_digit 9\n\ntypedef struct { int num, denom; } frac_t, *frac;\ntypedef enum { C_NUM = 0, C_ADD, C_SUB, C_MUL, C_DIV } op_type;\n\ntypedef struct expr_t *expr;\ntypedef struct expr_t {\n        op_type op;\n        expr left, right;\n        int value;\n} expr_t;\n\nvoid show_expr(expr e, op_type prec, int is_right)\n{\n        const char * op;\n        switch(e->op) {\n        case C_NUM:     printf(\"%d\", e->value);\n                        return;\n        case C_ADD:     op = \" + \"; break;\n        case C_SUB:     op = \" - \"; break;\n        case C_MUL:     op = \" x \"; break;\n        case C_DIV:     op = \" / \"; break;\n        }\n\n        if ((e->op == prec && is_right) || e->op < prec) printf(\"(\");\n        show_expr(e->left, e->op, 0);\n        printf(\"%s\", op);\n        show_expr(e->right, e->op, 1);\n        if ((e->op == prec && is_right) || e->op < prec) printf(\")\");\n}\n\nvoid eval_expr(expr e, frac f)\n{\n        frac_t left, right;\n        if (e->op == C_NUM) {\n                f->num = e->value;\n                f->denom = 1;\n                return;\n        }\n        eval_expr(e->left, &left);\n        eval_expr(e->right, &right);\n        switch (e->op) {\n        case C_ADD:\n                f->num = left.num * right.denom + left.denom * right.num;\n                f->denom = left.denom * right.denom;\n                return;\n        case C_SUB:\n                f->num = left.num * right.denom - left.denom * right.num;\n                f->denom = left.denom * right.denom;\n                return;\n        case C_MUL:\n                f->num = left.num * right.num;\n                f->denom = left.denom * right.denom;\n                return;\n        case C_DIV:\n                f->num = left.num * right.denom;\n                f->denom = left.denom * right.num;\n                return;\n        default:\n                fprintf(stderr, \"Unknown op: %d\\n\", e->op);\n                return;\n        }\n}\nint solve(expr ex_in[], int len)\n{\n        int i, j;\n        expr_t node;\n        expr ex[n_cards];\n        frac_t final;\n\n        if (len == 1) {\n                eval_expr(ex_in[0], &final);\n                if (final.num == final.denom * solve_goal && final.denom) {\n                        show_expr(ex_in[0], 0, 0);\n                        return 1;\n                }\n                return 0;\n        }\n\n        for (i = 0; i < len - 1; i++) {\n                for (j = i + 1; j < len; j++)\n                        ex[j - 1] = ex_in[j];\n                ex[i] = &node;\n                for (j = i + 1; j < len; j++) {\n                        node.left = ex_in[i];\n                        node.right = ex_in[j];\n                        for (node.op = C_ADD; node.op <= C_DIV; node.op++)\n                                if (solve(ex, len - 1))\n                                        return 1;\n\n                        node.left = ex_in[j];\n                        node.right = ex_in[i];\n                        node.op = C_SUB;\n                        if (solve(ex, len - 1)) return 1;\n                        node.op = C_DIV;\n                        if (solve(ex, len - 1)) return 1;\n\n                        ex[j] = ex_in[j];\n                }\n                ex[i] = ex_in[i];\n        }\n\n        return 0;\n}\n\nint solve24(int n[])\n{\n        int i;\n        expr_t ex[n_cards];\n        expr   e[n_cards];\n        for (i = 0; i < n_cards; i++) {\n                e[i] = ex + i;\n                ex[i].op = C_NUM;\n                ex[i].left = ex[i].right = 0;\n                ex[i].value = n[i];\n        }\n        return solve(e, n_cards);\n}\n\nint main()\n{\n        int i, j, n[] = { 3, 3, 8, 8, 9 };\n        srand(time(0));\n\n        for (j = 0; j < 10; j++) {\n                for (i = 0; i < n_cards; i++) {\n                        n[i] = 1 + (double) rand() * max_digit / RAND_MAX;\n                        printf(\" %d\", n[i]);\n                }\n                printf(\":  \");\n                printf(solve24(n) ? \"\\n\" : \"No solution\\n\");\n        }\n\n        return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <setjmp.h>\n#include <time.h>\n\njmp_buf ctx;\nconst char *msg;\n\nenum { OP_NONE = 0, OP_NUM, OP_ADD, OP_SUB, OP_MUL, OP_DIV };\n\ntypedef struct expr_t *expr, expr_t;\nstruct expr_t {\n\tint op, val, used;\n\texpr left, right;\n};\n\n#define N_DIGITS 4\nexpr_t digits[N_DIGITS];\n\nvoid gen_digits()\n{\n\tint i;\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].val = 1 + rand() % 9;\n}\n\n#define MAX_INPUT 64\nchar str[MAX_INPUT];\nint pos;\n\n#define POOL_SIZE 8\nexpr_t pool[POOL_SIZE];\nint pool_ptr;\n\nvoid reset()\n{\n\tint i;\n\tmsg = 0;\n\tpool_ptr = pos = 0;\n\tfor (i = 0; i < POOL_SIZE; i++) {\n\t\tpool[i].op = OP_NONE;\n\t\tpool[i].left = pool[i].right = 0;\n\t}\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].used = 0;\n}\n\n/* longish jumpish back to input cycle */\nvoid bail(const char *s)\n{\n\tmsg = s;\n\tlongjmp(ctx, 1);\n}\n\nexpr new_expr()\n{\n\tif (pool_ptr < POOL_SIZE)\n\t\treturn pool + pool_ptr++;\n\treturn 0;\n}\n\n/* check next input char */\nint next_tok()\n{\n\twhile (isspace(str[pos])) pos++;\n\treturn str[pos];\n}\n\n/* move input pointer forward */\nint take()\n{\n\tif (str[pos] != '\\0') return ++pos;\n\treturn 0;\n}\n\n/* BNF(ish)\nexpr = term { (\"+\")|(\"-\") term }\nterm = fact { (\"*\")|(\"/\") expr }\nfact =\tnumber\n\t| '(' expr ')'\n*/\n\nexpr get_fact();\nexpr get_term();\nexpr get_expr();\n\nexpr get_expr()\n{\n\tint c;\n\texpr l, r, ret;\n\tif (!(ret = get_term())) bail(\"Expected term\");\n\twhile ((c = next_tok()) == '+' || c == '-') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\t\tif (!(r = get_term())) bail(\"Expected term\");\n\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '+') ? OP_ADD : OP_SUB;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n\nexpr get_term()\n{\n\tint c;\n\texpr l, r, ret;\n\tret = get_fact();\n\twhile((c = next_tok()) == '*' || c == '/') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\n\t\tr = get_fact();\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '*') ? OP_MUL : OP_DIV;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n\nexpr get_digit()\n{\n\tint i, c = next_tok();\n\texpr ret;\n\tif (c >= '0' && c <= '9') {\n\t\ttake();\n\t\tret = new_expr();\n\t\tret->op = OP_NUM;\n\t\tret->val = c - '0';\n\t\tfor (i = 0; i < N_DIGITS; i++)\n\t\t\tif (digits[i].val == ret->val && !digits[i].used) {\n\t\t\t\tdigits[i].used = 1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\tbail(\"Invalid digit\");\n\t}\n\treturn 0;\n}\n\nexpr get_fact()\n{\n\tint c;\n\texpr l = get_digit();\n\tif (l) return l;\n\tif ((c = next_tok()) == '(') {\n\t\ttake();\n\t\tl = get_expr();\n\t\tif (next_tok() != ')') bail(\"Unbalanced parens\");\n\t\ttake();\n\t\treturn l;\n\t}\n\treturn 0;\n}\n\nexpr parse()\n{\n\tint i;\n\texpr ret = get_expr();\n\tif (next_tok() != '\\0')\n\t\tbail(\"Trailing garbage\");\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tif (!digits[i].used)\n\t\t\tbail(\"Not all digits are used\");\n\treturn ret;\n}\n\ntypedef struct frac_t frac_t, *frac;\nstruct frac_t { int denom, num; };\n\nint gcd(int m, int n)\n{\n\tint t;\n\twhile (m) {\n\t\tt = m; m = n % m; n = t;\n\t}\n\treturn n;\n}\n\n/* evaluate expression tree.  result in fraction form */\nvoid eval_tree(expr e, frac res)\n{\n\tfrac_t l, r;\n\tint t;\n\tif (e->op == OP_NUM) {\n\t\tres->num = e->val;\n\t\tres->denom = 1;\n\t\treturn;\n\t}\n\n\teval_tree(e->left, &l);\n\teval_tree(e->right, &r);\n\n\tswitch(e->op) {\n\tcase OP_ADD:\n\t\tres->num = l.num * r.denom + l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_SUB:\n\t\tres->num = l.num * r.denom - l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_MUL:\n\t\tres->num = l.num * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_DIV:\n\t\tres->num = l.num * r.denom;\n\t\tres->denom = l.denom * r.num;\n\t\tbreak;\n\t}\n\tif ((t = gcd(res->denom, res->num))) {\n\t\tres->denom /= t;\n\t\tres->num /= t;\n\t}\n}\n\nvoid get_input()\n{\n\tint i;\nreinput:\n\treset();\n\tprintf(\"\\nAvailable digits are:\");\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tprintf(\" %d\", digits[i].val);\n\tprintf(\". Type an expression and I'll check it for you, or make new numbers.\\n\"\n\t\t\"Your choice? [Expr/n/q] \");\n\n\twhile (1) {\n\t\tfor (i = 0; i < MAX_INPUT; i++) str[i] = '\\n';\n\t\tfgets(str, MAX_INPUT, stdin);\n\t\tif (*str == '\\0') goto reinput;\n\t\tif (str[MAX_INPUT - 1] != '\\n')\n\t\t\tbail(\"string too long\");\n\n\t\tfor (i = 0; i < MAX_INPUT; i++)\n\t\t\tif (str[i] == '\\n') str[i] = '\\0';\n\t\tif (str[0] == 'q') {\n\t\t\tprintf(\"Bye\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (str[0] == 'n') {\n\t\t\tgen_digits();\n\t\t\tgoto reinput;\n\t\t}\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tfrac_t f;\n\tsrand(time(0));\n\n\tgen_digits();\n\twhile(1) {\n\t\tget_input();\n\t\tsetjmp(ctx); /* if parse error, jump back here with err msg set */\n\t\tif (msg) {\n\t\t\t/* after error jump; announce, reset, redo */\n\t\t\tprintf(\"%s at '%.*s'\\n\", msg, pos, str);\n\t\t\tcontinue;\n\t\t}\n\n\t\teval_tree(parse(), &f);\n\n\t\tif (f.denom == 0) bail(\"Divide by zero\");\n\t\tif (f.denom == 1 && f.num == 24)\n\t\t\tprintf(\"You got 24.  Very good.\\n\");\n\t\telse {\n\t\t\tif (f.denom == 1)\n\t\t\t\tprintf(\"Eval to: %d, \", f.num);\n\t\t\telse\n\t\t\t\tprintf(\"Eval to: %d/%d, \", f.num, f.denom);\n\t\t\tprintf(\"no good.  Try again.\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <gmp.h>\n\n#define N 100000\nmpz_t p[N + 1];\n\nvoid calc(int n)\n{\n\tmpz_init_set_ui(p[n], 0);\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tint d = n - k * (3 * k - 1) / 2;\n\t\tif (d < 0) break;\n\n\t\tif (k&1)mpz_add(p[n], p[n], p[d]);\n\t\telse\tmpz_sub(p[n], p[n], p[d]);\n\n\t\td -= k;\n\t\tif (d < 0) break;\n\n\t\tif (k&1)mpz_add(p[n], p[n], p[d]);\n\t\telse\tmpz_sub(p[n], p[n], p[d]);\n\t}\n}\n\nint main(void)\n{\n\tint idx[] = { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n\tint at = 0;\n\n\tmpz_init_set_ui(p[0], 1);\n\n\tfor (int i = 1; idx[at]; i++) {\n\t\tcalc(i);\n\t\tif (i != idx[at]) continue;\n\n\t\tgmp_printf(\"%2d:\\t%Zd\\n\", i, p[i]);\n\t\tat++;\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n * 99 Bottles, C, KISS (i.e. keep it simple and straightforward) version\n */\n\n#include <stdio.h>\n\nint main(void)\n{\n  int n;\n\n  for( n = 99; n > 2; n-- )\n    printf(\n      \"%d bottles of beer on the wall, %d bottles of beer.\\n\"\n      \"Take one down and pass it around, %d bottles of beer on the wall.\\n\\n\",\n       n, n, n - 1);\n\n  printf(\n      \"2 bottles of beer on the wall, 2 bottles of beer.\\n\"\n      \"Take one down and pass it around, 1 bottle of beer on the wall.\\n\\n\"\n\n      \"1 bottle of beer on the wall, 1 bottle of beer.\\n\"\n      \"Take one down and pass it around, no more bottles of beer on the wall.\\n\\n\"\n\n      \"No more bottles of beer on the wall, no more bottles of beer.\\n\"\n      \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\");\n\n      return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n        if(argc == 99)\n                return 99;\n        if(argv[0] != NULL){\n                argv[0] = NULL;\n                argc = 0;\n        }\n        argc = main(argc + 1, argv);\n        printf(\"%d bottle%c of beer on the wall\\n\", argc, argc == 1?'\\0': 's');\n        printf(\"%d bottle%c of beer\\n\", argc, argc == 1?'\\0': 's');\n        printf(\"Take one down, pass it around\\n\");\n        printf(\"%d bottle%c of beer on the wall\\n\\n\", argc - 1, (argc - 1) == 1?'\\0': 's');\n        return argc - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nmain(){_=100;while(--_)printf(\"%i bottle%s of beer in the wall,\\n%i bottle%\"\n\"s of beer.\\nTake one down, pass it round,\\n%s%s\\n\\n\",_,_-1?\"s\":\"\",_,_-1?\"s\"\n:\"\",_-1?(char[]){(_-1)/10?(_-1)/10+48:(_-1)%10+48,(_-1)/10?(_-1)%10+48:2+30,\n(_-1)/10?32:0,0}:\"\",_-1?\"bottles of beer in the wall\":\"No more beers\");}\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main(void)\n{\n  (void) printf(SONG);\n  return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C",
    "code": "      int b =99,u =1;\n     #include<stdio.h>\n      char *d[16],y[]\n      = \"#:ottle/ of\"\n      \":eer_ a_Go<o5\"\n      \"st>y\\x20some6\"\n      \"_Take8;down4p\"\n      \"a=1rou7_17 _<\"\n      \"h;_ m?_nd_ on\"\n      \"_085wal\" \"l_ \"\n      \"b_e _ t_ss it\"\n      \"_?4bu_ore_9, \"\n      \"\\060.\"\"@, 9$\";\n     # define x  c  ^=\n    #include <string.h>\n   #define or(t,z) else\\\n  if(c==t && !(c = 0) &&\\\n (c =! z)); int p(char *t)\n{ char *s = t; int c; for (\nd[c = 0] = y; !t && (d[c +1\n]= strchr(s = d[c], '_'));*\n(d[++c]++) = 0); for(t = s?\ns:t;(c= *s++); c && putchar\n(c)) { if (!((( x 48)& ~0xf\n) && ( x 48)) ) p(d[c]), c=\n0 ; or('$', p(b - 99?\".\\n\":\n\".\" ) && p(b - 99? t : \"\"))\nor ('\\x40', c && p( d[!!b--\n+ 2])) or('/', c && p( b^1?\n\"s\": \"\")) or ('\\043', b++ ?\np(\"So6\" + --b):!printf(\"%d\"\n, b ? --b : (b += 99))) or(\n'S',!(++u % 3) * 32+ 78) or\n('.', puts(\".\"))}return c;}\n int main() {return p(0);}\n"
  },
  {
    "language": "C",
    "code": "// Standard input-output streams\n#include <stdio.h>\nint main()\n{\n   int a, b;\n   scanf(\"%d%d\", &a, &b);\n   printf(\"%d\\n\", a + b);\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// Input file: input.txt\n// Output file: output.txt\n#include <stdio.h>\nint main()\n{\n   freopen(\"input.txt\", \"rt\", stdin);\n   freopen(\"output.txt\", \"wt\", stdout);\n   int a, b;\n   scanf(\"%d%d\", &a, &b);\n   printf(\"%d\\n\", a + b);\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char **argv) //not sure if argv counts as input stream... certainly it is brought here via input stream.\n{\n   printf(\"%d\\n\", atoi(*(argv+1)) + atoi(*(argv+2)));\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint can_make_words(char **b, char *word)\n{\n\tint i, ret = 0, c = toupper(*word);\n\n#define SWAP(a, b) if (a != b) { char * tmp = a; a = b; b = tmp; }\n\n\tif (!c) return 1;\n\tif (!b[0]) return 0;\n\n\tfor (i = 0; b[i] && !ret; i++) {\n\t\tif (b[i][0] != c && b[i][1] != c) continue;\n\t\tSWAP(b[i], b[0]);\n\t\tret = can_make_words(b + 1, word + 1);\n\t\tSWAP(b[i], b[0]);\n\t}\n\n\treturn ret;\n}\n\nint main(void)\n{\n\tchar* blocks[] = {\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n\t\t\"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n\t\t\"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n\t\t0 };\n\n\tchar *words[] = {\n\t\t\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\", 0\n\t};\n\n\tchar **w;\n\tfor (w = words; *w; w++)\n\t\tprintf(\"%s\\t%d\\n\", *w, can_make_words(blocks, *w));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#ifndef INTERFACE_ABS\n#define INTERFACE_ABS\n\ntypedef struct sAbstractCls *AbsCls;\n\ntypedef struct sAbstractMethods {\n    int         (*method1)(AbsCls c, int a);\n    const char *(*method2)(AbsCls c, int b);\n    void        (*method3)(AbsCls c, double d);\n} *AbstractMethods, sAbsMethods;\n\nstruct sAbstractCls {\n    AbstractMethods  klass;\n    void     *instData;\n};\n\n#define ABSTRACT_METHODS( cName, m1, m2, m3 ) \\\n    static sAbsMethods cName ## _Iface = { &m1, &m2, &m3 }; \\\n    AbsCls cName ## _Instance( void *clInst) { \\\n        AbsCls ac = malloc(sizeof(struct sAbstractCls)); \\\n        if (ac) { \\\n            ac->klass = &cName ## _Iface; \\\n            ac->instData = clInst; \\\n        }\\\n        return ac; }\n\n#define Abs_Method1( c, a) (c)->klass->method1(c, a)\n#define Abs_Method2( c, b) (c)->klass->method2(c, b)\n#define Abs_Method3( c, d) (c)->klass->method3(c, d)\n#define Abs_Free(c) \\\n  do { if (c) { free((c)->instData); free(c); } } while(0);\n\n#endif\n"
  },
  {
    "language": "C",
    "code": "#ifndef SILLY_H\n#define SILLY_H\n#include \"intefaceAbs.h\"\n#include <stdlib.h>\n\ntypedef struct sillyStruct *Silly;\nextern Silly NewSilly( double, const char *);\nextern AbsCls Silly_Instance(void *);\n\n#endif\n"
  },
  {
    "language": "C",
    "code": "#include \"silly.h\"\n#include <string.h>\n#include <stdio.h>\n\nstruct sillyStruct {\n    double  v1;\n    char   str[32];\n};\n\nSilly NewSilly(double vInit, const char *strInit)\n{\n    Silly sily = malloc(sizeof( struct sillyStruct ));\n    sily->v1 = vInit;\n    sily->str[0] = '\\0';\n    strncat(sily->str, strInit, 31);\n    return sily;\n}\n\nstatic\nint MyMethod1(  AbsCls c, int a)\n{\n    Silly s = (Silly)(c->instData);\n    return a+strlen(s->str);\n}\n\nstatic\nconst char *MyMethod2(AbsCls c, int b)\n{\n    Silly s = (Silly)(c->instData);\n    sprintf(s->str, \"%d\", b);\n    return s->str;\n}\n\nstatic\nvoid  MyMethod3(AbsCls c, double d)\n{\n    Silly s = (Silly)(c->instData);\n    printf(\"InMyMethod3, %f\\n\",s->v1 * d);\n}\n\nABSTRACT_METHODS( Silly, MyMethod1, MyMethod2, MyMethod3)\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include \"silly.h\"\n\nint main()\n{\n    AbsCls abster = Silly_Instance(NewSilly( 10.1, \"Green Tomato\"));\n\n    printf(\"AbsMethod1: %d\\n\", Abs_Method1(abster, 5));\n    printf(\"AbsMethod2: %s\\n\", Abs_Method2(abster, 4));\n    Abs_Method3(abster, 21.55);\n    Abs_Free(abster);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define de 0\n#define pe 1\n#define ab 2\n\nint main(){\n\tint sum = 0, i, j;\n\tint try_max = 0;\n\t//1 is deficient by default and can add it deficient list\n\tint   count_list[3] = {1,0,0};\n\tfor(i=2; i <= 20000; i++){\n\t\t//Set maximum to check for proper division\n\t\ttry_max = i/2;\n\t\t//1 is in all proper division number\n\t\tsum = 1;\n\t\tfor(j=2; j<try_max; j++){\n\t\t\t//Check for proper division\n\t\t\tif (i % j)\n\t\t\t\tcontinue; //Pass if not proper division\n\t\t\t//Set new maximum for divisibility check\n\t\t\ttry_max = i/j;\n\t\t\t//Add j to sum\n\t\t\tsum += j;\n\t\t\tif (j != try_max)\n\t\t\t\tsum += try_max;\n\t\t}\n\t\t//Categorize summation\n\t\tif (sum < i){\n\t\t\tcount_list[de]++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sum > i){\n\t\t\tcount_list[ab]++;\n\t\t\tcontinue;\n\t\t}\n\t\tcount_list[pe]++;\n\t}\n\tprintf(\"\\nThere are %d deficient,\" ,count_list[de]);\n\tprintf(\" %d perfect,\" ,count_list[pe]);\n\tprintf(\" %d abundant numbers between 1 and 20000.\\n\" ,count_list[ab]);\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n//~ Take a number n and return a function that takes a number i\n#define ACCUMULATOR(name,n) __typeof__(n) name (__typeof__(n) i) { \\\n    static __typeof__(n) _n=n; LOGIC; }\n//~ have it return n incremented by the accumulation of i\n#define LOGIC return _n+=i\nACCUMULATOR(x,1.0)\nACCUMULATOR(y,3)\nACCUMULATOR(z,'a')\n#undef LOGIC\nint main (void) {\n    printf (\"%f\\n\", x(5));   /* 6.000000 */\n    printf (\"%f\\n\", x(2.3)); /* 8.300000 */\n    printf (\"%i\\n\", y(5.0)); /* 8 */\n    printf (\"%i\\n\", y(3.3)); /* 11 */\n    printf (\"%c\\n\", z(5));   /* f */\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint ackermann(int m, int n)\n{\n        if (!m) return n + 1;\n        if (!n) return ackermann(m - 1, 1);\n        return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n        int m, n;\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint m_bits, n_bits;\nint *cache;\n\nint ackermann(int m, int n)\n{\n        int idx, res;\n        if (!m) return n + 1;\n\n        if (n >= 1<<n_bits) {\n                printf(\"%d, %d\\n\", m, n);\n                idx = 0;\n        } else {\n                idx = (m << n_bits) + n;\n                if (cache[idx]) return cache[idx];\n        }\n\n        if (!n) res = ackermann(m - 1, 1);\n        else    res = ackermann(m - 1, ackermann(m, n - 1));\n\n        if (idx) cache[idx] = res;\n        return res;\n}\nint main()\n{\n        int m, n;\n\n        m_bits = 3;\n        n_bits = 20;  /* can save n values up to 2**20 - 1, that's 1 meg */\n        cache = malloc(sizeof(int) * (1 << (m_bits + n_bits)));\n        memset(cache, 0, sizeof(int) * (1 << (m_bits + n_bits)));\n\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <ldap.h>\n...\nchar *name, *password;\n...\nLDAP *ld = ldap_init(\"ldap.somewhere.com\", 389);\nldap_simple_bind_s(ld, name, password);\n... after done with it...\nldap_unbind(ld);\n"
  },
  {
    "language": "C",
    "code": "#include <ldap.h>\n\nchar *name, *password;\n...\n\nLDAP *ld = ldap_init(\"ldap.somewhere.com\", 389);\nldap_simple_bind_s(ld, name, password);\n\nLDAPMessage **result;\nldap_search_s(ld, \"dc=somewhere,dc=com\", LDAP_SCOPE_SUBTREE,\n\t/* search for all persons whose names start with joe or shmoe */\n\t\"(&(objectclass=person)(|(cn=joe*)(cn=shmoe*)))\",\n\tNULL, /* return all attributes */\n\t0,  /* want both types and values of attrs */\n\tresult); /* ldap will allocate room for return messages */\n\n/* arduously do stuff here to result, with ldap_first_message(),\n\tldap_parse_result(), etc. */\n\nldap_msgfree(*result);\t/* free messages */\nldap_unbind(ld);\t/* disconnect */\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <math.h>\n#include <sys/time.h>\n#include <pthread.h>\n\n/* no need to lock the object: at worst the readout would be 1 tick off,\n   which is no worse than integrator's inate inaccuracy */\ntypedef struct {\n\tdouble (*func)(double);\n\tstruct timeval start;\n\tdouble v, last_v, last_t;\n\tpthread_t id;\n} integ_t, *integ;\n\nvoid update(integ x)\n{\n\tstruct timeval tv;\n\tdouble t, v, (*f)(double);\n\n\tf = x->func;\n\tgettimeofday(&tv, 0);\n\tt = ((tv.tv_sec - x->start.tv_sec) * 1000000\n\t\t+ tv.tv_usec - x->start.tv_usec) * 1e-6;\n\tv = f ? f(t) : 0;\n\tx->v += (x->last_v + v) * (t - x->last_t) / 2;\n\tx->last_t = t;\n}\n\nvoid* tick(void *a)\n{\n\tinteg x = a;\n\twhile (1) {\n\t\tusleep(100000); /* update every .1 sec */\n\t\tupdate(x);\n\t}\n}\n\nvoid set_input(integ x, double (*func)(double))\n{\n\tupdate(x);\n\tx->func = func;\n\tx->last_t = 0;\n\tx->last_v = func ? func(0) : 0;\n}\n\ninteg new_integ(double (*func)(double))\n{\n\tinteg x = malloc(sizeof(integ_t));\n\tx->v = x->last_v = 0;\n\tx->func = 0;\n\tgettimeofday(&x->start, 0);\n\tset_input(x, func);\n\tpthread_create(&x->id, 0, tick, x);\n\treturn x;\n}\n\ndouble sine(double t) { return sin(4 * atan2(1, 1) * t); }\n\nint main()\n{\n\tinteg x = new_integ(sine);\n\tsleep(2);\n\tset_input(x, 0);\n\tusleep(500000);\n\tprintf(\"%g\\n\", x->v);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "int i;\nvoid* address_of_i = &i;\n"
  },
  {
    "language": "C",
    "code": "#include <memory>\nint i;\nauto address_of_i = std::addressof(i);\n"
  },
  {
    "language": "C",
    "code": "int& i = *(int*)0xA100;\n"
  },
  {
    "language": "C",
    "code": "#include <new>\nstruct S { int i = 0; S() {} };\nauto& s = *new (reinterpret_cast<void*>(0xa100)) S;\n"
  },
  {
    "language": "C",
    "code": "static union\n{\n  int i;\n  int j;\n};\n"
  },
  {
    "language": "C",
    "code": "int i;\nint& j = i;\n"
  },
  {
    "language": "C",
    "code": "#include <cstring>\ninline float read_as_float(int const& i) { float f; memcpy(&f, &i, sizeof(f)); return f; }\nint i = 0x0a112233;\nfloat f = read_as_float(i);\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nlong long c[100];\n\nvoid coef(int n)\n{\n\tint i, j;\n\n\tif (n < 0 || n > 63) abort(); // gracefully deal with range issue\n\n\tfor (c[i=0] = 1; i < n; c[0] = -c[0], i++)\n\t\tfor (c[1 + (j=i)] = 1; j > 0; j--)\n\t\t\tc[j] = c[j-1] - c[j];\n}\n\nint is_prime(int n)\n{\n\tint i;\n\n\tcoef(n);\n\tc[0] += 1, c[i=n] -= 1;\n\twhile (i-- && !(c[i] % n));\n\n\treturn i < 0;\n}\n\nvoid show(int n)\n{\n\tdo printf(\"%+lldx^%d\", c[n], n); while (n--);\n}\n\nint main(void)\n{\n\tint n;\n\n\tfor (n = 0; n < 10; n++) {\n\t\tcoef(n);\n\t\tprintf(\"(x-1)^%d = \", n);\n\t\tshow(n);\n\t\tputchar('\\n');\n\t}\n\n\tprintf(\"\\nprimes (never mind the 1):\");\n\tfor (n = 1; n <= 63; n++)\n\t\tif (is_prime(n))\n\t\t\tprintf(\" %d\", n);\n\n\tputchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdlib.h>\n#include<string.h>\n#include<stdio.h>\n\nunsigned long long bruteForceProperDivisorSum(unsigned long long n){\n\tunsigned long long i,sum = 0;\n\t\n\tfor(i=1;i<(n+1)/2;i++)\n\t\tif(n%i==0 && n!=i)\n\t\t\tsum += i;\n\t\t\n\treturn sum;\n}\n\nvoid printSeries(unsigned long long* arr,int size,char* type){\n\tint i;\n\t\n\tprintf(\"\\nInteger : %llu, Type : %s, Series : \",arr[0],type);\n\t\n\tfor(i=0;i<size-1;i++)\n\t\tprintf(\"%llu, \",arr[i]);\n\tprintf(\"%llu\",arr[i]);\n}\n\nvoid aliquotClassifier(unsigned long long n){\n\tunsigned long long arr[16];\n\tint i,j;\n\t\n\tarr[0] = n;\n\t\n\tfor(i=1;i<16;i++){\n\t\tarr[i] = bruteForceProperDivisorSum(arr[i-1]);\n\t\t\n\t\tif(arr[i]==0||arr[i]==n||(arr[i]==arr[i-1] && arr[i]!=n)){\n\t\t\tprintSeries(arr,i+1,(arr[i]==0)?\"Terminating\":(arr[i]==n && i==1)?\"Perfect\":(arr[i]==n && i==2)?\"Amicable\":(arr[i]==arr[i-1] && arr[i]!=n)?\"Aspiring\":\"Sociable\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(arr[j]==arr[i]){\n\t\t\t\tprintSeries(arr,i+1,\"Cyclic\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintSeries(arr,i+1,\"Non-Terminating\");\n}\n\nvoid processFile(char* fileName){\n\tFILE* fp = fopen(fileName,\"r\");\n\tchar str[21];\n\t\n\twhile(fgets(str,21,fp)!=NULL)\n\t\taliquotClassifier(strtoull(str,(char**)NULL,10));\n\t\n\tfclose(fp);\n}\n\nint main(int argC,char* argV[])\n{\n    if(argC!=2)\n\t\tprintf(\"Usage : %s <positive integer>\",argV[0]);\n\telse{\n\t\tif(strchr(argV[1],'.')!=NULL)\n\t\t\tprocessFile(argV[1]);\n\t\telse\n\t\t\taliquotClassifier(strtoull(argV[1],(char**)NULL,10));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n\nunsigned long long raiseTo(unsigned long long base, unsigned long long power){\n    unsigned long long result = 1,i;\n    for (i=0; i<power;i++) {\n        result*=base;\n    }\n    return result;\n}\n\nunsigned long long properDivisorSum(unsigned long long n){\n\tunsigned long long prod = 1;\n\tunsigned long long temp = n,i,count = 0;\n\n\twhile(n%2 == 0){\n\t\tcount++;\n\t\tn /= 2;\n\t}\n\t\n\tif(count!=0)\n\t\tprod *= (raiseTo(2,count + 1) - 1);\n\n\tfor(i=3;i*i<=n;i+=2){\n\t\tcount = 0;\n\t\t\n\t\twhile(n%i == 0){\n\t\t\tcount++;\n\t\t\tn /= i;\n\t\t}\n\t\t\n\t\tif(count==1)\n\t\t\tprod *= (i+1);\n\t\telse if(count > 1)\n\t\t\tprod *= ((raiseTo(i,count + 1) - 1)/(i-1));\n\t}\n\t\n\tif(n>2)\n\t\tprod *= (n+1);\n\n\treturn prod - temp;\n}\n\nvoid printSeries(unsigned long long* arr,int size,char* type){\n\tint i;\n\t\n\tprintf(\"\\nInteger : %llu, Type : %s, Series : \",arr[0],type);\n\t\n\tfor(i=0;i<size-1;i++)\n\t\tprintf(\"%llu, \",arr[i]);\n\tprintf(\"%llu\",arr[i]);\n}\n\nvoid aliquotClassifier(unsigned long long n){\n\tunsigned long long arr[16];\n\tint i,j;\n\t\n\tarr[0] = n;\n\t\n\tfor(i=1;i<16;i++){\n\t\tarr[i] = properDivisorSum(arr[i-1]);\n\t\t\n\t\tif(arr[i]==0||arr[i]==n||(arr[i]==arr[i-1] && arr[i]!=n)){\n\t\t\tprintSeries(arr,i+1,(arr[i]==0)?\"Terminating\":(arr[i]==n && i==1)?\"Perfect\":(arr[i]==n && i==2)?\"Amicable\":(arr[i]==arr[i-1] && arr[i]!=n)?\"Aspiring\":\"Sociable\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(arr[j]==arr[i]){\n\t\t\t\tprintSeries(arr,i+1,\"Cyclic\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintSeries(arr,i+1,\"Non-Terminating\");\n}\n\nvoid processFile(char* fileName){\n\tFILE* fp = fopen(fileName,\"r\");\n\tchar str[21];\n\t\n\twhile(fgets(str,21,fp)!=NULL)\n\t\taliquotClassifier(strtoull(str,(char**)NULL,10));\n\t\n\tfclose(fp);\n}\n\nint main(int argC,char* argV[])\n{\n    if(argC!=2)\n\t\tprintf(\"Usage : %s <positive integer>\",argV[0]);\n\telse{\n\t\tif(strchr(argV[1],'.')!=NULL)\n\t\t\tprocessFile(argV[1]);\n\t\telse\n\t\t\taliquotClassifier(strtoull(argV[1],(char**)NULL,10));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint kprime(int n, int k)\n{\n\tint p, f = 0;\n\tfor (p = 2; f < k && p*p <= n; p++)\n\t\twhile (0 == n % p)\n\t\t\tn /= p, f++;\n\n\treturn f + (n > 1) == k;\n}\n\nint main(void)\n{\n\tint i, c, k;\n\n\tfor (k = 1; k <= 5; k++) {\n\t\tprintf(\"k = %d:\", k);\n\n\t\tfor (i = 2, c = 0; c < 10; i++)\n\t\t\tif (kprime(i, k)) {\n\t\t\t\tprintf(\" %d\", i);\n\t\t\t\tc++;\n\t\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "typedef const char * amb_t;\n\namb_t amb(size_t argc, ...)\n{\n  amb_t *choices;\n  va_list ap;\n  int i;\n\n  if(argc) {\n    choices = malloc(argc*sizeof(amb_t));\n    va_start(ap, argc);\n    i = 0;\n    do { choices[i] = va_arg(ap, amb_t); } while(++i < argc);\n    va_end(ap);\n\n    i = 0;\n    do { TRY(choices[i]); } while(++i < argc);\n    free(choices);\n  }\n\n  FAIL;\n}\n\nint joins(const char *left, const char *right) { return left[strlen(left)-1] == right[0]; }\n\nint _main() {\n  const char *w1,*w2,*w3,*w4;\n\n  w1 = amb(3, \"the\", \"that\", \"a\");\n  w2 = amb(3, \"frog\", \"elephant\", \"thing\");\n  w3 = amb(3, \"walked\", \"treaded\", \"grows\");\n  w4 = amb(2, \"slowly\", \"quickly\");\n\n  if(!joins(w1, w2)) amb(0);\n  if(!joins(w2, w3)) amb(0);\n  if(!joins(w3, w4)) amb(0);\n\n  printf(\"%s %s %s %s\\n\", w1, w2, w3, w4);\n\n  return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef unsigned int uint;\n\nint main(int argc, char **argv)\n{\n  uint top = atoi(argv[1]);\n  uint *divsum = malloc((top + 1) * sizeof(*divsum));\n  uint pows[32] = {1, 0};\n\n  for (uint i = 0; i <= top; i++) divsum[i] = 1;\n\n  // sieve\n  // only sieve within lower half , the modification starts at 2*p\n  for (uint p = 2; p+p <= top; p++) {\n    if (divsum[p] > 1) {\n      divsum[p] -= p;// subtract number itself from divisor sum ('proper')\n      continue;}     // p not prime\n\n    uint x; // highest power of p we need\n    //checking x <= top/y instead of x*y <= top to avoid overflow\n    for (x = 1; pows[x - 1] <= top/p; x++)\n      pows[x] = p*pows[x - 1];\n\n    //counter where n is not a*p with a = ?*p, useful for most p.\n    //think of p>31 seldom divisions or p>sqrt(top) than no division is needed\n    //n = 2*p, so the prime itself is left unchanged => k=p-1\n    uint k= p-1;\n    for (uint n = p+p; n <= top; n += p) {\n      uint s=1+pows[1];\n      k--;\n      // search the right power only if needed\n      if ( k==0) {\n        for (uint i = 2; i < x && !(n%pows[i]); s += pows[i++]);\n        k = p; }\n      divsum[n] *= s;\n    }\n  }\n\n  //now correct the upper half\n  for (uint p = (top >> 1)+1; p <= top; p++) {\n    if (divsum[p] > 1){\n      divsum[p] -= p;}\n  }\n\n  uint cnt = 0;\n  for (uint a = 1; a <= top; a++) {\n    uint b = divsum[a];\n    if (b > a && b <= top && divsum[b] == a){\n      printf(\"%u %u\\n\", a, b);\n      cnt++;}\n  }\n  printf(\"\\nTop %u count : %u\\n\",top,cnt);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\nchar *sortedWord(const char *word, char *wbuf)\n{\n    char *p1, *p2, *endwrd;\n    char t;\n    int swaps;\n\n    strcpy(wbuf, word);\n    endwrd = wbuf+strlen(wbuf);\n    do {\n       swaps = 0;\n       p1 = wbuf; p2 = endwrd-1;\n       while (p1<p2) {\n          if (*p2 > *p1) {\n             t = *p2; *p2 = *p1; *p1 = t;\n             swaps = 1;\n          }\n          p1++; p2--;\n       }\n       p1 = wbuf; p2 = p1+1;\n       while(p2 < endwrd) {\n           if (*p2 > *p1) {\n             t = *p2; *p2 = *p1; *p1 = t;\n             swaps = 1;\n           }\n           p1++; p2++;\n       }\n    } while (swaps);\n    return wbuf;\n}\n\nstatic\nshort cxmap[] = {\n    0x06, 0x1f, 0x4d, 0x0c, 0x5c, 0x28, 0x5d, 0x0e, 0x09, 0x33, 0x31, 0x56,\n    0x52, 0x19, 0x29, 0x53, 0x32, 0x48, 0x35, 0x55, 0x5e, 0x14, 0x27, 0x24,\n    0x02, 0x3e, 0x18, 0x4a, 0x3f, 0x4c, 0x45, 0x30, 0x08, 0x2c, 0x1a, 0x03,\n    0x0b, 0x0d, 0x4f, 0x07, 0x20, 0x1d, 0x51, 0x3b, 0x11, 0x58, 0x00, 0x49,\n    0x15, 0x2d, 0x41, 0x17, 0x5f, 0x39, 0x16, 0x42, 0x37, 0x22, 0x1c, 0x0f,\n    0x43, 0x5b, 0x46, 0x4b, 0x0a, 0x26, 0x2e, 0x40, 0x12, 0x21, 0x3c, 0x36,\n    0x38, 0x1e, 0x01, 0x1b, 0x05, 0x4e, 0x44, 0x3d, 0x04, 0x10, 0x5a, 0x2a,\n    0x23, 0x34, 0x25, 0x2f, 0x2b, 0x50, 0x3a, 0x54, 0x47, 0x59, 0x13, 0x57,\n   };\n#define CXMAP_SIZE (sizeof(cxmap)/sizeof(short))\n\n\nint Str_Hash( const char *key, int ix_max )\n{\n   const char *cp;\n   short mash;\n   int  hash = 33501551;\n   for (cp = key; *cp; cp++) {\n      mash = cxmap[*cp % CXMAP_SIZE];\n      hash = (hash >>4) ^ 0x5C5CF5C ^ ((hash<<1) + (mash<<5));\n      hash &= 0x3FFFFFFF;\n      }\n   return  hash % ix_max;\n}\n\ntypedef struct sDictWord  *DictWord;\nstruct sDictWord {\n    const char *word;\n    DictWord next;\n};\n\ntypedef struct sHashEntry *HashEntry;\nstruct sHashEntry {\n    const char *key;\n    HashEntry next;\n    DictWord  words;\n    HashEntry link;\n    short wordCount;\n};\n\n#define HT_SIZE 8192\n\nHashEntry hashTable[HT_SIZE];\n\nHashEntry mostPerms = NULL;\n\nint buildAnagrams( FILE *fin )\n{\n    char buffer[40];\n    char bufr2[40];\n    char *hkey;\n    int hix;\n    HashEntry he, *hep;\n    DictWord  we;\n    int  maxPC = 2;\n    int numWords = 0;\n\n    while ( fgets(buffer, 40, fin)) {\n        for(hkey = buffer; *hkey && (*hkey!='\\n'); hkey++);\n        *hkey = 0;\n        hkey = sortedWord(buffer, bufr2);\n        hix = Str_Hash(hkey, HT_SIZE);\n        he = hashTable[hix]; hep = &hashTable[hix];\n        while( he && strcmp(he->key , hkey) ) {\n            hep = &he->next;\n            he = he->next;\n        }\n        if ( ! he ) {\n            he = malloc(sizeof(struct sHashEntry));\n            he->next = NULL;\n            he->key = strdup(hkey);\n            he->wordCount = 0;\n            he->words = NULL;\n            he->link = NULL;\n            *hep = he;\n        }\n        we = malloc(sizeof(struct sDictWord));\n        we->word = strdup(buffer);\n        we->next = he->words;\n        he->words = we;\n        he->wordCount++;\n        if ( maxPC < he->wordCount) {\n            maxPC = he->wordCount;\n            mostPerms = he;\n            he->link = NULL;\n        }\n        else if (maxPC == he->wordCount) {\n            he->link = mostPerms;\n            mostPerms = he;\n        }\n\n        numWords++;\n    }\n    printf(\"%d words in dictionary max ana=%d\\n\", numWords, maxPC);\n    return maxPC;\n}\n\n\nint main( )\n{\n    HashEntry he;\n    DictWord  we;\n    FILE *f1;\n\n    f1 = fopen(\"unixdict.txt\",\"r\");\n    buildAnagrams(f1);\n    fclose(f1);\n\n    f1 = fopen(\"anaout.txt\",\"w\");\n//    f1 = stdout;\n\n    for (he = mostPerms; he; he = he->link) {\n        fprintf(f1,\"%d:\", he->wordCount);\n        for(we = he->words; we; we = we->next) {\n            fprintf(f1,\"%s, \", we->word);\n        }\n        fprintf(f1, \"\\n\");\n    }\n\n    fclose(f1);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <string.h>\n\ntypedef struct { const char *key, *word; int cnt; } kw_t;\n\nint lst_cmp(const void *a, const void *b)\n{\n\treturn strcmp(((const kw_t*)a)->key, ((const kw_t*)b)->key);\n}\n\n/* Bubble sort.  Faster than stock qsort(), believe it or not */\nvoid sort_letters(char *s)\n{\n\tint i, j;\n\tchar t;\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tfor (j = i + 1; s[j] != '\\0'; j++)\n\t\t\tif (s[j] < s[i]) {\n\t\t\t\tt = s[j]; s[j] = s[i]; s[i] = t;\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tstruct stat s;\n\tchar *words, *keys;\n\tsize_t i, j, k, longest, offset;\n\tint n_word = 0;\n\tkw_t *list;\n\n\tint fd = open(\"unixdict.txt\", O_RDONLY);\n\tif (fd == -1) return 1;\n\tfstat(fd, &s);\n\twords = malloc(s.st_size * 2);\n\tkeys  = words + s.st_size;\n\n\tread(fd, words, s.st_size);\n\tmemcpy(keys, words, s.st_size);\n\n\t/* change newline to null for easy use; sort letters in keys */\n\tfor (i = j = 0; i < s.st_size; i++) {\n\t\tif (words[i] == '\\n') {\n\t\t\twords[i] = keys[i] = '\\0';\n\t\t\tsort_letters(keys + j);\n\t\t\tj = i + 1;\n\t\t\tn_word ++;\n\t\t}\n\t}\n\n\tlist = calloc(n_word, sizeof(kw_t));\n\n\t/* make key/word pointer pairs for sorting */\n\tfor (i = j = k = 0; i < s.st_size; i++) {\n\t\tif (words[i] == '\\0') {\n\t\t\tlist[j].key = keys + k;\n\t\t\tlist[j].word = words + k;\n\t\t\tk = i + 1;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tqsort(list, n_word, sizeof(kw_t), lst_cmp);\n\n\t/* count each key's repetition */\n\tfor (i = j = k = offset = longest = 0; i < n_word; i++) {\n\t\tif (!strcmp(list[i].key, list[j].key)) {\n\t\t\t++k;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* move current longest to begining of array */\n\t\tif (k < longest) {\n\t\t\tk = 0;\n\t\t\tj = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (k > longest) offset = 0;\n\n\t\twhile (j < i) list[offset++] = list[j++];\n\t\tlongest = k;\n\t\tk = 0;\n\t}\n\n\t/* show the longest */\n\tfor (i = 0; i < offset; i++) {\n\t\tprintf(\"%s \", list[i].word);\n\t\tif (i < n_word - 1 && strcmp(list[i].key, list[i+1].key))\n\t\t\tprintf(\"\\n\");\n\t}\n\n\t/* free(list); free(words); */\n\tclose(fd);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n// Letter lookup by frequency.  This is to reduce word insertion time.\nconst char *freq = \"zqxjkvbpygfwmucldrhsnioate\";\nint char_to_idx[128];\n\n// Trie structure of sorts\nstruct word {\n\tconst char *w;\n\tstruct word *next;\n};\n\nunion node {\n\tunion node *down[10];\n\tstruct word *list[10];\n};\n\nint deranged(const char *s1, const char *s2)\n{\n\tint i;\n\tfor (i = 0; s1[i]; i++)\n\t\tif (s1[i] == s2[i]) return 0;\n\treturn 1;\n}\n\nint count_letters(const char *s, unsigned char *c)\n{\n\tint i, len;\n\tmemset(c, 0, 26);\n\tfor (len = i = 0; s[i]; i++) {\n\t\tif (s[i] < 'a' || s[i] > 'z')\n\t\t\treturn 0;\n\t\tlen++, c[char_to_idx[(unsigned char)s[i]]]++;\n\t}\n\treturn len;\n}\n\nconst char * insert(union node *root, const char *s, unsigned char *cnt)\n{\n\tint i;\n\tunion node *n;\n\tstruct word *v, *w = 0;\n\n\tfor (i = 0; i < 25; i++, root = n) {\n\t\tif (!(n = root->down[cnt[i]]))\n\t\t\troot->down[cnt[i]] = n = calloc(1, sizeof(union node));\n\t}\n\n\tw = malloc(sizeof(struct word));\n\tw->w = s;\n\tw->next = root->list[cnt[25]];\n\troot->list[cnt[25]] = w;\n\n\tfor (v = w->next; v; v = v->next) {\n\t\tif (deranged(w->w, v->w))\n\t\t\treturn v->w;\n\t}\n\treturn 0;\n}\n\nint main(int c, char **v)\n{\n\tint i, j = 0;\n\tchar *words;\n\tstruct stat st;\n\n\tint fd = open(c < 2 ? \"unixdict.txt\" : v[1], O_RDONLY);\n\tif (fstat(fd, &st) < 0) return 1;\n\n\twords = malloc(st.st_size);\n\tread(fd, words, st.st_size);\n\tclose(fd);\n\n\tunion node root = {{0}};\n\tunsigned char cnt[26];\n\tint best_len = 0;\n\tconst char *b1, *b2;\n\n\tfor (i = 0; freq[i]; i++)\n\t\tchar_to_idx[(unsigned char)freq[i]] = i;\n\n\t/* count words, change newline to null */\n\tfor (i = j = 0; i < st.st_size; i++) {\n\t\tif (words[i] != '\\n') continue;\n\t\twords[i] = '\\0';\n\n\t\tif (i - j > best_len) {\n\t\t\tcount_letters(words + j, cnt);\n\t\t\tconst char *match = insert(&root, words + j, cnt);\n\n\t\t\tif (match) {\n\t\t\t\tbest_len = i - j;\n\t\t\t\tb1 = words + j;\n\t\t\t\tb2 = match;\n\t\t\t}\n\t\t}\n\n\t\tj = ++i;\n\t}\n\n\tif (best_len) printf(\"longest derangement: %s %s\\n\", b1, b2);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <math.h>\n#include <GL/glut.h>\n#include <GL/gl.h>\n#include <sys/time.h>\n\n#define length 5\n#define g 9.8\ndouble alpha, accl, omega = 0, E;\nstruct timeval tv;\n\ndouble elappsed() {\n\tstruct timeval now;\n\tgettimeofday(&now, 0);\n\tint ret = (now.tv_sec - tv.tv_sec) * 1000000\n\t\t+ now.tv_usec - tv.tv_usec;\n\ttv = now;\n\treturn ret / 1.e6;\n}\n\nvoid resize(int w, int h)\n{\n\tglViewport(0, 0, w, h);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\tglOrtho(0, w, h, 0, -1, 1);\n}\n\nvoid render()\n{\n\tdouble x = 320 + 300 * sin(alpha), y = 300 * cos(alpha);\n\tresize(640, 320);\n \tglClear(GL_COLOR_BUFFER_BIT);\n\n\tglBegin(GL_LINES);\n\tglVertex2d(320, 0);\n\tglVertex2d(x, y);\n\tglEnd();\n\tglFlush();\n\n\tdouble us = elappsed();\n\talpha += (omega + us * accl / 2) * us;\n\tomega += accl * us;\n\n\t/* don't let precision error go out of hand */\n\tif (length * g * (1 - cos(alpha)) >= E) {\n\t\talpha = (alpha < 0 ? -1 : 1) * acos(1 - E / length / g);\n\t\tomega = 0;\n\t}\n\taccl = -g / length * sin(alpha);\n}\n\nvoid init_gfx(int *c, char **v)\n{\n\tglutInit(c, v);\n\tglutInitDisplayMode(GLUT_RGB);\n\tglutInitWindowSize(640, 320);\n\tglutIdleFunc(render);\n\tglutCreateWindow(\"Pendulum\");\n}\n\nint main(int c, char **v)\n{\n\talpha = 4 * atan2(1, 1) / 2.1;\n\tE = length * g * (1 - cos(alpha));\n\n\taccl = -g / length * sin(alpha);\n\tomega = 0;\n\n\tgettimeofday(&tv, 0);\n\tinit_gfx(&c, v);\n\tglutMainLoop();\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <string.h>\n#include <gtk/gtk.h>\n\nconst gchar *hello = \"Hello World! \";\ngint direction = -1;\ngint cx=0;\ngint slen=0;\n\nGtkLabel *label;\n\nvoid change_dir(GtkLayout *o, gpointer d)\n{\n  direction = -direction;\n}\n\ngchar *rotateby(const gchar *t, gint q, gint l)\n{\n  gint i, cl = l, j;\n  gchar *r = malloc(l+1);\n  for(i=q, j=0; cl > 0; cl--, i = (i + 1)%l, j++)\n    r[j] = t[i];\n  r[l] = 0;\n  return r;\n}\n\ngboolean scroll_it(gpointer data)\n{\n  if ( direction > 0 )\n    cx = (cx + 1) % slen;\n  else\n    cx = (cx + slen - 1 ) % slen;\n  gchar *scrolled = rotateby(hello, cx, slen);\n  gtk_label_set_text(label, scrolled);\n  free(scrolled);\n  return TRUE;\n}\n\n\nint main(int argc, char **argv)\n{\n  GtkWidget *win;\n  GtkButton *button;\n  PangoFontDescription *pd;\n\n  gtk_init(&argc, &argv);\n  win = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n  gtk_window_set_title(GTK_WINDOW(win), \"Basic Animation\");\n  g_signal_connect(G_OBJECT(win), \"delete-event\", gtk_main_quit, NULL);\n\n  label = (GtkLabel *)gtk_label_new(hello);\n\n  // since we shift a whole character per time, it's better to use\n  // a monospace font, so that the shifting seems done at the same pace\n  pd = pango_font_description_new();\n  pango_font_description_set_family(pd, \"monospace\");\n  gtk_widget_modify_font(GTK_WIDGET(label), pd);\n\n  button = (GtkButton *)gtk_button_new();\n  gtk_container_add(GTK_CONTAINER(button), GTK_WIDGET(label));\n\n  gtk_container_add(GTK_CONTAINER(win), GTK_WIDGET(button));\n  g_signal_connect(G_OBJECT(button), \"clicked\", G_CALLBACK(change_dir), NULL);\n\n  slen = strlen(hello);\n\n  g_timeout_add(125, scroll_it, NULL);\n\n  gtk_widget_show_all(GTK_WIDGET(win));\n  gtk_main();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong fib(long x)\n{\n        long fib_i(long n) { return n < 2 ? n : fib_i(n - 2) + fib_i(n - 1); };\n        if (x < 0) {\n                printf(\"Bad argument: fib(%ld)\\n\", x);\n                return -1;\n        }\n        return fib_i(x);\n}\n\nlong fib_i(long n) /* just to show the fib_i() inside fib() has no bearing outside it */\n{\n        printf(\"This is not the fib you are looking for\\n\");\n        return -1;\n}\n\nint main()\n{\n        long x;\n        for (x = -1; x < 4; x ++)\n                printf(\"fib %ld = %ld\\n\", x, fib(x));\n\n        printf(\"calling fib_i from outside fib:\\n\");\n        fib_i(3);\n\n        return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n/* note that UID & GID are of type \"int\" */\ntypedef const char *STRING;\ntypedef struct{STRING fullname, office, extension, homephone, email; } gecos_t;\ntypedef struct{STRING account, password; int uid, gid; gecos_t gecos; STRING directory, shell; } passwd_t;\n\n#define GECOS_FMT \"%s,%s,%s,%s,%s\"\n#define PASSWD_FMT \"%s:%s:%d:%d:\"GECOS_FMT\":%s:%s\"\n\npasswd_t passwd_list[]={\n  {\"jsmith\", \"x\", 1001, 1000, /* UID and GID are type int */\n    {\"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\"},\n    \"/home/jsmith\", \"/bin/bash\"},\n  {\"jdoe\", \"x\", 1002, 1000,\n    {\"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\"},\n    \"/home/jdoe\", \"/bin/bash\"}\n};\n\nmain(){\n/****************************\n* Create a passwd text file *\n****************************/\n  FILE *passwd_text=fopen(\"passwd.txt\", \"w\");\n  int rec_num;\n  for(rec_num=0; rec_num < sizeof passwd_list/sizeof(passwd_t); rec_num++)\n    fprintf(passwd_text, PASSWD_FMT\"\\n\", passwd_list[rec_num]);\n  fclose(passwd_text);\n\n/********************************\n* Load text ready for appending *\n********************************/\n  passwd_text=fopen(\"passwd.txt\", \"a+\");\n  char passwd_buf[BUFSIZ]; /* warning: fixed length */\n  passwd_t new_rec =\n      {\"xyz\", \"x\", 1003, 1000, /* UID and GID are type int */\n          {\"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\"},\n          \"/home/xyz\", \"/bin/bash\"};\n  sprintf(passwd_buf, PASSWD_FMT\"\\n\", new_rec);\n/* An atomic append without a file lock,\n   Note: wont work on some file systems, eg NFS */\n  write(fileno(passwd_text), passwd_buf, strlen(passwd_buf));\n  close(passwd_text);\n\n/***********************************************\n* Finally reopen and check record was appended *\n***********************************************/\n  passwd_text=fopen(\"passwd.txt\", \"r\");\n  while(!feof(passwd_text))\n    fscanf(passwd_text, \"%[^\\n]\\n\", passwd_buf, \"\\n\");\n  if(strstr(passwd_buf, \"xyz\"))\n    printf(\"Appended record: %s\\n\", passwd_buf);\n}\n"
  },
  {
    "language": "C",
    "code": "#ifndef CALLBACK_H\n#define CALLBACK_H\n\n/*\n * By declaring the function in a separate file, we allow\n * it to be used by other source files.\n *\n * It also stops ICC from complaining.\n *\n * If you don't want to use it outside of callback.c, this\n * file can be removed, provided the static keyword is prepended\n * to the definition.\n */\nvoid map(int* array, int len, void(*callback)(int,int));\n\n#endif\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include \"callback.h\"\n\n/*\n * We don't need this function outside of this file, so\n * we declare it static.\n */\nstatic void callbackFunction(int location, int value)\n{\n  printf(\"array[%d] = %d\\n\", location, value);\n}\n\nvoid map(int* array, int len, void(*callback)(int,int))\n{\n  int i;\n  for(i = 0; i < len; i++)\n  {\n     callback(i, array[i]);\n  }\n}\n\nint main()\n{\n  int array[] = { 1, 2, 3, 4 };\n  map(array, 4, callbackFunction);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <gmp.h>\n#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n\tmpz_t a;\n\tmpz_init_set_ui(a, 5);\n\tmpz_pow_ui(a, a, 1 << 18); /* 2**18 == 4**9 */\n\n\tint len = mpz_sizeinbase(a, 10);\n\tprintf(\"GMP says size is: %d\\n\", len);\n\n\t/* because GMP may report size 1 too big; see doc */\n\tchar *s = mpz_get_str(0, 10, a);\n\tprintf(\"size really is %d\\n\", len = strlen(s));\n\tprintf(\"Digits: %.20s...%s\\n\", s, s + len - 20);\n\n\t// free(s); /* we could, but we won't. we are exiting anyway */\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/* 5432.c */\n\n#include <openssl/bn.h>\t\t/* BN_*() */\n#include <openssl/err.h>\t/* ERR_*() */\n#include <stdlib.h>\t\t/* exit() */\n#include <stdio.h>\t\t/* fprintf() */\n#include <string.h>\t\t/* strlen() */\n\nvoid\nfail(const char *message)\n{\n\tfprintf(stderr, \"%s: error 0x%08lx\\n\", ERR_get_error());\n\texit(1);\n}\n\nint\nmain()\n{\n\tBIGNUM two, three, four, five;\n\tBIGNUM answer;\n\tBN_CTX *context;\n\tsize_t length;\n\tchar *string;\n\n\tcontext = BN_CTX_new();\n\tif (context == NULL)\n\t\tfail(\"BN_CTX_new\");\n\n\t/* answer = 5 ** 4 ** 3 ** 2 */\n\tBN_init(&two);\n\tBN_init(&three);\n\tBN_init(&four);\n\tBN_init(&five);\n\tif (BN_set_word(&two, 2) == 0 ||\n\t    BN_set_word(&three, 3) == 0 ||\n\t    BN_set_word(&four, 4) == 0 ||\n\t    BN_set_word(&five, 5) == 0)\n\t\tfail(\"BN_set_word\");\n\tBN_init(&answer);\n\tif (BN_exp(&answer, &three, &two, context) == 0 ||\n\t    BN_exp(&answer, &four, &answer, context) == 0 ||\n\t    BN_exp(&answer, &five, &answer, context) == 0)\n\t\tfail(\"BN_exp\");\n\n\t/* string = decimal answer */\n\tstring = BN_bn2dec(&answer);\n\tif (string == NULL)\n\t\tfail(\"BN_bn2dec\");\n\n\tlength = strlen(string);\n\tprintf(\" First 20 digits: %.20s\\n\", string);\n\tif (length >= 20)\n\t\tprintf(\"  Last 20 digits: %.20s\\n\", string + length - 20);\n\tprintf(\"Number of digits: %zd\\n\", length);\n\n\tOPENSSL_free(string);\n\tBN_free(&answer);\n\tBN_free(&five);\n\tBN_free(&four);\n\tBN_free(&three);\n\tBN_free(&two);\n\tBN_CTX_free(context);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/* 5432_pure.c */\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n\n/* return = a * b.  Caller is responsible for freeing memory.\n * Handling of negatives, and zeros is not here, since not needed.\n */\nunsigned char *str_mult(const unsigned char *A, const unsigned char *B)\n{\n\tint ax = 0, bx = 0, rx = 0, al, bl;\n\tunsigned char *a, *b, *r; /* result */\n\n\tal = strlen(A); bl = strlen(B);\n\tr = calloc(al + bl + 1, 1);\n\t/* convert A and B from ASCII string numbers, into numeric */\n\ta = malloc(al+1); strcpy(a, A); for (ax = 0; ax < al; ++ax) a[ax] -= '0';\n\tb = malloc(bl+1); strcpy(b, B); for (bx = 0; bx < bl; ++bx) b[bx] -= '0';\n\t\n\t/* grade-school method of multiplication */\n\tfor (ax = al - 1; ax >= 0; ax--) {\n\t\tint carry = 0;\n\t\tfor (bx = bl - 1, rx = ax + bx + 1; bx >= 0; bx--, rx--) {\n\t\t\tint n = a[ax] * b[bx] + r[rx] + carry;\n\t\t\tr[rx] = (n % 10);\n\t\t\tcarry = n / 10;\n\t\t}\n\t\tr[rx] += carry;\n\t}\n\t/* convert result from numeric into ASCII string numeric */\n\tfor (rx = 0; rx < al + bl; ++rx)\n\t\tr[rx] += '0';\n\twhile (r[0] == '0')\n\t    memmove(r, &r[1], al + bl);\n\tfree(b); free(a);\n\treturn r;\n}\n\nunsigned char *str_exp(int b, int n) {\n  unsigned char *r, *tmp, *a;\n\n  r = malloc(2); strcpy(r, \"1\");\n  a = malloc(24); sprintf(a, \"%d\", b);\n\n  while (n!=1) {\n    if (n%2==1) {\n\t  tmp = str_mult(r, a);\n\t  free(r);\n\t  r = tmp;\n    }\n    n >>= 1;\n\ttmp = str_mult(a, a);\n\tfree(a);\n\ta = tmp;\n  }\n  free(r);\n  return a;\n}\n\n/* compute 5^4^3^2   which == 5^262144 */\nint main() {\n\tunsigned char *r = str_exp(5,262144);\n\tprintf (\"Length of 5^4^3^2 is %d\\n\", strlen(r));\n\tprintf (\"First 20 digits:  %20.20s\\n\", r);\n\tprintf (\"Last 20 digits:   %s\\n\", &r[strlen(r)-20]);\n\tfree(r);\n\tprintf (\"This took %.2f seconds\\n\", ((double)clock())/CLOCKS_PER_SEC);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n"
  },
  {
    "language": "C",
    "code": "int *var = malloc(n*sizeof(int));\nTypename *var = malloc(sizeof(Typename));\nTypename *var = malloc(sizeof var[0]);\n"
  },
  {
    "language": "C",
    "code": "typedef struct mytypeStruct { .... } sMyType, *MyType;\n\nMyType var = malloc(sizeof(sMyType));\n"
  },
  {
    "language": "C",
    "code": "/* allocate an array of n MyTypes */\nMyType var = calloc(n, sizeof(sMyType));\n\nMyType third = var+3;       /* a reference to the 3rd item allocated */\n\nMyType fourth = &var[4];    /* another way, getting the fourth item */\n"
  },
  {
    "language": "C",
    "code": "free(var);\n"
  },
  {
    "language": "C",
    "code": "Typename *var = alloca(sizeof(Typename));\n"
  },
  {
    "language": "C",
    "code": "#include <sys/mman.h>\n#include <unistd.h>\n#include <stdio.h>\n\n// VERY rudimentary C memory management independent of C library's malloc.\n\n// Linked list (yes, this is inefficient)\nstruct __ALLOCC_ENTRY__\n{\n    void * allocatedAddr;\n    size_t size;\n    struct __ALLOCC_ENTRY__ * next;\n};\ntypedef struct __ALLOCC_ENTRY__ __ALLOCC_ENTRY__;\n\n// Keeps track of allocated memory and metadata\n__ALLOCC_ENTRY__ * __ALLOCC_ROOT__ = NULL;\n__ALLOCC_ENTRY__ * __ALLOCC_TAIL__ = NULL;\n\n// Add new metadata to the table\nvoid _add_mem_entry(void * location, size_t size)\n{\n\n    __ALLOCC_ENTRY__ * newEntry = (__ALLOCC_ENTRY__ *) mmap(NULL, sizeof(__ALLOCC_ENTRY__), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n    if (__ALLOCC_TAIL__ != NULL)\n    {\n        __ALLOCC_TAIL__ -> next = newEntry;\n        __ALLOCC_TAIL__ = __ALLOCC_TAIL__ -> next;\n    }\n    else\n    {\n        // Create new table\n        __ALLOCC_ROOT__ = newEntry;\n        __ALLOCC_TAIL__ = newEntry;\n    }\n\n    __ALLOCC_ENTRY__ * tail = __ALLOCC_TAIL__;\n    tail -> allocatedAddr = location;\n    tail -> size = size;\n    tail -> next = NULL;\n    __ALLOCC_TAIL__ = tail;\n}\n\n// Remove metadata from the table given pointer\nsize_t _remove_mem_entry(void * location)\n{\n    __ALLOCC_ENTRY__ * curNode = __ALLOCC_ROOT__;\n\n    // Nothing to do\n    if (curNode == NULL)\n    {\n        return 0;\n    }\n\n    // First entry matches\n    if (curNode -> allocatedAddr == location)\n    {\n        __ALLOCC_ROOT__ = curNode -> next;\n        size_t chunkSize = curNode -> size;\n\n        // No nodes left\n        if (__ALLOCC_ROOT__ == NULL)\n        {\n            __ALLOCC_TAIL__ = NULL;\n        }\n        munmap(curNode, sizeof(__ALLOCC_ENTRY__));\n\n        return chunkSize;\n    }\n\n    // If next node is null, remove it\n    while (curNode -> next != NULL)\n    {\n        __ALLOCC_ENTRY__ * nextNode = curNode -> next;\n\n        if (nextNode -> allocatedAddr == location)\n        {\n            size_t chunkSize = nextNode -> size;\n\n            if(curNode -> next == __ALLOCC_TAIL__)\n            {\n                __ALLOCC_TAIL__ = curNode;\n            }\n            curNode -> next = nextNode -> next;\n            munmap(nextNode, sizeof(__ALLOCC_ENTRY__));\n\n            return chunkSize;\n        }\n\n        curNode = nextNode;\n    }\n\n    // Nothing was found\n    return 0;\n}\n\n// Allocate a block of memory with size\n// When customMalloc an already mapped location, causes undefined behavior\nvoid * customMalloc(size_t size)\n{\n    // Now we can use 0 as our error state\n    if (size == 0)\n    {\n        return NULL;\n    }\n\n    void * mapped = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n    // Store metadata\n    _add_mem_entry(mapped, size);\n\n    return mapped;\n}\n\n// Free a block of memory that has been customMalloc'ed\nvoid customFree(void * addr)\n{\n    size_t size = _remove_mem_entry(addr);\n\n    munmap(addr, size);\n}\n\nint main(int argc, char const *argv[])\n{\n    int *p1 = customMalloc(4*sizeof(int));  // allocates enough for an array of 4 int\n    int *p2 = customMalloc(sizeof(int[4])); // same, naming the type directly\n    int *p3 = customMalloc(4*sizeof *p3);   // same, without repeating the type name\n\n    if(p1) {\n        for(int n=0; n<4; ++n) // populate the array\n            p1[n] = n*n;\n        for(int n=0; n<4; ++n) // print it back out\n            printf(\"p1[%d] == %d\\n\", n, p1[n]);\n    }\n\n    customFree(p1);\n    customFree(p2);\n    customFree(p3);\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <complex.h>\n#include <stdio.h>\n\nvoid cprint(double complex c)\n{\n  printf(\"%f%+fI\", creal(c), cimag(c));\n}\nvoid complex_operations() {\n  double complex a = 1.0 + 1.0I;\n  double complex b = 3.14159 + 1.2I;\n\n  double complex c;\n\n  printf(\"\\na=\"); cprint(a);\n  printf(\"\\nb=\"); cprint(b);\n\n  // addition\n  c = a + b;\n  printf(\"\\na+b=\"); cprint(c);\n  // multiplication\n  c = a * b;\n  printf(\"\\na*b=\"); cprint(c);\n  // inversion\n  c = 1.0 / a;\n  printf(\"\\n1/c=\"); cprint(c);\n  // negation\n  c = -a;\n  printf(\"\\n-a=\"); cprint(c);\n  // conjugate\n  c = conj(a);\n  printf(\"\\nconj a=\"); cprint(c); printf(\"\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "typedef struct{\n        double real;\n        double imag;\n} Complex;\n\nComplex add(Complex a, Complex b){\n        Complex ans;\n        ans.real = a.real + b.real;\n        ans.imag = a.imag + b.imag;\n        return ans;\n}\n\nComplex mult(Complex a, Complex b){\n        Complex ans;\n        ans.real = a.real * b.real - a.imag * b.imag;\n        ans.imag = a.real * b.imag + a.imag * b.real;\n        return ans;\n}\n\n/* it's arguable that things could be better handled if either\n   a.real or a.imag is +/-inf, but that's much work */\nComplex inv(Complex a){\n        Complex ans;\n        double denom = a.real * a.real + a.imag * a.imag;\n        ans.real =  a.real / denom;\n        ans.imag = -a.imag / denom;\n        return ans;\n}\n\nComplex neg(Complex a){\n        Complex ans;\n        ans.real = -a.real;\n        ans.imag = -a.imag;\n        return ans;\n}\n\nComplex conj(Complex a){\n        Complex ans;\n        ans.real =  a.real;\n        ans.imag = -a.imag;\n        return ans;\n}\n\nvoid put(Complex c)\n{\n        printf(\"%lf%+lfI\", c.real, c.imag);\n}\n\nvoid complex_ops(void)\n{\n  Complex a = { 1.0,     1.0 };\n  Complex b = { 3.14159, 1.2 };\n\n  printf(\"\\na=\");   put(a);\n  printf(\"\\nb=\");   put(b);\n  printf(\"\\na+b=\"); put(add(a,b));\n  printf(\"\\na*b=\"); put(mult(a,b));\n  printf(\"\\n1/a=\"); put(inv(a));\n  printf(\"\\n-a=\");  put(neg(a));\n  printf(\"\\nconj a=\");  put(conj(a));  printf(\"\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<stdlib.h>\n\ndouble agm( double a, double g ) {\n   /* arithmetic-geometric mean */\n   double iota = 1.0E-16;\n   double a1, g1;\n\n   if( a*g < 0.0 ) {\n      printf( \"arithmetic-geometric mean undefined when x*y<0\\n\" );\n      exit(1);\n   }\n\n   while( fabs(a-g)>iota ) {\n      a1 = (a + g) / 2.0;\n      g1 = sqrt(a * g);\n\n      a = a1;\n      g = g1;\n   }\n\n   return a;\n}\n\nint main( void ) {\n   double x, y;\n   printf( \"Enter two numbers: \" );\n   scanf( \"%lf%lf\", &x, &y );\n   printf( \"The arithmetic-geometric mean is %lf\\n\", agm(x, y) );\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*Arithmetic Geometric Mean of 1 and 1/sqrt(2)\n\n  Nigel_Galloway\n  February 7th., 2012.\n*/\n\n#include \"gmp.h\"\n\nvoid agm (const mpf_t in1, const mpf_t in2, mpf_t out1, mpf_t out2) {\n\tmpf_add (out1, in1, in2);\n\tmpf_div_ui (out1, out1, 2);\n\tmpf_mul (out2, in1, in2);\n\tmpf_sqrt (out2, out2);\n}\n\nint main (void) {\n\tmpf_set_default_prec (65568);\n\tmpf_t x0, y0, resA, resB;\n\n\tmpf_init_set_ui (y0, 1);\n\tmpf_init_set_d (x0, 0.5);\n\tmpf_sqrt (x0, x0);\n\tmpf_init (resA);\n\tmpf_init (resB);\n\n\tfor(int i=0; i<7; i++){\n\t\tagm(x0, y0, resA, resB);\n\t\tagm(resA, resB, x0, y0);\n\t}\n\tgmp_printf (\"%.20000Ff\\n\", x0);\n\tgmp_printf (\"%.20000Ff\\n\\n\", y0);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include \"gmp.h\"\n\nvoid agm (const mpf_t in1, const mpf_t in2, mpf_t out1, mpf_t out2) {\n\tmpf_add (out1, in1, in2);\n\tmpf_div_ui (out1, out1, 2);\n\tmpf_mul (out2, in1, in2);\n\tmpf_sqrt (out2, out2);\n}\n\nint main (void) {\n\tmpf_set_default_prec (300000);\n\tmpf_t x0, y0, resA, resB, Z, var;\n\n\tmpf_init_set_ui (x0, 1);\n\tmpf_init_set_d (y0, 0.5);\n\tmpf_sqrt (y0, y0);\n\tmpf_init (resA);\n\tmpf_init (resB);\n\tmpf_init_set_d (Z, 0.25);\n\tmpf_init (var);\n\n\tint n = 1;\n        int i;\n\tfor(i=0; i<8; i++){\n\t\tagm(x0, y0, resA, resB);\n\t\tmpf_sub(var, resA, x0);\n\t\tmpf_mul(var, var, var);\n\t\tmpf_mul_ui(var, var, n);\n\t\tmpf_sub(Z, Z, var);\n\t\tn += n;\n\t\tagm(resA, resB, x0, y0);\n\t\tmpf_sub(var, x0, resA);\n\t\tmpf_mul(var, var, var);\n\t\tmpf_mul_ui(var, var, n);\n\t\tmpf_sub(Z, Z, var);\n\t\tn += n;\n\t}\n\tmpf_mul(x0, x0, x0);\n\tmpf_div(x0, x0, Z);\n\tgmp_printf (\"%.100000Ff\\n\", x0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n  int a, b;\n  if (argc < 3) exit(1);\n  b = atoi(argv[--argc]);\n  if (b == 0) exit(2);\n  a = atoi(argv[--argc]);\n  printf(\"a+b = %d\\n\", a+b);\n  printf(\"a-b = %d\\n\", a-b);\n  printf(\"a*b = %d\\n\", a*b);\n  printf(\"a/b = %d\\n\", a/b); /* truncates towards 0 (in C99) */\n  printf(\"a%%b = %d\\n\", a%b); /* same sign as first operand (in C99) */\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define FMT \"%lld\"\ntypedef long long int fr_int_t;\ntypedef struct { fr_int_t num, den; } frac;\n\nfr_int_t gcd(fr_int_t m, fr_int_t n)\n{\n\tfr_int_t t;\n\twhile (n) { t = n; n = m % n; m = t; }\n\treturn m;\n}\n\nfrac frac_new(fr_int_t num, fr_int_t den)\n{\n\tfrac a;\n\tif (!den) {\n\t\tprintf(\"divide by zero: \"FMT\"/\"FMT\"\\n\", num, den);\n\t\tabort();\n\t}\n\n\tint g = gcd(num, den);\n\n\tif (g)\t{ num /= g; den /= g; }\n\telse\t{ num = 0; den = 1;   }\n\n\tif (den < 0) {\n\t\tden = -den;\n\t\tnum = -num;\n\t}\n\ta.num = num; a.den = den;\n\treturn a;\n}\n\n#define BINOP(op, n, d) frac frac_##op(frac a, frac b) { return frac_new(n,d); }\nBINOP(add, a.num * b.den + b.num * a.den, a.den * b.den);\nBINOP(sub, a.num * b.den - b.num + a.den, a.den * b.den);\nBINOP(mul, a.num * b.num, a.den * b.den);\nBINOP(div, a.num * b.den, a.den * b.num);\n\nint frac_cmp(frac a, frac b) {\n\tint l = a.num * b.den, r = a.den * b.num;\n\treturn l < r ? -1 : l > r;\n}\n#define frac_cmp_int(a, b) frac_cmp(a, frac_new(b, 1))\nint frtoi(frac a) { return a.den / a.num; }\ndouble frtod(frac a) { return (double)a.den / a.num; }\n\nint main()\n{\n\tint n, k;\n\tfrac sum, kf;\n\n\tfor (n = 2; n < 1<<19; n++) {\n\t\tsum = frac_new(1, n);\n\n\t\tfor (k = 2; k * k < n; k++) {\n\t\t\tif (n % k) continue;\n\t\t\tkf = frac_new(1, k);\n\t\t\tsum = frac_add(sum, kf);\n\n\t\t\tkf = frac_new(1, n / k);\n\t\t\tsum = frac_add(sum, kf);\n\t\t}\n\t\tif (frac_cmp_int(sum, 1) == 0) printf(\"%d\\n\", n);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define ARRAY_CONCAT(TYPE, A, An, B, Bn) \\\n  (TYPE *)array_concat((const void *)(A), (An), (const void *)(B), (Bn), sizeof(TYPE));\n\nvoid *array_concat(const void *a, size_t an,\n                   const void *b, size_t bn, size_t s)\n{\n  char *p = malloc(s * (an + bn));\n  memcpy(p, a, an*s);\n  memcpy(p + an*s, b, bn*s);\n  return p;\n}\n\n// testing\nconst int a[] = { 1, 2, 3, 4, 5 };\nconst int b[] = { 6, 7, 8, 9, 0 };\n\nint main(void)\n{\n  unsigned int i;\n\n  int *c = ARRAY_CONCAT(int, a, 5, b, 5);\n\n  for(i = 0; i < 10; i++)\n    printf(\"%d\\n\", c[i]);\n\n  free(c);\n  return EXIT_SUCCCESS;\n}\n"
  },
  {
    "language": "C",
    "code": "int myArray2[10] = { 1, 2, 0 }; /* the rest of elements get the value 0 */\nfloat myFloats[] ={1.2, 2.5, 3.333, 4.92, 11.2, 22.0 }; /* automatically sizes */\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <stdio.h>\ntypedef struct node{\n  char value;\n  struct node* next;\n} node;\ntypedef struct charList{\n  node* first;\n  int size;\n} charList;\n\ncharList createList(){\n  charList foo = {.first = NULL, .size = 0};\n  return foo;\n}\nint addEl(charList* list, char c){\n  if(list != NULL){\n    node* foo = (node*)malloc(sizeof(node));\n    if(foo == NULL) return -1;\n    foo->value = c; foo->next = NULL;\n    if(list->first == NULL){\n      list->first = foo;\n    }else{\n      node* it= list->first;\n      while(it->next != NULL)it = it->next;\n      it->next = foo;\n    }\n    list->size = list->size+1;\n    return 0;\n  }else return -1;\n}\nint removeEl(charList* list, int index){\n    if(list != NULL && list->size > index){\n      node* it = list->first;\n      for(int i = 0; i < index-1; i++) it = it->next;\n      node* el = it->next;\n      it->next = el->next;\n      free(el);\n      list->size--;\n      return 0;\n    }else return -1;\n}\nchar getEl(charList* list, int index){\n    if(list != NULL && list->size > index){\n        node* it = list->first;\n        for(int i = 0; i < index; i++) it = it->next;\n        return it->value;\n    }else return '\\0';\n}\nstatic void cleanHelp(node* el){\n  if(el != NULL){\n    if(el->next != NULL) cleanHelp(el->next);\n    free(el);\n  }\n}\nvoid clean(charList* list){\n  cleanHelp(list->first);\n  list->size = 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define MYFLOAT_SIZE (sizeof(myFloats)/sizeof(myFloats[0]))\n"
  },
  {
    "language": "C",
    "code": "long a2D_Array[3][5];    /* 3 rows, 5 columns. */\nfloat my2Dfloats[][3] = {\n   1.0, 2.0, 0.0,\n   5.0, 1.0, 3.0 };\n#define FLOAT_ROWS (sizeof(my2Dfloats)/sizeof(my2dFloats[0]))\n"
  },
  {
    "language": "C",
    "code": "int numElements = 10;\nint *myArray = malloc(sizeof(int) * numElements);  /* array of 10 integers */\nif ( myArray != NULL )   /* check to ensure allocation succeeded. */\n{\n  /* allocation succeeded */\n  /* at the end, we need to free the allocated memory */\n  free(myArray);\n}\n                    /* calloc() additionally pre-initializes to all zeros */\nshort *myShorts = calloc( numElements, sizeof(short)); /* array of 10 */\nif (myShorts != NULL)....\n"
  },
  {
    "language": "C",
    "code": "myArray[0] = 1;\nmyArray[1] = 3;\n"
  },
  {
    "language": "C",
    "code": "printf(\"%d\\n\", myArray[1]);\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nConsole.WriteLine(\"Hello World\");\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nconst double X = 3.141592653;\ndouble x = 3.141592653589793;\nConsole.WriteLine(x + X);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A;\n}\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nint[] B = {1, 2, 3};\nConsole.WriteLine(A[0] + A[1] + A[2]);\nConsole.WriteLine(B[0] + B[1] + B[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = new string[3];\nA[0] = \"a\";\nA[1] = \"b\";\nA[2] = \"c\";\nConsole.WriteLine(A[0] + A[1] + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nstring x = A[1];\nstring y = A[2];\nConsole.WriteLine(x + y);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nstring x = A[1];\nA[0] = \"d\";\nA[1] = A[2];\nA[2] = x;\nConsole.WriteLine(A[0] + A[1] + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nint x = A.Length;\nConsole.WriteLine(x);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[, ] A = new int[, ] {{1,2},\n{3,4},\n{5,6},\n{7,8}};\nConsole.WriteLine(A[0,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[,, ] B = new int[,, ] {\n{{1,2,3},\n{4,5,6}},\n{{7,8,9},\n{10,11,12}}\n};\nConsole.WriteLine(B[0,1,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[,] C = new int[2,3];\nC[0,0] = 5;\nC[0,1] = 6;\nC[0,2] = 5;\nC[1,0] = 5;\nC[1,1] = 5;\nC[1,2] = 5;\nConsole.WriteLine(C[0,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "class HelloWorld {\nstatic void Main() {\nint a, b, c;\na = 1;\na += 1;\na = b = c = 1;\nConsole.WriteLine(a + b + c);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 1;\nint b = 2;\nint c = 3;\nif(a < b){c += 1;} else {c -= 1;}\nConsole.WriteLine(\"c=\" + c);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[] A = {1, 2, 3};\nif(A[0] < A[1]){A[2] += 1;}\nConsole.WriteLine(\"A[2]=\" + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint i = 0;\nwhile (i < 5) {\nConsole.WriteLine(\"i = \" + i);\ni++;\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint i = 0;\ndo {\nConsole.WriteLine(\"i = \" + i);\ni++;\n}\nwhile (i < 5);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nint i = 0;\nstring t = \"\";\nwhile (i < A.Length) {\nt += \"\\n i[\" + i + \"]=\" + A[i];\ni++;\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nint i = 0;\nstring t = \"\";\ndo {\nt += \"\\n i[\" + i + \"]=\" + A[i];\ni++;\n}\nwhile (i < A.Length);\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 5;\nint b = 0;\nfor (int i = 0; i < a; i++) {\nb += i;\n}\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nstring t = \"\";\nfor (int i = 0; i < A.Length; i++) {\nt += \"\\n A[\" + i + \"]=\" + A[i];\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[, ] A = new string[, ] {\n{\"a\",\"b\"},\n{\"c\",\"d\"},\n{\"e\",\"f\"},\n{\"g\",\"h\"}\n};\nstring t = \"\";\nint x = A.GetLength(0);\nint y = A.GetLength(1);\nfor (int i = 0; i < x; i++) {\nfor (int j = 0; j < y; j++) {\nt += \"\\n A[\"+i+\",\"+j+\"]=\" + A[i,j];\n}\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[, ] A = new string[, ] {\n{\"a\",\"b\"},\n{\"c\",\"d\"},\n{\"e\",\"f\"},\n{\"g\",\"h\"}\n};\nstring t = \"\";\nint n = A.GetLength(0);\nint m = A.GetLength(1);\nint i = 0;\nint j = 0;\nfor (int v = 0; v < n*m; v++) {\nj = v % m;\nif(v!=0 && j == 0){i++;}\nt += v + \" A[\"+i+\",\"+j+\"]=\";\nt += A[i,j] + \"\\n\";\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic int compute(int x)\n{\nreturn x + x / x - x * x;\n}\nstatic void Main(string[] args)\n{\nint a = 10;\nint b = compute(a);\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nConsole.WriteLine(\"Code 65 is the:'\" + (char) 65 + \"' letter\");\nConsole.WriteLine(\"Letter A has the code:'\" + (int) 'A' + \"'\");\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic string compute(string t, string [] a)\n{\nfor (int i = 0; i < a.Length; i++) {\nt += \"\\n a[\" + i + \"]=\" + a[i];\n}\nreturn t;\n}\nstatic void Main(string[] args)\n{\nstring[] a = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nstring t = \"\";\nstring b = compute(t, a);\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 3;\nint b = c(c(c(c(a))));\nb = -b;\nConsole.WriteLine(b);\n}\nstatic int c(int x)\n{return x + x / x - x * x;}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main(string[] args)\n{\nint[] a = {1, 2, 3, 4, 5};\nint t = 0;\nint b = c1(t, a);\nConsole.WriteLine(b);\n}\nstatic int c1(int t, int[] a){\nreturn 5 + c2(t, a);\n}\nstatic int c2(int t, int[] a){\nreturn c3(t, a) + 5;\n}\nstatic int c3(int t, int[] a){\nint s = 1;\nreturn s + c4(t, a);\n}\nstatic int c4(int t, int[] a){\nreturn c5(t, a) + c5(t, a);\n}\nstatic int c5(int t, int[] a){\nfor (int i = 0; i < a.Length; i++) {\nt += a[i];\n}\nreturn t;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic int for_loop(int a, int b, int r){\na++;\nr += 5;\nif(a>=b){\nreturn r;\n} else {\nreturn for_loop(a, b, r);\n}\n}\nstatic void Main() {\nint a = for_loop(0, 7, 0);\nConsole.WriteLine(a);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic const double a = 3.1415;\npublic static int b;\nstatic int compute()\n{\nint x = b;\nreturn x + x / x - x * x;\n}\nstatic void Main(string[] args)\n{\nb = 11;\nint c = compute();\nConsole.WriteLine(c + \"\\n\" + a);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic static int a;\nstatic void Main() {\na = 10;\nint b = pure(a);\nConsole.WriteLine(b + \" & \" + a);\nint c = inpure(a);\nConsole.WriteLine(c + \" & \" + a);\nint d = pure(a);\nConsole.WriteLine(d + \" & \" + a);\n}\nstatic int pure(int x){\nreturn x + x / x - x * x;\n}\nstatic int inpure(int x){\na = 11;\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic static int b;\npublic static int a;\nstatic void Main() {\na = 16;\nb = f(a);\nConsole.WriteLine(b);\np();\nConsole.WriteLine(b);\n}\nstatic int f(int x){\nreturn x + x / x - x * x;\n}\nstatic void p(){\nint x = a - 11;\nb = x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = \"*******%%**********%%******\";\nstring q = \"%%\";\nint b = a.Length;\nint c = a.Replace(q, \"\").Length;\nif(c < b){\nConsole.WriteLine(\"a contains q\");\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = x(\"*\", \"\", 10);\nConsole.WriteLine(\"Repeat:\\n[\" + a + \"]\");\nint b = sum(23);\nConsole.WriteLine(\"Sum:[\" + b + \"]\");\nint c = factorial(10);\nConsole.WriteLine(\n\"Factorial:\\n[\" + c + \"]\"\n);\nint[] d = sequence(5, new int[5], 0, 5);\nConsole.WriteLine(\n\"A sequence:\\n[{0}\",\nstring.Join(\",\", d) + \"]\"\n);\nint[] e = fibonacci(2,\nnew int[3] {1,2,3}, 5);\nConsole.WriteLine(\n\"Fibonacci:\\n[{0}\",\nstring.Join(\",\", e) + \"]\"\n);\nint[] q = {1, 3, 3, 4, 5, 9};\nint f = sum_array(q.Length - 1, q, 0);\nConsole.WriteLine(\n\"Sum array:[\" + f + \"]\"\n);\n}\nstatic string x(string c, string s,\nint n){\ns += c;\nif(s.Length>=n){\nreturn s;\n} else {\nreturn x(c, s, n);\n}\n}\nstatic int sum(int n){\nif (n <= 1) {return n;}\nreturn n + sum(n - 1);\n}\nstatic int factorial(int n){\nif (n <= 1) {\nreturn n;\n} else {\nreturn factorial(n - 1) * n;\n}\n}\nstatic int[] sequence(int n, int[] m,\nint i, int t){\nm[i] = n;\ni++;\nif (i >= t) {\nreturn m;\n} else {\nreturn sequence((n-1)+(n-2),\nm, i, t);\n}\n}\nstatic int[] fibonacci(int n, int[] m,\nint t){\nn++;\nArray.Resize(ref m, n+1);\nm[n] = m[n-1] + m[n-2];\nif (n >= t) {\nreturn m;\n} else {\nreturn fibonacci(n, m, t);\n}\n}\nstatic int sum_array(int n, int[] q,\nint r){\nr += q[n];\nif (n <= 0) {\nreturn r;\n} else {\nreturn sum_array(n - 1, q, r);\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = distribution(3, 21);\nConsole.WriteLine(a);\n}\nstatic string distribution(\nint start, int stop){\nstring t = \"\";\nfor (int i = start; i < stop; i++) {\nt += compute(i) + \"\\n\";\n}\nreturn t;\n}\nstatic int compute(int x){\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[] a = distribution(3, 21);\nConsole.WriteLine(string.Join(\"\\n\", a));\n}\nstatic int[] distribution(\nint start, int stop){\nint[] b = new int[stop - start];\nfor (int i = start; i < stop; i++) {\nb[i - start] = compute(i);\n}\nreturn b;\n}\nstatic int compute(int x){\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nint a, b, c;\na = 7;\nb = 3;\na = 7; b = 3;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\npublic class SpectralForecast\n{\npublic static void Main(string[] args)\n{\nstring A = \"10.3,23.4,44.8,63.2,44.1,35.1,46.5,62.6,50.4\";\nstring B = \"18.8,43.1,52.2,45.5,46.8,46.6,67.9,66.3,70.4\";\nstring[] nA = A.Split(',');\nstring[] nB = B.Split(',');\nstring M = \"\";\ndouble maxA = 0;\ndouble maxB = 0;\ndouble d = 33;\ndouble v = 0;\ndouble[] tA = new double[nA.Length];\ndouble[] tB = new double[nB.Length];\nfor(int i=0; i < nA.Length; i++)\n{\ntA[i] = double.Parse(nA[i]);\ntB[i] = double.Parse(nB[i]);\nif (tA[i] > maxA){maxA = tA[i];}\nif (tB[i] > maxB){maxB = tB[i];}\n}\ndouble maxAB = Math.Max(maxA, maxB);\nfor(int i=0; i < tA.Length; i++) {\nv = ((d/maxA)*tA[i])+(((maxAB-d)/maxB)*tB[i]);\nM += Math.Round(v, 2);\nif(i < tA.Length-1){M += ',';}\n}\nConsole.WriteLine (M);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nString a = \"this is \";\nString b = a +\n\"C\t\"output\";\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nString a = \"this is \"; String b = a + \"C  }\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\n42\n3.14159265358979323846264\n'a'\n\"this text\"\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint x = 12;\nint y = 15;\nstring color = \"green\";\nstring xname = \"Paul\";\nbool logic = true;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint x = 12;\nint y = 15;\nstring color = \"green\";\nstring xname = \"Paul\";\nbool logic = true;\nConsole.WriteLine(logic);\nConsole.WriteLine(x + y);\nConsole.WriteLine(color + x);\nConsole.WriteLine(x + xname);\nConsole.WriteLine(x + y + color);\nConsole.WriteLine(color + x + y);\nConsole.WriteLine(x + x / x - x * x);\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "// Calculate hypotenuse n of OTT assuming only nothingness, unity, and hyp[n-1] if n>1\n// Nigel Galloway, May 6th., 2013\n#include <gmpxx.h>\nint N{123456};\nmpz_class hyp[N-3];\nconst mpz_class G(const int n,const int g){return g>n?0:(g==1 or n-g<2)?1:hyp[n-g-2];};\nvoid G_hyp(const int n){for(int i=0;i<N-2*n-1;i++) n==1?hyp[n-1+i]=1+G(i+n+1,n+1):hyp[n-1+i]+=G(i+n+1,n+1);}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nint main(){\n  N=25;\n  for (int n=1; n<N/2; n++){\n    G_hyp(n);\n    for (int g=0; g<N-3; g++) std::cout << std::setw(4) << hyp[g];\n    std::cout << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "int main(){\n  N = 25;\n  std::cout << std::setw(N+52) << \"1\" << std::endl;\n  std::cout << std::setw(N+55) << \"1     1\" << std::endl;\n  std::cout << std::setw(N+58) << \"1     1     1\" << std::endl;\n  std::string ott[N-3];\n  for (int n=1; n<N/2; n++) {\n    G_hyp(n);\n    for (int g=(n-1)*2; g<N-3; g++) {\n      std::string t = hyp[g-(n-1)].get_str();\n      //if (t.size()==1) t.insert(t.begin(),1,' ');\n      ott[g].append(t);\n      ott[g].append(6-t.size(),' ');\n    }\n  }\n  for(int n = 0; n<N-3; n++) {\n    std::cout <<std::setw(N+43-3*n) << 1 << \"     \" << ott[n];\n    for (int g = (n+1)/2; g>0; g--) {\n      std::string t{hyp[g-1].get_str()};\n      t.append(6-t.size(),' ');\n      std::cout << t;\n    }\n    std::cout << \"1     1\" << std::endl;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint main(){\n  for (int n=1; n<N/2; n++) G_hyp(n);\n  std::cout << \"G(23)     = \" << hyp[21] << std::endl;\n  std::cout << \"G(123)    = \" << hyp[121] << std::endl;\n  std::cout << \"G(1234)   = \" << hyp[1232] << std::endl;\n  std::cout << \"G(12345)  = \" << hyp[12343] << std::endl;\n  mpz_class r{3};\n  for (int i = 0; i<N-3; i++) r += hyp[i];\n  std::cout << \"G(123456) = \" << r << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing std::cout;\n\nint main()\n{\n  for(int bottles(99); bottles > 0; bottles -= 1){\n    cout << bottles << \" bottles of beer on the wall\\n\"\n         << bottles << \" bottles of beer\\n\"\n         << \"Take one down, pass it around\\n\"\n         << bottles - 1 << \" bottles of beer on the wall\\n\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntemplate<int max, int min> struct bottle_countdown\n{\n  static const int middle = (min + max)/2;\n  static void print()\n  {\n    bottle_countdown<max, middle+1>::print();\n    bottle_countdown<middle, min>::print();\n  }\n};\n\ntemplate<int value> struct bottle_countdown<value, value>\n{\n  static void print()\n  {\n    std::cout << value << \" bottles of beer on the wall\\n\"\n              << value << \" bottles of beer\\n\"\n              << \"Take one down, pass it around\\n\"\n              << value-1 << \" bottles of beer\\n\\n\";\n  }\n};\n\nint main()\n{\n  bottle_countdown<100, 1>::print();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid rec(int bottles)\n{\nif ( bottles!=0)\n {\n     cout << bottles << \" bottles of beer on the wall\" << endl;\n        cout << bottles << \" bottles of beer\" << endl;\n        cout << \"Take one down, pass it around\" << endl;\n        cout << --bottles << \" bottles of beer on the wall\\n\" << endl;\n    rec(bottles);\n }\n}\n\nint main()\n {\nrec(99);\nsystem(\"pause\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ostream>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main()\n{\n  std::cout << SONG;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                          //>,_\n                        //Beer Song>,_\n                       #include <iostream>\n                      using namespace std;\n                     int main(){ for( int\n                    b=-1; b<99;  cout <<\n                   '\\n') for ( int w=0;\n                  w<3; cout << \".\\n\"){\n                 if (w==2) cout << ((\n                b--) ?\"Take one dow\"\n               \"n and pass it arou\"\n              \"nd\":\"Go to the sto\"\n             \"re and buy some mo\"\n            \"re\"); if (b<0) b=99\n           ; do{ if (w) cout <<\n          \", \"; if (b) cout <<\n          b;  else  cout << (\n         (w) ? 'n' : 'N') <<\n         \"o more\"; cout <<\n         \" bottle\" ;  if\n        (b!=1) cout <<\n       's' ; cout <<\n       \" of beer\";\n      if (w!=1)\n     cout  <<\n    \" on th\"\n   \"e wall\"\n  ;} while\n (!w++);}\n  return\n       0\n       ;\n       }\n      //\n  // by barrym 2011-05-01\n     // no bottles were harmed in the\n            // making of this program!!!\n"
  },
  {
    "language": "C++",
    "code": "// Standard input-output streams\n#include <iostream>\nusing namespace std;\nint main()\n{\n   int a, b;\n   cin >> a >> b;\n   cout << a + b << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Input file: input.txt\n// Output file: output.txt\n#include <fstream>\nusing namespace std;\nint main()\n{\n   ifstream in(\"input.txt\");\n   ofstream out(\"output.txt\");\n   int a, b;\n   in >> a >> b;\n   out << a + b << endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cctype>\n\n\ntypedef std::pair<char,char> item_t;\ntypedef std::vector<item_t> list_t;\n\nbool can_make_word(const std::string& w, const list_t& vals) {\n    std::set<uint32_t> used;\n    while (used.size() < w.size()) {\n        const char c = toupper(w[used.size()]);\n        uint32_t x = used.size();\n        for (uint32_t i = 0, ii = vals.size(); i < ii; ++i) {\n            if (used.find(i) == used.end()) {\n                if (toupper(vals[i].first) == c || toupper(vals[i].second) == c) {\n                    used.insert(i);\n                    break;\n                }\n            }\n        }\n        if (x == used.size()) break;\n    }\n    return used.size() == w.size();\n}\n\n\nint main() {\n    list_t vals{ {'B','O'}, {'X','K'}, {'D','Q'}, {'C','P'}, {'N','A'}, {'G','T'}, {'R','E'}, {'T','G'}, {'Q','D'}, {'F','S'}, {'J','W'}, {'H','U'}, {'V','I'}, {'A','N'}, {'O','B'}, {'E','R'}, {'F','S'}, {'L','Y'}, {'P','C'}, {'Z','M'} };\n    std::vector<std::string> words{\"A\",\"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"};\n    for (const std::string& w : words) {\n        std::cout << w << \": \" << std::boolalpha << can_make_word(w,vals) << \".\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "class Abs {\npublic:\n\tvirtual int method1(double value) = 0;\n\tvirtual int add(int a, int b){\n\t\treturn a+b;\n\t}\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> findProperDivisors ( int n ) {\n   std::vector<int> divisors ;\n   for ( int i = 1 ; i < n / 2 + 1 ; i++ ) {\n      if ( n % i == 0 )\n\t divisors.push_back( i ) ;\n   }\n   return divisors  ;\n}\n\nint main( ) {\n   std::vector<int> deficients , perfects , abundants , divisors ;\n   for ( int n = 1 ; n < 20001 ; n++ ) {\n      divisors = findProperDivisors( n ) ;\n      int sum = std::accumulate( divisors.begin( ) , divisors.end( ) , 0 ) ;\n      if ( sum < n ) {\n\t deficients.push_back( n ) ;\n      }\n      if ( sum == n ) {\n\t perfects.push_back( n ) ;\n      }\n      if ( sum > n ) {\n\t abundants.push_back( n ) ;\n      }\n   }\n   std::cout << \"Deficient : \" << deficients.size( ) << std::endl ;\n   std::cout << \"Perfect   : \" << perfects.size( ) << std::endl ;\n   std::cout << \"Abundant  : \" << abundants.size( ) << std::endl ;\n   return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nclass Acc\n{\npublic:\n    Acc(int init)\n        : _type(intType)\n        , _intVal(init)\n    {}\n\n    Acc(float init)\n        : _type(floatType)\n        , _floatVal(init)\n    {}\n\n    int operator()(int x)\n    {\n        if( _type == intType )\n        {\n            _intVal += x;\n            return _intVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return static_cast<int>(_floatVal);\n        }\n    }\n\n    float operator()(float x)\n    {\n        if( _type == intType )\n        {\n            _floatVal = _intVal + x;\n            _type = floatType;\n            return _floatVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return _floatVal;\n        }\n    }\nprivate:\n    enum {floatType, intType} _type;\n    float _floatVal;\n    int _intVal;\n};\n\nint main()\n{\n    Acc a(1);\n    a(5);\n    Acc(3);\n    std::cout << a(2.3f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n\ntemplate <typename T>\nstd::function<T(T)> makeAccumulator(T sum) {\n\treturn [=](T increment) mutable {\n\t\treturn sum += increment;\n\t};\n}\n\nint main() {\n\tauto acc = makeAccumulator<float>(1);\n\tacc(5);\n\tmakeAccumulator(3);\n\tstd::cout << acc(2.3) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "struct CumulantBase_\n{\n   virtual ~CumulantBase_();\n   virtual std::ostream& Write(std::ostream& dst) const = 0;\n};\n\ntemplate<class T_> struct Cumulant_ : CumulantBase_\n{\n   T_ val_;\n   Cumulant_(const T_& val) : val_(val) {}\n   std::ostream& Write(std::ostream& dst) const override\n   {\n      return dst << val_;\n   }\n};\n\nstruct Accumulator_\n{\n   std::unique_ptr<CumulantBase_> val_;\n   template<class T_> Accumulator_(const T_& val) { Set(val); }\n   template<class T_> void Set(const T_& val) { val_.reset(new Cumulant_<T_>(val)); }\n"
  },
  {
    "language": "C++",
    "code": "// still inside struct Accumulator_\n\t// various operator() implementations provide a de facto multimethod\n\tAccumulator_& operator()(int more)\n\t{\n\t\tif (auto i = CoerceInt(*val_))\n\t\t\tSet(+i + more);\n\t\telse if (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(int) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(double more)\n\t{\n\t\tif (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(double) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(const String_& more)\n\t{\n\t\tif (auto s = CoerceString(*val_))\n\t\t\tSet(+s + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(string) failed\");\n\t\treturn *this;\n\t}\n};\n"
  },
  {
    "language": "C++",
    "code": "// recognize cumulants by type\nboost::optional<int> CoerceInt(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<int>*>(&c))\n\t\treturn p->val_;\n\treturn boost::optional<int>();\n}\nboost::optional<double> CoerceDouble(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<double>*>(&c))\n\t\treturn p->val_;\n\tif (auto i = CoerceInt(c))\n\t\treturn boost::optional<double>(i);\n\treturn boost::optional<double>();\n}\nboost::optional<String_> CoerceString(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<String_>*>(&c))\n\t\treturn p->val_;\n\treturn boost::optional<String_>();\n}\n"
  },
  {
    "language": "C++",
    "code": "std::ostream& operator<<(std::ostream& dst, const Accumulator_& acc)\n{\n\treturn acc.val_->Write(dst);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m < 4; ++m) {\n    for (unsigned int n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing big_int = boost::multiprecision::cpp_int;\n\nbig_int ipow(big_int base, big_int exp) {\n  big_int result(1);\n  while (exp) {\n    if (exp & 1) {\n      result *= base;\n    }\n    exp >>= 1;\n    base *= base;\n  }\n  return result;\n}\n\nbig_int ackermann(unsigned m, unsigned n) {\n  static big_int (*ack)(unsigned, big_int) =\n      [](unsigned m, big_int n)->big_int {\n    switch (m) {\n    case 0:\n      return n + 1;\n    case 1:\n      return n + 2;\n    case 2:\n      return 3 + 2 * n;\n    case 3:\n      return 5 + 8 * (ipow(big_int(2), n) - 1);\n    default:\n      return n == 0 ? ack(m - 1, big_int(1)) : ack(m - 1, ack(m, n - 1));\n    }\n  };\n  return ack(m, big_int(n));\n}\n\nint main() {\n  for (unsigned m = 0; m < 4; ++m) {\n    for (unsigned n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n\n  std::cout << \"A(4, 1) = \" << ackermann(4, 1) << \"\\n\";\n\n  std::stringstream ss;\n  ss << ackermann(4, 2);\n  auto text = ss.str();\n  std::cout << \"A(4, 2) = (\" << text.length() << \" digits)\\n\"\n            << text.substr(0, 80) << \"\\n...\\n\"\n            << text.substr(text.length() - 80) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atomic>\n#include <chrono>\n#include <cmath>\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nclass Integrator\n{\n  public:\n    using clock_type = std::chrono::high_resolution_clock;\n    using dur_t      = std::chrono::duration<double>;\n    using func_t     = double(*)(double);\n\n    explicit Integrator(func_t f = nullptr);\n    ~Integrator();\n    void input(func_t new_input);\n    double output() { return integrate(); }\n\n  private:\n    std::atomic_flag continue_;\n    std::mutex       mutex;\n    std::thread      worker;\n\n    func_t                       func;\n    double                       state = 0;\n    //Improves precision by reducing sin result error on large values\n    clock_type::time_point const beginning = clock_type::now();\n    clock_type::time_point       t_prev = beginning;\n\n    void do_work();\n    double integrate();\n};\n\nIntegrator::Integrator(func_t f) : func(f)\n{\n    continue_.test_and_set();\n    worker = std::thread(&Integrator::do_work, this);\n}\n\nIntegrator::~Integrator()\n{\n    continue_.clear();\n    worker.join();\n}\n\nvoid Integrator::input(func_t new_input)\n{\n    integrate();\n    std::lock_guard<std::mutex> lock(mutex);\n    func = new_input;\n}\n\nvoid Integrator::do_work()\n{\n    while(continue_.test_and_set()) {\n        integrate();\n        std::this_thread::sleep_for(1ms);\n    }\n}\n\ndouble Integrator::integrate()\n{\n    std::lock_guard<std::mutex> lock(mutex);\n    auto now = clock_type::now();\n    dur_t start = t_prev - beginning;\n    dur_t fin   =    now - beginning;\n    if(func)\n        state += (func(start.count()) + func(fin.count())) * (fin - start).count() / 2;\n    t_prev = now;\n    return state;\n}\n\ndouble sine(double time)\n{\n    constexpr double PI = 3.1415926535897932;\n    return std::sin(2 * PI * 0.5 * time);\n}\n\nint main()\n{\n    Integrator foo(sine);\n    std::this_thread::sleep_for(2s);\n    foo.input(nullptr);\n    std::this_thread::sleep_for(500ms);\n    std::cout << foo.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\nusing namespace std;\n\nconst int pasTriMax = 61;\n\nuint64_t pasTri[pasTriMax + 1];\n\nvoid pascalTriangle(unsigned long n)\n// Calculate the n'th line 0.. middle\n{\n    unsigned long j, k;\n\n    pasTri[0] = 1;\n    j = 1;\n    while (j <= n)\n    {\n        j++;\n        k = j / 2;\n        pasTri[k] = pasTri[k - 1];\n        for ( ;k >= 1; k--)\n            pasTri[k] += pasTri[k - 1];\n    }\n}\n\nbool isPrime(unsigned long n)\n{\n    if (n > pasTriMax)\n    {\n        cout << n << \" is out of range\" << endl;\n        exit(1);\n    }\n\n    pascalTriangle(n);\n    bool res = true;\n    int i = n / 2;\n    while (res && (i > 1))\n    {\n        res = res && (pasTri[i] % n == 0);\n        i--;\n    }\n    return res;\n}\n\nvoid expandPoly(unsigned long n)\n{\n    const char vz[] = {'+', '-'};\n\n    if (n > pasTriMax)\n    {\n        cout << n << \" is out of range\" << endl;\n        exit(1);\n    }\n\n    switch (n)\n    {\n        case 0:\n            cout << \"(x-1)^0 = 1\" << endl;\n            break;\n        case 1:\n            cout << \"(x-1)^1 = x-1\" << endl;\n            break;\n        default:\n            pascalTriangle(n);\n            cout << \"(x-1)^\" << n << \" = \";\n            cout << \"x^\" << n;\n            bool bVz = true;\n            int nDiv2 = n / 2;\n            for (unsigned long j = n - 1; j > nDiv2; j--, bVz = !bVz)\n                cout << vz[bVz] << pasTri[n - j] << \"*x^\" << j;\n            for (unsigned long j = nDiv2; j > 1; j--, bVz = !bVz)\n                cout << vz[bVz] << pasTri[j] << \"*x^\" << j;\n            cout << vz[bVz] << pasTri[1] << \"*x\";\n            bVz = !bVz;\n            cout << vz[bVz] << pasTri[0] << endl;\n            break;\n    }\n}\n\nint main()\n{\n    for (unsigned long n = 0; n <= 9; n++)\n        expandPoly(n);\n    for (unsigned long n = 2; n <= pasTriMax; n++)\n        if (isPrime(n))\n            cout << setw(3) << n;\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <list>\n\nbool k_prime(unsigned n, unsigned k) {\n    unsigned f = 0;\n    for (unsigned p = 2; f < k && p * p <= n; p++)\n        while (0 == n % p) { n /= p; f++; }\n    return f + (n > 1 ? 1 : 0) == k;\n}\n\nstd::list<unsigned> primes(unsigned k, unsigned n)  {\n    std::list<unsigned> list;\n    for (unsigned i = 2;list.size() < n;i++)\n        if (k_prime(i, k)) list.push_back(i);\n    return list;\n}\n\nint main(const int argc, const char* argv[]) {\n    using namespace std;\n    for (unsigned k = 1; k <= 5; k++) {\n        ostringstream os(\"\");\n        const list<unsigned> l = primes(k, 10);\n        for (list<unsigned>::const_iterator i = l.begin(); i != l.end(); i++)\n            os << setw(4) << *i;\n        cout << \"k = \" << k << ':' << os.str() << endl;\n    }\n\n\treturn EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nint main() {\n    std::vector<int> alreadyDiscovered;\n    std::unordered_map<int, int> divsumMap;\n    int count = 0;\n\n    for (int N = 1; N <= 20000; ++N)\n    {\n        int divSumN = 0;\n\n        for (int i = 1; i <= N / 2; ++i)\n        {\n            if (fmod(N, i) == 0)\n            {\n                divSumN += i;\n            }\n        }\n\n        // populate map of integers to the sum of their proper divisors\n        if (divSumN != 1) // do not include primes\n            divsumMap[N] = divSumN;\n\n        for (std::unordered_map<int, int>::iterator it = divsumMap.begin(); it != divsumMap.end(); ++it)\n        {\n            int M = it->first;\n            int divSumM = it->second;\n            int divSumN = divsumMap[N];\n\n            if (N != M && divSumM == N && divSumN == M)\n            {\n                // do not print duplicate pairs\n                if (std::find(alreadyDiscovered.begin(), alreadyDiscovered.end(), N) != alreadyDiscovered.end())\n                    break;\n\n                std::cout << \"[\" << M << \", \" << N << \"]\" << std::endl;\n\n                alreadyDiscovered.push_back(M);\n                alreadyDiscovered.push_back(N);\n                count++;\n            }\n        }\n    }\n\n    std::cout << count << \" amicable pairs discovered\" << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <string>\n\nbool is_deranged(const std::string& left, const std::string& right)\n{\n    return (left.size() == right.size()) &&\n        (std::inner_product(left.begin(), left.end(), right.begin(), 0, std::plus<int>(), std::equal_to<char>()) == 0);\n}\n\nint main()\n{\n    std::ifstream input(\"unixdict.txt\");\n    if (!input) {\n        std::cerr << \"can't open input file\\n\";\n        return EXIT_FAILURE;\n    }\n\n    typedef std::set<std::string> WordList;\n    typedef std::map<std::string, WordList> AnagraMap;\n    AnagraMap anagrams;\n\n    std::pair<std::string, std::string> result;\n    size_t longest = 0;\n\n    for (std::string value; input >> value; /**/) {\n        std::string key(value);\n        std::sort(key.begin(), key.end());\n\n        if (longest < value.length()) { // is it a long candidate?\n            if (0 < anagrams.count(key)) { // is it an anagram?\n                for (const auto& prior : anagrams[key]) {\n                    if (is_deranged(prior, value)) { // are they deranged?\n                        result = std::make_pair(prior, value);\n                        longest = value.length();\n                    }\n                }\n            }\n        }\n        anagrams[key].insert(value);\n    }\n\n    std::cout << result.first << ' ' << result.second << '\\n';\n    return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nint main() {\n  std::ifstream in(\"unixdict.txt\");\n  typedef  std::map<std::string, std::vector<std::string> > AnagramMap;\n  AnagramMap anagrams;\n\n  std::string word;\n  size_t count = 0;\n  while (std::getline(in, word)) {\n    std::string key = word;\n    std::sort(key.begin(), key.end());\n    // note: the [] op. automatically inserts a new value if key does not exist\n    AnagramMap::mapped_type & v = anagrams[key];\n    v.push_back(word);\n    count = std::max(count, v.size());\n  }\n\n  in.close();\n\n  for (AnagramMap::const_iterator it = anagrams.begin(), e = anagrams.end();\n       it != e; it++)\n    if (it->second.size() >= count) {\n      std::copy(it->second.begin(), it->second.end(),\n                std::ostream_iterator<std::string>(std::cout, \", \"));\n      std::cout << std::endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __wxPendulumDlg_h__\n#define __wxPendulumDlg_h__\n\n// ---------------------\n/// @author Martin Ettl\n/// @date   2013-02-03\n// ---------------------\n\n#ifdef __BORLANDC__\n#pragma hdrstop\n#endif\n\n#ifndef WX_PRECOMP\n#include <wx/wx.h>\n#include <wx/dialog.h>\n#else\n#include <wx/wxprec.h>\n#endif\n#include <wx/timer.h>\n#include <wx/dcbuffer.h>\n#include <cmath>\n\nclass wxPendulumDlgApp : public wxApp\n{\n    public:\n        bool OnInit();\n        int OnExit();\n};\n\nclass wxPendulumDlg : public wxDialog\n{\n    public:\n\n        wxPendulumDlg(wxWindow *parent, wxWindowID id = 1, const wxString &title = wxT(\"wxPendulum\"),\n\t\t\t\t const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize,\n\t\t\t\t long style = wxSUNKEN_BORDER | wxCAPTION | wxRESIZE_BORDER | wxSYSTEM_MENU | wxDIALOG_NO_PARENT | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxCLOSE_BOX);\n\n        virtual ~wxPendulumDlg();\n\t\n\t\t// Event handler\n        void wxPendulumDlgPaint(wxPaintEvent& event);\n        void wxPendulumDlgSize(wxSizeEvent& event);\n        void OnTimer(wxTimerEvent& event);\n\n    private:\n\n\t\t// a pointer to a timer object\n        wxTimer *m_timer;\n\n\t\tunsigned int m_uiLength;\n\t\tdouble  \t m_Angle;\n\t\tdouble       m_AngleVelocity;\n\n        enum wxIDs\n        {\n            ID_WXTIMER1 = 1001,\n            ID_DUMMY_VALUE_\n        };\n\n        void OnClose(wxCloseEvent& event);\n        void CreateGUIControls();\n\n        DECLARE_EVENT_TABLE()\n};\n\n#endif // __wxPendulumDlg_h__\n"
  },
  {
    "language": "C++",
    "code": "// ---------------------\n/// @author Martin Ettl\n/// @date   2013-02-03\n// ---------------------\n\n#include \"wxPendulumDlg.hpp\"\n#include <wx/pen.h>\n\nIMPLEMENT_APP(wxPendulumDlgApp)\n\nbool wxPendulumDlgApp::OnInit()\n{\n    wxPendulumDlg* dialog = new wxPendulumDlg(NULL);\n    SetTopWindow(dialog);\n    dialog->Show(true);\n    return true;\n}\n\nint wxPendulumDlgApp::OnExit()\n{\n    return 0;\n}\n\nBEGIN_EVENT_TABLE(wxPendulumDlg, wxDialog)\n    EVT_CLOSE(wxPendulumDlg::OnClose)\n    EVT_SIZE(wxPendulumDlg::wxPendulumDlgSize)\n    EVT_PAINT(wxPendulumDlg::wxPendulumDlgPaint)\n    EVT_TIMER(ID_WXTIMER1, wxPendulumDlg::OnTimer)\nEND_EVENT_TABLE()\n\nwxPendulumDlg::wxPendulumDlg(wxWindow *parent, wxWindowID id, const wxString &title, const wxPoint &position, const wxSize& size, long style)\n    : wxDialog(parent, id, title, position, size, style)\n{\n    CreateGUIControls();\n}\n\nwxPendulumDlg::~wxPendulumDlg()\n{\n}\n\nvoid wxPendulumDlg::CreateGUIControls()\n{\n    SetIcon(wxNullIcon);\n    SetSize(8, 8, 509, 412);\n    Center();\n\n\tm_uiLength = 200;\n\tm_Angle    = M_PI/2.;\n\tm_AngleVelocity = 0;\n\n    m_timer = new wxTimer();\n    m_timer->SetOwner(this, ID_WXTIMER1);\n    m_timer->Start(20);\n}\n\nvoid wxPendulumDlg::OnClose(wxCloseEvent& WXUNUSED(event))\n{\n    Destroy();\n}\n\nvoid wxPendulumDlg::wxPendulumDlgPaint(wxPaintEvent& WXUNUSED(event))\n{\n    SetBackgroundStyle(wxBG_STYLE_CUSTOM);\n    wxBufferedPaintDC dc(this);\n\n    // Get window dimensions\n    wxSize sz = GetClientSize();\n\t// determine the center of the canvas\n    const wxPoint center(wxPoint(sz.x / 2, sz.y / 2));\n\n    // create background color\n    wxColour powderblue = wxColour(176,224,230);\n\n    // draw powderblue background\n    dc.SetPen(powderblue);\n    dc.SetBrush(powderblue);\n    dc.DrawRectangle(0, 0, sz.x, sz.y);\n\n    // draw lines\n\twxPen Pen(*wxBLACK_PEN);\n\tPen.SetWidth(1);\n    dc.SetPen(Pen);\n    dc.SetBrush(*wxBLACK_BRUSH);\n\n    double angleAccel, dt = 0.15;\n\n    angleAccel = (-9.81 / m_uiLength) * sin(m_Angle);\n    m_AngleVelocity += angleAccel * dt;\n    m_Angle += m_AngleVelocity * dt;\n\n    int anchorX = sz.x / 2, anchorY = sz.y / 4;\n    int ballX = anchorX + (int)(sin(m_Angle) * m_uiLength);\n    int ballY = anchorY + (int)(cos(m_Angle) * m_uiLength);\n    dc.DrawLine(anchorX, anchorY, ballX, ballY);\n\n    dc.SetBrush(*wxGREY_BRUSH);\n    dc.DrawEllipse(anchorX - 3, anchorY - 4, 7, 7);\n\n    dc.SetBrush(wxColour(255,255,0)); // yellow\n    dc.DrawEllipse(ballX - 7, ballY - 7, 20, 20);\n}\n\nvoid wxPendulumDlg::wxPendulumDlgSize(wxSizeEvent& WXUNUSED(event))\n{\n    Refresh();\n}\n\nvoid wxPendulumDlg::OnTimer(wxTimerEvent& WXUNUSED(event))\n{\n\t// force refresh\n\tRefresh();\n}\n"
  },
  {
    "language": "C++",
    "code": "double fib(double n)\n{\n  if(n < 0)\n  {\n    throw \"Invalid argument passed to fib\";\n  }\n  else\n  {\n    struct actual_fib\n    {\n        static double calc(double n)\n        {\n          if(n < 2)\n          {\n            return n;\n          }\n          else\n          {\n            return calc(n-1) + calc(n-2);\n          }\n        }\n    };\n\n    return actual_fib::calc(n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\nusing namespace std;\n\ndouble fib(double n)\n{\n  if(n < 0)\n    throw \"Invalid argument\";\n\n  function<double(double)> actual_fib = [&](double n)\n  {\n    if(n < 2) return n;\n    return actual_fib(n-1) + actual_fib(n-2);\n  };\n\n  return actual_fib(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "double fib(double n)\n{\n  if(n < 0)\n  {\n    throw \"Invalid argument passed to fib\";\n  }\n  else\n  {\n    struct actual_fib\n    {\n      double operator()(double n)\n      {\n        if(n < 2)\n        {\n          return n;\n        }\n        else\n        {\n          return (*this)(n-1) + (*this)(n-2);\n        }\n      }\n    };\n\n    return actual_fib()(n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nstd::ostream& operator<<(std::ostream& out, const std::string s) {\n    return out << s.c_str();\n}\n\nstruct gecos_t {\n    std::string fullname, office, extension, homephone, email;\n\n    friend std::ostream& operator<<(std::ostream&, const gecos_t&);\n};\n\nstd::ostream& operator<<(std::ostream& out, const gecos_t& g) {\n    return out << g.fullname << ',' << g.office << ',' << g.extension << ',' << g.homephone << ',' << g.email;\n}\n\nstruct passwd_t {\n    std::string account, password;\n    int uid, gid;\n    gecos_t gecos;\n    std::string directory, shell;\n\n    passwd_t(const std::string& a, const std::string& p, int u, int g, const gecos_t& ge, const std::string& d, const std::string& s)\n        : account(a), password(p), uid(u), gid(g), gecos(ge), directory(d), shell(s)\n    {\n        //empty\n    }\n\n    friend std::ostream& operator<<(std::ostream&, const passwd_t&);\n};\n\nstd::ostream& operator<<(std::ostream& out, const passwd_t& p) {\n    return out << p.account << ':' << p.password << ':' << p.uid << ':' << p.gid << ':' << p.gecos << ':' << p.directory << ':' << p.shell;\n}\n\nstd::vector<passwd_t> passwd_list{\n    {\n        \"jsmith\", \"x\", 1001, 1000,\n        {\"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\"},\n        \"/home/jsmith\", \"/bin/bash\"\n    },\n    {\n        \"jdoe\", \"x\", 1002, 1000,\n        {\"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\"},\n        \"/home/jdoe\", \"/bin/bash\"\n    }\n};\n\nint main() {\n    // Write the first two records\n    std::ofstream out_fd(\"passwd.txt\");\n    for (size_t i = 0; i < passwd_list.size(); ++i) {\n        out_fd << passwd_list[i] << '\\n';\n    }\n    out_fd.close();\n\n    // Append the third record\n    out_fd.open(\"passwd.txt\", std::ios::app);\n    out_fd << passwd_t(\"xyz\", \"x\", 1003, 1000, { \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\" }, \"/home/xyz\", \"/bin/bash\") << '\\n';\n    out_fd.close();\n\n    // Verify the record was appended\n    std::ifstream in_fd(\"passwd.txt\");\n    std::string line, temp;\n    while (std::getline(in_fd, temp)) {\n        // the last line of the file is empty, make sure line contains the last record\n        if (!temp.empty()) {\n            line = temp;\n        }\n    }\n    if (line.substr(0, 4) == \"xyz:\") {\n        std::cout << \"Appended record: \" << line << '\\n';\n    } else {\n        std::cout << \"Failed to find the expected record appended.\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> //cout for printing\n#include <algorithm> //for_each defined here\n\n//create the function (print the square)\nvoid print_square(int i) {\n  std::cout << i*i << \" \";\n}\n\nint main() {\n  //create the array\n  int ary[]={1,2,3,4,5};\n  //stl for_each\n  std::for_each(ary,ary+5,print_square);\n  return 0;\n}\n//prints 1 4 9 16 25\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  // cout for printing\n#include <algorithm> // for_each defined here\n#include <vector>    // stl vector class\n\n// create the function (print the square)\nvoid print_square(int i) {\n  std::cout << i*i << \" \";\n}\n\nint main() {\n  // create the array\n  std::vector<int> ary;\n  ary.push_back(1);\n  ary.push_back(2);\n  ary.push_back(3);\n  ary.push_back(4);\n  ary.push_back(5);\n  // stl for_each\n  std::for_each(ary.begin(),ary.end(),print_square);\n  return 0;\n}\n//prints 1 4 9 16 25\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>   // cout for printing\n#include <algorithm>  // for_each defined here\n#include <vector>     // stl vector class\n#include <functional> // bind and ptr_fun\n\n// create a binary function (print any two arguments together)\ntemplate<class type1,class type2>\nvoid print_juxtaposed(type1 x, type2 y) {\n  std::cout << x << y;\n}\n\nint main() {\n  // create the array\n  std::vector<int> ary;\n  ary.push_back(1);\n  ary.push_back(2);\n  ary.push_back(3);\n  ary.push_back(4);\n  ary.push_back(5);\n  // stl for_each, using binder and adaptable unary function\n  std::for_each(ary.begin(),ary.end(),std::bind2nd(std::ptr_fun(print_juxtaposed<int,std::string>),\"x \"));\n  return 0;\n}\n//prints 1x 2x 3x 4x 5x\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\nusing namespace boost::lambda;\nvector<int> ary(10);\nint i = 0;\nfor_each(ary.begin(), ary.end(), _1 = ++var(i)); // init array\ntransform(ary.begin(), ary.end(), ostream_iterator<int>(cout, \" \"), _1 * _1); // square and output\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nint main() {\n   std::vector<int> intVec(10);\n   std::iota(std::begin(intVec), std::end(intVec), 1 ); // Fill the vector\n   std::transform(std::begin(intVec) , std::end(intVec), std::begin(intVec),\n\t [](int i) { return i * i ; } ); // Transform it with closures\n   std::copy(std::begin(intVec), end(intVec) ,\n\t std::ostream_iterator<int>(std::cout, \" \"));\n   std::cout << std::endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <boost/multiprecision/gmp.hpp>\n#include <string>\n\nnamespace mp = boost::multiprecision;\n\nint main(int argc, char const *argv[])\n{\n    // We could just use (1 << 18) instead of tmpres, but let's point out one\n    // pecularity with gmp and hence boost::multiprecision: they won't accept\n    // a second mpz_int with pow(). Therefore, if we stick to multiprecision\n    // pow we need to convert_to<uint64_t>().\n    uint64_t tmpres = mp::pow(mp::mpz_int(4)\n                            , mp::pow(mp::mpz_int(3)\n                                    , 2).convert_to<uint64_t>()\n                                      ).convert_to<uint64_t>();\n    mp::mpz_int res = mp::pow(mp::mpz_int(5), tmpres);\n    std::string s = res.str();\n    std::cout << s.substr(0, 20)\n              << \"...\"\n              << s.substr(s.length() - 20, 20) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "T* foo = new(arena) T;\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cassert>\n#include <new>\n\n// This class basically provides a global stack of pools; it is not thread-safe, and pools must be destructed in reverse order of construction\n// (you definitely want something better in production use :-))\nclass Pool\n{\npublic:\n  Pool(std::size_type sz);\n  ~Pool();\n  static Pool& current() { return *cur; }\n  void* allocate(std::size_type sz, std::size_t alignment);\nprivate:\n  char* memory; // char* instead of void* enables pointer arithmetic\n  char* free;\n  char* end;\n  Pool* prev;\n  static Pool* cur;\n\n  // prohibit copying\n  Pool(Pool const&); // not implemented\n  Pool& operator=(Pool const&); // not implemented\n};\n\nPool* pool::cur = 0;\n\nPool::Pool(std::size_type size):\n  memory(static_cast<char*>(::operator new(size))),\n  free(memory),\n  end(memory + size))\n{\n  prev = cur;\n  cur = this;\n}\n\nPool::~Pool()\n{\n  ::operator delete(memory);\n  cur = prev;\n}\n\nvoid* Pool::allocate(std::size_t size, std::size_t alignment)\n{\n  char* start = free;\n\n  // align the pointer\n  std::size_t extra = (start - memory) % aligment;\n  if (extra != 0)\n  {\n    extra = alignment - extra;\n  }\n\n  // test if we can still allocate that much memory\n  if (end - free < size + extra)\n    throw std::bad_alloc();\n\n  // the free memory now starts after the newly allocated object\n  free = start + size + extra;\n  return start;\n}\n\n// this is just a simple C-like struct, except that it uses a specific allocation/deallocation function.\nstruct X\n{\n  int member;\n  void* operator new(std::size_t);\n  void operator delete(void*) {} // don't deallocate memory for single objects\n};\n\nvoid* X::operator new(std::size_t size)\n{\n  // unfortunately C++ doesn't offer a portable way to find out alignment\n  // however, using the size as alignment is always safe (although usually wasteful)\n  return Pool::current().allocate(size, size);\n}\n\n// Example program\nint main()\n{\n  Pool my_pool(3*sizeof(X));\n  X* p1 = new X; // uses the allocator function defined above\n  X* p2 = new X;\n  X* p3 = new X;\n  delete p3; // doesn't really deallocate the memory because operator delete has an empty body\n\n  try\n  {\n    X* p4 = new X; // should fail\n    assert(false);\n  }\n  catch(...)\n  {\n  }\n\n  X* p5 = new X[10]; // uses global array allocation routine because we didn't provide operator new[] and operator delete[]\n  delete[] p5; // global array deallocation\n\n  Pool* my_second_pool(1000); // a large pool\n  X* p6 = new X; // allocate a new object from that pool\n  X* p7 = new X;\n  delete my_second_pool // also deallocates the memory for p6 and p7\n\n} // Here my_pool goes out of scope, deallocating the memory for p1, p2 and p3\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing std::complex;\n\nvoid complex_operations() {\n  complex<double> a(1.0, 1.0);\n  complex<double> b(3.14159, 1.25);\n\n  // addition\n  std::cout << a + b << std::endl;\n  // multiplication\n  std::cout << a * b << std::endl;\n  // inversion\n  std::cout << 1.0 / a << std::endl;\n  // negation\n  std::cout << -a << std::endl;\n  // conjugate\n  std::cout << std::conj(a) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <boost/spirit.hpp>\n #include <boost/spirit/tree/ast.hpp>\n #include <string>\n #include <cassert>\n #include <iostream>\n #include <istream>\n #include <ostream>\n\n using boost::spirit::rule;\n using boost::spirit::parser_tag;\n using boost::spirit::ch_p;\n using boost::spirit::real_p;\n\n using boost::spirit::tree_node;\n using boost::spirit::node_val_data;\n\n // The grammar\n struct parser: public boost::spirit::grammar<parser>\n {\n   enum rule_ids { addsub_id, multdiv_id, value_id, real_id };\n\n   struct set_value\n   {\n     set_value(parser const& p): self(p) {}\n     void operator()(tree_node<node_val_data<std::string::iterator,\n                                             double> >& node,\n                     std::string::iterator begin,\n                     std::string::iterator end) const\n     {\n       node.value.value(self.tmp);\n     }\n     parser const& self;\n   };\n\n   mutable double tmp;\n\n   template<typename Scanner> struct definition\n   {\n     rule<Scanner, parser_tag<addsub_id> > addsub;\n     rule<Scanner, parser_tag<multdiv_id> > multdiv;\n     rule<Scanner, parser_tag<value_id> > value;\n     rule<Scanner, parser_tag<real_id> > real;\n\n     definition(parser const& self)\n     {\n       using namespace boost::spirit;\n       addsub = multdiv\n         >> *((root_node_d[ch_p('+')] | root_node_d[ch_p('-')]) >> multdiv);\n       multdiv = value\n         >> *((root_node_d[ch_p('*')] | root_node_d[ch_p('/')]) >> value);\n       value = real | inner_node_d[('(' >> addsub >> ')')];\n       real = leaf_node_d[access_node_d[real_p[assign_a(self.tmp)]][set_value(self)]];\n     }\n\n     rule<Scanner, parser_tag<addsub_id> > const& start() const\n     {\n       return addsub;\n     }\n   };\n };\n\n template<typename TreeIter>\n double evaluate(TreeIter const& i)\n {\n   double op1, op2;\n   switch (i->value.id().to_long())\n   {\n   case parser::real_id:\n     return i->value.value();\n   case parser::value_id:\n   case parser::addsub_id:\n   case parser::multdiv_id:\n     op1 = evaluate(i->children.begin());\n     op2 = evaluate(i->children.begin()+1);\n     switch(*i->value.begin())\n     {\n     case '+':\n       return op1 + op2;\n     case '-':\n       return op1 - op2;\n     case '*':\n       return op1 * op2;\n     case '/':\n       return op1 / op2;\n     default:\n       assert(!\"Should not happen\");\n     }\n   default:\n     assert(!\"Should not happen\");\n   }\n   return 0;\n }\n\n // the read/eval/write loop\n int main()\n {\n   parser eval;\n   std::string line;\n   while (std::cout << \"Expression: \"\n          && std::getline(std::cin, line)\n          && !line.empty())\n   {\n     typedef boost::spirit::node_val_data_factory<double> factory_t;\n     boost::spirit::tree_parse_info<std::string::iterator, factory_t> info =\n       boost::spirit::ast_parse<factory_t>(line.begin(), line.end(),\n                                           eval, boost::spirit::space_p);\n     if (info.full)\n     {\n       std::cout << \"Result: \" << evaluate(info.trees.begin()) << std::endl;\n     }\n     else\n     {\n       std::cout << \"Error in expression.\" << std::endl;\n     }\n   }\n };\n"
  },
  {
    "language": "C++",
    "code": "#include <gmpxx.h>\n\nvoid agm(mpf_class& rop1, mpf_class& rop2, const mpf_class& op1,\n        const mpf_class& op2)\n{\n    rop1 = (op1 + op2) / 2;\n    rop2 = op1 * op2;\n    mpf_sqrt(rop2.get_mpf_t(), rop2.get_mpf_t());\n}\n\nint main(void)\n{\n    mpf_set_default_prec(300000);\n    mpf_class x0, y0, resA, resB, Z;\n\n    x0 = 1;\n    y0 = 0.5;\n    Z  = 0.25;\n    mpf_sqrt(y0.get_mpf_t(), y0.get_mpf_t());\n\n    int n = 1;\n    for (int i = 0; i < 8; i++) {\n        agm(resA, resB, x0, y0);\n        Z -= n * (resA - x0) * (resA - x0);\n        n *= 2;\n\n        agm(x0, y0, resA, resB);\n        Z -= n * (x0 - resA) * (x0 - resA);\n        n *= 2;\n    }\n\n    x0 = x0 * x0 / Z;\n    gmp_printf (\"%.100000Ff\\n\", x0.get_mpf_t());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define _cin\tios_base::sync_with_stdio(0);\tcin.tie(0);\n#define rep(a, b)\tfor(ll i =a;i<=b;++i)\n\ndouble agm(double a, double g)\t\t//ARITHMETIC GEOMETRIC MEAN\n{\tdouble epsilon = 1.0E-16,a1,g1;\n\tif(a*g<0.0)\n\t{\tcout<<\"Couldn't find arithmetic-geometric mean of these numbers\\n\";\n\t\texit(1);\n\t}\n\twhile(fabs(a-g)>epsilon)\n\t{\ta1 = (a+g)/2.0;\n\t\tg1 = sqrt(a*g);\n\t\ta = a1;\n\t\tg = g1;\n\t}\n\treturn a;\n}\n\nint main()\n{\t_cin;    //fast input-output\n\tdouble x, y;\n\tcout<<\"Enter X and Y: \";\t//Enter two numbers\n\tcin>>x>>y;\n\tcout<<\"\\nThe Arithmetic-Geometric Mean of \"<<x<<\" and \"<<y<<\" is \"<<agm(x, y);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n  int a, b;\n  std::cin >> a >> b;\n  std::cout << \"a+b = \" << a+b << \"\\n\";\n  std::cout << \"a-b = \" << a-b << \"\\n\";\n  std::cout << \"a*b = \" << a*b << \"\\n\";\n  std::cout << \"a/b = \" << a/b << \", remainder \" << a%b << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include \"math.h\"\n#include \"boost/rational.hpp\"\n\ntypedef  boost::rational<int> frac;\n\nbool is_perfect(int c)\n{\n    frac sum(1, c);\n    for (int f = 2;f < sqrt(static_cast<float>(c)); ++f){\n\n        if (c % f == 0) sum += frac(1,f) + frac(1, c/f);\n    }\n    if (sum.denominator() == 1){\n \treturn (sum == 1);\n    }\n    return false;\n}\n\nint main()\n{\n    for (int candidate = 2; candidate < 0x80000; ++candidate){\n        if (is_perfect(candidate))\n\t        std::cout << candidate << \" is perfect\" << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nint main()\n{\n  std::vector<int> a(3), b(4);\n  a[0] = 11; a[1] = 12; a[2] = 13;\n  b[0] = 21; b[1] = 22; b[2] = 23; b[3] = 24;\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for (int i = 0; i < a.size(); ++i)\n    std::cout << \"a[\" << i << \"] = \" << a[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nint main() {\n  std::vector<int> a {1, 2, 3, 4};\n  std::vector<int> b {5, 6, 7, 8, 9};\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for(int& i: a) std::cout << i << \" \";\n  std::cout << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntemplate <typename T1, typename T2>\nint* concatArrays( T1& array_1, T2& array_2) {\n  int arrayCount_1 = sizeof(array_1) / sizeof(array_1[0]);\n  int arrayCount_2 = sizeof(array_2) / sizeof(array_2[0]);\n  int newArraySize = arrayCount_1 + arrayCount_2;\n\n  int *p = new int[newArraySize];\n\n  for (int i = 0; i < arrayCount_1; i++) {\n    p[i] = array_1[i];\n  }\n\n  for (int i = arrayCount_1; i < newArraySize; i++) {\n    int newIndex = i-arrayCount_2;\n\n    if (newArraySize % 2 == 1)\n\tnewIndex--;\n\n    p[i] = array_2[newIndex];\n    cout << \"i: \" << i << endl;\n    cout << \"array_2[i]: \" << array_2[newIndex] << endl;\n    cout << endl;\n  }\n\n  return p;\n}\n\nint main() {\n\n  int ary[4] = {1, 2, 3, 123};\n  int anotherAry[3] = {4, 5, 6};\n\n  int *r = concatArrays(ary, anotherAry);\n\n  cout << *(r + 0) << endl;\n  cout << *(r + 1) << endl;\n  cout << *(r + 2) << endl;\n  cout << *(r + 3) << endl;\n  cout << *(r + 4) << endl;\n  cout << *(r + 5) << endl;\n  cout << *(r + 6) << endl;\n\n  delete r;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <vector>\n\n// These headers are only needed for the demonstration\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n\n// This is a template function that works for any array-like object\ntemplate <typename Array>\nvoid demonstrate(Array& array)\n{\n  // Array element access\n  array[2] = \"Three\";  // Fast, but unsafe - if the index is out of bounds you\n                       // get undefined behaviour\n  array.at(1) = \"Two\"; // *Slightly* less fast, but safe - if the index is out\n                       // of bounds, an exception is thrown\n\n  // Arrays can be used with standard algorithms\n  std::reverse(begin(array), end(array));\n  std::for_each(begin(array), end(array),\n    [](typename Array::value_type const& element) // in C++14, you can just use auto\n    {\n      std::cout << element << ' ';\n    });\n\n  std::cout << '\\n';\n}\n\nint main()\n{\n  // Compile-time sized fixed-size array\n  auto fixed_size_array = std::array<std::string, 3>{ \"One\", \"Four\", \"Eight\" };\n  // If you do not supply enough elements, the remainder are default-initialized\n\n  // Dynamic array\n  auto dynamic_array = std::vector<std::string>{ \"One\", \"Four\" };\n  dynamic_array.push_back(\"Eight\"); // Dynamically grows to accept new element\n\n  // All types of arrays can be used more or less interchangeably\n  demonstrate(fixed_size_array);\n  demonstrate(dynamic_array);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert> // assert.h also works\n\nint main()\n{\n  int a;\n  // ... input or change a here\n\n  assert(a == 42); // Aborts program if a is not 42, unless the NDEBUG macro was defined\n                    // when including <cassert>, in which case it has no effect\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostreams>\n\nint main()\n{\n  // Create the map.\n  std::map<int, double> exampleMap;\n\n  // Choose our key\n  int myKey = 7;\n\n  // Choose our value\n  double myValue = 3.14;\n\n  // Assign a value to the map with the specified key.\n  exampleMap[myKey] = myValue;\n\n  // Retrieve the value\n  double myRetrievedValue = exampleMap[myKey];\n\n  // Display our retrieved value.\n  std::cout << myRetrievedValue << std::endl;\n\n  // main() must return 0 on success.\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "std::map<A, B> exampleMap\n"
  },
  {
    "language": "C++",
    "code": "std::map<int, double> exampleMap\n"
  },
  {
    "language": "C++",
    "code": "exampleMap[7] = 3.14\n"
  },
  {
    "language": "C++",
    "code": "int myKey = 7;\ndouble myValue = 3.14;\nexampleMap[myKey] = myValue;\n"
  },
  {
    "language": "C++",
    "code": "exampleMap.insert(std::pair<int, double>(7,3.14));\n"
  },
  {
    "language": "C++",
    "code": "exampleMap.insert(std::make_pair(7,3.14));\n"
  },
  {
    "language": "C++",
    "code": "myValue = exampleMap[myKey]\n"
  },
  {
    "language": "C++",
    "code": "double myValue = 0.0;\nstd::map<int, double>::iterator myIterator = exampleMap.find(myKey);\nif(exampleMap.end() != myIterator)\n{\n  // Return the value for that key.\n  myValue = myIterator->second;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  std::map<std::string, int> dict {\n    {\"One\", 1},\n    {\"Two\", 2},\n    {\"Three\", 7}\n  };\n\n  dict[\"Three\"] = 3;\n\n  std::cout << \"One: \" << dict[\"One\"] << std::endl;\n  std::cout << \"Key/Value pairs: \" << std::endl;\n  for(auto& kv: dict) {\n    std::cout << \"  \" << kv.first << \": \" << kv.second << std::endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "std::map<std::string, int> myDict;\nmyDict[\"hello\"] = 1;\nmyDict[\"world\"] = 2;\nmyDict[\"!\"] = 3;\n\n// iterating over key-value pairs:\nfor (std::map<std::string, int>::iterator it = myDict.begin(); it != myDict.end(); ++it) {\n    // the thing pointed to by the iterator is an std::pair<const std::string, int>&\n    const std::string& key = it->first;\n    int& value = it->second;\n    std::cout << \"key = \" << key << \", value = \" << value << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <chrono>\n#include <iomanip>\n#include <iostream>\n#include <mutex>\n#include <random>\n#include <thread>\n\nusing namespace std;\n\nconstexpr int bucket_count = 15;\n\nvoid equalizer(array<int, bucket_count>& buckets,\n               array<mutex, bucket_count>& bucket_mutex) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);\n\n    while (true) {\n        int from = dist_bucket(gen);\n        int to = dist_bucket(gen);\n        if (from != to) {\n            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);\n            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);\n            int diff = buckets[from] - buckets[to];\n            int amount = abs(diff / 2);\n            if (diff < 0) {\n                swap(from, to);\n            }\n            buckets[from] -= amount;\n            buckets[to] += amount;\n        }\n    }\n}\n\nvoid randomizer(array<int, bucket_count>& buckets,\n                array<mutex, bucket_count>& bucket_mutex) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);\n\n    while (true) {\n        int from = dist_bucket(gen);\n        int to = dist_bucket(gen);\n        if (from != to) {\n            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);\n            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);\n            uniform_int_distribution<> dist_amount(0, buckets[from]);\n            int amount = dist_amount(gen);\n            buckets[from] -= amount;\n            buckets[to] += amount;\n        }\n    }\n}\n\nvoid print_buckets(const array<int, bucket_count>& buckets) {\n    int total = 0;\n    for (const int& bucket : buckets) {\n        total += bucket;\n        cout << setw(3) << bucket << ' ';\n    }\n    cout << \"= \" << setw(3) << total << endl;\n}\n\nint main() {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist(0, 99);\n\n    array<int, bucket_count> buckets;\n    array<mutex, bucket_count> bucket_mutex;\n    for (int& bucket : buckets) {\n        bucket = dist(gen);\n    }\n    print_buckets(buckets);\n\n    thread t_eq(equalizer, ref(buckets), ref(bucket_mutex));\n    thread t_rd(randomizer, ref(buckets), ref(bucket_mutex));\n\n    while (true) {\n        this_thread::sleep_for(chrono::seconds(1));\n        for (mutex& mutex : bucket_mutex) {\n            mutex.lock();\n        }\n        print_buckets(buckets);\n        for (mutex& mutex : bucket_mutex) {\n            mutex.unlock();\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <random>\n#include <vector>\n#include <iostream>\n\n#define MAX_N 20\n#define TIMES 1000000\n\n/**\n * Used to generate a uniform random distribution\n */\nstatic std::random_device rd;  //Will be used to obtain a seed for the random number engine\nstatic std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()\nstatic std::uniform_int_distribution<> dis;\n\nint randint(int n) {\n    int r, rmax = RAND_MAX / n * n;\n    dis=std::uniform_int_distribution(0,rmax) ;\n    r = dis(gen);\n    return r / (RAND_MAX / n);\n}\n\nunsigned long factorial(size_t n) {\n    //Factorial using dynamic programming to memoize the values.\n    static std::vector<unsigned long>factorials{1,1,2};\n\tfor (;factorials.size() <= n;)\n\t    factorials.push_back(factorials.back()*factorials.size());\n\treturn factorials[n];\n}\n\nlong double expected(size_t n) {\n    long double sum = 0;\n    for (size_t i = 1; i <= n; i++)\n        sum += factorial(n) / pow(n, i) / factorial(n - i);\n    return sum;\n}\n\nint test(int n, int times) {\n    int i, count = 0;\n    for (i = 0; i < times; i++) {\n        unsigned int x = 1, bits = 0;\n        while (!(bits & x)) {\n            count++;\n            bits |= x;\n            x = static_cast<unsigned int>(1 << randint(n));\n        }\n    }\n    return count;\n}\n\nint main() {\n    puts(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\");\n\n    int n;\n    for (n = 1; n <= MAX_N; n++) {\n        int cnt = test(n, TIMES);\n        long double avg = (double)cnt / TIMES;\n        long double theory = expected(static_cast<size_t>(n));\n        long double diff = (avg / theory - 1) * 100;\n        printf(\"%2d %8.4f %8.4f %6.3f%%\\n\", n, static_cast<double>(avg), static_cast<double>(theory), static_cast<double>(diff));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n\ndouble mean(const std::vector<double>& numbers)\n{\n     if (numbers.size() == 0)\n          return 0;\n\n     double sum = 0;\n     for (std::vector<double>::iterator i = numbers.begin(); i != numbers.end(); i++)\n          sum += *i;\n     return sum / numbers.size();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n\ndouble mean(const std::vector<double>& numbers)\n{\n    if (numbers.empty())\n        return 0;\n    return std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n}\n"
  },
  {
    "language": "Java",
    "code": "class HundredDoors {\n    public static void main(String[] args) {\n        boolean[] doors = new boolean[101];\n\n        for (int i = 1; i < doors.length; i++) {\n            for (int j = i; j < doors.length; j += i) {\n                doors[j] = !doors[j];\n            }\n        }\n\n        for (int i = 1; i < doors.length; i++) {\n            if (doors[i]) {\n                System.out.printf(\"Door %d is open.%n\", i);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\n\npublic class HundredDoors {\n    public static void main(String[] args) {\n        final int n = 100;\n        var a = new BitSet(n);\n        for (int i = 1; i <= n; i++) {\n            for (int j = i - 1; j < n; j += i) {\n                a.flip(j);\n            }\n        }\n        a.stream().map(i -> i + 1).forEachOrdered(System.out::println);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "class HundredDoors {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++)\n            System.out.printf(\"Door %d is open.%n\", i * i);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nclass HundredDoors {\n    public static void main(String args[]) {\n        String openDoors = IntStream.rangeClosed(1, 100)\n                .filter(i -> Math.pow((int) Math.sqrt(i), 2) == i)\n                .mapToObj(Integer::toString)\n                .collect(Collectors.joining(\", \"));\n        System.out.printf(\"Open doors: %s%n\", openDoors);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {\n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\nimport static java.lang.Math.min;\n\npublic class Test {\n\n    static List<BigInteger> cumu(int n) {\n        List<List<BigInteger>> cache = new ArrayList<>();\n        cache.add(asList(BigInteger.ONE));\n\n        for (int L = cache.size(); L < n + 1; L++) {\n            List<BigInteger> r = new ArrayList<>();\n            r.add(BigInteger.ZERO);\n            for (int x = 1; x < L + 1; x++)\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\n            cache.add(r);\n        }\n        return cache.get(n);\n    }\n\n    static List<BigInteger> row(int n) {\n        List<BigInteger> r = cumu(n);\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Rows:\");\n        for (int x = 1; x < 11; x++)\n            System.out.printf(\"%2d: %s%n\", x, row(x));\n\n        System.out.println(\"\\nSums:\");\n        for (int x : new int[]{23, 123, 1234}) {\n            List<BigInteger> c = cumu(x);\n            System.out.printf(\"%s %s%n\", x, c.get(c.size() - 1));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.text.MessageFormat;\n\npublic class Beer {\n    static String bottles(int n) {\n        return MessageFormat.format(\"{0,choice,0#No more bottles|1#One bottle|2#{0} bottles} of beer\", n);\n    }\n\n    public static void main(String[] args) {\n        String bottles = bottles(99);\n        for (int n = 99; n > 0; ) {\n            System.out.println(bottles + \" on the wall\");\n            System.out.println(bottles);\n            System.out.println(\"Take one down, pass it around\");\n            bottles = bottles(--n);\n            System.out.println(bottles + \" on the wall\");\n            System.out.println();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Beer {\n    public static void main(String[] args) {\n        int bottles = 99;\n        StringBuilder sb = new StringBuilder();\n        String verse1 = \" bottles of beer on the wall\\n\";\n        String verse2 = \" bottles of beer.\\nTake one down, pass it around,\\n\";\n        String verse3 = \"Better go to the store and buy some more.\";\n\n        while (bottles > 0)\n            sb.append(bottles).append(verse1).append(bottles).append(verse2).append(--bottles).append(verse1).append(\"\\n\");\n\n        System.out.println(sb.append(verse3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Beer {\n    public static void main(String args[]) {\n        song(99);\n    }\n\n    public static void song(int bottles) {\n        if (bottles >= 0) {\n            if (bottles > 1)\n                System.out.println(bottles + \" bottles of beer on the wall\\n\" + bottles + \" bottles of beer\\nTake one down, pass it around\\n\" + (bottles - 1) + \" bottles of beer on the wall.\\n\");\n            else if (bottles == 1)\n                System.out.println(bottles + \" bottle of beer on the wall\\n\" + bottles + \" bottle of beer\\nTake one down, pass it around\\n\" + (bottles - 1) + \" bottles of beer on the wall.\\n\");\n            else\n                System.out.println(bottles + \" bottles of beer on the wall\\n\" + bottles + \" bottles of beer\\nBetter go to the store and buy some more!\");\n            song(bottles - 1);\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.BorderLayout;\nimport java.awt.event.ActionEvent;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.JTextArea;\n\npublic class Beer extends JFrame {\n    private int x;\n    private JTextArea text;\n\n    public static void main(String[] args) {\n        new Beer().setVisible(true);\n    }\n\n    public Beer() {\n        x = 99;\n\n        JButton take = new JButton(\"Take one down, pass it around\");\n        take.addActionListener(this::onTakeClick);\n\n        text = new JTextArea(4, 30);\n        text.setText(x + \" bottles of beer on the wall\\n\" + x + \" bottles of beer\");\n        text.setEditable(false);\n\n        setLayout(new BorderLayout());\n        add(text, BorderLayout.CENTER);\n        add(take, BorderLayout.PAGE_END);\n        pack();\n        setLocationRelativeTo(null);\n        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n    }\n\n    private void onTakeClick(ActionEvent event) {\n        JOptionPane.showMessageDialog(null, --x + \" bottles of beer on the wall\");\n        text.setText(x + \" bottles of beer on the wall\\n\" + x + \" bottles of beer\");\n        if (x == 0) {\n            dispose();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); // Standard input\n        System.out.println(in.nextInt() + in.nextInt()); // Standard output\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class SumDif {\n   StreamTokenizer in;\n   PrintWriter out;\n\n   public static void main(String[] args) throws IOException {\n      new SumDif().run();\n   }\n\n   private int nextInt() throws IOException {\n      in.nextToken();\n      return (int)in.nval;\n   }\n\n   public void run() throws IOException {\n      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // Standard input\n      out = new PrintWriter(new OutputStreamWriter(System.out)); // Standard output\n      solve();\n      out.flush();\n   }\n\n   private void solve() throws IOException {\n      out.println(nextInt() + nextInt());\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.nio.charset.Charset;\n\npublic class AplusB {\n    public static void main(String[] args) throws IOException {\n        StreamTokenizer in = new StreamTokenizer(new InputStreamReader(System.in, Charset.defaultCharset()));\n        in.nextToken();\n        int a = (int) in.nval;\n        in.nextToken();\n        int b = (int) in.nval;\n\n        try (Writer out = new OutputStreamWriter(System.out, Charset.defaultCharset())) {\n            out.write(Integer.toString(a + b));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "grammar aplusb ;\n\noptions {\n\tlanguage = Java;\n}\n\naplusb\t:\t(WS* e1=Num WS+ e2=Num NEWLINE {System.out.println($e1.text + \" + \" + $e2.text + \" = \" + (Integer.parseInt($e1.text) + Integer.parseInt($e2.text)));})+\n\t;\nNum\t:\t'-'?('0'..'9')+\n\t;\nWS\t:\t(' ' | '\\t')\n\t;\nNEWLINE\t:\tWS* '\\r'? '\\n'\n        ;\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ABC {\n\n    public static void main(String[] args) {\n        List<String> blocks = Arrays.asList(\n                \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n                \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n                \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\");\n\n        for (String word : Arrays.asList(\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\")) {\n            System.out.printf(\"%s: %s%n\", word.isEmpty() ? \"\\\"\\\"\" : word, canMakeWord(word, blocks));\n        }\n    }\n\n    public static boolean canMakeWord(String word, List<String> blocks) {\n        if (word.isEmpty())\n            return true;\n\n        char c = word.charAt(0);\n        for (int i = 0; i < blocks.size(); i++) {\n            String b = blocks.get(i);\n            if (b.charAt(0) != c && b.charAt(1) != c)\n                continue;\n            Collections.swap(blocks, 0, i);\n            if (canMakeWord(word.substring(1), blocks.subList(1, blocks.size())))\n                return true;\n            Collections.swap(blocks, 0, i);\n        }\n\n        return false;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public interface Inter {\n    int method1(double value);\n    int method2(String name);\n    int add(int a, int b);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n\n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n\n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n\n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Accumulator\n    //implements java.util.function.UnaryOperator<Number> // Java 8\n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t// Acts like sum += n, but chooses long or double.\n\t// Converts weird types (like BigInteger) to double.\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.function.UnaryOperator;\n\npublic class AccumulatorFactory {\n\n    public static UnaryOperator<Number> accumulator(Number sum0) {\n\t// Allows sum[0] = ... inside lambda.\n\tNumber[] sum = { sum0 };\n\n\t// Acts like n -> sum[0] += n, but chooses long or double.\n\t// Converts weird types (like BigInteger) to double.\n\treturn n -> (longable(sum[0]) && longable(n)) ?\n\t    (sum[0] = sum[0].longValue() + n.longValue()) :\n\t    (sum[0] = sum[0].doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tUnaryOperator<Number> x = accumulator(1);\n\tx.apply(5);\n\taccumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class AccumulatorFactory {\n\n    public interface Accumulator {\n        double add(double x);\n    }\n\n    private static Accumulator accumulator(final double initial) {\n        return new Accumulator() {\n            private double sum = initial;\n\n            @Override\n            public double add(double x) {\n                return sum += x;\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        Accumulator x = accumulator(1.0);\n        x.add(5.0);\n        System.out.println(accumulator(3.0));\n        System.out.println(x.add(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.function.DoubleUnaryOperator;\n\npublic interface AccumulatorFactory {\n  public static DoubleUnaryOperator accumulator(double element) {\n    double[] sum = { element };\n    return value -> sum[0] += value;\n  }\n\n  public static void main(String... arguments) {\n    DoubleUnaryOperator x = accumulator(1.0);\n    x.applyAsDouble(5.0);\n    System.out.println(accumulator(3.0));\n    System.out.println(x.applyAsDouble(2.3));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Accumulator {\n    private Long sumA; // non-null if we're working in the integer domain\n    private double sumB;\n    public Accumulator(Number sum0) {\n\tif (sum0 instanceof Double) {\n\t    sumB = sum0.doubleValue();\n\t} else {\n\t    sumA = sum0.longValue();\n\t}\n    }\n    public Number call(Number n) {\n        if (sumA != null) {\n\t    if (n instanceof Double) {\n\t\tsumB = n.doubleValue() + sumA;\n\t\tsumA = null;\n\t\treturn sumB;\n\t    }\n            return sumA += n.longValue();\n        }\n        return sumB += n.doubleValue();\n    }\n\n    public static void main(String[] args) {\n        Accumulator x = new Accumulator(1);\n        x.call(5);\n        Accumulator y = new Accumulator(3);\n        System.out.println(y+\" has value \"+y.call(0));\n        System.out.println(x.call(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"
  },
  {
    "language": "Java",
    "code": "@FunctionalInterface\npublic interface FunctionalField<FIELD extends Enum<?>> {\n  public Object untypedField(FIELD field);\n\n  @SuppressWarnings(\"unchecked\")\n  public default <VALUE> VALUE field(FIELD field) {\n    return (VALUE) untypedField(field);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Stream;\n\npublic interface TailRecursive {\n  public static <INPUT, INTERMEDIARY, OUTPUT> Function<INPUT, OUTPUT> new_(Function<INPUT, INTERMEDIARY> toIntermediary, UnaryOperator<INTERMEDIARY> unaryOperator, Predicate<INTERMEDIARY> predicate, Function<INTERMEDIARY, OUTPUT> toOutput) {\n    return input ->\n      $.new_(\n        Stream.iterate(\n          toIntermediary.apply(input),\n          unaryOperator\n        ),\n        predicate,\n        toOutput\n      )\n    ;\n  }\n\n  public static <INPUT1, INPUT2, INTERMEDIARY, OUTPUT> BiFunction<INPUT1, INPUT2, OUTPUT> new_(BiFunction<INPUT1, INPUT2, INTERMEDIARY> toIntermediary, UnaryOperator<INTERMEDIARY> unaryOperator, Predicate<INTERMEDIARY> predicate, Function<INTERMEDIARY, OUTPUT> toOutput) {\n    return (input1, input2) ->\n      $.new_(\n        Stream.iterate(\n          toIntermediary.apply(input1, input2),\n          unaryOperator\n        ),\n        predicate,\n        toOutput\n      )\n    ;\n  }\n\n  public enum $ {\n    $$;\n\n    private static <INTERMEDIARY, OUTPUT> OUTPUT new_(Stream<INTERMEDIARY> stream, Predicate<INTERMEDIARY> predicate, Function<INTERMEDIARY, OUTPUT> function) {\n      return stream\n        .filter(predicate)\n        .map(function)\n        .findAny()\n        .orElseThrow(RuntimeException::new)\n      ;\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Stack;\nimport java.util.function.BinaryOperator;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic interface Ackermann {\n  public static Ackermann new_(BigInteger number1, BigInteger number2, Stack<BigInteger> stack, boolean flag) {\n    return $.new_(number1, number2, stack, flag);\n  }\n  public static void main(String... arguments) {\n    $.main(arguments);\n  }\n  public BigInteger number1();\n  public BigInteger number2();\n\n  public Stack<BigInteger> stack();\n\n  public boolean flag();\n\n  public enum $ {\n    $$;\n\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger THREE = BigInteger.valueOf(3);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static Ackermann new_(BigInteger number1, BigInteger number2, Stack<BigInteger> stack, boolean flag) {\n      return (FunctionalAckermann) field -> {\n        switch (field) {\n          case number1: return number1;\n          case number2: return number2;\n          case stack: return stack;\n          case flag: return flag;\n          default: throw new UnsupportedOperationException(\n            field instanceof Field\n              ? \"Field checker has not been updated properly.\"\n              : \"Field is not of the correct type.\"\n          );\n        }\n      };\n    }\n\n    private static final BinaryOperator<BigInteger> ACKERMANN =\n      TailRecursive.new_(\n        (BigInteger number1, BigInteger number2) ->\n          new_(\n            number1,\n            number2,\n            Stream.of(number1).collect(\n              Collectors.toCollection(Stack::new)\n            ),\n            false\n          )\n        ,\n        ackermann -> {\n          BigInteger number1 = ackermann.number1();\n          BigInteger number2 = ackermann.number2();\n          Stack<BigInteger> stack = ackermann.stack();\n          if (!stack.empty() && !ackermann.flag()) {\n            number1 = stack.pop();\n          }\n          switch (number1.intValue()) {\n            case 0:\n              return new_(\n                number1,\n                number2.add(ONE),\n                stack,\n                false\n              );\n            case 1:\n              return new_(\n                number1,\n                number2.add(TWO),\n                stack,\n                false\n              );\n            case 2:\n              return new_(\n                number1,\n                number2.multiply(TWO).add(THREE),\n                stack,\n                false\n              );\n            default:\n              if (ZERO.equals(number2)) {\n                return new_(\n                  number1.subtract(ONE),\n                  ONE,\n                  stack,\n                  true\n                );\n              } else {\n                stack.push(number1.subtract(ONE));\n                return new_(\n                  number1,\n                  number2.subtract(ONE),\n                  stack,\n                  true\n                );\n              }\n          }\n        },\n        ackermann -> ackermann.stack().empty(),\n        Ackermann::number2\n      )::apply\n    ;\n\n    private static void main(String... arguments) {\n      System.out.println(ACKERMANN.apply(FOUR, TWO));\n    }\n\n    private enum Field {\n      number1,\n      number2,\n      stack,\n      flag\n    }\n\n    @FunctionalInterface\n    private interface FunctionalAckermann extends FunctionalField<Field>, Ackermann {\n      @Override\n      public default BigInteger number1() {\n        return field(Field.number1);\n      }\n\n      @Override\n      public default BigInteger number2() {\n        return field(Field.number2);\n      }\n\n      @Override\n      public default Stack<BigInteger> stack() {\n        return field(Field.stack);\n      }\n\n      @Override\n      public default boolean flag() {\n        return field(Field.flag);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "/*\n * Source https://stackoverflow.com/a/51092690/5520417\n */\n\npackage matematicas;\n\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * @author rodri\n *\n */\n\npublic class IterativeAckermannMemoryOptimization extends Thread {\n\n  /**\n   * Max percentage of free memory that the program will use. Default is 10% since\n   * the majority of the used devices are mobile and therefore it is more likely\n   * that the user will have more opened applications at the same time than in a\n   * desktop device\n   */\n  private static Double SYSTEM_MEMORY_LIMIT_PERCENTAGE = 0.1;\n\n  /**\n   * Attribute of the type IterativeAckermann\n   */\n  private IterativeAckermann iterativeAckermann;\n\n  /**\n   * @param iterativeAckermann\n   */\n  public IterativeAckermannMemoryOptimization(IterativeAckermann iterativeAckermann) {\n    super();\n    this.iterativeAckermann = iterativeAckermann;\n  }\n\n  /**\n   * @return\n   */\n  public IterativeAckermann getIterativeAckermann() {\n    return iterativeAckermann;\n  }\n\n  /**\n   * @param iterativeAckermann\n   */\n  public void setIterativeAckermann(IterativeAckermann iterativeAckermann) {\n    this.iterativeAckermann = iterativeAckermann;\n  }\n\n  public static Double getSystemMemoryLimitPercentage() {\n    return SYSTEM_MEMORY_LIMIT_PERCENTAGE;\n  }\n\n  /**\n   * Principal method of the thread. Checks that the memory used doesn't exceed or\n   * equal the limit, and informs the user when that happens.\n   */\n  @Override\n  public void run() {\n    String operating_system = System.getProperty(\"os.name\").toLowerCase();\n    if ( operating_system.equals(\"windows\") || operating_system.equals(\"linux\") || operating_system.equals(\"macintosh\") ) {\n      SYSTEM_MEMORY_LIMIT_PERCENTAGE = 0.25;\n    }\n\n    while ( iterativeAckermann.getConsumed_heap() >= SYSTEM_MEMORY_LIMIT_PERCENTAGE * Runtime.getRuntime().freeMemory() ) {\n      try {\n        wait();\n      }\n      catch ( InterruptedException e ) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    }\n    if ( ! iterativeAckermann.isAlive() )\n      iterativeAckermann.start();\n    else\n      notifyAll();\n\n  }\n\n}\n\n\npublic class IterativeAckermann extends Thread {\n\n  /*\n   * Adjust parameters conveniently\n   */\n  /**\n   *\n   */\n  private static final int HASH_SIZE_LIMIT = 636;\n\n  /**\n   *\n   */\n  private BigInteger m;\n\n  /**\n   *\n   */\n  private BigInteger n;\n\n  /**\n   *\n   */\n  private Integer hash_size;\n\n  /**\n   *\n   */\n  private Long consumed_heap;\n\n  /**\n   * @param m\n   * @param n\n   * @param invalid\n   * @param invalid2\n   */\n  public IterativeAckermann(BigInteger m, BigInteger n, Integer invalid, Long invalid2) {\n    super();\n    this.m = m;\n    this.n = n;\n    this.hash_size = invalid;\n    this.consumed_heap = invalid2;\n  }\n\n  /**\n   *\n   */\n  public IterativeAckermann() {\n    // TODO Auto-generated constructor stub\n    super();\n    m = null;\n    n = null;\n    hash_size = 0;\n    consumed_heap = 0l;\n  }\n\n  /**\n   * @return\n   */\n  public static BigInteger getLimit() {\n    return LIMIT;\n  }\n\n  /**\n   * @author rodri\n   *\n   * @param <T1>\n   * @param <T2>\n   */\n  /**\n   * @author rodri\n   *\n   * @param <T1>\n   * @param <T2>\n   */\n  static class Pair<T1, T2> {\n\n    /**\n     *\n     */\n    /**\n     *\n     */\n    T1 x;\n\n    /**\n     *\n     */\n    /**\n     *\n     */\n    T2 y;\n\n    /**\n     * @param x_\n     * @param y_\n     */\n    /**\n     * @param x_\n     * @param y_\n     */\n    Pair(T1 x_, T2 y_) {\n      x = x_;\n      y = y_;\n    }\n\n    /**\n     *\n     */\n    /**\n     *\n     */\n    @Override\n    public int hashCode() {\n      return x.hashCode() ^ y.hashCode();\n    }\n\n    /**\n     *\n     */\n    /**\n     *\n     */\n    @Override\n    public boolean equals(Object o_) {\n\n      if ( o_ == null ) {\n        return false;\n      }\n      if ( o_.getClass() != this.getClass() ) {\n        return false;\n      }\n      Pair<?, ?> o = (Pair<?, ?>) o_;\n      return x.equals(o.x) && y.equals(o.y);\n    }\n  }\n\n  /**\n   *\n   */\n  private static final BigInteger LIMIT = new BigInteger(\"6\");\n\n  /**\n   * @param m\n   * @param n\n   * @return\n   */\n\n  /**\n   *\n   */\n  @Override\n  public void run() {\n    while ( hash_size >= HASH_SIZE_LIMIT ) {\n      try {\n        this.wait();\n      }\n      catch ( InterruptedException e ) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    }\n    for ( BigInteger i = BigInteger.ZERO; i.compareTo(LIMIT) == - 1; i = i.add(BigInteger.ONE) ) {\n      for ( BigInteger j = BigInteger.ZERO; j.compareTo(LIMIT) == - 1; j = j.add(BigInteger.ONE) ) {\n        IterativeAckermann iterativeAckermann = new IterativeAckermann(i, j, null, null);\n        System.out.printf(\"Ackmermann(%d, %d) = %d\\n\", i, j, iterativeAckermann.iterative_ackermann(i, j));\n\n      }\n    }\n  }\n\n  /**\n   * @return\n   */\n  public BigInteger getM() {\n    return m;\n  }\n\n  /**\n   * @param m\n   */\n  public void setM(BigInteger m) {\n    this.m = m;\n  }\n\n  /**\n   * @return\n   */\n  public BigInteger getN() {\n    return n;\n  }\n\n  /**\n   * @param n\n   */\n  public void setN(BigInteger n) {\n    this.n = n;\n  }\n\n  /**\n   * @return\n   */\n  public Integer getHash_size() {\n    return hash_size;\n  }\n\n  /**\n   * @param hash_size\n   */\n  public void setHash_size(Integer hash_size) {\n    this.hash_size = hash_size;\n  }\n\n  /**\n   * @return\n   */\n  public Long getConsumed_heap() {\n    return consumed_heap;\n  }\n\n  /**\n   * @param consumed_heap\n   */\n  public void setConsumed_heap(Long consumed_heap) {\n    this.consumed_heap = consumed_heap;\n  }\n\n  /**\n   * @param m\n   * @param n\n   * @return\n   */\n  public BigInteger iterative_ackermann(BigInteger m, BigInteger n) {\n    if ( m.compareTo(BigInteger.ZERO) != - 1 && m.compareTo(BigInteger.ZERO) != - 1 )\n      try {\n        HashMap<Pair<BigInteger, BigInteger>, BigInteger> solved_set = new HashMap<Pair<BigInteger, BigInteger>, BigInteger>(900000);\n        Stack<Pair<BigInteger, BigInteger>> to_solve = new Stack<Pair<BigInteger, BigInteger>>();\n        to_solve.push(new Pair<BigInteger, BigInteger>(m, n));\n\n        while ( ! to_solve.isEmpty() ) {\n          Pair<BigInteger, BigInteger> head = to_solve.peek();\n          if ( head.x.equals(BigInteger.ZERO) ) {\n            solved_set.put(head, head.y.add(BigInteger.ONE));\n            to_solve.pop();\n          }\n          else if ( head.y.equals(BigInteger.ZERO) ) {\n            Pair<BigInteger, BigInteger> next = new Pair<BigInteger, BigInteger>(head.x.subtract(BigInteger.ONE), BigInteger.ONE);\n            BigInteger result = solved_set.get(next);\n            if ( result == null ) {\n              to_solve.push(next);\n            }\n            else {\n              solved_set.put(head, result);\n              to_solve.pop();\n            }\n          }\n          else {\n            Pair<BigInteger, BigInteger> next0 = new Pair<BigInteger, BigInteger>(head.x, head.y.subtract(BigInteger.ONE));\n            BigInteger result0 = solved_set.get(next0);\n            if ( result0 == null ) {\n              to_solve.push(next0);\n            }\n            else {\n              Pair<BigInteger, BigInteger> next = new Pair<BigInteger, BigInteger>(head.x.subtract(BigInteger.ONE), result0);\n              BigInteger result = solved_set.get(next);\n              if ( result == null ) {\n                to_solve.push(next);\n              }\n              else {\n                solved_set.put(head, result);\n                to_solve.pop();\n              }\n            }\n          }\n        }\n        this.hash_size = solved_set.size();\n        System.out.println(\"Hash Size: \" + hash_size);\n        consumed_heap = (Runtime.getRuntime().totalMemory() / (1024 * 1024));\n        System.out.println(\"Consumed Heap: \" + consumed_heap + \"m\");\n        setHash_size(hash_size);\n        setConsumed_heap(consumed_heap);\n        return solved_set.get(new Pair<BigInteger, BigInteger>(m, n));\n\n      }\n      catch ( OutOfMemoryError e ) {\n        // TODO: handle exception\n        e.printStackTrace();\n      }\n    throw new IllegalArgumentException(\"The arguments must be non-negative integers.\");\n  }\n\n  /**\n   * @param args\n   */\n  /**\n   * @param args\n   */\n  public static void main(String[] args) {\n    IterativeAckermannMemoryOptimization iterative_ackermann_memory_optimization = new IterativeAckermannMemoryOptimization(\n        new IterativeAckermann());\n    iterative_ackermann_memory_optimization.start();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapConnectionDemo {\n\n    public static void main(String[] args) throws LdapException, IOException {\n        try (LdapConnection connection = new LdapNetworkConnection(\"localhost\", 10389)) {\n            connection.bind();\n            connection.unBind();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.cursor.CursorException;\nimport org.apache.directory.api.ldap.model.cursor.EntryCursor;\nimport org.apache.directory.api.ldap.model.entry.Entry;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.message.SearchScope;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapSearchDemo {\n\n    public static void main(String[] args) throws IOException, LdapException, CursorException {\n        new LdapSearchDemo().demonstrateSearch();\n    }\n\n    private void demonstrateSearch() throws IOException, LdapException, CursorException {\n        try (LdapConnection conn = new LdapNetworkConnection(\"localhost\", 11389)) {\n            conn.bind(\"uid=admin,ou=system\", \"********\");\n            search(conn, \"*mil*\");\n            conn.unBind();\n        }\n    }\n\n    private void search(LdapConnection connection, String uid) throws LdapException, CursorException {\n        String baseDn = \"ou=users,o=mojo\";\n        String filter = \"(&(objectClass=person)(&(uid=\" + uid + \")))\";\n        SearchScope scope = SearchScope.SUBTREE;\n        String[] attributes = {\"dn\", \"cn\", \"sn\", \"uid\"};\n        int ksearch = 0;\n\n        EntryCursor cursor = connection.search(baseDn, filter, scope, attributes);\n        while (cursor.next()) {\n            ksearch++;\n            Entry entry = cursor.get();\n            System.out.printf(\"Search entry %d = %s%n\", ksearch, entry);\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Integrates input function K over time\n * S + (t1 - t0) * (K(t1) + K(t0)) / 2\n */\npublic class Integrator {\n\n    public interface Function {\n        double apply(double timeSinceStartInSeconds);\n    }\n\n    private final long start;\n    private volatile boolean running;\n\n    private Function func;\n    private double t0;\n    private double v0;\n    private double sum;\n\n    public Integrator(Function func) {\n        this.start = System.nanoTime();\n        setFunc(func);\n        new Thread(this::integrate).start();\n    }\n\n    public void setFunc(Function func) {\n        this.func = func;\n        v0 = func.apply(0.0);\n        t0 = 0;\n    }\n\n    public double getOutput() {\n        return sum;\n    }\n\n    public void stop() {\n        running = false;\n    }\n\n    private void integrate() {\n        running = true;\n        while (running) {\n            try {\n                Thread.sleep(1);\n                update();\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n\n    private void update() {\n        double t1 = (System.nanoTime() - start) / 1.0e9;\n        double v1 = func.apply(t1);\n        double rect = (t1 - t0) * (v0 + v1) / 2;\n        this.sum += rect;\n        t0 = t1;\n        v0 = v1;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Integrator integrator = new Integrator(t -> Math.sin(Math.PI * t));\n        Thread.sleep(2000);\n\n        integrator.setFunc(t -> 0.0);\n        Thread.sleep(500);\n\n        integrator.stop();\n        System.out.println(integrator.getOutput());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class AksTest {\n    private static final long[] c = new long[64];\n\n    public static void main(String[] args) {\n        for (int n = 0; n < 10; n++) {\n            coeff(n);\n            show(n);\n        }\n\n        System.out.print(\"Primes:\");\n        for (int n = 1; n < c.length; n++)\n            if (isPrime(n))\n                System.out.printf(\" %d\", n);\n\n        System.out.println();\n    }\n\n    static void coeff(int n) {\n        c[0] = 1;\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\n            c[1 + i] = 1;\n            for (int j = i; j > 0; j--)\n                c[j] = c[j - 1] - c[j];\n        }\n    }\n\n    static boolean isPrime(int n) {\n        coeff(n);\n        c[0]++;\n        c[n]--;\n\n        int i = n;\n        while (i-- != 0 && c[i] % n == 0)\n            continue;\n        return i < 0;\n    }\n\n    static void show(int n) {\n        System.out.print(\"(x-1)^\" + n + \" =\");\n        for (int i = n; i >= 0; i--) {\n            System.out.print(\" + \" + c[i] + \"x^\" + i);\n        }\n        System.out.println();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Aligns fields into columns, separated by \"|\"\n */\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    /**\n     * Initialize columns aligner from lines in a single string\n     *\n     * @param s\n     *            lines in a single string. Empty string does form a column.\n     */\n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    /**\n     * Initialize columns aligner from lines in a list of strings\n     *\n     * @param lines\n     *            lines in a single string. Empty string does form a column.\n     */\n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    /**\n     * Left-align all columns\n     *\n     * @return Lines, terminated by \"\\n\" of columns, separated by \"|\"\n     */\n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    /**\n     * Right-align all columns\n     *\n     * @return Lines, terminated by \"\\n\" of columns, separated by \"|\"\n     */\n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    /**\n     * Center-align all columns\n     *\n     * @return Lines, terminated by \"\\n\" of columns, separated by \"|\"\n     */\n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.LongStream;\n\npublic class AmicablePairs {\n\n    public static void main(String[] args) {\n        int limit = 20_000;\n\n        Map<Long, Long> map = LongStream.rangeClosed(1, limit)\n                .parallel()\n                .boxed()\n                .collect(Collectors.toMap(Function.identity(), AmicablePairs::properDivsSum));\n\n        LongStream.rangeClosed(1, limit)\n                .forEach(n -> {\n                    long m = map.get(n);\n                    if (m > n && m <= limit && map.get(m) == n)\n                        System.out.printf(\"%s %s %n\", n, m);\n                });\n    }\n\n    public static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0).sum();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\");\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\n\npublic interface Anagram {\n  public static <AUTOCLOSEABLE extends AutoCloseable, OUTPUT> Supplier<OUTPUT> tryWithResources(Callable<AUTOCLOSEABLE> callable, Function<AUTOCLOSEABLE, Supplier<OUTPUT>> function, Supplier<OUTPUT> defaultSupplier) {\n    return () -> {\n      try (AUTOCLOSEABLE autoCloseable = callable.call()) {\n        return function.apply(autoCloseable).get();\n      } catch (Throwable throwable) {\n        return defaultSupplier.get();\n      }\n    };\n  }\n\n  public static <INPUT, OUTPUT> Function<INPUT, OUTPUT> function(Supplier<OUTPUT> supplier) {\n    return i -> supplier.get();\n  }\n\n  public static void main(String... args) {\n    Map<String, Collection<String>> anagrams = new ConcurrentSkipListMap<>();\n    int count = tryWithResources(\n      () -> new BufferedReader(\n        new InputStreamReader(\n          new URL(\n            \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n          ).openStream()\n        )\n      ),\n      reader -> () -> reader.lines()\n        .parallel()\n        .mapToInt(word -> {\n          char[] chars = word.toCharArray();\n          Arrays.parallelSort(chars);\n          String key = Arrays.toString(chars);\n          Collection<String> collection = anagrams.computeIfAbsent(\n            key, function(ArrayList::new)\n          );\n          collection.add(word);\n          return collection.size();\n        })\n        .max()\n        .orElse(0),\n      () -> 0\n    ).get();\n    anagrams.values().stream()\n      .filter(ana -> ana.size() >= count)\n      .forEach(System.out::println)\n    ;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class DerangedAnagrams {\n\n    public static void main(String[] args) throws IOException {\n        List<String> words = Files.readAllLines(new File(\"unixdict.txt\").toPath());\n        printLongestDerangedAnagram(words);\n    }\n\n    private static void printLongestDerangedAnagram(List<String> words) {\n        words.sort(Comparator.comparingInt(String::length).reversed().thenComparing(String::toString));\n\n        Map<String, ArrayList<String>> map = new HashMap<>();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = String.valueOf(chars);\n\n            List<String> anagrams = map.computeIfAbsent(key, k -> new ArrayList<>());\n            for (String anagram : anagrams) {\n                if (isDeranged(word, anagram)) {\n                    System.out.printf(\"%s %s%n\", anagram, word);\n                    return;\n                }\n            }\n            anagrams.add(word);\n        }\n        System.out.println(\"no result\");\n    }\n\n    private static boolean isDeranged(String word1, String word2) {\n        for (int i = 0; i < word1.length(); i++) {\n            if (word1.charAt(i) == word2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport javax.swing.*;\n\npublic class Pendulum extends JPanel implements Runnable {\n\n    private double angle = Math.PI / 2;\n    private int length;\n\n    public Pendulum(int length) {\n        this.length = length;\n        setDoubleBuffered(true);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.setColor(Color.BLACK);\n        int anchorX = getWidth() / 2, anchorY = getHeight() / 4;\n        int ballX = anchorX + (int) (Math.sin(angle) * length);\n        int ballY = anchorY + (int) (Math.cos(angle) * length);\n        g.drawLine(anchorX, anchorY, ballX, ballY);\n        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);\n        g.fillOval(ballX - 7, ballY - 7, 14, 14);\n    }\n\n    public void run() {\n        double angleAccel, angleVelocity = 0, dt = 0.1;\n        while (true) {\n            angleAccel = -9.81 / length * Math.sin(angle);\n            angleVelocity += angleAccel * dt;\n            angle += angleVelocity * dt;\n            repaint();\n            try { Thread.sleep(15); } catch (InterruptedException ex) {}\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(2 * length + 50, length / 2 * 3);\n    }\n\n    public static void main(String[] args) {\n        JFrame f = new JFrame(\"Pendulum\");\n        Pendulum p = new Pendulum(200);\n        f.add(p);\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.pack();\n        f.setVisible(true);\n        new Thread(p).start();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.WindowConstants;\n\npublic class Rotate {\n\n    private static class State {\n        private final String text = \"Hello World! \";\n        private int startIndex = 0;\n        private boolean rotateRight = true;\n    }\n\n    public static void main(String[] args) {\n        State state = new State();\n\n        JLabel label = new JLabel(state.text);\n        label.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent event) {\n                state.rotateRight = !state.rotateRight;\n            }\n        });\n\n        TimerTask task = new TimerTask() {\n            public void run() {\n                int delta = state.rotateRight ? 1 : -1;\n                state.startIndex = (state.startIndex + state.text.length() + delta) % state.text.length();\n                label.setText(rotate(state.text, state.startIndex));\n            }\n        };\n        Timer timer = new Timer(false);\n        timer.schedule(task, 0, 500);\n\n        JFrame rot = new JFrame();\n        rot.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        rot.add(label);\n        rot.pack();\n        rot.setLocationRelativeTo(null);\n        rot.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosed(WindowEvent e) {\n                timer.cancel();\n            }\n        });\n        rot.setVisible(true);\n    }\n\n    private static String rotate(String text, int startIdx) {\n        char[] rotated = new char[text.length()];\n        for (int i = 0; i < text.length(); i++) {\n            rotated[i] = text.charAt((i + startIdx) % text.length());\n        }\n        return String.valueOf(rotated);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public static long fib(int n) {\n    if (n < 0)\n        throw new IllegalArgumentException(\"n can not be a negative number\");\n\n    return new Object() {\n        private long fibInner(int n) {\n            return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));\n        }\n    }.fibInner(n);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.function.Function;\n\n@FunctionalInterface\ninterface SelfApplicable<OUTPUT> {\n    OUTPUT apply(SelfApplicable<OUTPUT> input);\n}\n\nclass Utils {\n    public static <INPUT, OUTPUT> SelfApplicable<Function<Function<Function<INPUT, OUTPUT>, Function<INPUT, OUTPUT>>, Function<INPUT, OUTPUT>>> y() {\n        return y -> f -> x -> f.apply(y.apply(y).apply(f)).apply(x);\n    }\n\n    public static <INPUT, OUTPUT> Function<Function<Function<INPUT, OUTPUT>, Function<INPUT, OUTPUT>>, Function<INPUT, OUTPUT>> fix() {\n        return Utils.<INPUT, OUTPUT>y().apply(Utils.<INPUT, OUTPUT>y());\n    }\n\n    public static long fib(int m) {\n        if (m < 0)\n            throw new IllegalArgumentException(\"n can not be a negative number\");\n\n        return Utils.<Integer, Long>fix().apply(\n                f -> n -> (n < 2) ? n : (f.apply(n - 1) + f.apply(n - 2))\n        ).apply(m);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.util.Objects.requireNonNull;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class RecordAppender {\n    static class Record {\n        private final String account;\n        private final String password;\n        private final int uid;\n        private final int gid;\n        private final List<String> gecos;\n        private final String directory;\n        private final String shell;\n\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\n            this.account = requireNonNull(account);\n            this.password = requireNonNull(password);\n            this.uid = uid;\n            this.gid = gid;\n            this.gecos = requireNonNull(gecos);\n            this.directory = requireNonNull(directory);\n            this.shell = requireNonNull(shell);\n        }\n\n        @Override\n        public String toString() {\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\",\", gecos) + ':' + directory + ':' + shell;\n        }\n\n        public static Record parse(String text) {\n            String[] tokens = text.split(\":\");\n            return new Record(\n                    tokens[0],\n                    tokens[1],\n                    Integer.parseInt(tokens[2]),\n                    Integer.parseInt(tokens[3]),\n                    Arrays.asList(tokens[4].split(\",\")),\n                    tokens[5],\n                    tokens[6]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<String> rawData = Arrays.asList(\n                \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n                \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\",\n                \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n        );\n\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\n\n        Path tmp = Paths.get(\"_rosetta\", \".passwd\");\n        Files.createDirectories(tmp.getParent());\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\n\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\n\n        try (Stream<String> lines = Files.lines(tmp)) {\n            lines.map(Record::parse).forEach(System.out::println);\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class ArrayCallback7 {\n\n    interface IntConsumer {\n        void run(int x);\n    }\n\n    interface IntToInt {\n        int run(int x);\n    }\n\n    static void forEach(int[] arr, IntConsumer consumer) {\n        for (int i : arr) {\n            consumer.run(i);\n        }\n    }\n\n    static void update(int[] arr, IntToInt mapper) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = mapper.run(arr[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n\n        update(numbers, new IntToInt() {\n            @Override\n            public int run(int x) {\n                return x * x;\n            }\n        });\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\n\npublic class ArrayCallback {\n\n    public static void main(String[] args) {\n        int[] myIntArray = {1, 2, 3, 4, 5};\n\n        int sum = Arrays.stream(myIntArray)\n                .map(x -> {\n                    int cube = x * x * x;\n                    System.out.println(cube);\n                    return cube;\n                })\n                .reduce(0, (left, right) -> left + right); // <-- could substitute .sum() for .reduce(...) here.\n        System.out.println(\"sum: \" + sum);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\n\nclass IntegerPower {\n    public static void main(String[] args) {\n        BigInteger power = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValueExact()).intValueExact());\n        String str = power.toString();\n        int len = str.length();\n        System.out.printf(\"5**4**3**2 = %s...%s and has %d digits%n\",\n                str.substring(0, 20), str.substring(len - 20), len);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        // FOIL of (a+bi)(c+di) with i*i = -1\n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        // 1/(a+bi) * (a-bi)/(a-bi) = 1/(a+bi) but it's more workable\n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); //just some numbers\n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "/*\n * Arithmetic-Geometric Mean of 1 & 1/sqrt(2)\n * Brendan Shaklovitz\n * 5/29/12\n */\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        // Get the 2 numbers from command line arguments\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        // The result of adding 'a' and 'b' (Note: integer addition is discouraged in print statements due to confusion with string concatenation)\n        int difference = a - b; // The result of subtracting 'b' from 'a'\n        int product = a * b;    // The result of multiplying 'a' and 'b'\n        int division = a / b;   // The result of dividing 'a' by 'b' (Note: 'division' does not contain the fractional result)\n        int remainder = a % b;  // The remainder of dividing 'a' by 'b'\n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   // truncates towards 0\n        System.out.println(\"remainder of a / b = \" + remainder);   // same sign as first operand\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class BigRationalFindPerfectNumbers {\n    public static void main(String[] args) {\n        int MAX_NUM = 1 << 19;\n        System.out.println(\"Searching for perfect numbers in the range [1, \" + (MAX_NUM - 1) + \"]\");\n\n        BigRational TWO = BigRational.valueOf(2);\n        for (int i = 1; i < MAX_NUM; i++) {\n            BigRational reciprocalSum = BigRational.ONE;\n            if (i > 1)\n                reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());\n            int maxDivisor = (int) Math.sqrt(i);\n            if (maxDivisor >= i)\n                maxDivisor--;\n\n            for (int divisor = 2; divisor <= maxDivisor; divisor++) {\n                if (i % divisor == 0) {\n                    reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());\n                    int dividend = i / divisor;\n                    if (divisor != dividend)\n                        reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());\n                }\n            }\n            if (reciprocalSum.equals(TWO))\n                System.out.println(String.valueOf(i) + \" is a perfect number\");\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public static Object[] concat(Object[] arr1, Object[] arr2) {\n    Object[] res = new Object[arr1.length + arr2.length];\n\n    System.arraycopy(arr1, 0, res, 0, arr1.length);\n    System.arraycopy(arr2, 0, res, arr1.length, arr2.length);\n\n    return res;\n}\n"
  },
  {
    "language": "Java",
    "code": "int[] array = new int[10]; //optionally, replace \"new int[10]\" with a braced list of ints like \"{1, 2, 3}\"\narray[0] = 42;\nSystem.out.println(array[3]);\n"
  },
  {
    "language": "Java",
    "code": "List<Integer> list = new ArrayList<Integer>();   // optionally add an initial size as an argument\nlist.add(5);   // appends to the end of the list\nlist.add(1, 6);   // inserts an element at index 1\nSystem.out.println(list.get(0));\n"
  },
  {
    "language": "Java",
    "code": "public class Assertions {\n\n    public static void main(String[] args) {\n        int a = 13;\n\n        // ... some real code here ...\n\n        assert a == 42;\n        // Throws an AssertionError when a is not 42.\n\n        assert a == 42 : \"Error message\";\n        // Throws an AssertionError when a is not 42,\n        // with \"Error message\" for the message.\n        // The error message can be any non-void expression.\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "Map<String, Integer> map = new HashMap<String, Integer>();\nmap.put(\"foo\", 5);\nmap.put(\"bar\", 10);\nmap.put(\"baz\", 15);\nmap.put(\"foo\", 6);\n"
  },
  {
    "language": "Java",
    "code": "public static Map<String, Integer> map = new HashMap<String, Integer>(){{\n   put(\"foo\", 5);\n   put(\"bar\", 10);\n   put(\"baz\", 15);\n   put(\"foo\", 6);\n}};\n"
  },
  {
    "language": "Java",
    "code": "map.get(\"foo\"); // => 6\nmap.get(\"invalid\"); // => null\n"
  },
  {
    "language": "Java",
    "code": "for (String key: map.keySet())\n   System.out.println(key);\n"
  },
  {
    "language": "Java",
    "code": "for (int value: map.values())\n   System.out.println(value);\n"
  },
  {
    "language": "Java",
    "code": "for (Map.Entry<String, Integer> entry: map.entrySet())\n   System.out.println(entry.getKey() + \" => \" + entry.getValue());\n"
  },
  {
    "language": "Java",
    "code": "Map<String, Integer> map = new HashMap<String, Integer>();\nmap.put(\"hello\", 1);\nmap.put(\"world\", 2);\nmap.put(\"!\", 3);\n\n// iterating over key-value pairs:\nfor (Map.Entry<String, Integer> e : map.entrySet()) {\n    String key = e.getKey();\n    Integer value = e.getValue();\n    System.out.println(\"key = \" + key + \", value = \" + value);\n}\n\n// iterating over keys:\nfor (String key : map.keySet()) {\n    System.out.println(\"key = \" + key);\n}\n\n// iterating over values:\nfor (Integer value : map.values()) {\n    System.out.println(\"value = \" + value);\n}\n"
  },
  {
    "language": "Java",
    "code": "Map<String, Integer> map = new HashMap<>();\nmap.put(\"hello\", 1);\nmap.put(\"world\", 2);\nmap.put(\"!\", 3);\n\n// iterating over key-value pairs:\nmap.forEach((k, v) -> {\n    System.out.printf(\"key = %s, value = %s%n\", k, v);\n});\n\n// iterating over keys:\nmap.keySet().forEach(k -> System.out.printf(\"key = %s%n\", k));\n\n// iterating over values:\nmap.values().forEach(v -> System.out.printf(\"value = %s%n\", v));\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class AtomicUpdates {\n\n    private static final int NUM_BUCKETS = 10;\n\n    public static class Buckets {\n        private final int[] data;\n\n        public Buckets(int[] data) {\n            this.data = data.clone();\n        }\n\n        public int getBucket(int index) {\n            synchronized (data) {\n                return data[index];\n            }\n        }\n\n        public int transfer(int srcIndex, int dstIndex, int amount) {\n            if (amount < 0)\n                throw new IllegalArgumentException(\"negative amount: \" + amount);\n            if (amount == 0)\n                return 0;\n\n            synchronized (data) {\n                if (data[srcIndex] - amount < 0)\n                    amount = data[srcIndex];\n                if (data[dstIndex] + amount < 0)\n                    amount = Integer.MAX_VALUE - data[dstIndex];\n                if (amount < 0)\n                    throw new IllegalStateException();\n                data[srcIndex] -= amount;\n                data[dstIndex] += amount;\n                return amount;\n            }\n        }\n\n        public int[] getBuckets() {\n            synchronized (data) {\n                return data.clone();\n            }\n        }\n    }\n\n    private static long getTotal(int[] values) {\n        long total = 0;\n        for (int value : values) {\n            total += value;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        int[] values = new int[NUM_BUCKETS];\n        for (int i = 0; i < values.length; i++)\n            values[i] = rnd.nextInt() & Integer.MAX_VALUE;\n        System.out.println(\"Initial Array: \" + getTotal(values) + \" \" + Arrays.toString(values));\n\n        Buckets buckets = new Buckets(values);\n        new Thread(() -> equalize(buckets), \"equalizer\").start();\n        new Thread(() -> transferRandomAmount(buckets), \"transferrer\").start();\n        new Thread(() -> print(buckets), \"printer\").start();\n    }\n\n    private static void transferRandomAmount(Buckets buckets) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n        while (true) {\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\n            int amount = rnd.nextInt() & Integer.MAX_VALUE;\n            buckets.transfer(srcIndex, dstIndex, amount);\n        }\n    }\n\n    private static void equalize(Buckets buckets) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n        while (true) {\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\n            int amount = (buckets.getBucket(srcIndex) - buckets.getBucket(dstIndex)) / 2;\n            if (amount >= 0)\n                buckets.transfer(srcIndex, dstIndex, amount);\n        }\n    }\n\n    private static void print(Buckets buckets) {\n        while (true) {\n            long nextPrintTime = System.currentTimeMillis() + 3000;\n            long now;\n            while ((now = System.currentTimeMillis()) < nextPrintTime) {\n                try {\n                    Thread.sleep(nextPrintTime - now);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n\n            int[] bucketValues = buckets.getBuckets();\n            System.out.println(\"Current values: \" + getTotal(bucketValues) + \" \" + Arrays.toString(bucketValues));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class AverageLoopLength {\n\n    private static final int N = 100000;\n\n    //analytical(n) = sum_(i=1)^n (n!/(n-i)!/n**i)\n    private static double analytical(int n) {\n        double[] factorial = new double[n + 1];\n        double[] powers = new double[n + 1];\n        powers[0] = 1.0;\n        factorial[0] = 1.0;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n            powers[i] = powers[i - 1] * n;\n        }\n        double sum = 0;\n        //memoized factorial and powers\n        for (int i = 1; i <= n; i++) {\n            sum += factorial[n] / factorial[n - i] / powers[i];\n        }\n        return sum;\n    }\n\n    private static double average(int n) {\n        Random rnd = new Random();\n        double sum = 0.0;\n        for (int a = 0; a < N; a++) {\n            int[] random = new int[n];\n            for (int i = 0; i < n; i++) {\n                random[i] = rnd.nextInt(n);\n            }\n            Set<Integer> seen = new HashSet<>(n);\n            int current = 0;\n            int length = 0;\n            while (seen.add(current)) {\n                length++;\n                current = random[current];\n            }\n            sum += length;\n        }\n        return sum / N;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\" N    average    analytical    (error)\");\n        System.out.println(\"===  =========  ============  =========\");\n        for (int i = 1; i <= 20; i++) {\n            double avg = average(i);\n            double ana = analytical(i);\n            System.out.println(String.format(\"%3d  %9.4f  %12.4f  (%6.2f%%)\", i, avg, ana, ((ana - avg) / ana * 100)));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class MeanTimeOfDay {\n\n    static double meanAngle(double[] angles) {\n        int len = angles.length;\n        double sinSum = 0.0;\n        for (int i = 0; i < len; i++) {\n            sinSum += Math.sin(angles[i] * Math.PI / 180.0);\n        }\n\n        double cosSum = 0.0;\n        for (int i = 0; i < len; i++) {\n            cosSum += Math.cos(angles[i] * Math.PI / 180.0);\n        }\n\n        return Math.atan2(sinSum / len, cosSum / len) * 180.0 / Math.PI;\n    }\n\n    /* time string assumed to be in format \"hh:mm:ss\" */\n    static int timeToSecs(String t) {\n        int hours = Integer.parseInt(t.substring(0, 2));\n        int mins  = Integer.parseInt(t.substring(3, 5));\n        int secs  = Integer.parseInt(t.substring(6, 8));\n        return 3600 * hours + 60 * mins + secs;\n    }\n\n    /* 1 second of time = 360/(24 * 3600) = 1/240th degree */\n    static double timeToDegrees(String t) {\n        return timeToSecs(t) / 240.0;\n    }\n\n    static String degreesToTime(double d) {\n        if (d < 0.0) d += 360.0;\n        int secs  = (int)(d * 240.0);\n        int hours = secs / 3600;\n        int mins  = secs % 3600;\n        secs = mins % 60;\n        mins /= 60;\n        return String.format(\"%2d:%2d:%2d\", hours, mins, secs);\n    }\n\n    public static void main(String[] args) {\n        String[] tm = {\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"};\n        double[] angles = new double[4];\n        for (int i = 0; i < 4; i++) angles[i] = timeToDegrees(tm[i]);\n        double mean = meanAngle(angles);\n        System.out.println(\"Average time is : \" + degreesToTime(mean));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// Note: this function modifies the input list\npublic static double median(List<Double> list) {\n    Collections.sort(list);\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\n}\n"
  },
  {
    "language": "Java",
    "code": "public static double median2(List<Double> list) {\n    PriorityQueue<Double> pq = new PriorityQueue<Double>(list);\n    int n = list.size();\n    for (int i = 0; i < (n - 1) / 2; i++)\n        pq.poll(); // discard first half\n    if (n % 2 != 0) // odd length\n        return pq.poll();\n    else\n        return (pq.poll() + pq.poll()) / 2.0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Mode {\n    public static <T> List<T> mode(List<? extends T> coll) {\n        Map<T, Integer> seen = new HashMap<T, Integer>();\n        int max = 0;\n        List<T> maxElems = new ArrayList<T>();\n        for (T value : coll) {\n            if (seen.containsKey(value))\n                seen.put(value, seen.get(value) + 1);\n            else\n                seen.put(value, 1);\n            if (seen.get(value) > max) {\n                max = seen.get(value);\n                maxElems.clear();\n                maxElems.add(value);\n            } else if (seen.get(value) == max) {\n                maxElems.add(value);\n            }\n        }\n        return maxElems;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); // prints [6]\n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); // prints [1, 4]\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var doors=[];\nfor(var i=0;i<100;i++)\n doors[i]=false;             //create doors\nfor(var i=1;i<=100;i++)\n for(var i2=i-1,g;i2<100;i2+=i)\n  doors[i2]=!doors[i2];      //toggle doors\nfor(var i=1;i<=100;i++)      //read doors\n console.log(\"Door %d is %s\",i,doors[i-1]?\"open\":\"closed\")\n"
  },
  {
    "language": "JavaScript",
    "code": "// Array comprehension style\n[ for (i of Array.apply(null, { length: 100 })) i ].forEach((_, i) => {\n  var door = i + 1\n  var sqrt = Math.sqrt(door);\n\n  if (sqrt === (sqrt | 0)) {\n    console.log(\"Door %d is open\", door);\n  }\n});\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n\n\n    // ONLY PERFECT SQUARES HAVE AN ODD NUMBER OF INTEGER FACTORS\n    // (Leaving the door open at the end of the process)\n\n    return perfectSquaresUpTo(n);\n\n\n    // perfectSquaresUpTo :: Int -> [Int]\n    function perfectSquaresUpTo(n) {\n        return range(1, Math.floor(Math.sqrt(n)))\n            .map(x => x * x);\n    }\n\n\n    // GENERIC\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, step) {\n        let d = (step || 1) * (n >= m ? 1 : -1);\n\n        return Array.from({\n            length: Math.floor((n - m) / d) + 1\n        }, (_, i) => m + (i * d));\n    }\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n    'use strict';\n\n\n    // finalDoors :: Int -> [(Int, Bool)]\n    function finalDoors(n) {\n        var lstRange = range(1, n);\n\n        return lstRange\n            .reduce(function (a, _, k) {\n                var m = k + 1;\n\n                return a.map(function (x, i) {\n                    var j = i + 1;\n\n                    return [j, j % m ? x[1] : !x[1]];\n                });\n            }, zip(\n                lstRange,\n                replicate(n, false)\n            ));\n    };\n\n\n\n    // GENERIC FUNCTIONS\n\n    // zip :: [a] -> [b] -> [(a,b)]\n    function zip(xs, ys) {\n        return xs.length === ys.length ? (\n            xs.map(function (x, i) {\n                return [x, ys[i]];\n            })\n        ) : undefined;\n    }\n\n    // replicate :: Int -> a -> [a]\n    function replicate(n, a) {\n        var v = [a],\n            o = [];\n\n        if (n < 1) return o;\n        while (n > 1) {\n            if (n & 1) o = o.concat(v);\n            n >>= 1;\n            v = v.concat(v);\n        }\n        return o.concat(v);\n    }\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, delta) {\n        var d = delta || 1,\n            blnUp = n > m,\n            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,\n            a = Array(lng),\n            i = lng;\n\n        if (blnUp)\n            while (i--) a[i] = (d * i) + m;\n        else\n            while (i--) a[i] = m - (d * i);\n\n        return a;\n    }\n\n\n    return finalDoors(n)\n        .filter(function (tuple) {\n            return tuple[1];\n        })\n        .map(function (tuple) {\n            return {\n                door: tuple[0],\n                open: tuple[1]\n            };\n        });\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "[{\"door\":1, \"open\":true}, {\"door\":4, \"open\":true}, {\"door\":9, \"open\":true}, {\"door\":16, \"open\":true}, {\"door\":25, \"open\":true}, {\"door\":36, \"open\":true}, {\"door\":49, \"open\":true}, {\"door\":64, \"open\":true}, {\"door\":81, \"open\":true}, {\"door\":100, \"open\":true}]\n"
  },
  {
    "language": "JavaScript",
    "code": "for (var door = 1; door <= 100; door++) {\n  var sqrt = Math.sqrt(door);\n  if (sqrt === (sqrt | 0)) {\n    console.log(\"Door %d is open\", door);\n  }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "for(var door=1;i<10/*Math.sqrt(100)*/;i++){\n console.log(\"Door %d is open\",i*i);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n    'use strict';\n\n    return range(1, 100)\n        .filter(function (x) {\n            return integerFactors(x)\n                .length % 2;\n        });\n\n    function integerFactors(n) {\n        var rRoot = Math.sqrt(n),\n            intRoot = Math.floor(rRoot),\n\n            lows = range(1, intRoot)\n            .filter(function (x) {\n                return (n % x) === 0;\n            });\n\n        // for perfect squares, we can drop the head of the 'highs' list\n        return lows.concat(lows.map(function (x) {\n                return n / x;\n            })\n            .reverse()\n            .slice((rRoot === intRoot) | 0));\n    }\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, delta) {\n        var d = delta || 1,\n            blnUp = n > m,\n            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,\n            a = Array(lng),\n            i = lng;\n\n        if (blnUp)\n            while (i--) a[i] = (d * i) + m;\n        else\n            while (i--) a[i] = m - (d * i);\n\n        return a;\n    }\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n    'use strict';\n\n    return perfectSquaresUpTo(100);\n\n    function perfectSquaresUpTo(n) {\n        return range(1, Math.floor(Math.sqrt(n)))\n            .map(function (x) {\n                return x * x;\n            });\n    }\n\n    // GENERIC\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, delta) {\n        var d = delta || 1,\n            blnUp = n > m,\n            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,\n            a = Array(lng),\n            i = lng;\n\n        if (blnUp)\n            while (i--) a[i] = (d * i) + m;\n        else\n            while (i--) a[i] = m - (d * i);\n        return a;\n    }\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n"
  },
  {
    "language": "JavaScript",
    "code": "Array.apply(null, { length: 100 })\n  .map((v, i) => i + 1)\n    .forEach(door => {\n      var sqrt = Math.sqrt(door);\n\n      if (sqrt === (sqrt | 0)) {\n        console.log(\"Door %d is open\", door);\n      }\n    });\n"
  },
  {
    "language": "JavaScript",
    "code": "var ar=[],order=[0,1,2],op=[],val=[];\nvar NOVAL=9999,oper=\"+-*/\",out;\n\nfunction rnd(n){return Math.floor(Math.random()*n)}\n\nfunction say(s){\n try{document.write(s+\"<br>\")}\n catch(e){WScript.Echo(s)}\n}\n\nfunction getvalue(x,dir){\n var r=NOVAL;\n if(dir>0)++x;\n while(1){\n  if(val[x]!=NOVAL){\n   r=val[x];\n   val[x]=NOVAL;\n   break;\n  }\n  x+=dir;\n }\n return r*1;\n}\n\nfunction calc(){\n var c=0,l,r,x;\n val=ar.join('/').split('/');\n while(c<3){\n  x=order[c];\n  l=getvalue(x,-1);\n  r=getvalue(x,1);\n  switch(op[x]){\n   case 0:val[x]=l+r;break;\n   case 1:val[x]=l-r;break;\n   case 2:val[x]=l*r;break;\n   case 3:\n   if(!r||l%r)return 0;\n   val[x]=l/r;\n  }\n  ++c;\n }\n return getvalue(-1,1);\n}\n\nfunction shuffle(s,n){\n var x=n,p=eval(s),r,t;\n while(x--){\n  r=rnd(n);\n  t=p[x];\n  p[x]=p[r];\n  p[r]=t;\n }\n}\n\nfunction parenth(n){\n while(n>0)--n,out+='(';\n while(n<0)++n,out+=')';\n}\n\nfunction getpriority(x){\n for(var z=3;z--;)if(order[z]==x)return 3-z;\n return 0;\n}\n\nfunction showsolution(){\n var x=0,p=0,lp=0,v=0;\n while(x<4){\n  if(x<3){\n   lp=p;\n   p=getpriority(x);\n   v=p-lp;\n   if(v>0)parenth(v);\n  }\n  out+=ar[x];\n  if(x<3){\n   if(v<0)parenth(v);\n   out+=oper.charAt(op[x]);\n  }\n  ++x;\n }\n parenth(-p);\n say(out);\n}\n\nfunction solve24(s){\n var z=4,r;\n while(z--)ar[z]=s.charCodeAt(z)-48;\n out=\"\";\n for(z=100000;z--;){\n  r=rnd(256);\n  op[0]=r&3;\n  op[1]=(r>>2)&3;\n  op[2]=(r>>4)&3;\n  shuffle(\"ar\",4);\n  shuffle(\"order\",3);\n  if(calc()!=24)continue;\n  showsolution();\n  break;\n }\n}\n\nsolve24(\"1234\");\nsolve24(\"6789\");\nsolve24(\"1127\");\n"
  },
  {
    "language": "JavaScript",
    "code": "function twentyfour(numbers, input) {\n    var invalidChars = /[^\\d\\+\\*\\/\\s-\\(\\)]/;\n\n    var validNums = function(str) {\n        // Create a duplicate of our input numbers, so that\n        // both lists will be sorted.\n        var mnums = numbers.slice();\n        mnums.sort();\n\n        // Sort after mapping to numbers, to make comparisons valid.\n        return str.replace(/[^\\d\\s]/g, \" \")\n            .trim()\n            .split(/\\s+/)\n            .map(function(n) { return parseInt(n, 10); })\n            .sort()\n            .every(function(v, i) { return v === mnums[i]; });\n    };\n\n    var validEval = function(input) {\n        try {\n            return eval(input);\n        } catch (e) {\n            return {error: e.toString()};\n        }\n    };\n\n    if (input.trim() === \"\") return \"You must enter a value.\";\n    if (input.match(invalidChars)) return \"Invalid chars used, try again. Use only:\\n + - * / ( )\";\n    if (!validNums(input)) return \"Wrong numbers used, try again.\";\n    var calc = validEval(input);\n    if (typeof calc !== 'number') return \"That is not a valid input; please try again.\";\n    if (calc !== 24) return \"Wrong answer: \" + String(calc) + \"; please try again.\";\n    return input + \" == 24.  Congratulations!\";\n};\n\n// I/O below.\n\nwhile (true) {\n    var numbers = [1, 2, 3, 4].map(function() {\n        return Math.floor(Math.random() * 8 + 1);\n    });\n\n    var input = prompt(\n        \"Your numbers are:\\n\" + numbers.join(\" \") +\n        \"\\nEnter expression. (use only + - * / and parens).\\n\", +\"'x' to exit.\", \"\");\n\n    if (input === 'x') {\n        break;\n    }\n    alert(twentyfour(numbers, input));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "(function () {\n    var cache = [\n        [1]\n    ];\n//this was never needed.\n   /* function PyRange(start, end, step) {\n        step = step || 1;\n        if (!end) {\n            end = start;\n            start = 0;\n        }\n        var arr = [];\n        for (var i = start; i < end; i += step) arr.push(i);\n        return arr;\n    }*/\n\n    function cumu(n) {\n        var /*ra = PyRange(cache.length, n + 1),*/ //Seems there is a better version for this\n            r, l, x, Aa, Mi;\n       // for (ll in ra) { too pythony\n       for (l=cache.length;l<n+1;l++) {\n            r = [0];\n//            l = ra[ll];\n//            ran = PyRange(1, l + 1);\n//            for (xx in ran) {\n            for(x=1;x<l+1;x++){\n//                x = ran[xx];\n                r.push(r[r.length - 1] + (Aa = cache[l - x < 0 ? cache.length - (l - x) : l - x])[(Mi = Math.min(x, l - x)) < 0 ? Aa.length - Mi : Mi]);\n            }\n            cache.push(r);\n        }\n        return cache[n];\n    }\n\n    function row(n) {\n        var r = cumu(n),\n//            rra = PyRange(n),\n            leArray = [],\n            i;\n//        for (ii in rra) {\n        for (i=0;i<n;i++) {\n//            i = rra[ii];\n            leArray.push(r[i + 1] - r[i]);\n        }\n        return leArray;\n    }\n\n    console.log(\"Rows:\");\n    for (iterator = 1; iterator < 12; iterator++) {\n        console.log(row(iterator));\n    }\n\n    console.log(\"Sums\")[23, 123, 1234, 12345].foreach(function (a) {\n        var s = cumu(a);\n        console.log(a, s[s.length - 1]);\n    });\n})()\n"
  },
  {
    "language": "JavaScript",
    "code": "var beer = 99;\nwhile (beer > 0) {\n  var verse = [\n    beer + \" bottles of beer on the wall,\",\n    beer + \" bottles of beer!\",\n    \"Take one down, pass it around\",\n    (beer - 1) + \" bottles of beer on the wall!\"\n  ].join(\"\\n\");\n\n  console.log(verse);\n\n  beer--;\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "let beer = 99;\nwhile (beer > 0) {\n  let verse = `${beer} bottles of beer on the wall,\n  ${beer} bottles of beer!\n  Take one down, pass it around\n  ${beer-1} bottles of beer on the wall`;\n\n  console.log(verse);\n  beer--;\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var bottles = 99;\nvar songTemplate  = \"{X} bottles of beer on the wall \\n\" +\n                    \"{X} bottles of beer \\n\"+\n                    \"Take one down, pass it around \\n\"+\n                    \"{X-1} bottles of beer on the wall \\n\";\n\nfunction song(x, txt) {\n  return txt.replace(/\\{X\\}/gi, x).replace(/\\{X-1\\}/gi, x-1) + (x > 1 ? song(x-1, txt) : \"\");\n}\n\nconsole.log(song(bottles, songTemplate));\n"
  },
  {
    "language": "JavaScript",
    "code": "// Line breaks are in HTML\nvar beer; while ((beer = typeof beer === \"undefined\" ? 99 : beer) > 0) document.write( beer + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer on the wall<br>\" + beer + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer<br>Take one down, pass it around<br>\" + (--beer) + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer on the wall<br>\" );\n"
  },
  {
    "language": "JavaScript",
    "code": "Array.from(Array(100).keys()).splice(1).reverse().forEach(n => console.log(`${n} bottle${n !== 1 ? 's' : ''} of beer on the wall\\n${n} bottle${n !== 1 ? 's' : ''} of beer\\nTake one down, pass it around\\n${n - 1} bottle${n - 1 !== 1 ? 's' : ''} of beer on the wall\\n\\n`));\n"
  },
  {
    "language": "JavaScript",
    "code": "function Bottles(count) {\n  this.count = count || 99;\n}\n\nBottles.prototype.take = function() {\n  var verse = [\n    this.count + \" bottles of beer on the wall,\",\n    this.count + \" bottles of beer!\",\n    \"Take one down, pass it around\",\n    (this.count - 1) + \" bottles of beer on the wall!\"\n  ].join(\"\\n\");\n\n  console.log(verse);\n\n  this.count--;\n};\n\nBottles.prototype.sing = function() {\n  while (this.count) {\n    this.take();\n  }\n};\n\nvar bar = new Bottles(99);\nbar.sing();\n"
  },
  {
    "language": "JavaScript",
    "code": "function bottleSong(n) {\n  if (!isFinite(Number(n)) || n == 0) n = 100;\n  var a  = '%% bottles of beer',\n      b  = ' on the wall',\n      c  = 'Take one down, pass it around',\n      r  = '<br>'\n      p  = document.createElement('p'),\n      s  = [],\n      re = /%%/g;\n\n  while(n) {\n    s.push((a+b+r+a+r+c+r).replace(re, n) + (a+b).replace(re, --n));\n  }\n  p.innerHTML = s.join(r+r);\n  document.body.appendChild(p);\n}\n\nwindow.onload = bottleSong;\n"
  },
  {
    "language": "JavaScript",
    "code": "<html>\n<body>\n<div id='input'></div>\n<div id='output'></div>\n<script type='text/javascript'>\nvar a = window.prompt('enter A number', '');\nvar b = window.prompt('enter B number', '');\ndocument.getElementById('input').innerHTML = a + ' ' + b;\n\nvar sum = Number(a) + Number(b);\ndocument.getElementById('output').innerHTML = sum;\n</script>\n</body>\n</html>\n"
  },
  {
    "language": "JavaScript",
    "code": "process.openStdin().on (\n    'data',\n    function (line) {\n        var xs = String(line).match(/^\\s*(\\d+)\\s+(\\d+)\\s*/)\n        console.log (\n            xs ? Number(xs[1]) + Number(xs[2]) : 'usage: <number> <number>'\n        )\n        process.exit()\n    }\n)\n"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.on(\"data\", buffer => {\n  console.log(\n    (buffer + \"\").trim().split(\" \").map(Number).reduce((a, v) => a + v, 0)\n  );\n});\n"
  },
  {
    "language": "JavaScript",
    "code": "var a = WScript.StdIn.ReadLine();\nvar b = WScript.StdIn.ReadLine();\nWSH.echo(a, \" + \" , b , \" = \" , Number(a)+Number(b));\n"
  },
  {
    "language": "JavaScript",
    "code": "var blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n\nfunction CheckWord(blocks, word) {\n   // Makes sure that word only contains letters.\n   if(word !== /([a-z]*)/i.exec(word)[1]) return false;\n   // Loops through each character to see if a block exists.\n   for(var i = 0; i < word.length; ++i)\n   {\n      // Gets the ith character.\n      var letter = word.charAt(i);\n      // Stores the length of the blocks to determine if a block was removed.\n      var length = blocks.length;\n      // The regexp gets constructed by eval to allow more browsers to use the function.\n      var reg = eval(\"/([a-z]\"+letter+\"|\"+letter+\"[a-z])/i\");\n      // This does the same as above, but some browsers do not support...\n      //var reg = new RegExp(\"([a-z]\"+letter+\"|\"+letter+\"[a-z])\", \"i\");\n      // Removes all occurrences of the match.\n      blocks = blocks.replace(reg, \"\");\n      // If the length did not change then a block did not exist.\n      if(blocks.length === length) return false;\n   }\n   // If every character has passed then return true.\n   return true;\n};\n\nvar words = [\n   \"A\",\n   \"BARK\",\n   \"BOOK\",\n   \"TREAT\",\n   \"COMMON\",\n   \"SQUAD\",\n   \"CONFUSE\"\n];\n\nfor(var i = 0;i<words.length;++i)\n   console.log(words[i] + \": \" + CheckWord(blocks, words[i]));\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (strWords) {\n\n    var strBlocks =\n        'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM',\n        blocks = strBlocks.split(' ');\n\n    function abc(lstBlocks, strWord) {\n        var lngChars = strWord.length;\n\n        if (!lngChars) return [];\n\n        var b = lstBlocks[0],\n            c = strWord[0];\n\n        return chain(lstBlocks, function (b) {\n            return (b.indexOf(c.toUpperCase()) !== -1) ? [\n                (b + ' ').concat(\n                    abc(removed(b, lstBlocks), strWord.slice(1)))\n            ] : [];\n        })\n    }\n\n    // Monadic bind (chain) for lists\n    function chain(xs, f) {\n        return [].concat.apply([], xs.map(f));\n    }\n\n    // a -> [a] -> [a]\n    function removed(x, xs) {\n        var h = xs.length ? xs[0] : null,\n            t = h ? xs.slice(1) : [];\n\n        return h ? (\n            h === x ? t : [h].concat(removed(x, t))\n        ) : [];\n    }\n\n    function solution(strWord) {\n        var strAttempt = abc(blocks, strWord)[0].split(',')[0];\n\n        // two chars per block plus one space -> 3\n        return strWord + ((strAttempt.length === strWord.length * 3) ?\n            ' -> ' + strAttempt : ': [no solution]');\n    }\n\n    return strWords.split(' ').map(solution).join('\\n');\n\n})('A bark BooK TReAT COMMON squAD conFUSE');\n"
  },
  {
    "language": "JavaScript",
    "code": "A -> NA\nbark -> BO NA RE XK\nBooK: [no solution]\nTReAT -> GT RE ER NA TG\nCOMMON: [no solution]\nsquAD -> FS DQ HU NA QD\nconFUSE -> CP BO NA FS HU FS RE\n"
  },
  {
    "language": "JavaScript",
    "code": "let characters = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\nlet blocks = characters.split(\" \").map(pair => pair.split(\"\"));\n\nfunction isWordPossible(word) {\n  var letters = [...word.toUpperCase()];\n  var length = letters.length;\n  var copy = new Set(blocks);\n\n  for (let letter of letters) {\n    for (let block of copy) {\n      let index = block.indexOf(letter);\n\n      if (index !== -1) {\n        length--;\n        copy.delete(block);\n        break;\n      }\n    }\n\n  }\n  return !length;\n}\n\n[\n  \"A\",\n  \"BARK\",\n  \"BOOK\",\n  \"TREAT\",\n  \"COMMON\",\n  \"SQUAD\",\n  \"CONFUSE\"\n].forEach(word => console.log(`${word}: ${isWordPossible(word)}`));\n"
  },
  {
    "language": "JavaScript",
    "code": "(() => {\n    'use strict';\n\n    // ABC BLOCKS -------------------------------------------------------------\n\n    // spellWith :: [(Char, Char)] -> [Char] -> [[(Char, Char)]]\n    const spellWith = (blocks, wordChars) =>\n        (isNull(wordChars)) ? [\n            []\n        ] :\n        (() => {\n            const [x, xs] = uncons(wordChars);\n            return concatMap(\n                b => elem(x, b) ? concatMap(\n                    bs => [cons(b, bs)],\n                    spellWith(\n                        deleteBy(\n                            (p, q) => (p[0] === q[0]) && (p[1] === q[1]),\n                            b, blocks\n                        ),\n                        xs\n                    )\n                ) : [],\n                blocks\n            );\n        })();\n\n    // GENERIC FUNCTIONS ------------------------------------------------------\n\n    // compose :: [(a -> a)] -> (a -> a)\n    const compose = fs => x => fs.reduceRight((a, f) => f(a), x);\n\n    // concatMap :: (a -> [b]) -> [a] -> [b]\n    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));\n\n    // cons :: a -> [a] -> [a]\n    const cons = (x, xs) => [x].concat(xs);\n\n    // curry :: Function -> Function\n    const curry = (f, ...args) => {\n        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :\n            function () {\n                return go(xs.concat([].slice.apply(arguments)));\n            };\n        return go([].slice.call(args, 1));\n    };\n\n    // deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\n    const deleteBy = (f, x, xs) =>\n        xs.length > 0 ? (\n            f(x, xs[0]) ? (\n                xs.slice(1)\n            ) : [xs[0]].concat(deleteBy(f, x, xs.slice(1)))\n        ) : [];\n\n    // elem :: Eq a => a -> [a] -> Bool\n    const elem = (x, xs) => xs.indexOf(x) !== -1;\n\n    // isNull :: [a] -> Bool\n    const isNull = xs => (xs instanceof Array) ? xs.length < 1 : undefined;\n\n    // map :: (a -> b) -> [a] -> [b]\n    const map = (f, xs) => xs.map(f);\n\n    // not :: Bool -> Bool\n    const not = b => !b;\n\n    // show :: a -> String\n    const show = x => JSON.stringify(x); //, null, 2);\n\n    // stringChars :: String -> [Char]\n    const stringChars = s => s.split('');\n\n    // toUpper :: Text -> Text\n    const toUpper = s => s.toUpperCase();\n\n    // uncons :: [a] -> Maybe (a, [a])\n    const uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined;\n\n    // unlines :: [String] -> String\n    const unlines = xs => xs.join('\\n');\n\n    // words :: String -> [String]\n    const words = s => s.split(/\\s+/);\n\n    // TEST -------------------------------------------------------------------\n    // blocks :: [(Char, Char)]\n    const blocks = words(\n        \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n    );\n\n    return unlines(map(\n        x => show([x, compose(\n            [not, isNull, curry(spellWith)(blocks), stringChars, toUpper]\n        )(x)]), [\"\", \"A\", \"BARK\", \"BoOK\", \"TrEAT\", \"COmMoN\", \"SQUAD\", \"conFUsE\"]\n    ));\n})();\n"
  },
  {
    "language": "JavaScript",
    "code": "for (var dpa=[1,0,0], n=2; n<=20000; n+=1) {\n    for (var ds=0, d=1, e=n/2+1; d<e; d+=1) if (n%d==0) ds+=d\n    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1\n}\ndocument.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )\n"
  },
  {
    "language": "JavaScript",
    "code": "for (var dpa=[1,0,0], n=2; n<=20000; n+=1) {\n    for (var ds=1, d=2, e=Math.sqrt(n); d<e; d+=1) if (n%d==0) ds+=d+n/d\n    if (n%e==0) ds+=e\n    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1\n}\ndocument.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )\n"
  },
  {
    "language": "JavaScript",
    "code": "function primes(t) {\n    var ps = {2:true, 3:true}\n    next: for (var n=5, i=2; n<=t; n+=i, i=6-i) {\n        var s = Math.sqrt( n )\n        for ( var p in ps ) {\n            if ( p > s ) break\n            if ( n % p ) continue\n            continue next\n        }\n        ps[n] = true\n    }\n    return ps\n}\n\nfunction factorize(f, t) {\n    var cs = {}, ps = primes(t)\n    for (var n=f; n<=t; n++) if (!ps[n]) cs[n] = factors(n)\n    return cs\n    function factors(n) {\n        for ( var p in ps ) if ( n % p == 0 ) break\n        var ts = {}\n        ts[p] = 1\n        if ( ps[n /= p] ) {\n            if ( !ts[n]++ ) ts[n]=1\n        }\n        else {\n            var fs = cs[n]\n            if ( !fs ) fs = cs[n] = factors(n)\n            for ( var e in fs ) ts[e] = fs[e] + (e==p)\n        }\n        return ts\n    }\n}\n\nfunction pContrib(p, e) {\n    for (var pc=1, n=1, i=1; i<=e; i+=1) pc+=n*=p;\n    return pc\n}\n\nfor (var dpa=[1,0,0], t=20000, cs=factorize(2,t), n=2; n<=t; n+=1) {\n    var ds=1, fs=cs[n]\n    if (fs) {\n        for (var p in fs) ds *= pContrib(p, fs[p])\n        ds -= n\n    }\n    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1\n}\ndocument.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )\n"
  },
  {
    "language": "JavaScript",
    "code": "(() => {\n    'use strict';\n\n    const\n    // divisors :: (Integral a) => a -> [a]\n        divisors = n => range(1, Math.floor(n / 2))\n            .filter(x => n % x === 0),\n\n        // classOf :: (Integral a) => a -> Ordering\n        classOf = n => compare(divisors(n)\n            .reduce((a, b) => a + b, 0), n),\n\n        classTypes = {\n            deficient: -1,\n            perfect: 0,\n            abundant: 1\n        };\n\n    // GENERIC FUNCTIONS\n    const\n    // compare :: Ord a => a -> a -> Ordering\n        compare = (a, b) =>\n            a < b ? -1 : (a > b ? 1 : 0),\n\n        // range :: Int -> Int -> [Int]\n        range = (m, n) =>\n            Array.from({\n                length: Math.floor(n - m) + 1\n            }, (_, i) => m + i);\n\n    // TEST\n\n    // classes :: [Ordering]\n    const classes = range(1, 20000)\n        .map(classOf);\n\n    return Object.keys(classTypes)\n        .map(k => k + \": \" + classes\n            .filter(x => x === classTypes[k])\n            .length.toString())\n        .join('\\n');\n})();\n"
  },
  {
    "language": "JavaScript",
    "code": "function accumulator(sum) {\n  return function(n) {\n    return sum += n;\n  }\n}\nvar x = accumulator(1);\nx(5);\nconsole.log(accumulator(3).toString() + '<br>');\nconsole.log(x(2.3));\n"
  },
  {
    "language": "JavaScript",
    "code": "let accumulator = sum => (n => sum += n);\nlet x = accumulator(1);\nconsole.log(x(5));\naccumulator(3);\nconsole.log(x(2.3));\n"
  },
  {
    "language": "JavaScript",
    "code": "function accumulator(sum) function(n) sum += n;\nvar x = accumulator(1);\nx(5);\nconsole.log(accumulator(3).toSource());\nconsole.log(x(2.3));\n"
  },
  {
    "language": "JavaScript",
    "code": "function ack(m, n) {\n return m === 0 ? n + 1 : ack(m - 1, n === 0  ? 1 : ack(m, n - 1));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function ack(M,N) {\n  for (; M > 0; M--) {\n    N = N === 0 ? 1 : ack(M,N-1);\n  }\n  return N+1;\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function stackermann(M, N) {\n  const stack = [];\n  for (;;) {\n    if (M === 0) {\n      N++;\n      if (stack.length === 0) return N;\n      const r = stack[stack.length-1];\n      if (r[1] === 1) stack.length--;\n      else r[1]--;\n      M = r[0];\n    } else if (N === 0) {\n      M--;\n      N = 1;\n    } else {\n      M--\n      stack.push([M, N]);\n      N = 1;\n    }\n  }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "#!/usr/bin/env nodejs\nfunction ack(M, N){\n\tconst next = new Float64Array(M + 1);\n\tconst goal = new Float64Array(M + 1).fill(1, 0, M);\n\tconst n = N + 1;\n\n\t// This serves as a sentinel value;\n\t// next[M] never equals goal[M] == -1,\n\t// so we don't need an extra check for\n\t// loop termination below.\n\tgoal[M] = -1;\n\n\tlet v;\n\tdo {\n\t\tv = next[0] + 1;\n\t\tlet m = 0;\n\t\twhile (next[m] === goal[m]) {\n\t\t\tgoal[m] = v;\n\t\t\tnext[m++]++;\n\t\t}\n\t\tnext[m]++;\n\t} while (next[M] !== n);\n\treturn v;\n}\nvar args = process.argv;\nconsole.log(ack(parseInt(args[2]), parseInt(args[3])));\n"
  },
  {
    "language": "JavaScript",
    "code": "(() => {\n    'use strict';\n\n    // ackermann :: Int -> Int -> Int\n    const ackermann = m => n => {\n        const go = (m, n) =>\n            0 === m ? (\n                succ(n)\n            ) : go(pred(m), 0 === n ? (\n                1\n            ) : go(m, pred(n)));\n        return go(m, n);\n    };\n\n    // TEST -----------------------------------------------\n    const main = () => console.log(JSON.stringify(\n        [0, 1, 2, 3].map(\n            flip(ackermann)(3)\n        )\n    ));\n\n\n    // GENERAL FUNCTIONS ----------------------------------\n\n    // flip :: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        x => y => f(y)(x);\n\n    // pred :: Enum a => a -> a\n    const pred = x => x - 1;\n\n    // succ :: Enum a => a -> a\n    const succ = x => 1 + x;\n\n\n    // MAIN ---\n    return main();\n})();\n"
  },
  {
    "language": "JavaScript",
    "code": "function Integrator(sampleIntervalMS) {\n    var inputF = function () { return 0.0 };\n    var sum = 0.0;\n\n    var t1 = new Date().getTime();\n    var input1 = inputF(t1 / 1000);\n\n    function update() {\n        var t2 = new Date().getTime();\n        var input2 = inputF(t2 / 1000);\n        var dt = (t2 - t1) / 1000;\n\n        sum += (input1 + input2) * dt / 2;\n\n        t1 = t2;\n        input1 = input2;\n    }\n\n    var updater = setInterval(update, sampleIntervalMS);\n\n    return ({\n        input: function (newF) { inputF = newF },\n        output: function () { return sum },\n        shutdown: function () { clearInterval(updater) },\n    });\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "<p><span id=\"a\">Test running...</span> <code id=\"b\">-</code></p>\n\n<script type=\"text/javascript\">\n    var f = 0.5;\n\n    var i = new Integrator(1);\n    var displayer = setInterval(function () { document.getElementById(\"b\").firstChild.data = i.output() }, 100)\n\n    setTimeout(function () {\n        i.input(function (t) { return Math.sin(2*Math.PI*f*t) }); // test step 1\n        setTimeout(function () { // test step 2\n            i.input(function (t) { return 0 }); // test step 3\n            setTimeout(function () { // test step 3\n                i.shutdown();\n                clearInterval(displayer);\n                document.getElementById(\"a\").firstChild.data = \"Done, should be about 0: \"\n            }, 500);\n        }, 2000);\n    }, 1)\n</script>\n"
  },
  {
    "language": "JavaScript",
    "code": "e = {}       // generic object\ne.foo = 1\ne[\"bar\"] = 2    // name specified at runtime\n"
  },
  {
    "language": "JavaScript",
    "code": "var i, p, pascal, primerow, primes, show, _i;\n\npascal = function() {\n  var a;\n  a = [];\n  return function() {\n    var b, i;\n    if (a.length === 0) {\n      return a = [1];\n    } else {\n      b = (function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          _results.push(a[i] + a[i + 1]);\n        }\n        return _results;\n      })();\n      return a = [1].concat(b).concat([1]);\n    }\n  };\n};\n\nshow = function(a) {\n  var degree, i, sgn, show_x, str, _i, _ref;\n  show_x = function(e) {\n    switch (e) {\n      case 0:\n        return \"\";\n      case 1:\n        return \"x\";\n      default:\n        return \"x^\" + e;\n    }\n  };\n  degree = a.length - 1;\n  str = \"(x - 1)^\" + degree + \" =\";\n  sgn = 1;\n  for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n    str += ' ' + (sgn > 0 ? \"+\" : \"-\") + ' ' + a[i] + show_x(degree - i);\n    sgn = -sgn;\n  }\n  return str;\n};\n\nprimerow = function(row) {\n  var degree;\n  degree = row.length - 1;\n  return row.slice(1, degree).every(function(x) {\n    return x % degree === 0;\n  });\n};\n\np = pascal();\n\nfor (i = _i = 0; _i <= 7; i = ++_i) {\n  console.log(show(p()));\n}\n\np = pascal();\n\np();\n\np();\n\nprimes = (function() {\n  var _j, _results;\n  _results = [];\n  for (i = _j = 1; _j <= 49; i = ++_j) {\n    if (primerow(p())) {\n      _results.push(i + 1);\n    }\n  }\n  return _results;\n})();\n\nconsole.log(\"\");\n\nconsole.log(\"The primes upto 50 are: \" + primes);\n"
  },
  {
    "language": "JavaScript",
    "code": "function pascal(n) {\n\tvar cs = []; if (n) while (n--) coef(); return coef\n\tfunction coef() {\n\t\tif (cs.length === 0) return cs = [1];\n\t\tfor (var t=[1,1], i=cs.length-1; i; i-=1) t.splice( 1, 0, cs[i-1]+cs[i] ); return cs = t\n\t}\n}\n\nfunction show(cs) {\n\tfor (var s='', sgn=true, i=0, deg=cs.length-1; i<=deg; sgn=!sgn, i+=1) {\n\t\ts += ' ' + (sgn ? '+' : '-') + cs[i] + (e => e==0 ? '' : e==1 ? 'x' : 'x<sup>' + e + '</sup>')(deg-i)\n\t}\n\treturn '(x-1)<sup>' + deg + '</sup> =' + s;\n}\n\nfunction isPrime(cs) {\n\tvar deg=cs.length-1; return cs.slice(1, deg).every( function(c) { return c % deg === 0 } )\n}\n\nvar coef=pascal(); for (var i=0; i<=7; i+=1) document.write(show(coef()), '<br>')\n\ndocument.write('<br>Primes: ');\nfor (var coef=pascal(2), n=2; n<=50; n+=1) if (isPrime(coef())) document.write(' ', n)\n"
  },
  {
    "language": "JavaScript",
    "code": "function coef(n) {\n \tfor (var c=[1], i=0; i<n; c[0]=-c[0], i+=1) {\n\t\tc[i+1]=1; for (var j=i; j; j-=1) c[j] = c[j-1]-c[j]\t\t\n\t}\n\treturn c\n}\n\nfunction show(cs)\t{\n\tvar s='', n=cs.length-1\n\tdo s += (cs[n]>0 ? ' +' : ' ') + cs[n] + (n==0 ? '' : n==1 ? 'x' :'x<sup>'+n+'</sup>'); while (n--)\n\treturn s\n}\n\nfunction isPrime(n) {\n\tvar cs=coef(n), i=n-1; while (i-- && cs[i]%n == 0);\n\treturn i < 1\n}\n\nfor (var n=0; n<=7; n++) document.write('(x-1)<sup>',n,'</sup> = ', show(coef(n)), '<br>')\n\ndocument.write('<br>Primes: ');\nfor (var n=2; n<=50; n++) if (isPrime(n)) document.write(' ', n)\n"
  },
  {
    "language": "JavaScript",
    "code": "var justification=\"center\",\ninput=[\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n\"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n\"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n\"column$are$separated$by$at$least$one$space.\",\n\"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n\"justified,$right$justified,$or$center$justified$within$its$column.\"],\nx,y,cols,max,cols=0,diff,left,right\n\nString.prototype.repeat=function(n){return new Array(1 + parseInt(n)).join(this);}\n\nfor(x=0;x<input.length;x++) {\n input[x]=input[x].split(\"$\");\n if(input[x].length>cols) cols=input[x].length;\n}\nfor(x=0;x<cols;x++) {\n max=0;\n for(y=0;y<input.length;y++) if(input[y][x]&&max<input[y][x].length) max=input[y][x].length;\n for(y=0;y<input.length;y++)\n  if(input[y][x]) {\n   diff=(max-input[y][x].length)/2;\n   left=\" \".repeat(Math.floor(diff));\n   right=\" \".repeat(Math.ceil(diff));\n   if(justification==\"left\") {right+=left;left=\"\"}\n   if(justification==\"right\") {left+=right;right=\"\"}\n   input[y][x]=left+input[y][x]+right;\n  }\n}\nfor(x=0;x<input.length;x++) input[x]=input[x].join(\" \");\ninput=input.join(\"\\n\");\ndocument.write(input);\n"
  },
  {
    "language": "JavaScript",
    "code": "//break up each string by '$'. The assumption is that the user wants the trailing $.\nvar data = [\n  \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n  \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n  \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n  \"column$are$separated$by$at$least$one$space.\",\n  \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n  \"justified,$right$justified,$or$center$justified$within$its$column.\"\n].map(function (str) { return str.split('$'); })\n\n//boilerplate: get longest array or string in array\nvar getLongest = function (arr) {\n  return arr.reduce(function (acc, item) { return acc.length > item.length ? acc : item; }, 0);\n};\n\n//boilerplate: this function would normally be in a library like underscore, lodash, or ramda\nvar zip = function (items, toInsert) {\n  toInsert = (toInsert === undefined) ? null : toInsert;\n  var longestItem = getLongest(items);\n  return longestItem.map(function (_unused, index) {\n    return items.map(function (item) {\n      return item[index] === undefined ? toInsert : item[index];\n    });\n  });\n};\n\n//here's the part that's not boilerplate\nvar makeColumns = function (formatting, data) {\n  var zipData = zip(data, '');\n  var makeSpaces = function (num) { return new Array(num + 1).join(' '); };\n  var formattedCols = zipData.map(function (column) {\n    var maxLen = getLongest(column).length;//find the maximum word length\n    if (formatting === 'left') {\n      return column.map(function (word) { return word + makeSpaces(maxLen - word.length); });\n    } else if (formatting === 'right') {\n      return column.map(function (word) { return makeSpaces(maxLen - word.length) + word; });\n    } else {\n      return column.map(function (word) {\n        var spaces = maxLen - word.length,\n            first = ~~(spaces / 2),\n            last = spaces - first;\n        return makeSpaces(first) + word + makeSpaces(last);\n      });\n    }\n  });\n\n  return zip(formattedCols).map(function (row) { return row.join(' '); }).join('\\n');\n};\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (strText) {\n    'use strict';\n\n    // [[a]] -> [[a]]\n    function transpose(lst) {\n        return lst[0].map(function (_, iCol) {\n            return lst.map(function (row) {\n                return row[iCol];\n            })\n        });\n    }\n\n    // (a -> b -> c) -> [a] -> [b] -> [c]\n    function zipWith(f, xs, ys) {\n        return xs.length === ys.length ? (\n            xs.map(function (x, i) {\n                return f(x, ys[i]);\n            })\n        ) : undefined;\n    }\n\n    // (a -> a -> Ordering) -> [a] -> a\n    function maximumBy(f, xs) {\n        return xs.reduce(function (a, x) {\n            return a === undefined ? x : (\n                f(x) > f(a) ? x : a\n            );\n        }, undefined)\n    }\n\n    // [String] -> String\n    function widest(lst) {\n        return maximumBy(length, lst)\n            .length;\n    }\n\n    // [[a]] -> [[a]]\n    function fullRow(lst, n) {\n        return lst.concat(Array.apply(null, Array(n - lst.length))\n            .map(function () {\n                return ''\n            }));\n    }\n\n    // String -> Int -> String\n    function nreps(s, n) {\n        var o = '';\n        if (n < 1) return o;\n        while (n > 1) {\n            if (n & 1) o += s;\n            n >>= 1;\n            s += s;\n        }\n        return o + s;\n    }\n\n    // [String] -> String\n    function unwords(xs) {\n        return xs.join('  ');\n    }\n\n    // [String] -> String\n    function unlines(xs) {\n        return xs.join('\\n');\n    }\n\n    // [a] -> Int\n    function length(xs) {\n        return xs.length;\n    }\n\n    // -- Int -> [String] -> [[String]]\n    function padWords(n, lstWords, eAlign) {\n        return lstWords.map(function (w) {\n            var lngPad = n - w.length;\n\n            return (\n                    (eAlign === eCenter) ? (function () {\n                        var lngHalf = Math.floor(lngPad / 2);\n\n                        return [\n                            nreps(' ', lngHalf), w,\n                            nreps(' ', lngPad - lngHalf)\n                        ];\n                    })() : (eAlign === eLeft) ?\n                        ['', w, nreps(' ', lngPad)] :\n                        [nreps(' ', lngPad), w, '']\n                )\n                .join('');\n        });\n    }\n\n    // MAIN\n\n    var eLeft = -1,\n        eCenter = 0,\n        eRight = 1;\n\n    var lstRows = strText.split('\\n')\n        .map(function (x) {\n            return x.split('$');\n        }),\n\n        lngCols = widest(lstRows),\n        lstCols = transpose(lstRows.map(function (r) {\n            return fullRow(r, lngCols)\n        })),\n        lstColWidths = lstCols.map(widest);\n\n    // THREE PARAGRAPHS, WITH VARIOUS WORD COLUMN ALIGNMENTS:\n\n    return [eLeft, eRight, eCenter]\n        .map(function (eAlign) {\n            var fPad = function (n, lstWords) {\n                return padWords(n, lstWords, eAlign);\n            };\n\n            return transpose(\n                    zipWith(fPad, lstColWidths, lstCols)\n                )\n                .map(unwords);\n        })\n        .map(unlines)\n        .join('\\n\\n');\n\n})(\n    \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\\n\\\nare$delineated$by$a$single$'dollar'$character,$write$a$program\\n\\\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\n\\\ncolumn$are$separated$by$at$least$one$space.\\n\\\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\\n\\\njustified,$right$justified,$or$center$justified$within$its$column.\"\n);\n"
  },
  {
    "language": "JavaScript",
    "code": "function almostPrime (n, k) {\n    var divisor = 2, count = 0\n    while(count < k + 1 && n != 1) {\n        if (n % divisor == 0) {\n            n = n / divisor\n            count = count + 1\n        } else {\n            divisor++\n        }\n    }\n    return count == k\n}\n\nfor (var k = 1; k <= 5; k++) {\n    document.write(\"<br>k=\", k, \": \")\n    var count = 0, n = 0\n    while (count <= 10) {\n        n++\n        if (almostPrime(n, k)) {\n            document.write(n, \" \")\n            count++\n        }\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function ambRun(func) {\n    var choices = [];\n    var index;\n\n    function amb(values) {\n        if (values.length == 0) {\n            fail();\n        }\n        if (index == choices.length) {\n            choices.push({i: 0,\n                          count: values.length});\n        }\n        var choice = choices[index++];\n        return values[choice.i];\n    }\n\n    function fail() { throw fail; }\n\n    while (true) {\n        try {\n            index = 0;\n            return func(amb, fail);\n        } catch (e) {\n            if (e != fail) {\n                throw e;\n            }\n            var choice;\n            while ((choice = choices.pop()) && ++choice.i == choice.count) {}\n            if (choice == undefined) {\n                return undefined;\n            }\n            choices.push(choice);\n        }\n    }\n}\n\nambRun(function(amb, fail) {\n    function linked(s1, s2) {\n        return s1.slice(-1) == s2.slice(0, 1);\n    }\n\n    var w1 = amb([\"the\", \"that\", \"a\"]);\n    var w2 = amb([\"frog\", \"elephant\", \"thing\"]);\n    if (!linked(w1, w2)) fail();\n\n    var w3 = amb([\"walked\", \"treaded\", \"grows\"]);\n    if (!linked(w2, w3)) fail();\n\n    var w4 = amb([\"slowly\", \"quickly\"]);\n    if (!linked(w3, w4)) fail();\n\n    return [w1, w2, w3, w4].join(' ');\n});  // \"that thing grows slowly\"\n"
  },
  {
    "language": "JavaScript",
    "code": "(() => {\n    'use strict';\n\n    // amb :: [a] -> (a -> [b]) -> [b]\n    const amb = xs => f =>\n        xs.reduce((a, x) => a.concat(f(x)), []);\n\n    // when :: Bool -> [a] -> [a]\n    const when = p =>\n        xs => p ? (\n            xs\n        ) : [];\n\n\n    // TEST -----------------------------------------------\n    const main = () => {\n\n        // joins :: String -> String -> Bool\n        const joins = (a, b) =>\n            b[0] === last(a);\n\n        console.log(\n            amb(['the', 'that', 'a'])\n            (w1 => when(true)(\n\n                amb(['frog', 'elephant', 'thing'])\n                (w2 => when(joins(w1, w2))(\n\n                    amb(['walked', 'treaded', 'grows'])\n                    (w3 => when(joins(w2, w3))(\n\n                        amb(['slowly', 'quickly'])\n                        (w4 => when(joins(w3, w4))(\n\n                            unwords([w1, w2, w3, w4])\n\n                        ))\n                    ))\n                ))\n            ))\n        );\n    };\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // last :: [a] -> a\n    const last = xs =>\n        0 < xs.length ? xs.slice(-1)[0] : undefined;\n\n    // unwords :: [String] -> String\n    const unwords = xs => xs.join(' ');\n\n    // MAIN ---\n    return main();\n})();\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (max) {\n\n    // Proper divisors\n    function properDivisors(n) {\n        if (n < 2) return [];\n        else {\n            var rRoot = Math.sqrt(n),\n                intRoot = Math.floor(rRoot),\n\n                lows = range(1, intRoot).filter(function (x) {\n                    return (n % x) === 0;\n                });\n\n            return lows.concat(lows.slice(1).map(function (x) {\n                return n / x;\n            }).reverse().slice((rRoot === intRoot) | 0));\n        }\n    }\n\n    // [m..n]\n    function range(m, n) {\n        var a = Array(n - m + 1),\n            i = n + 1;\n        while (i--) a[i - 1] = i;\n        return a;\n    }\n\n    // Filter an array of proper divisor sums,\n    // reading the array index as a function of N (N-1)\n    // and the sum of proper divisors as a potential M\n\n    var pairs = range(1, max).map(function (x) {\n        return properDivisors(x).reduce(function (a, d) {\n            return a + d;\n        }, 0)\n    }).reduce(function (a, m, i, lst) {\n        var n = i + 1;\n\n        return (m > n) && lst[m - 1] === n ? a.concat([[n, m]]) : a;\n    }, []);\n\n    // [[a]] -> bool -> s -> s\n    function wikiTable(lstRows, blnHeaderRow, strStyle) {\n        return '{| class=\"wikitable\" ' + (\n            strStyle ? 'style=\"' + strStyle + '\"' : ''\n        ) + lstRows.map(function (lstRow, iRow) {\n            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');\n\n            return '\\n|-\\n' + strDelim + ' ' + lstRow.map(function (v) {\n                return typeof v === 'undefined' ? ' ' : v;\n            }).join(' ' + strDelim + strDelim + ' ');\n        }).join('') + '\\n|}';\n    }\n\n    return wikiTable(\n        [['N', 'M']].concat(pairs),\n        true,\n        'text-align:center'\n    ) + '\\n\\n' + JSON.stringify(pairs);\n\n})(20000);\n"
  },
  {
    "language": "JavaScript",
    "code": "[[220,284],[1184,1210],[2620,2924],[5020,5564],\n [6232,6368],[10744,10856],[12285,14595],[17296,18416]]\n"
  },
  {
    "language": "JavaScript",
    "code": "(() => {\n    'use strict';\n\n    // amicablePairsUpTo :: Int -> [(Int, Int)]\n    const amicablePairsUpTo = n => {\n        const sigma = compose(sum, properDivisors);\n        return enumFromTo(1)(n).flatMap(x => {\n            const y = sigma(x);\n            return x < y && x === sigma(y) ? ([\n                [x, y]\n            ]) : [];\n        });\n    };\n\n    // properDivisors :: Int -> [Int]\n    const properDivisors = n => {\n        const\n            rRoot = Math.sqrt(n),\n            intRoot = Math.floor(rRoot),\n            lows = enumFromTo(1)(intRoot)\n            .filter(x => 0 === (n % x));\n        return lows.concat(lows.map(x => n / x)\n            .reverse()\n            .slice((rRoot === intRoot) | 0, -1));\n    };\n\n\n    // TEST -----------------------------------------------\n\n    // main :: IO ()\n    const main = () =>\n        console.log(unlines(\n            amicablePairsUpTo(20000).map(JSON.stringify)\n        ));\n\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\n    const compose = (...fs) =>\n        x => fs.reduceRight((a, f) => f(a), x);\n\n\n    // enumFromTo :: Int -> Int -> [Int]\n    const enumFromTo = m => n =>\n        Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n\n    // sum :: [Num] -> Num\n    const sum = xs => xs.reduce((a, x) => a + x, 0);\n\n\n    // unlines :: [String] -> String\n    const unlines = xs => xs.join('\\n');\n\n\n    // MAIN ---\n    return main();\n})();\n"
  },
  {
    "language": "JavaScript",
    "code": "[[220, 284], [1184, 1210], [2620, 2924], [5020, 5564],\n[6232, 6368], [10744, 10856], [12285, 14595], [17296, 18416]]\n"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs');\nvar words = fs.readFileSync('unixdict.txt', 'UTF-8').split('\\n');\n\nvar i, item, max = 0,\n    anagrams = {};\n\nfor (i = 0; i < words.length; i += 1) {\n  var key = words[i].split('').sort().join('');\n  if (!anagrams.hasOwnProperty(key)) {//check if property exists on current obj only\n      anagrams[key] = [];\n  }\n  var count = anagrams[key].push(words[i]); //push returns new array length\n  max = Math.max(count, max);\n}\n\n//note, this returns all arrays that match the maximum length\nfor (item in anagrams) {\n  if (anagrams.hasOwnProperty(item)) {//check if property exists on current obj only\n    if (anagrams[item].length === max) {\n        console.log(anagrams[item].join(' '));\n    }\n  }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs');\nvar dictionary = fs.readFileSync('unixdict.txt', 'UTF-8').split('\\n');\n\n//group anagrams\nvar sortedDict = dictionary.reduce(function (acc, word) {\n  var sortedLetters = word.split('').sort().join('');\n  if (acc[sortedLetters] === undefined) { acc[sortedLetters] = []; }\n  acc[sortedLetters].push(word);\n  return acc;\n}, {});\n\n//sort list by frequency\nvar keysSortedByFrequency = Object.keys(sortedDict).sort(function (keyA, keyB) {\n  if (sortedDict[keyA].length < sortedDict[keyB].length) { return 1; }\n  if (sortedDict[keyA].length > sortedDict[keyB].length) { return -1; }\n  return 0;\n});\n\n//print first 10 anagrams by frequency\nkeysSortedByFrequency.slice(0, 10).forEach(function (key) {\n  console.log(sortedDict[key].join(' '));\n});\n"
  },
  {
    "language": "JavaScript",
    "code": "#!/usr/bin/env js\n\nfunction main() {\n    var wordList = read('unixdict.txt').split(/\\s+/);\n    var anagrams = findAnagrams(wordList);\n    var derangedAnagrams = findDerangedAnagrams(anagrams);\n    var longestPair = findLongestDerangedPair(derangedAnagrams);\n    print(longestPair.join(' '));\n\n}\n\nfunction findLongestDerangedPair(danas) {\n    var longestLen = danas[0][0].length;\n    var longestPair = danas[0];\n    for (var i in danas) {\n        if (danas[i][0].length > longestLen) {\n            longestLen = danas[i][0].length;\n            longestPair = danas[i];\n        }\n    }\n    return longestPair;\n}\n\nfunction findDerangedAnagrams(anagrams) {\n    var deranged = [];\n\n    function isDeranged(w1, w2) {\n        for (var c = 0; c < w1.length; c++) {\n            if (w1[c] == w2[c]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function findDeranged(anas) {\n        for (var a = 0; a < anas.length; a++) {\n            for (var b = a + 1; b < anas.length; b++) {\n                if (isDeranged(anas[a], anas[b])) {\n                    deranged.push([anas[a], anas[b]]);\n                }\n            }\n        }\n    }\n\n    for (var a in anagrams) {\n        var anas = anagrams[a];\n        findDeranged(anas);\n    }\n\n    return deranged;\n}\n\nfunction findAnagrams(wordList) {\n    var anagrams = {};\n\n    for (var wordNum in wordList) {\n        var word = wordList[wordNum];\n        var key = word.split('').sort().join('');\n        if (!(key in anagrams)) {\n            anagrams[key] = [];\n        }\n        anagrams[key].push(word);\n    }\n\n    for (var a in anagrams) {\n        if (anagrams[a].length < 2) {\n            delete(anagrams[a]);\n        }\n    }\n\n    return anagrams;\n}\n\nmain();\n"
  },
  {
    "language": "JavaScript",
    "code": "<html><head><title>Intoxication</title></head>\n<body><pre id='x'></pre>\n<script type=\"application/javascript\">\n\nfunction show(t) {\n\tvar l = document.createTextNode(t + '\\n');\n\tdocument.getElementById('x').appendChild(l);\n}\n\n// get words; be ware of cross-site restrictions on XMLHttpRequest\nvar words = null;\nvar req = new XMLHttpRequest();\nreq.open('GET', 'file:///tmp/unixdict.txt', false);\nreq.send(null);\nwords = req.responseText.split('\\n');\n\nvar idx = {};\nfor (var i = 0; i < words.length; i++) {\n\tvar t = words[i].split('').sort().join('');\n\tif (idx[t]) idx[t].push(words[i]);\n\telse\t    idx[t] = [words[i]];\n}\n\nvar best = '';\nvar best_pair;\nfor (var i in idx) {\n\tif (i.length <= best.length) continue;\n\tif (idx[i].length == 1) continue;\n\n\tvar a = idx[i], got = null;\n\tfor (var j = 0, l1 = a[j]; j < a.length && !got; j++) {\n\t\tfor (var k = j + 1, l2 = a[k]; k < a.length && !got; k++)\n\t\t\tfor (var m = 0; m < l1.length || !(got = [l2]); m++)\n\t\t\t\tif (l1[m] == l2[m]) break;\n\t\tif (got) got.push(l1);\n\t}\n\n\tif (got) {\n\t\tbest_pair = got;\n\t\tbest = got[0];\n\t}\n}\n\nshow(best_pair);\n</script></body></html>\n"
  },
  {
    "language": "JavaScript",
    "code": "<html><head>\n  <title>Pendulum</title>\n</head><body style=\"background: gray;\">\n\n<canvas id=\"canvas\" width=\"600\" height=\"600\">\n  <p>Sorry, your browser does not support the &lt;canvas&gt; used to display the pendulum animation.</p>\n</canvas>\n<script>\n  function PendulumSim(length_m, gravity_mps2, initialAngle_rad, timestep_ms, callback) {\n    var velocity = 0;\n    var angle = initialAngle_rad;\n    var k = -gravity_mps2/length_m;\n    var timestep_s = timestep_ms / 1000;\n    return setInterval(function () {\n      var acceleration = k * Math.sin(angle);\n      velocity += acceleration * timestep_s;\n      angle    += velocity     * timestep_s;\n      callback(angle);\n    }, timestep_ms);\n  }\n\n  var canvas = document.getElementById('canvas');\n  var context = canvas.getContext('2d');\n  var prev=0;\n  var sim = PendulumSim(1, 9.80665, Math.PI*99/100, 10, function (angle) {\n    var rPend = Math.min(canvas.width, canvas.height) * 0.47;\n    var rBall = Math.min(canvas.width, canvas.height) * 0.02;\n    var rBar = Math.min(canvas.width, canvas.height) * 0.005;\n    var ballX = Math.sin(angle) * rPend;\n    var ballY = Math.cos(angle) * rPend;\n\n    context.fillStyle = \"rgba(255,255,255,0.51)\";\n    context.globalCompositeOperation = \"destination-out\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n\n    context.fillStyle = \"yellow\";\n    context.strokeStyle = \"rgba(0,0,0,\"+Math.max(0,1-Math.abs(prev-angle)*10)+\")\";\n    context.globalCompositeOperation = \"source-over\";\n\n    context.save();\n      context.translate(canvas.width/2, canvas.height/2);\n      context.rotate(angle);\n\n      context.beginPath();\n      context.rect(-rBar, -rBar, rBar*2, rPend+rBar*2);\n      context.fill();\n      context.stroke();\n\n      context.beginPath();\n      context.arc(0, rPend, rBall, 0, Math.PI*2, false);\n      context.fill();\n      context.stroke();\n    context.restore();\n    prev=angle;\n  });\n</script>\n\n</body></html>\n"
  },
  {
    "language": "JavaScript",
    "code": "<html>\n\t<head>\n\t\t<title>Swinging Pendulum Simulation</title>\n\t</head>\n\t<body><center>\n\t\t<svg id=\"scene\" height=\"200\" width=\"300\">\n\t\t\t<line id=\"string\" x1=\"150\" y1=\"50\" x2=\"250\" y2=\"50\" stroke=\"brown\" stroke-width=\"4\" />\n\t\t\t<circle id=\"ball\" cx=\"250\" cy=\"50\" r=\"20\" fill=\"black\" />\n\t\t</svg>\n\t\t<br>\n\t\tInitial angle:<input id=\"in_angle\" type=\"number\" min=\"0\" max=\"180\" onchange=\"condReset()\"/>(degrees)\n\t\t<br>\n\t\t<button type=\"button\" onclick=\"startAnimation()\">Start</button>\n\t\t<button type=\"button\" onclick=\"stopAnimation()\">Stop</button>\n\t\t<button type=\"button\" onclick=\"reset()\">Reset</button>\n\t\t<script>\n\t\t\tin_angle.value = 0;\n\t\t\tvar cx = 150, cy = 50;\n\t\t\tvar radius = 100; // cm\n\t\t\tvar g = 9.81; // m/s^2\n\t\t\tvar angle = 0; // radians\n\t\t\tvar vel = 0; // m/s\n\t\t\tvar dx = 0.02; // s\n\t\t\tvar acc, vel, penx, peny;\n\t\t\tvar timerFunction = null;\n\t\t\tfunction stopAnimation() {\n\t\t\t\tif(timerFunction != null){\n\t\t\t\t\tclearInterval(timerFunction);\n\t\t\t\t\ttimerFunction = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction startAnimation() {\n\t\t\t\tif(!timerFunction) timerFunction = setInterval(swing, dx * 1000);\n\t\t\t}\n\t\t\tfunction swing(){\n\t\t\t\tacc = g * Math.cos(angle);\n\t\t\t\tvel += acc * dx;//Convert m/s/s to m/s\n\t\t\t\tangle += vel/(radius/100) * dx; //convert m/s into rad/s and then into rad\n\t\t\t\tsetPenPos();\n\t\t\t}\n\t\t\tfunction setPenPos(){\n\t\t\t\tpenx = cx + radius * Math.cos(angle);\n\t\t\t\tpeny = cy + radius * Math.sin(angle);\n\t\t\t\tscene.getElementById(\"string\").setAttribute(\"x2\", penx);\n\t\t\t\tscene.getElementById(\"string\").setAttribute(\"y2\", peny);\n\t\t\t\tscene.getElementById(\"ball\").setAttribute(\"cx\", penx);\n\t\t\t\tscene.getElementById(\"ball\").setAttribute(\"cy\", peny);\n\t\t\t}\n\t\t\tfunction reset(){\n\t\t\t\tvar val = parseInt(in_angle.value)*0.0174532925199;\n\t\t\t\tif (val) angle = val;\n\t\t\t\telse angle = 0;\n\t\t\t\tacc = 0;\n\t\t\t\tvel = 0;\n\t\t\t\tsetPenPos();\n\t\t\t}\n\t\t\tfunction condReset(){\n\t\t\t\tif (!timerFunction) reset();\n\t\t\t}\n\t\t</script>\n\t</body>\n</html>\n"
  },
  {
    "language": "JavaScript",
    "code": "<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"100\" height=\"40\">\n    <script type=\"text/javascript\">\n        function animate(element) {\n            var textNode = element.childNodes[0]; // assuming no other children\n            var text = textNode.data;\n            var reverse = false;\n\n            element.onclick = function () { reverse = !reverse; };\n\n            setInterval(function () {\n                if (reverse)\n                    text = text.substring(1) + text[0];\n                else\n                    text = text[text.length - 1] + text.substring(0, text.length - 1);\n                textNode.data = text;\n            }, 100);\n        }\n    </script>\n\n    <rect width=\"100\" height=\"40\" fill=\"yellow\"/>\n    <text x=\"2\" y=\"20\" onload=\"animate(this);\">Hello World! </text>\n</svg>\n"
  },
  {
    "language": "JavaScript",
    "code": "function fibo(n) {\n  if (n < 0) { throw \"Argument cannot be negative\"; }\n\n  return (function(n) {\n    return (n < 2) ? 1 : arguments.callee(n-1) + arguments.callee(n-2);\n  })(n);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function fibo(n) {\n  if (n < 0) { throw \"Argument cannot be negative\"; }\n\n  return (function fib(n) {\n    return (n < 2) ? 1 : fib(n-1) + fib(n-2);\n  })(n);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function map(a, func) {\n  var ret = [];\n  for (var i = 0; i < a.length; i++) {\n    ret[i] = func(a[i]);\n  }\n  return ret;\n}\n\nmap([1, 2, 3, 4, 5], function(v) { return v * v; });\n"
  },
  {
    "language": "JavaScript",
    "code": "[1, 2, 3, 4, 5].map(function(v) { return v * v; });\n"
  },
  {
    "language": "JavaScript",
    "code": "[1, 2, 3, 4, 5].map(v => v * v);\n"
  },
  {
    "language": "JavaScript",
    "code": "function Complex(r, i) {\n\tthis.r = r;\n\tthis.i = i;\n}\n\nComplex.add = function() {\n\tvar num = arguments[0];\n\t\n\tfor(var i = 1, ilim = arguments.length; i < ilim; i += 1){\n\t\tnum.r += arguments[i].r;\n\t\tnum.i += arguments[i].i;\n\t}\n\t\n\treturn num;\n}\n\nComplex.multiply = function() {\n\tvar num = arguments[0];\n\t\n\tfor(var i = 1, ilim = arguments.length; i < ilim; i += 1){\n\t\tnum.r = (num.r * arguments[i].r) - (num.i * arguments[i].i);\n\t\tnum.i = (num.i * arguments[i].r) - (num.r * arguments[i].i);\n\t}\n\t\n\treturn num;\n}\n\nComplex.negate = function (z) {\n\treturn new Complex(-1*z.r, -1*z.i);\n}\n\nComplex.invert = function(z) {\n\tvar denom = Math.pow(z.r,2) + Math.pow(z.i,2);\n\treturn new Complex(z.r/denom, -1*z.i/denom);\n}\n\nComplex.conjugate = function(z) {\n\treturn new Complex(z.r, -1*z.i);\n}\n\n// BONUSES!\n\n\nComplex.prototype.toString = function() {\n\treturn this.r === 0 && this.i === 0\n          ? \"0\"\n          : (this.r !== 0 ? this.r : \"\")\n          + ((this.r !== 0 || this.i < 0) && this.i !== 0\n              ? (this.i > 0 ? \"+\" : \"-\")\n              : \"\" ) + ( this.i !== 0 ? Math.abs(this.i) + \"i\" : \"\" );\n}\n\nComplex.prototype.getMod = function() {\n\treturn Math.sqrt( Math.pow(this.r,2) , Math.pow(this.i,2) )\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function evalArithmeticExp(s) {\n  s = s.replace(/\\s/g,'').replace(/^\\+/,'');\n  var rePara = /\\([^\\(\\)]*\\)/;\n  var exp = s.match(rePara);\n\n  while (exp = s.match(rePara)) {\n    s = s.replace(exp[0], evalExp(exp[0]));\n  }\n  return evalExp(s);\n\n  function evalExp(s) {\n    s = s.replace(/[\\(\\)]/g,'');\n    var reMD = /\\d+\\.?\\d*\\s*[\\*\\/]\\s*[+-]?\\d+\\.?\\d*/;\n    var reM = /\\*/;\n    var reAS = /-?\\d+\\.?\\d*\\s*[\\+-]\\s*[+-]?\\d+\\.?\\d*/;\n    var reA  = /\\d\\+/;\n    var exp;\n\n    while (exp = s.match(reMD)) {\n      s = exp[0].match(reM)? s.replace(exp[0], multiply(exp[0])) : s.replace(exp[0], divide(exp[0]));\n    }\n\n    while (exp = s.match(reAS)) {\n      s = exp[0].match(reA)? s.replace(exp[0], add(exp[0])) : s.replace(exp[0], subtract(exp[0]));\n    }\n\n    return '' + s;\n\n    function multiply(s, b) {\n      b = s.split('*');\n      return b[0] * b[1];\n    }\n\n    function divide(s, b) {\n      b = s.split('/');\n      return b[0] / b[1];\n    }\n\n    function add(s, b) {\n      s = s.replace(/^\\+/,'').replace(/\\++/,'+');\n      b = s.split('+');\n      return Number(b[0]) + Number(b[1]);\n    }\n\n    function subtract(s, b) {\n      s = s.replace(/\\+-|-\\+/g,'-');\n\n      if (s.match(/--/)) {\n        return add(s.replace(/--/,'+'));\n      }\n      b = s.split('-');\n      return b.length == 3? -1 * b[1] - b[2] : b[0] - b[1];\n    }\n  }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function agm(a0, g0) {\n    var an = (a0 + g0) / 2,\n        gn = Math.sqrt(a0 * g0);\n    while (Math.abs(an - gn) > tolerance) {\n        an = (an + gn) / 2, gn = Math.sqrt(an * gn)\n    }\n    return an;\n}\n\nagm(1, 1 / Math.sqrt(2));\n"
  },
  {
    "language": "JavaScript",
    "code": "(() => {\n    'use strict';\n\n    // ARITHMETIC-GEOMETRIC MEAN\n\n    // agm :: Num a => a -> a -> a\n    let agm = (a, g) => {\n            let abs = Math.abs,\n                sqrt = Math.sqrt;\n\n            return until(\n                    m => abs(m.an - m.gn) < tolerance,\n                    m => {\n                        return {\n                            an: (m.an + m.gn) / 2,\n                            gn: sqrt(m.an * m.gn)\n                        };\n                    }, {\n                        an: (a + g) / 2,\n                        gn: sqrt(a * g)\n                    }\n                )\n                .an;\n        },\n\n        // GENERIC\n\n        // until :: (a -> Bool) -> (a -> a) -> a -> a\n        until = (p, f, x) => {\n            let v = x;\n            while (!p(v)) v = f(v);\n            return v;\n        };\n\n\n    // TEST\n\n    let tolerance = 0.000001;\n\n\n    return agm(1, 1 / Math.sqrt(2));\n\n})();\n"
  },
  {
    "language": "Julia",
    "code": "doors = falses(100)\nfor a in 1:100, b in a:a:100\n    doors[b] = !doors[b]\nend\nfor a = 1:100\n    println(\"Door $a is \" * (doors[a] ? \"open.\" : \"closed.\"))\nend\n"
  },
  {
    "language": "Julia",
    "code": "for i in 1:10 println(\"Door $(i^2) is open.\") end\n"
  },
  {
    "language": "Julia",
    "code": "function solve24(nums)\n    length(nums) != 4 && error(\"Input must be a 4-element Array\")\n    syms = [+,-,*,/]\n    for x in syms, y in syms, z in syms\n        for i = 1:24\n            a,b,c,d = nthperm(nums,i)\n            if round(x(y(a,b),z(c,d)),5) == 24\n                return \"($a$y$b)$x($c$z$d)\"\n            elseif round(x(a,y(b,z(c,d))),5) == 24\n                return \"$a$x($b$y($c$z$d))\"\n            elseif round(x(y(z(c,d),b),a),5) == 24\n                return \"(($c$z$d)$y$b)$x$a\"\n            elseif round(x(y(b,z(c,d)),a),5) == 24\n                return \"($b$y($c$z$d))$x$a\"\n            end\n        end\n    end\n    return \"0\"\nend\n"
  },
  {
    "language": "Julia",
    "code": "validexpr(ex::Expr) = ex.head == :call && ex.args[1] in [:*,:/,:+,:-] && all(validexpr, ex.args[2:end])\nvalidexpr(ex::Int) = true\nvalidexpr(ex::Any) = false\nfindnumbers(ex::Number) = Int[ex]\nfindnumbers(ex::Expr) = vcat(map(findnumbers, ex.args)...)\nfindnumbers(ex::Any) = Int[]\nfunction twentyfour()\n    digits = sort!(rand(1:9, 4))\n    while true\n        print(\"enter expression using $digits => \")\n        ex = parse(readline())\n        try\n            validexpr(ex) || error(\"only *, /, +, - of integers is allowed\")\n            nums = sort!(findnumbers(ex))\n            nums == digits || error(\"expression $ex used numbers $nums != $digits\")\n            val = eval(ex)\n            val == 24 || error(\"expression $ex evaluated to $val, not 24\")\n            println(\"you won!\")\n            return\n        catch e\n            if isa(e, ErrorException)\n                println(\"incorrect: \", e.msg)\n            else\n                rethrow()\n            end\n        end\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Combinatorics, StatsBase\n\nnamesofline(n) = counts([x[1] for x in integer_partitions(n)])\n\nfunction centerjustpyramid(n)\n    maxwidth = length(string(namesofline(n)))\n    for i in 1:n\n        s = string(namesofline(i))\n        println(\" \" ^ div(maxwidth - length(s), 2), s)\n    end\nend\n\ncenterjustpyramid(25)\n\nconst cachecountpartitions = Dict{BigInt,BigInt}()\nfunction countpartitions(n::BigInt)\n    if n < 0\n        0\n    elseif n < 2\n        1\n    elseif (np = get(cachecountpartitions, n, 0)) > 0\n        np\n    else\n        np = 0\n        sgn = 1\n        for k = 1:n\n            np += sgn * (countpartitions(n - (k*(3k-1)) >> 1) + countpartitions(n - (k*(3k+1)) >> 1))\n            sgn = -sgn\n        end\n        cachecountpartitions[n] = np\n    end\nend\n\nG(n) = countpartitions(BigInt(n))\n\nfor g in [23, 123, 1234, 12345]\n    @time println(\"\\nG($g) is $(G(g))\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "for i = 99:-1:1 print(\"\\n$i bottles of beer on the wall\\n$i bottles of beer\\nTake one down, pass it around\\n$(i-1) bottles of beer on the wall\\n\") end\n"
  },
  {
    "language": "Julia",
    "code": "bottles(n) = n==0 ? \"No more bottles\" :\n             n==1 ? \"1 bottle\" :\n             \"$n bottles\"\n\nfor n = 99:-1:1\n    println(\"\"\"\n        $(bottles(n)) of beer on the wall\n        $(bottles(n)) of beer\n        Take one down, pass it around\n        $(bottles(n-1)) of beer on the wall\n    \"\"\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "bottles(n) = \"$(n==0 ? \"No more\" : n) bottle$(n==1 ? \"\" : \"s\")\"\n"
  },
  {
    "language": "Julia",
    "code": "input = parse.(Int, split(readline(stdin)))\nprintln(stdout, sum(input))\n"
  },
  {
    "language": "Julia",
    "code": "julia> println(parse(Int, readuntil(stdin, ' ')) + parse(Int, readuntil(stdin, '\\n')))\n1 2\n3\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nfunction abc(str::AbstractString, list)\n    isempty(str) && return true\n    for i in eachindex(list)\n        str[end] in list[i] &&\n            any([abc(str[1:end-1], deleteat!(copy(list), i))]) &&\n            return true\n    end\n    return false\nend\n\nlet test = [\"A\", \"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"],\n    list = [\"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\n            \"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"]\n    for str in test\n        @printf(\"%-8s |  %s\\n\", str, abc(str, list))\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "abstract type \u00abname\u00bb end\nabstract type \u00abname\u00bb <: \u00absupertype\u00bb end\n"
  },
  {
    "language": "Julia",
    "code": "abstract type Number end\nabstract type Real          <: Number end\nabstract type FloatingPoint <: Real end\nabstract type Integer       <: Real end\nabstract type Signed        <: Integer end\nabstract type Unsigned      <: Integer end\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib(p::Int64, a::Int64)\n    n = one(p)\n    pcon = one(p)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum(n::Int64)\n    dsum = one(n)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "const L = 2*10^4\niclasslabel = [\"Deficient\", \"Perfect\", \"Abundant\"]\niclass = zeros(Int64, 3)\niclass[1] = one(Int64) #by convention 1 is deficient\n\nfor n in 2:L\n    if isprime(n)\n        iclass[1] += 1\n    else\n        iclass[sign(divisorsum(n)-n)+2] += 1\n    end\nend\n\nprintln(\"Classification of integers from 1 to \", L)\nfor i in 1:3\n    println(\"   \", iclasslabel[i], \", \", iclass[i])\nend\n"
  },
  {
    "language": "Julia",
    "code": "function accumulator(i)\n\tf(n) = i += n\n\treturn f\nend\n\nx = accumulator(1)\n@show x(5)\n\naccumulator(3)\n@show x(2.3)\n"
  },
  {
    "language": "Julia",
    "code": "function ack(m,n)\n    if m == 0\n        return n + 1\n    elseif n == 0\n        return ack(m-1,1)\n    else\n        return ack(m-1,ack(m,n-1))\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "ack2(m::Integer, n::Integer) = m == 0 ? n + 1 : n == 0 ? ack2(m - 1, 1) : ack2(m - 1, ack2(m, n - 1))\n"
  },
  {
    "language": "Julia",
    "code": "using Memoize\n@memoize ack3(m::Integer, n::Integer) = m == 0 ? n + 1 : n == 0 ? ack3(m - 1, 1) : ack3(m - 1, ack3(m, n - 1))\n"
  },
  {
    "language": "Julia",
    "code": "mutable struct Integrator\n    func::Function\n    runningsum::Float64\n    dt::Float64\n    running::Bool\n    function Integrator(f::Function, dt::Float64)\n        this = new()\n        this.func = f\n        this.runningsum = 0.0\n        this.dt = dt\n        this.running = false\n        return this\n    end\nend\n\nfunction run(integ::Integrator, lastval::Float64 = 0.0)\n    lasttime = time()\n    while integ.running\n        sleep(integ.dt)\n        newtime = time()\n        measuredinterval = newtime - lasttime\n        newval = integ.func(measuredinterval)\n        integ.runningsum += (lastval + newval) * measuredinterval / 2.0\n        lasttime = newtime\n        lastval = newval\n    end\nend\n\nstart!(integ::Integrator) = (integ.running = true; @async run(integ))\nstop!(integ) = (integ.running = false)\nf1(t) = sin(2\u03c0 * t)\nf2(t) = 0.0\n\nit = Integrator(f1, 0.00001)\nstart!(it)\nsleep(2.0)\nit.func = f2\nsleep(0.5)\nv2 = it.runningsum\nprintln(\"After 2.5 seconds, integrator value was $v2\")\n"
  },
  {
    "language": "Julia",
    "code": "{\"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    },\n    {\n      \"type\": \"mobile\",\n      \"number\": \"123 456-7890\"\n    }]}\n"
  },
  {
    "language": "Julia",
    "code": "mutable struct Contact\n    name::String\n    phonenumber::Dict{Any,Any}\nend\n\nperson = Contact(\"Jane Doe\", Dict())\nperson.phonenumber[\"home\"] = \"212 555-1234\"\n"
  },
  {
    "language": "Julia",
    "code": "julia> x = [1, 2, 3]\njulia> ptr = pointer_from_objref(x)\nPtr{Void} @0x000000010282e4a0\njulia> unsafe_pointer_to_objref(ptr)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n"
  },
  {
    "language": "Julia",
    "code": "julia> A = [1, 2.3, 4]\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 4.0\n\njulia> p = pointer(A)\nPtr{Float64} @0x0000000113f70d60\n\njulia> unsafe_load(p, 3)\n4.0\n\njulia> unsafe_store!(p, 3.14159, 3)\njulia> A\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 3.14149\n\njulia> pointer_to_array(p, (3,))\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 3.14149\n"
  },
  {
    "language": "Julia",
    "code": "julia>\njulia> q = convert(Ptr{Float64}, 0x0000000113f70d68)\nPtr{Float64} @0x0000000113f70d68\n\njulia> B = pointer_to_array(q, (2,))\n2-element Array{Float64,1}:\n 2.3\n 3.14149\n"
  },
  {
    "language": "Julia",
    "code": "function polycoefs(n::Int64)\n    pc = typeof(n)[]\n    if n < 0\n        return pc\n    end\n    sgn = one(n)\n    for k in n:-1:0\n        push!(pc, sgn*binomial(n, k))\n        sgn = -sgn\n    end\n    return pc\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nfunction stringpoly(n::Int64)\n    if n < 0\n        return \"\"\n    end\n    st = @sprintf \"(x - 1)^{%d} & = & \" n\n    for (i, c) in enumerate(polycoefs(n))\n        if i == 1\n            op = \"\"\n            ac = c\n        elseif c < 0\n            op = \"-\"\n            ac = abs(c)\n        else\n            op = \"+\"\n            ac = abs(c)\n        end\n        p = n + 1 - i\n        if p == 0\n            st *= @sprintf \" %s %d\\\\\\\\\" op ac\n        elseif ac == 1\n            st *= @sprintf \" %s x^{%d}\" op p\n        else\n            st *= @sprintf \" %s %dx^{%d}\" op ac p\n        end\n    end\n    return st\nend\n"
  },
  {
    "language": "Julia",
    "code": "function isaksprime(n::Int64)\n    if n < 2\n        return false\n    end\n    for c in polycoefs(n)[2:(end-1)]\n        if c%n != 0\n            return false\n        end\n    end\n    return true\nend\n"
  },
  {
    "language": "Julia",
    "code": "println(\"<math>\")\nprintln(\"\\\\begin{array}{lcl}\")\nfor i in 0:10\n    println(stringpoly(i))\nend\nprintln(\"\\\\end{array}\")\nprintln(\"</math>\\n\")\n\nL = 50\nprint(\"AKS primes less than \", L, \":  \")\nsep = \"\"\nfor i in 1:L\n    if isaksprime(i)\n        print(sep, i)\n        sep = \", \"\n    end\nend\nprintln()\n"
  },
  {
    "language": "Julia",
    "code": "txt = \"\"\"Given\\$a\\$txt\\$file\\$of\\$many\\$lines,\\$where\\$fields\\$within\\$a\\$line\\$\nare\\$delineated\\$by\\$a\\$single\\$'dollar'\\$character,\\$write\\$a\\$program\nthat\\$aligns\\$each\\$column\\$of\\$fields\\$by\\$ensuring\\$that\\$words\\$in\\$each\\$\ncolumn\\$are\\$separated\\$by\\$at\\$least\\$one\\$space.\nFurther,\\$allow\\$for\\$each\\$word\\$in\\$a\\$column\\$to\\$be\\$either\\$left\\$\njustified,\\$right\\$justified,\\$or\\$center\\$justified\\$within\\$its\\$column.\"\"\"\n\n# left/right/center justification of strings:\nljust(s, width) = s * \" \"^max(0, width - length(s))\nrjust(s, width) = \" \"^max(0, width - length(s)) * s\nfunction center(s, width)\n  pad = width - length(s)\n  if pad <= 0\n    return s\n  else\n    pad2 = div(pad, 2)\n    return \" \"^pad2 * s * \" \"^(pad - pad2)\n  end\nend\n\nparts = [split(rstrip(line, '$'), '$') for line in split(txt, '\\n')]\n\nmax_widths = zeros(Int, maximum(length, parts))\nfor line in parts\n  for (i, word) in enumerate(line)\n    max_widths[i] = max(max_widths[i], length(word))\n  end\nend\nmax_widths += 1 # separate cols by at least one space\n\nfor (label, justify) in ((\"Left\", ljust), (\"Right\",rjust), (\"Center\",center))\n  println(label, \" column-aligned output:\")\n  for line in parts\n    for (j, word) in enumerate(line)\n      print(justify(word, max_widths[j]))\n    end\n    println()\n  end\n  println(\"-\"^sum(max_widths))\nend\n"
  },
  {
    "language": "Julia",
    "code": "function aliquotclassifier{T<:Integer}(n::T)\n    a = T[n]\n    b = divisorsum(a[end])\n    len = 1\n    while len < 17 && !(b in a) && 0 < b && b < 2^47+1\n        push!(a, b)\n        b = divisorsum(a[end])\n        len += 1\n    end\n    if b in a\n        1 < len || return (\"Perfect\", a)\n        if b == a[1]\n            2 < len || return (\"Amicable\", a)\n            return (\"Sociable\", a)\n        elseif b == a[end]\n            return (\"Aspiring\", a)\n        else\n            return (\"Cyclic\", push!(a, b))\n        end\n    end\n    push!(a, b)\n    b != 0 || return (\"Terminating\", a)\n    return (\"Non-terminating\", a)\nend\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib{T<:Integer}(p::T, a::T)\n    n = one(T)\n    pcon = one(T)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum{T<:Integer}(n::T)\n    dsum = one(T)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nprintln(\"Classification Tests:\")\ntests = [1:12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\nfor i in tests\n    (class, a) = aliquotclassifier(i)\n    println(@sprintf(\"%8d => \", i), @sprintf(\"%16s, \", class), a)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(undef,N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(undef,N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "# This is a general purpose AMB function that takes a two-argument failure function and\n# arbitrary number of iterable objects and returns the first solution found as an array\n# this function is in essence an iterative backtracking solver\n\nfunction amb(failure, itrs...)\n    n = length(itrs)\n    if n == 1 return end\n    states = Vector(n)\n    values = Vector(n)\n    # starting point, we put down the first value from the first iterable object\n    states[1] = start(itrs[1])\n    values[1], states[1] = next(itrs[1], states[1])\n    i = 1\n    # main solver loop\n    while true\n        # test for failure\n        if i > 1 && failure(values[i-1], values[i])\n            # loop for generating a new value upon failure\n            # in fact this would be way more readable using goto, but Julia doesn't seem to have that :(\n            while true\n                # if we failed, we must generate a new value, but first we must check whether there is any\n                if done(itrs[i], states[i])\n                    # backtracking step with sanity check in case we ran out of values from the current generator\n                    if i == 1\n                        return\n                    else\n                        i -= 1\n                        continue\n                    end\n                else\n                    # if there is indeed a new value, generate it\n                    values[i], states[i] = next(itrs[i], states[i])\n                    break\n                end\n            end\n        else\n            # no failure branch\n            # if solution is ready (i.e. all generators are used) just return it\n            if i == n return values end\n            # else start up the next generator\n            i += 1\n            states[i] = start(itrs[i])\n            values[i], states[i] = next(itrs[i], states[i])\n        end\n    end\nend\n\n# Call our generic AMB function according to the task description and\n# form the solution sentence from the returned array of words\namb((s1,s2) -> s1[end] != s2[1], # failure function\n    [\"the\", \"that\", \"a\"],\n    [\"frog\", \"elephant\", \"thing\"],\n    [\"walked\", \"treaded\", \"grows\"],\n    [\"slowly\", \"quickly\"]) |>\n    x -> join(x, \" \") |>\n    println\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib(p::Int64, a::Int64)\n    n = one(p)\n    pcon = one(p)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum(n::Int64)\n    dsum = one(n)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nconst L = 2*10^4\nacnt = 0\n\nprintln(\"Amicable pairs not greater than \", L)\n\nfor i in 2:L\n    !isprime(i) || continue\n    j = divisorsum(i)\n    j < i && divisorsum(j) == i || continue\n    acnt += 1\n    println(@sprintf(\"%4d\", acnt), \" => \", j, \", \", i)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Base.isless\n# Let's define the less than operator for any two vectors that have the same type:\n# This does lexicographic comparison, we use it on vectors of chars in this task.\nfunction Base.isless(t1, t2)\n    for (a, b) in zip(t1, t2) # zip only to the shorter length\n        if !isequal(a, b)\n            return isless(a, b)\n        end\n    end\n    return length(t1) < length(t2)\nend\n\n# The sort function of Julia doesn't work on strings, so we write one:\n# This returns a sorted vector of the chars of the given string\nsortchars(s::AbstractString) = sort(collect(Char, s))\n\n# Custom comparator function for sorting the loaded wordlist\nsortanagr(s1::AbstractString, s2::AbstractString) =\n    if length(s1) != length(s2) length(s1) < length(s2) else sortchars(s1) < sortchars(s2) end\n\n# Tests if two strings are deranged anagrams, returns a bool:\n# in our case s2 is never longer than s1\nfunction deranged(s1::AbstractString, s2::AbstractString)\n    # Tests for derangement first\n    for (a, b) in zip(s1, s2)\n        if a == b return false end\n    end\n    # s1 and s2 are deranged, but are they anagrams at all?\n    return sortchars(s1) == sortchars(s2)\nend\n\n# Task starts here, we load the wordlist line by line, strip eol char, and sort the wordlist\n# in a way that ensures that longer words come first and anagrams go next to each other\nwords = sort(open(readlines, \"./data/unixdict.txt\"), rev = true, lt = sortanagr)\n\n# Now we just look for deranged anagrams in the neighbouring words of the sorted wordlist\nfor i in 1:length(words)-1\n    if deranged(words[i], words[i+1])\n        # The first match is guaranteed to be the longest due to the custom sorting\n        println(\"The longest deranged anagrams are $(words[i]) and $(words[i+1])\")\n        break\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\nwordlist = open(readlines, download(url))\n\nwsort(word::AbstractString) = join(sort(collect(word)))\n\nfunction anagram(wordlist::Vector{<:AbstractString})\n    dict = Dict{String, Set{String}}()\n    for word in wordlist\n        sorted = wsort(word)\n        push!(get!(dict, sorted, Set{String}()), word)\n    end\n    wcnt = maximum(length, values(dict))\n    return collect(Iterators.filter((y) -> length(y) == wcnt, values(dict)))\nend\n\nprintln.(anagram(wordlist))\n"
  },
  {
    "language": "Julia",
    "code": "using Luxor\nusing Colors\nusing BoundaryValueDiffEq\n\n# constants for differential equations and movie\nconst g = 9.81\nconst L = 1.0                         # pendulum length in meters\nconst bobd = 0.10                     # pendulum bob diameter in meters\nconst framerate = 50.0                # intended frame rate/sec\nconst t0 = 0.0                        # start time (s)\nconst tf = 2.3                        # end simulation time (s)\nconst dtframe = 1.0/framerate         # time increment per frame\nconst tspan = LinRange(t0, tf, Int(floor(tf*framerate)))  # array of time points in animation\n\nconst bgcolor = \"black\"               # gif background\nconst leaderhue = (0.80, 0.70, 0.20)  # gif swing arm hue light gold\nconst hslcolors = [HSL(col) for col in (distinguishable_colors(\n                   Int(floor(tf*framerate)+3),[RGB(1,1,1)])[2:end])]\nconst giffilename = \"pendulum.gif\"    # output file\n\n# differential equations\nsimplependulum(du, u, p, t) = (\u03b8=u[1]; d\u03b8=u[2]; du[1]=d\u03b8; du[2]=-(g/L)*sin(\u03b8))\nbc2(residual, u, p, t) = (residual[1] = u[end\u00f72][1] + pi/2; residual[2] = u[end][1] - pi/2)\nbvp2 = BVProblem(simplependulum, bc2, [pi/2,pi/2], (tspan[1],tspan[end]))\nsol2 = solve(bvp2, MIRK4(), dt=dtframe) # use the MIRK4 solver for TwoPointBVProblem\n\n# movie making background\nbackdrop(scene, framenumber) = background(bgcolor)\n\nfunction frame(scene, framenumber)\n    u1, u2 = sol2.u[framenumber]\n    y, x = L*cos(u1), L*sin(u1)\n    sethue(leaderhue)\n    poly([Point(-4.0, 0.0), Point(4.0, 0.0),\n          Point(160.0x,160.0y)], :fill)\n    sethue(Colors.HSV(framenumber*4.0, 1, 1))\n    circle(Point(160.0x,160.0y), 160bobd, :fill)\n    text(string(\"frame $framenumber of $(scene.framerange.stop)\"),\n        Point(0.0, -190.0),\n        halign=:center)\nend\n\nmuv = Movie(400, 400, \"Pendulum Demo\", 1:length(tspan))\nanimate(muv, [Scene(muv, backdrop),\n              Scene(muv, frame, easingfunction=easeinoutcubic)],\n              creategif=true, pathname=giffilename)\n"
  },
  {
    "language": "Julia",
    "code": "using Tk\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction windowanim(stepinterval::Float64)\n    wind = Window(\"Animation\", 300, 100)\n    frm = Frame(wind)\n    hello = \"Hello World!                                           \"\n    but = Button(frm, width=30, text=hello)\n    rightward = true\n    callback(s) = (rightward = !rightward)\n    bind(but, \"command\", callback)\n    pack(frm, expand=true, fill = \"both\")\n    pack(but, expand=true, fill = \"both\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    while true\n        but[:text] = permut[ppos]\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if ppos > pmod\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if ppos < 1\n                ppos = pmod\n            end\n        end\n    end\nend\n\nwindowanim(frameinterval)\n"
  },
  {
    "language": "Julia",
    "code": "using Gtk.ShortNames\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction textanimation(stepinterval::Float64)\n    hello = \"Hello World!                        \"\n    win = Window(\"Animation\", 210, 40) |> (Frame() |> (but = Button(\"Switch Directions\")))\n    rightward = true\n    switchdirections(s) = (rightward = !rightward)\n    signal_connect(switchdirections, but, \"clicked\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    nobreak = true\n    endit(w) = (nobreak = false)\n    signal_connect(endit, win, :destroy)\n    showall(win)\n    while nobreak\n        setproperty!(but, :label, permut[ppos])\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if(ppos > pmod)\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if(ppos < 1)\n                ppos = pmod\n            end\n        end\n    end\nend\n\ntextanimation(frameinterval)\n"
  },
  {
    "language": "Julia",
    "code": "function fib(n)\n    if n < 0\n        throw(ArgumentError(\"negative arguments not allowed\"))\n    end\n    aux(m) = m < 2 ? one(m) : aux(m-1) + aux(m-2)\n    aux(n)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using SHA  # security instincts say do not write bare passwords to a shared file even in toy code :)\n\nmutable struct Personnel\n    fullname::String\n    office::String\n    extension::String\n    homephone::String\n    email::String\n    Personnel(ful,off,ext,hom,ema) = new(ful,off,ext,hom,ema)\nend\n\nmutable struct Passwd\n     account::String\n     password::String\n     uid::Int32\n     gid::Int32\n     personal::Personnel\n     directory::String\n     shell::String\n     Passwd(acc,pas,uid,gid,per,dir,she) =  new(acc,pas,uid,gid,per,dir,she)\nend\n\nfunction writepasswd(filename, passrecords)\n    if(passrecords isa Array) == false\n        passrecords = [passrecords]\n    end\n    fh = open(filename, \"a\") # should throw an exception if cannot open in a locked or exclusive mode for append\n    for pas in passrecords\n        record = join([pas.account, bytes2hex(sha256(pas.password)), pas.uid, pas.gid,\n                 join([pas.personal.fullname, pas.personal.office, pas.personal.extension,\n                 pas.personal.homephone, pas.personal.email], ','),\n                 pas.directory, pas.shell], ':')\n        write(fh, record, \"\\n\")\n    end\n    close(fh)\nend\n\nconst jsmith = Passwd(\"jsmith\",\"x\",1001, 1000, Personnel(\"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\"), \"/home/jsmith\", \"/bin/bash\")\nconst jdoe = Passwd(\"jdoe\",\"x\",1002, 1000, Personnel(\"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\"), \"/home/jdoe\", \"/bin/bash\")\nconst xyz = Passwd(\"xyz\",\"x\",1003, 1000, Personnel(\"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\"), \"/home/xyz\", \"/bin/bash\")\n\nconst pfile = \"pfile.csv\"\nwritepasswd(pfile, [jsmith, jdoe])\nprintln(\"Before last record added, file is:\\n$(readstring(pfile))\")\nwritepasswd(pfile, xyz)\nprintln(\"After last record added, file is:\\n$(readstring(pfile))\")\n"
  },
  {
    "language": "Julia",
    "code": "numbers = [1, 3, 5, 7]\n\n@show [n ^ 2 for n in numbers]                  # list comprehension\nsquare(x) = x ^ 2; @show map(square, numbers)   # functional form\n@show map(x -> x ^ 2, numbers)                  # functional form with anonymous function\n@show [n * n for n in numbers]    \t\t\t\t# no need for a function,\n@show numbers .* numbers                        # element-wise operation\n@show numbers .^ 2                              # includes .+, .-, ./, comparison, and bitwise operations as well\n"
  },
  {
    "language": "Julia",
    "code": "julia> @elapsed bigstr = string(BigInt(5)^4^3^2)\n0.017507363\n\njulia> length(bigstr)\n183231\n\njulia> bigstr[1:20]\n\"62060698786608744707\"\n\njulia> bigstr[end-20:end]\n\"892256259918212890625\"\n"
  },
  {
    "language": "Julia",
    "code": "matrix = zeros(Float64, (1000,1000,1000))\n# use matrix, then when done set variable to 0 to garbage collect the matrix:\nmatrix = 0 # large memory pool will now be collected when needed\n"
  },
  {
    "language": "Julia",
    "code": "julia> z1 = 1.5 + 3im\njulia> z2 = 1.5 + 1.5im\njulia> z1 + z2\n3.0 + 4.5im\njulia> z1 - z2\n0.0 + 1.5im\njulia> z1 * z2\n-2.25 + 6.75im\njulia> z1 / z2\n1.5 + 0.5im\njulia> - z1\n-1.5 - 3.0im\njulia> conj(z1), z1'   # two ways to conjugate\n(1.5 - 3.0im,1.5 - 3.0im)\njulia> abs(z1)\n3.3541019662496847\njulia> z1^z2\n-1.102482955327779 - 0.38306415117199305im\njulia> real(z1)\n1.5\njulia> imag(z1)\n3.0\n"
  },
  {
    "language": "Julia",
    "code": "julia> expr=\"2 * (3 -1) + 2 * 5\"\n\"2 * (3 -1) + 2 * 5\"\n\njulia> parsed = parse(expr) #Julia provides low-level access to language parser for AST/Expr creation\n:(+(*(2,-(3,1)),*(2,5)))\n\njulia> t = typeof(parsed)\nExpr\n\njulia> names(t) #shows type fields\n(:head,:args,:typ)\n\njulia> parsed.args #Inspect our 'Expr' type innards\n3-element Any Array:\n :+\n :(*(2,-(3,1)))\n :(*(2,5))\n\njulia> typeof(parsed.args[2]) #'Expr' types can nest\nExpr\n\njulia> parsed.args[2].args\n3-element Any Array:\n  :*\n 2\n  :(-(3,1))\n\njulia> parsed.args[2].args[3].args #Will nest until lowest level of AST\n3-element Any Array:\n  :-\n 3\n 1\n\njulia> eval(parsed)\n14\n\njulia> eval(parse(\"1 - 5 * 2 / 20 + 1\"))\n1.5\n\njulia> eval(parse(\"2 * (3 + ((5) / (7 - 11)))\"))\n3.5\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nagm1step(x, y) = (x + y) / 2, sqrt(x * y)\n\nfunction approx\u03c0step(x, y, z, n::Integer)\n    a, g = agm1step(x, y)\n    k = n + 1\n    s = z + 2 ^ (k + 1) * (a ^ 2 - g ^ 2)\n    return a, g, s, k\nend\n\napprox\u03c0(a, g, s) = 4a ^ 2 / (1 - s)\n\nfunction testmakepi()\n\tsetprecision(512)\n\ta, g, s, k = BigFloat(1.0), 1 / \u221aBigFloat(2.0), BigFloat(0.0), 0\n\told\u03c0 = BigFloat(0.0)\n\tprintln(\"Approximating \u03c0 using \", precision(BigFloat), \"-bit floats.\")\n\tprintln(\"   k     Error  Result\")\n\tfor i in 1:100\n\t\ta, g, s, k = approx\u03c0step(a, g, s, k)\n\t\test\u03c0 = approx\u03c0(a, g, s)\n\t\tif abs(est\u03c0 - old\u03c0) < 2eps(est\u03c0) break end\n\t\told\u03c0 = est\u03c0\n\t\terr = abs(\u03c0 - est\u03c0)\n\t\t@printf(\"%4d%10.1e%68.60e\\n\", i, err, est\u03c0)\n\tend\nend\n\ntestmakepi()\n"
  },
  {
    "language": "Julia",
    "code": "function agm(x, y, e::Real = 5)\n    (x \u2264 0 || y \u2264 0 || e \u2264 0) && throw(DomainError(\"x, y must be strictly positive\"))\n    g, a = minmax(x, y)\n    while e * eps(x) < a - g\n        a, g = (a + g) / 2, sqrt(a * g)\n    end\n    a\nend\n\nx, y = 1.0, 1 / \u221a2\nprintln(\"# Using literal-precision float numbers:\")\n@show agm(x, y)\n\nprintln(\"# Using half-precision float numbers:\")\nx, y = Float32(x), Float32(y)\n@show agm(x, y)\n\nprintln(\"# Using \", precision(BigFloat), \"-bit float numbers:\")\nx, y = big(1.0), 1 / \u221abig(2.0)\n@show agm(x, y)\n"
  },
  {
    "language": "Julia",
    "code": "function arithmetic (a = parse(Int, readline()), b = parse(Int, readline()))\n  for op in  [+,-,*,div,rem]\n    println(\"a $op b = $(op(a,b))\")\n  end\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\ndivisors(n) = foldl((a, (p, e)) -> vcat((a * [p^i for i in 0:e]')...), factor(n), init=[1])\n\nisperfect(n) = sum(1 // d for d in divisors(n)) == 2\n\nlo, hi = 2, 2^19\nprintln(\"Perfect numbers between \", lo, \" and \", hi, \": \", collect(filter(isperfect, lo:hi)))\n"
  },
  {
    "language": "Julia",
    "code": "a = [1,2,3]\nb = [4,5,6]\nab = [a;b]\n# the above bracket notation simply generates a call to vcat\nab = vcat(a,b)\n# hcat is short for `horizontal concatenation`\nab = hcat(a,b) \t#ab -> 3x2 matrix\n# the append!(a,b) method is mutating, appending `b` to `a`\nappend!(a,b)\t# a now equals [1,2,3,4,5,6]\n"
  },
  {
    "language": "Julia",
    "code": "const x = 5\n\n# @assert macro checks the supplied conditional expression, with the expression\n# returned in the failed-assertion message\n@assert x == 42\n# ERROR: LoadError: AssertionError: x == 42\n\n# Julia also has type assertions of the form, x::Type which can be appended to\n# variable for type-checking at any point\nx::String\n# ERROR: LoadError: TypeError: in typeassert, expected String, got Int64\n"
  },
  {
    "language": "Julia",
    "code": "dict = Dict('a' => 97, 'b' => 98) # list keys/values\n# Dict{Char,Int64} with 2 entries:\n#   'b' => 98\n#   'a' => 97\n\ndict = Dict(c => Int(c) for c = 'a':'d') # dict comprehension\n# Dict{Char,Int64} with 4 entries:\n#   'b' => 98\n#   'a' => 97\n#   'd' => 100\n#   'c' => 99\n\ndict['\u00e9'] = 233; dict # add an element\n# Dict{Char,Int64} with 3 entries:\n#   'b' => 98\n#   'a' => 97\n#   '\u00e9' => 233\n\nemptydict = Dict() # create an empty dict\n# Dict{Any,Any} with 0 entries\n\ndict[\"a\"] = 1 # type mismatch\n# ERROR: MethodError: Cannot `convert` an object of type String to an object of type Char\n\ntypeof(dict) # type is infered correctly\n# Dict{Char,Int64}\n"
  },
  {
    "language": "Julia",
    "code": "dict = Dict(\"hello\" => 13, \"world\" => 31, \"!\" => 71)\n\n# applying a function to key-value pairs:\nforeach(println, dict)\n\n# iterating over key-value pairs:\nfor (key, value) in dict\n    println(\"dict[$key] = $value\")\nend\n\n# iterating over keys:\nfor key in keys(dict)\n    @show key\nend\n\n# iterating over values:\nfor value in values(dict)\n    @show value\nend\n"
  },
  {
    "language": "Julia",
    "code": "using StatsBase\n\nfunction runall()\n    nbuckets = 16\n    unfinish = true\n    spinner = ReentrantLock()\n    buckets = rand(1:99, nbuckets)\n    totaltrans = 0\n\n    bucketsum() = sum(buckets)\n    smallpause() = sleep(rand() / 2000)\n    picktwo() = (samplepair(nbuckets)...)\n    function equalizer()\n        while unfinish\n            smallpause()\n            if trylock(spinner)\n                i, j = picktwo()\n                sm = buckets[i] + buckets[j]\n                m = fld(sm + 1, 2)\n                buckets[i], buckets[j] = m, sm - m\n                totaltrans += 1\n                unlock(spinner)\n            end\n        end\n    end\n    function redistributor()\n        while unfinish\n            smallpause()\n            if trylock(spinner)\n                i, j = picktwo()\n                sm = buckets[i] + buckets[j]\n                buckets[i] = rand(0:sm)\n                buckets[j] = sm - buckets[i]\n                totaltrans += 1\n                unlock(spinner)\n            end\n        end\n    end\n    function accountant()\n        count = 0\n        while count < 16\n            smallpause()\n            if trylock(spinner)\n                println(\"Current state of buckets: $buckets. Total in buckets: $(bucketsum())\")\n                unlock(spinner)\n                count += 1\n                sleep(1)\n            end\n        end\n        unfinish = false\n    end\n    t = time()\n    @async equalizer()\n    @async redistributor()\n    @async accountant()\n    while unfinish sleep(0.25) end\n    println(\"Total transactions: $totaltrans ($(round(Int, totaltrans / (time() - t))) unlocks per second).\")\nend\n\nrunall()\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nanalytical(n::Integer) = sum(factorial(n) / big(n) ^ i / factorial(n - i) for i = 1:n)\n\nfunction test(n::Integer, times::Integer = 1000000)\n    c = 0\n    for i = range(0, times)\n        x, bits = 1, 0\n        while (bits & x) == 0\n            c += 1\n            bits |= x\n            x = 1 << rand(0:(n - 1))\n        end\n    end\n    return c / times\nend\n\nfunction main(n::Integer)\n    println(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\")\n    for n in 1:n\n        avg = test(n)\n        theory = analytical(n)\n        diff = (avg / theory - 1) * 100\n        @printf(STDOUT, \"%2d %8.4f %8.4f %6.3f%%\\n\", n, avg, theory, diff)\n    end\nend\n\nmain(20)\n"
  },
  {
    "language": "Julia",
    "code": "julia> using Statistics; mean([1,2,3])\n2.0\njulia> mean(1:10)\n5.5\njulia> mean([])\nERROR: mean of empty collection undefined: []\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\nmeandegrees(degrees) = radians2degrees(atan2(mean(sind(degrees)), mean(cosd(degrees))))\n"
  },
  {
    "language": "Julia",
    "code": "julia> meandegrees([350, 10])\n0.0\n\njulia> meandegrees([90, 180, 270, 360]])\n0.0\n\njulia> meandegrees([10, 20, 30]])\n19.999999999999996\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\n\nfunction meantime(times::Array, dlm::String=\":\")\n    c = \u03c0 / (12 * 60 * 60)\n    a = map(x -> parse.(Int, x), split.(times, dlm))\n    \u03d5 = collect(3600t[1] + 60t[2] + t[3] for t in a)\n    d = angle(mean(exp.(c * im * \u03d5))) / 2\u03c0 # days\n    if d < 0 d += 1 end\n    # Convert to h:m:s\n    h = trunc(Int, d * 24)\n    m = trunc(Int, d * 24 * 60) - h * 60\n    s = trunc(Int, d * 24 * 60 * 60) - h * 60 * 60 - m * 60\n    return \"$h:$m:$s\"\nend\n\ntimes = String[\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]\nmtime = meantime(times)\nprintln(\"Times:\")\nprintln.(times)\nprintln(\"Mean: $mtime\")\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\nfunction median2(n)\n\ts = sort(n)\n\tlen = length(n)\n\tif len % 2 == 0\n\t\treturn (s[floor(Int, len / 2) + 1] + s[floor(Int, len / 2)]) / 2\n\telse\n\t\treturn  s[floor(Int, len / 2) + 1]\n\tend\nend\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]\nb = [4.1, 7.2, 1.7, 9.3, 4.4, 3.2]\n\n@show a b median2(a) median(a) median2(b) median(b)\n"
  },
  {
    "language": "Julia",
    "code": "function modes(values)\n    dict = Dict() # Values => Number of repetitions\n    modesArray = typeof(values[1])[] # Array of the modes so far\n    max = 0 # Max of repetitions so far\n\n    for v in values\n        # Add one to the dict[v] entry (create one if none)\n        if v in keys(dict)\n            dict[v] += 1\n        else\n            dict[v] = 1\n        end\n\n        # Update modesArray if the number of repetitions\n        # of v reaches or surpasses the max value\n        if dict[v] >= max\n            if dict[v] > max\n                empty!(modesArray)\n                max += 1\n            end\n            append!(modesArray, [v])\n        end\n    end\n\n    return modesArray\nend\n\nprintln(modes([1,3,6,6,6,6,7,7,12,12,17]))\nprintln(modes((1,1,2,4,4)))\n"
  },
  {
    "language": "Julia",
    "code": "amean(A) = sum(A)/length(A)\n\ngmean(A) = prod(A)^(1/length(A))\n\nhmean(A) = length(A)/sum(1./A)\n"
  },
  {
    "language": "Julia",
    "code": "sqrt(sum(A.^2.) / length(A))\n"
  },
  {
    "language": "Julia",
    "code": "sqrt(mean(A.^2.))\n"
  },
  {
    "language": "Julia",
    "code": "sqrt(sum(x -> x*x, A) / length(A))\n"
  },
  {
    "language": "Julia",
    "code": "function rms(A)\n   s = 0.0\n   for a in A\n      s += a*a\n   end\n   return sqrt(s / length(A))\nend\n"
  },
  {
    "language": "Julia",
    "code": "norm(A) / sqrt(length(A))\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\n"
  },
  {
    "language": "Julia",
    "code": "function movingaverage(::Type{T} = Float64; lim::Integer = -1) where T<:Real\n\tbuffer = Vector{T}(0)\n\tif lim == -1\n\t\t# unlimited buffer\n\t\treturn (y::T) -> begin\n\t\t\tpush!(buffer, y)\n\t\t\treturn mean(buffer)\n\t\tend\n\telse\n\t\t# limited size buffer\n\t\treturn (y) -> begin\n\t\t\tpush!(buffer, y)\n\t\t\tif length(buffer) > lim shift!(buffer) end\n\t\t\treturn mean(buffer)\n\t\tend\n\tend\nend\n\ntest = movingaverage()\n@show test(1.0) # mean([1])\n@show test(2.0) # mean([1, 2])\n@show test(3.0) # mean([1, 2, 3])\n"
  },
  {
    "language": "Kotlin",
    "code": "fun oneHundredDoors(): List<Int> {\n    val doors = BooleanArray(100, { false })\n    for (i in 0..99) {\n        for (j in i..99 step (i + 1)) {\n            doors[j] = !doors[j]\n        }\n    }\n    return doors\n        .mapIndexed { i, b -> i to b }\n        .filter { it.second }\n        .map { it.first + 1 }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\nimport java.util.Random\n\nconst val N_CARDS = 4\nconst val SOLVE_GOAL = 24\nconst val MAX_DIGIT = 9\n\nclass Frac(val num: Int, val den: Int)\n\nenum class OpType { NUM, ADD, SUB, MUL, DIV }\n\nclass Expr(\n    var op:    OpType = OpType.NUM,\n    var left:  Expr?  = null,\n    var right: Expr?  = null,\n    var value: Int    = 0\n)\n\nfun showExpr(e: Expr?, prec: OpType, isRight: Boolean) {\n    if (e == null) return\n    val op = when (e.op) {\n        OpType.NUM -> { print(e.value); return }\n        OpType.ADD -> \" + \"\n        OpType.SUB -> \" - \"\n        OpType.MUL -> \" x \"\n        OpType.DIV -> \" / \"\n    }\n\n    if ((e.op == prec && isRight) || e.op < prec) print(\"(\")\n    showExpr(e.left, e.op, false)\n    print(op)\n    showExpr(e.right, e.op, true)\n    if ((e.op == prec && isRight) || e.op < prec) print(\")\")\n}\n\nfun evalExpr(e: Expr?): Frac {\n    if (e == null) return Frac(0, 1)\n    if (e.op == OpType.NUM) return Frac(e.value, 1)\n    val l = evalExpr(e.left)\n    val r = evalExpr(e.right)\n    return when (e.op) {\n        OpType.ADD -> Frac(l.num * r.den + l.den * r.num, l.den * r.den)\n        OpType.SUB -> Frac(l.num * r.den - l.den * r.num, l.den * r.den)\n        OpType.MUL -> Frac(l.num * r.num, l.den * r.den)\n        OpType.DIV -> Frac(l.num * r.den, l.den * r.num)\n        else       -> throw IllegalArgumentException(\"Unknown op: ${e.op}\")\n    }\n}\n\nfun solve(ea: Array<Expr?>, len: Int): Boolean {\n    if (len == 1) {\n        val final = evalExpr(ea[0])\n        if (final.num == final.den * SOLVE_GOAL && final.den != 0) {\n            showExpr(ea[0], OpType.NUM, false)\n            return true\n        }\n    }\n\n    val ex = arrayOfNulls<Expr>(N_CARDS)\n    for (i in 0 until len - 1) {\n        for (j in i + 1 until len) ex[j - 1] = ea[j]\n        val node = Expr()\n        ex[i] = node\n        for (j in i + 1 until len) {\n            node.left = ea[i]\n            node.right = ea[j]\n            for (k in OpType.values().drop(1)) {\n                node.op = k\n                if (solve(ex, len - 1)) return true\n            }\n            node.left = ea[j]\n            node.right = ea[i]\n            node.op = OpType.SUB\n            if (solve(ex, len - 1)) return true\n            node.op = OpType.DIV\n            if (solve(ex, len - 1)) return true\n            ex[j] = ea[j]\n        }\n        ex[i] = ea[i]\n    }\n    return false\n}\n\nfun solve24(n: IntArray) =\n    solve (Array(N_CARDS) { Expr(value = n[it]) }, N_CARDS)\n\nfun main(args: Array<String>) {\n    val r = Random()\n    val n = IntArray(N_CARDS)\n    for (j in 0..9) {\n        for (i in 0 until N_CARDS) {\n            n[i] = 1 + r.nextInt(MAX_DIGIT)\n            print(\" ${n[i]}\")\n        }\n        print(\":  \")\n        println(if (solve24(n)) \"\" else \"No solution\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\nimport java.util.Scanner\nimport java.util.Stack\n\ninternal object Game24 {\n    fun run() {\n        val r = Random()\n        val digits = IntArray(4).map { r.nextInt(9) + 1 }\n        println(\"Make 24 using these digits: $digits\")\n        print(\"> \")\n\n        val s = Stack<Float>()\n        var total = 0L\n        val cin = Scanner(System.`in`)\n        for (c in cin.nextLine()) {\n            when (c) {\n                in '0'..'9' -> {\n                    val d = c - '0'\n                    total += (1 shl (d * 5)).toLong()\n                    s += d.toFloat()\n                }\n                else ->\n                    if (\"+/-*\".indexOf(c) != -1) {\n                        s += c.applyOperator(s.pop(), s.pop())\n                    }\n            }\n        }\n\n        when {\n            tally(digits) != total ->\n                print(\"Not the same digits. \")\n            s.peek().compareTo(target) == 0 ->\n                println(\"Correct!\")\n            else ->\n                print(\"Not correct.\")\n        }\n    }\n\n    private fun Char.applyOperator(a: Float, b: Float) = when (this) {\n        '+' -> a + b\n        '-' -> b - a\n        '*' -> a * b\n        '/' -> b / a\n        else -> Float.NaN\n    }\n\n    private fun tally(a: List<Int>): Long = a.reduce({ t, i -> t + (1 shl (i * 5)) }).toLong()\n\n    private val target = 24\n}\n\nfun main(args: Array<String>) = Game24.run()\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.min\nimport java.math.BigInteger\nimport java.util.ArrayList\nimport java.util.Arrays.asList\n\nfun namesOfGod(n: Int): List<BigInteger> {\n    val cache = ArrayList<List<BigInteger>>()\n    cache.add(asList(BigInteger.ONE))\n\n    (cache.size..n).forEach { l ->\n        val r = ArrayList<BigInteger>()\n        r.add(BigInteger.ZERO)\n\n        (1..l).forEach { x ->\n            r.add(r[r.size - 1] + cache[l - x][min(x, l - x)])\n        }\n        cache.add(r)\n    }\n    return cache[n]\n}\n\nfun row(n: Int) = namesOfGod(n).let { r -> (0 until n).map { r[it + 1] - r[it] } }\n\nfun main(args: Array<String>) {\n    println(\"Rows:\")\n    (1..25).forEach {\n        System.out.printf(\"%2d: %s%n\", it, row(it))\n    }\n\n    println(\"\\nSums:\")\n    intArrayOf(23, 123, 1234, 1234).forEach {\n        val c = namesOfGod(it)\n        System.out.printf(\"%s %s%n\", it, c[c.size - 1])\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    for (i in 99.downTo(1)) {\n        println(\"$i bottles of beer on the wall\")\n        println(\"$i bottles of beer\")\n        println(\"Take one down, pass it around\")\n    }\n    println(\"No more bottles of beer on the wall!\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun main(args: Array<String>) {\n    val r = Regex(\"\"\"-?\\d+[ ]+-?\\d+\"\"\")\n    while(true) {\n        print(\"Enter two integers separated by space(s) or q to quit: \")\n        val input: String = readLine()!!.trim()\n        if (input == \"q\" || input == \"Q\") break\n        if (!input.matches(r)) {\n            println(\"Invalid input, try again\")\n            continue\n        }\n        val index = input.lastIndexOf(' ')\n        val a = input.substring(0, index).trimEnd().toInt()\n        val b = input.substring(index + 1).toInt()\n        if (Math.abs(a) > 1000 || Math.abs(b) > 1000) {\n            println(\"Both numbers must be in the interval [-1000, 1000] - try again\")\n        }\n        else {\n            println(\"Their sum is ${a + b}\\n\")\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "object ABC_block_checker {\n    fun run() {\n        val blocks = arrayOf(\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\")\n\n        println(\"\\\"\\\": \" + blocks.canMakeWord(\"\"))\n        val words = arrayOf(\"A\", \"BARK\", \"book\", \"treat\", \"COMMON\", \"SQuAd\", \"CONFUSE\")\n        for (w in words)  println(\"$w: \" + blocks.canMakeWord(w))\n    }\n\n    private fun Array<String>.swap(i: Int, j: Int) {\n        val tmp = this[i]\n        this[i] = this[j]\n        this[j] = tmp\n    }\n\n    private fun Array<String>.canMakeWord(word: String): Boolean {\n        if (word.isEmpty())\n            return true\n\n        val c = Character.toUpperCase(word.first())\n        var i = 0\n        forEach { b ->\n            if (b.first().toUpperCase() == c || b[1].toUpperCase() == c) {\n                swap(0, i)\n                if (drop(1).toTypedArray().canMakeWord(word.substring(1)))\n                    return true\n                swap(0, i)\n            }\n            i++\n        }\n\n        return false\n    }\n}\n\nfun main(args: Array<String>) = ABC_block_checker.run()\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\ninterface Announcer {\n    fun announceType()\n\n    // interface can contain non-abstract members but cannot store state\n    fun announceName() {\n        println(\"I don't have a name\")\n    }\n}\n\nabstract class Animal: Announcer {\n    abstract fun makeNoise()\n\n    // abstract class can contain non-abstract members\n    override fun announceType() {\n        println(\"I am an Animal\")\n    }\n}\n\nclass Dog(private val name: String) : Animal() {\n    override fun makeNoise() {\n       println(\"Woof!\")\n    }\n\n    override fun announceName() {\n       println(\"I'm called $name\")\n    }\n}\n\nclass Cat: Animal() {\n    override fun makeNoise() {\n       println(\"Meow!\")\n    }\n\n    override fun announceType() {\n       println(\"I am a Cat\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val d = Dog(\"Fido\")\n    with(d) {\n        makeNoise()\n        announceType()  // inherits Animal's implementation\n        announceName()\n    }\n    println()\n    val c = Cat()\n    with(c) {\n        makeNoise()\n        announceType()\n        announceName()  // inherits Announcer's implementation\n   }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun sumProperDivisors(n: Int) =\n    if (n < 2) 0 else (1..n / 2).filter { (n % it) == 0 }.sum()\n\nfun main(args: Array<String>) {\n    var sum: Int\n    var deficient = 0\n    var perfect = 0\n    var abundant = 0\n\n    for (n in 1..20000) {\n        sum = sumProperDivisors(n)\n        when {\n            sum < n -> deficient++\n            sum == n -> perfect++\n            sum > n -> abundant++\n        }\n    }\n\n    println(\"The classification of the numbers from 1 to 20,000 is as follows:\\n\")\n    println(\"Deficient = $deficient\")\n    println(\"Perfect   = $perfect\")\n    println(\"Abundant  = $abundant\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun foo(n: Double): (d: Double) -> Double {\n    var nn = n\n    return { nn += it; nn }\n}\n\nfun foo(n: Int): (i: Int) -> Int {\n    var nn = n\n    return { nn += it; nn }\n}\n\nfun main(args: Array<String>) {\n    val x = foo(1.0) // calls 'Double' overload\n    x(5.0)\n    foo(3.0)\n    println(x(2.3))\n    val y = foo(1)   // calls 'Int' overload\n    y(5)\n    foo(5)\n    println(y(2))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun A(m: Long, n: Long): Long = when {\n    m == 0L -> n + 1\n    m > 0L -> when {\n        n == 0L -> A(m - 1, 1)\n        n > 0L -> A(m - 1, A(m, n - 1))\n        else -> throw IllegalArgumentException(\"illegal n\")\n    }\n    else -> throw IllegalArgumentException(\"illegal m\")\n}\n\nfun main(args: Array<String>) {\n    val M: Long = 4\n    val N: Long = 20\n    val r = 0..N\n    for (m  in 0..M) {\n        print(\"\\nA($m, $r) =\")\n        var able = true\n        r.forEach {\n            try {\n                if (able) {\n                    val a = A(m, it)\n                    print(\" %6d\".format(a))\n                } else\n                    print(\"      ?\")\n            } catch(e: Throwable) {\n                print(\"      ?\")\n                able = false\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import org.apache.directory.api.ldap.model.exception.LdapException\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection\nimport java.io.IOException\nimport java.util.logging.Level\nimport java.util.logging.Logger\n\nclass LDAP(map: Map<String, String>) {\n    fun run() {\n        var connection: LdapNetworkConnection? = null\n        try {\n            if (info) log.info(\"LDAP Connection to $hostname on port $port\")\n            connection = LdapNetworkConnection(hostname, port.toInt())\n\n            try {\n                if (info) log.info(\"LDAP bind\")\n                connection.bind()\n            } catch (e: LdapException) {\n                log.severe(e.toString())\n            }\n\n            try {\n                if (info) log.info(\"LDAP unbind\")\n                connection.unBind()\n            } catch (e: LdapException) {\n                log.severe(e.toString())\n            }\n        } finally {\n            try {\n                if (info) log.info(\"LDAP close connection\")\n                connection!!.close()\n            } catch (e: IOException) {\n                log.severe(e.toString())\n            }\n        }\n    }\n\n    private val log = Logger.getLogger(LDAP::class.java.name)\n    private val info = log.isLoggable(Level.INFO)\n    private val hostname: String by map\n    private val port: String by map\n}\n\nfun main(args: Array<String>) = LDAP(mapOf(\"hostname\" to \"localhost\", \"port\"  to \"10389\")).run()\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.0\n\nimport kotlin.math.*\n\ntypealias Function = (Double) -> Double\n\n/**\n * Integrates input function K over time\n * S + (t1 - t0) * (K(t1) + K(t0)) / 2\n */\nclass Integrator {\n    private val start: Long\n    private @Volatile var running = false\n    private lateinit var func: Function\n    private var t0 = 0.0\n    private var v0 = 0.0\n    private var sum = 0.0\n\n    constructor(func: Function) {\n        start = System.nanoTime()\n        setFunc(func)\n        Thread(this::integrate).start()\n    }\n\n    fun setFunc(func: Function) {\n        this.func = func\n        v0 = func(0.0)\n        t0 = 0.0\n    }\n\n    fun getOutput() = sum\n\n    fun stop() {\n        running = false\n    }\n\n    private fun integrate() {\n        running = true\n        while (running) {\n            try {\n                Thread.sleep(1)\n                update()\n            }\n            catch(e: InterruptedException) {\n                return\n            }\n        }\n    }\n\n    private fun update() {\n        val t1 = (System.nanoTime() - start) / 1.0e9\n        val v1 = func(t1)\n        val rect = (t1 - t0) * (v0 + v1) / 2.0\n        sum  += rect\n        t0 = t1\n        v0 = v1\n    }\n}\n\nfun main(args: Array<String>) {\n    val integrator = Integrator( { sin(PI * it) } )\n    Thread.sleep(2000)\n\n    integrator.setFunc( { 0.0 } )\n    Thread.sleep(500)\n\n    integrator.stop()\n    println(integrator.getOutput())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nclass SomeClass {\n    val runtimeVariables = mutableMapOf<String, Any>()\n}\n\nfun main(args: Array<String>) {\n    val sc = SomeClass()\n    println(\"Create two variables at runtime: \")\n    for (i in 1..2) {\n        println(\"  Variable #$i:\")\n        print(\"       Enter name  : \")\n        val name = readLine()!!\n        print(\"       Enter value : \")\n        val value = readLine()!!\n        sc.runtimeVariables.put(name, value)\n        println()\n    }\n    while (true) {\n        print(\"Which variable do you want to inspect ? \")\n        val name = readLine()!!\n        val value = sc.runtimeVariables[name]\n        if (value == null) {\n            println(\"There is no variable of that name, try again\")\n        } else {\n            println(\"Its value is '${sc.runtimeVariables[name]}'\")\n            return\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    val intVar = nativeHeap.alloc<IntVar>()\n    intVar.value = 42\n    with(intVar) { println(\"Value is $value, address is $rawPtr\") }\n    nativeHeap.free(intVar)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun binomial(n: Int, k: Int): Long = when {\n    n < 0 || k < 0 -> throw IllegalArgumentException(\"negative numbers not allowed\")\n    k == 0         -> 1L\n    k == n         -> 1L\n    else           -> {\n        var prod = 1L\n        var div  = 1L\n        for (i in 1..k) {\n            prod *= (n + 1 - i)\n            div  *= i\n            if (prod % div == 0L) {\n                prod /= div\n                div = 1L\n            }\n        }\n        prod\n    }\n}\n\nfun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n    return (1 until n).none { binomial(n, it) % n.toLong() != 0L }\n}\n\nfun main(args: Array<String>) {\n    var coeff: Long\n    var sign: Int\n    var op: String\n    for (n in 0..9) {\n        print(\"(x - 1)^$n = \")\n        sign = 1\n        for (k in n downTo 0) {\n            coeff = binomial(n, k)\n            op = if (sign == 1) \" + \" else \" - \"\n            when (k) {\n                n    -> print(\"x^$n\")\n                0    -> println(\"${op}1\")\n                else -> print(\"$op${coeff}x^$k\")\n            }\n            if (n == 0) println()\n            sign *= -1\n        }\n    }\n    // generate primes under 62\n    var p = 2\n    val primes = mutableListOf<Int>()\n    do {\n        if (isPrime(p)) primes.add(p)\n        if (p != 2) p += 2 else p = 3\n    }\n    while (p < 62)\n    println(\"\\nThe prime numbers under 62 are:\")\n    println(primes)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.nio.charset.StandardCharsets\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\nenum class AlignFunction {\n    LEFT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + s.length + 's').format(s)) },\n    RIGHT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + l + 's').format(s)) },\n    CENTER { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + ((l + s.length) / 2) + 's').format(s)) };\n\n    abstract operator fun invoke(s: String, l: Int): String\n}\n\n/** Aligns fields into columns, separated by \"|\".\n * @constructor Initializes columns aligner from lines in a list of strings.\n * @property lines Lines in a single string. Empty string does form a column.\n */\nclass ColumnAligner(val lines: List<String>) {\n     operator fun invoke(a: AlignFunction) : String {\n        var result = \"\"\n        for (lineWords in words) {\n            for (i in lineWords.indices) {\n                if (i == 0)\n                    result += '|'\n                result += a(lineWords[i], column_widths[i])\n                result += '|'\n            }\n            result += '\\n'\n        }\n        return result\n    }\n\n    private val words = arrayListOf<Array<String>>()\n    private val column_widths = arrayListOf<Int>()\n\n    init {\n        lines.forEach  {\n            val lineWords = java.lang.String(it).split(\"\\\\$\")\n            words += lineWords\n            for (i in lineWords.indices) {\n                if (i >= column_widths.size) {\n                    column_widths += lineWords[i].length\n                } else {\n                    column_widths[i] = Math.max(column_widths[i], lineWords[i].length)\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isEmpty()) {\n        println(\"Usage: ColumnAligner file [L|R|C]\")\n        return\n    }\n    val ca = ColumnAligner(Files.readAllLines(Paths.get(args[0]), StandardCharsets.UTF_8))\n    val alignment = if (args.size >= 2) args[1] else \"L\"\n    when (alignment) {\n        \"L\" -> print(ca(AlignFunction.LEFT))\n        \"R\" -> print(ca(AlignFunction.RIGHT))\n        \"C\" -> print(ca(AlignFunction.CENTER))\n        else -> System.err.println(\"Error! Unknown alignment: \" + alignment)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\ndata class Classification(val sequence: List<Long>, val aliquot: String)\n\nconst val THRESHOLD = 1L shl 47\n\nfun sumProperDivisors(n: Long): Long {\n    if (n < 2L) return 0L\n    val sqrt = Math.sqrt(n.toDouble()).toLong()\n    var sum = 1L + (2L..sqrt)\n        .filter { n % it == 0L }\n        .map { it + n / it }\n        .sum()\n    if (sqrt * sqrt == n) sum -= sqrt\n    return sum\n}\n\nfun classifySequence(k: Long): Classification {\n    require(k > 0)\n    var last = k\n    val seq = mutableListOf(k)\n    while (true) {\n        last = sumProperDivisors(last)\n        seq.add(last)\n        val n = seq.size\n        val aliquot = when {\n            last == 0L                  -> \"Terminating\"\n            n == 2 && last == k         -> \"Perfect\"\n            n == 3 && last == k         -> \"Amicable\"\n            n >= 4 && last == k         -> \"Sociable[${n - 1}]\"\n            last == seq[n - 2]          -> \"Aspiring\"\n            last in seq.slice(1..n - 3) -> \"Cyclic[${n - 1 - seq.indexOf(last)}]\"\n            n == 16 || last > THRESHOLD -> \"Non-Terminating\"\n            else                        -> \"\"\n        }\n        if (aliquot != \"\") return Classification(seq, aliquot)\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\"Aliqot classifications - periods for Sociable/Cyclic in square brackets:\\n\")\n    for (k in 1L..10) {\n        val (seq, aliquot) = classifySequence(k)\n        println(\"${\"%2d\".format(k)}: ${aliquot.padEnd(15)} $seq\")\n    }\n\n    val la = longArrayOf(\n        11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488\n    )\n    println()\n\n    for (k in la) {\n        val (seq, aliquot) = classifySequence(k)\n        println(\"${\"%7d\".format(k)}: ${aliquot.padEnd(15)} $seq\")\n    }\n\n    println()\n\n    val k = 15355717786080L\n    val (seq, aliquot) = classifySequence(k)\n    println(\"$k: ${aliquot.padEnd(15)} $seq\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun Int.k_prime(x: Int): Boolean {\n    var n = x\n    var f = 0\n    var p = 2\n    while (f < this && p * p <= n) {\n        while (0 == n % p) { n /= p; f++ }\n        p++\n    }\n    return f + (if (n > 1) 1 else 0) == this\n}\n\nfun Int.primes(n : Int) : List<Int> {\n    var i = 2\n    var list = mutableListOf<Int>()\n    while (list.size < n) {\n        if (k_prime(i)) list.add(i)\n        i++\n    }\n    return list\n}\n\nfun main(args: Array<String>) {\n    for (k in 1..5)\n        println(\"k = $k: \" + k.primes(10))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.41\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nfun main(args: Array<String>) = amb {\n    val a = amb(\"the\", \"that\", \"a\")\n    val b = amb(\"frog\", \"elephant\", \"thing\")\n    val c = amb(\"walked\", \"treaded\", \"grows\")\n    val d = amb(\"slowly\", \"quickly\")\n\n    if (a[a.lastIndex] != b[0]) amb()\n    if (b[b.lastIndex] != c[0]) amb()\n    if (c[c.lastIndex] != d[0]) amb()\n\n    println(listOf(a, b, c, d))\n\n\n    val x = amb(1, 2, 3)\n    val y = amb(7, 6, 4, 5)\n    if (x * y != 8) amb()\n    println(listOf(x, y))\n}\n\n\nclass AmbException(): Exception(\"Refusing to execute\")\ndata class AmbPair<T>(val cont: Continuation<T>, val valuesLeft: MutableList<T>)\n\n@RestrictsSuspension\nclass AmbEnvironment {\n    val ambList = mutableListOf<AmbPair<*>>()\n\n    suspend fun <T> amb(value: T, vararg rest: T): T = suspendCoroutineOrReturn { cont ->\n        if (rest.size > 0) {\n            ambList.add(AmbPair(clone(cont), mutableListOf(*rest)))\n        }\n\n        value\n    }\n\n    suspend fun amb(): Nothing = suspendCoroutine<Nothing> { }\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <R> amb(block: suspend AmbEnvironment.() -> R): R {\n    var result: R? = null\n    var toThrow: Throwable? = null\n\n    val dist = AmbEnvironment()\n    block.startCoroutine(receiver = dist, completion = object : Continuation<R> {\n        override val context: CoroutineContext get() = EmptyCoroutineContext\n        override fun resume(value: R) { result = value }\n        override fun resumeWithException(exception: Throwable) { toThrow = exception }\n    })\n\n    while (result == null && toThrow == null && !dist.ambList.isEmpty()) {\n        val last = dist.ambList.run { this[lastIndex] }\n\n        if (last.valuesLeft.size == 1) {\n            dist.ambList.removeAt(dist.ambList.lastIndex)\n            last.apply {\n                (cont as Continuation<Any?>).resume(valuesLeft[0])\n            }\n        } else {\n            val value = last.valuesLeft.removeAt(last.valuesLeft.lastIndex)\n            (clone(last.cont) as Continuation<Any?>).resume(value)\n        }\n    }\n\n    if (toThrow != null)\n    {\n        throw toThrow!!\n    }\n    else if (result != null)\n    {\n        return result!!\n    }\n    else\n    {\n        throw AmbException()\n    }\n}\n\nval UNSAFE = Class.forName(\"sun.misc.Unsafe\")\n    .getDeclaredField(\"theUnsafe\")\n    .apply { isAccessible = true }\n    .get(null) as sun.misc.Unsafe\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <T: Any> clone(obj: T): T {\n    val clazz = obj::class.java\n    val copy = UNSAFE.allocateInstance(clazz) as T\n    copyDeclaredFields(obj, copy, clazz)\n    return copy\n}\n\ntailrec fun <T> copyDeclaredFields(obj: T, copy: T, clazz: Class<out T>) {\n    for (field in clazz.declaredFields) {\n        field.isAccessible = true\n        val v = field.get(obj)\n        field.set(copy, if (v === obj) copy else v)\n    }\n    val superclass = clazz.superclass\n    if (superclass != null) copyDeclaredFields(obj, copy, superclass)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun sumProperDivisors(n: Int): Int {\n    if (n < 2) return 0\n    return (1..n / 2).filter{ (n % it) == 0 }.sum()\n}\n\nfun main(args: Array<String>) {\n    val sum = IntArray(20000, { sumProperDivisors(it) } )\n    println(\"The pairs of amicable numbers below 20,000 are:\\n\")\n    for(n in 2..19998) {\n        val m = sum[n]\n        if (m > n && m < 20000 && n == sum[m]) {\n            println(n.toString().padStart(5) + \" and \" + m.toString().padStart(5))\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\n\nfun isDeranged(s1: String, s2: String): Boolean {\n    return (0 until s1.length).none { s1[it] == s2[it] }\n}\n\nfun main(args: Array<String>) {\n    val url = URL(\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) {\n            anagrams.put(key, mutableListOf<String>())\n            anagrams[key]!!.add(word)\n        }\n        else {\n            val deranged = anagrams[key]!!.any { isDeranged(it, word) }\n            if (deranged) {\n                anagrams[key]!!.add(word)\n                count = Math.max(count, word.length)\n            }\n        }\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size > 1 && it[0].length == count }\n        .forEach { println(it) }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\nimport kotlin.math.max\n\nfun main() {\n    val url = URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) anagrams[key] = mutableListOf()\n        anagrams[key]?.add(word)\n        count = max(count, anagrams[key]?.size ?: 0)\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size == count }\n        .forEach { println(it) }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.awt.*\nimport java.util.concurrent.*\nimport javax.swing.*\n\nclass Pendulum(private val length: Int) : JPanel(), Runnable {\n    init {\n        val f = JFrame(\"Pendulum\")\n        f.add(this)\n        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        f.pack()\n        f.isVisible = true\n        isDoubleBuffered = true\n    }\n\n    override fun paint(g: Graphics) {\n        with(g) {\n            color = Color.WHITE\n            fillRect(0, 0, width, height)\n            color = Color.BLACK\n            val anchor = Element(width / 2, height / 4)\n            val ball = Element((anchor.x + Math.sin(angle) * length).toInt(), (anchor.y + Math.cos(angle) * length).toInt())\n            drawLine(anchor.x, anchor.y, ball.x, ball.y)\n            fillOval(anchor.x - 3, anchor.y - 4, 7, 7)\n            fillOval(ball.x - 7, ball.y - 7, 14, 14)\n        }\n    }\n\n    override fun run() {\n        angleVelocity += -9.81 / length * Math.sin(angle) * dt\n        angle += angleVelocity * dt\n        repaint()\n    }\n\n    override fun getPreferredSize() = Dimension(2 * length + 50, length / 2 * 3)\n\n    private data class Element(val x: Int, val y: Int)\n\n    private val dt = 0.1\n    private var angle = Math.PI / 2\n    private var angleVelocity = 0.0\n}\n\nfun main(a: Array<String>) {\n    val executor = Executors.newSingleThreadScheduledExecutor()\n    executor.scheduleAtFixedRate(Pendulum(200), 0, 15, TimeUnit.MILLISECONDS)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.0\n\nimport java.awt.Dimension\nimport java.awt.event.MouseAdapter\nimport java.awt.event.MouseEvent\nimport java.util.*\nimport javax.swing.JFrame\nimport javax.swing.JLabel\n\nclass Rotate : JFrame() {\n    val text = \"Hello World! \"\n    val label = JLabel(text)\n    var rotRight = true\n    var startIdx = 0\n\n    init {\n        preferredSize = Dimension(96, 64)\n        label.addMouseListener(object: MouseAdapter() {\n            override fun mouseClicked(evt: MouseEvent) {\n                rotRight = !rotRight\n            }\n        })\n        add(label)\n        pack()\n        defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        isVisible = true\n    }\n}\n\nfun getRotatedText(text: String, startIdx: Int): String {\n    val ret = StringBuilder()\n    var i = startIdx\n    do {\n        ret.append(text[i++])\n        i %= text.length\n    }\n    while (i != startIdx)\n    return ret.toString()\n}\n\nfun main(args: Array<String>) {\n    val rot = Rotate()\n    val task = object : TimerTask() {\n        override fun run() {\n            if (rot.rotRight) {\n                if (--rot.startIdx < 0) rot.startIdx += rot.text.length\n            }\n            else {\n                if (++rot.startIdx >= rot.text.length) rot.startIdx -= rot.text.length\n            }\n            rot.label.text = getRotatedText(rot.text, rot.startIdx)\n        }\n    }\n    Timer(false).schedule(task, 0, 500)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun fib(n: Int): Int {\n   require(n >= 0)\n   fun fib1(k: Int, a: Int, b: Int): Int =\n       if (k == 0) a else fib1(k - 1, b, a + b)\n   return fib1(n, 0, 1)\n}\n\nfun main(args: Array<String>) {\n    for (i in 0..20) print(\"${fib(i)} \")\n    println()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.41\n\nimport java.io.File\n\nclass Record(\n    val account: String,\n    val password: String,\n    val uid: Int,\n    val gid: Int,\n    val gecos: List<String>,\n    val directory: String,\n    val shell: String\n){\n    override fun toString() =\n        \"$account:$password:$uid:$gid:${gecos.joinToString(\",\")}:$directory:$shell\"\n}\n\nfun parseRecord(line: String): Record {\n    val fields = line.split(':')\n    return Record(\n        fields[0],\n        fields[1],\n        fields[2].toInt(),\n        fields[3].toInt(),\n        fields[4].split(','),\n        fields[5],\n        fields[6]\n    )\n}\n\nfun main(args: Array<String>) {\n    val startData = listOf(\n        \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n        \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\"\n    )\n    val records = startData.map { parseRecord(it) }\n    val f = File(\"passwd.csv\")\n    f.printWriter().use {\n        for (record in records) it.println(record)\n    }\n    println(\"Initial records:\\n\")\n    f.forEachLine {\n        println(parseRecord(it))\n    }\n\n    val newData = \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n    val record = parseRecord(newData)\n    if (!f.setWritable(true, true)) {\n        println(\"\\nFailed to make file writable only by owner\\n.\")\n    }\n    f.appendText(\"$record\\n\")\n    println(\"\\nRecords after another one is appended:\\n\")\n    f.forEachLine {\n        println(parseRecord(it))\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)  // build\n    val function = { i: Int -> i * i } // function to apply\n    val list = array.map { function(it) } // process each item\n    println(list) // print results\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigInteger\n\nfun main(args: Array<String>) {\n    val x = BigInteger.valueOf(5).pow(Math.pow(4.0, 3.0 * 3.0).toInt())\n    val y = x.toString()\n    val len = y.length\n    println(\"5^4^3^2 = ${y.substring(0, 20)}...${y.substring(len - 20)} and has $len digits\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    memScoped {\n        val intVar1 = alloc<IntVar>()\n        intVar1.value = 1\n        val intVar2 = alloc<IntVar>()\n        intVar2.value = 2\n        println(\"${intVar1.value} + ${intVar2.value} = ${intVar1.value + intVar2.value}\")\n    }\n    // native memory used by intVar1 & intVar2 is automatically freed when memScoped block ends\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class Complex(private val real: Double, private val imag: Double) {\n    operator fun plus(other: Complex) = Complex(real + other.real, imag + other.imag)\n\n    operator fun times(other: Complex) = Complex(\n        real * other.real - imag * other.imag,\n        real * other.imag + imag * other.real\n    )\n\n    fun inv(): Complex {\n        val denom = real * real + imag * imag\n        return Complex(real / denom, -imag / denom)\n    }\n\n    operator fun unaryMinus() = Complex(-real, -imag)\n\n    operator fun minus(other: Complex) = this + (-other)\n\n    operator fun div(other: Complex) = this * other.inv()\n\n    fun conj() = Complex(real, -imag)\n\n    override fun toString() =\n        if (imag >= 0.0) \"$real + ${imag}i\"\n        else \"$real - ${-imag}i\"\n}\n\nfun main(args: Array<String>) {\n    val x = Complex(1.0, 3.0)\n    val y = Complex(5.0, 2.0)\n    println(\"x     =  $x\")\n    println(\"y     =  $y\")\n    println(\"x + y =  ${x + y}\")\n    println(\"x - y =  ${x - y}\")\n    println(\"x * y =  ${x * y}\")\n    println(\"x / y =  ${x / y}\")\n    println(\"-x    =  ${-x}\")\n    println(\"1 / x =  ${x.inv()}\")\n    println(\"x*    =  ${x.conj()}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.10\n\n/* if string is empty, returns zero */\nfun String.toDoubleOrZero() = this.toDoubleOrNull() ?: 0.0\n\nfun multiply(s: String): String {\n    val b = s.split('*').map { it.toDoubleOrZero() }\n    return (b[0] * b[1]).toString()\n}\n\nfun divide(s: String): String {\n    val b = s.split('/').map { it.toDoubleOrZero() }\n    return (b[0] / b[1]).toString()\n}\n\nfun add(s: String): String {\n    var t = s.replace(Regex(\"\"\"^\\+\"\"\"), \"\").replace(Regex(\"\"\"\\++\"\"\"), \"+\")\n    val b = t.split('+').map { it.toDoubleOrZero() }\n    return (b[0] + b[1]).toString()\n}\n\nfun subtract(s: String): String {\n    var t = s.replace(Regex(\"\"\"(\\+-|-\\+)\"\"\"), \"-\")\n    if (\"--\" in t) return add(t.replace(\"--\", \"+\"))\n    val b = t.split('-').map { it.toDoubleOrZero() }\n    return (if (b.size == 3) -b[1] - b[2] else b[0] - b[1]).toString()\n}\n\nfun evalExp(s: String): String {\n    var t = s.replace(Regex(\"\"\"[()]\"\"\"), \"\")\n    val reMD = Regex(\"\"\"\\d+\\.?\\d*\\s*[*/]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reM  = Regex( \"\"\"\\*\"\"\")\n    val reAS = Regex(\"\"\"-?\\d+\\.?\\d*\\s*[+-]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reA  = Regex(\"\"\"\\d\\+\"\"\")\n\n    while (true) {\n        val match = reMD.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reM.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, multiply(exp))\n            else\n                t.replace(exp, divide(exp))\n    }\n\n    while (true) {\n        val match = reAS.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reA.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, add(exp))\n            else\n                t.replace(exp, subtract(exp))\n    }\n\n    return t\n}\n\nfun evalArithmeticExp(s: String): Double {\n    var t = s.replace(Regex(\"\"\"\\s\"\"\"), \"\").replace(\"\"\"^\\+\"\"\", \"\")\n    val rePara = Regex(\"\"\"\\([^()]*\\)\"\"\")\n    while(true) {\n        val match = rePara.find(t)\n        if (match == null) break\n        val exp = match.value\n        t = t.replace(exp, evalExp(exp))\n    }\n    return evalExp(t).toDoubleOrZero()\n}\n\nfun main(arsg: Array<String>) {\n    listOf(\n        \"2+3\",\n        \"2+3/4\",\n        \"2*3-4\",\n        \"2*(3+4)+5/6\",\n        \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n        \"2*-3--4+-0.25\",\n         \"-4 - 3\",\n         \"((((2))))+ 3 * 5\",\n         \"1 + 2 * (3 + (4 * 5 + 6 * 7 * 8) - 9) / 10\",\n         \"1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22/(7 + 2*(3 - 1)) - 1)) + 1\"\n    ).forEach { println(\"$it = ${evalArithmeticExp(it)}\") }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.math.MathContext\n\nval con1024 = MathContext(1024)\nval bigTwo  = BigDecimal(2)\nval bigFour = bigTwo * bigTwo\n\nfun bigSqrt(bd: BigDecimal, con: MathContext): BigDecimal {\n    var x0 = BigDecimal.ZERO\n    var x1 = BigDecimal.valueOf(Math.sqrt(bd.toDouble()))\n    while (x0 != x1) {\n        x0 = x1\n        x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con)\n    }\n    return x1\n}\n\nfun main(args: Array<String>) {\n    var a = BigDecimal.ONE\n    var g = a.divide(bigSqrt(bigTwo, con1024), con1024)\n    var t : BigDecimal\n    var sum = BigDecimal.ZERO\n    var pow = bigTwo\n    while (a != g) {\n        t = (a + g).divide(bigTwo, con1024)\n        g = bigSqrt(a * g, con1024)\n        a = t\n        pow *= bigTwo\n        sum += (a * a - g * g) * pow\n    }\n    val pi = (bigFour * a * a).divide(BigDecimal.ONE - sum, con1024)\n    println(pi)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun agm(a: Double, g: Double): Double {\n    var aa = a             // mutable 'a'\n    var gg = g             // mutable 'g'\n    var ta: Double         // temporary variable to hold next iteration of 'aa'\n    val epsilon = 1.0e-16  // tolerance for checking if limit has been reached\n\n    while (true) {\n        ta = (aa + gg) / 2.0\n        if (Math.abs(aa - ta) <= epsilon) return ta\n        gg = Math.sqrt(aa * gg)\n        aa = ta\n    }\n}\n\nfun main(args: Array<String>) {\n    println(agm(1.0, 1.0 / Math.sqrt(2.0)))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun main(args: Array<String>) {\n    val r = Regex(\"\"\"-?\\d+[ ]+-?\\d+\"\"\")\n    while(true) {\n        print(\"Enter two integers separated by space(s) or q to quit: \")\n        val input: String = readLine()!!.trim()\n        if (input == \"q\" || input == \"Q\") break\n        if (!input.matches(r)) {\n            println(\"Invalid input, try again\")\n            continue\n        }\n        val index = input.lastIndexOf(' ')\n        val a = input.substring(0, index).trimEnd().toLong()\n        val b = input.substring(index + 1).toLong()\n        println(\"$a + $b = ${a + b}\")\n        println(\"$a - $b = ${a - b}\")\n        println(\"$a * $b = ${a * b}\")\n        if (b != 0L) {\n            println(\"$a / $b = ${a / b}\")  // rounds towards zero\n            println(\"$a % $b = ${a % b}\")  // if non-zero, matches sign of first operand\n        }\n        else {\n            println(\"$a / $b = undefined\")\n            println(\"$a % $b = undefined\")\n        }\n        val d = Math.pow(a.toDouble(), b.toDouble())\n        print(\"$a ^ $b = \")\n        if (d % 1.0 == 0.0) {\n            if (d >= Long.MIN_VALUE.toDouble() && d <= Long.MAX_VALUE.toDouble())\n                println(\"${d.toLong()}\")\n            else\n                println(\"out of range\")\n        }\n        else if (!d.isFinite())\n            println(\"not finite\")\n        else\n            println(\"not integral\")\n        println()\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nfun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\n\ninfix fun Long.ldiv(denom: Long) = Frac(this, denom)\n\ninfix fun Int.idiv(denom: Int) = Frac(this.toLong(), denom.toLong())\n\nfun Long.toFrac() = Frac(this, 1)\n\nfun Int.toFrac() = Frac(this.toLong(), 1)\n\nclass Frac : Comparable<Frac> {\n    val num: Long\n    val denom: Long\n\n    companion object {\n        val ZERO = Frac(0, 1)\n        val ONE  = Frac(1, 1)\n    }\n\n    constructor(n: Long, d: Long) {\n        require(d != 0L)\n        var nn = n\n        var dd = d\n        if (nn == 0L) {\n            dd = 1\n        }\n        else if (dd < 0) {\n            nn = -nn\n            dd = -dd\n        }\n        val g = Math.abs(gcd(nn, dd))\n        if (g > 1) {\n            nn /= g\n            dd /= g\n        }\n        num = nn\n        denom = dd\n    }\n\n    constructor(n: Int, d: Int) : this(n.toLong(), d.toLong())\n\n    operator fun plus(other: Frac) =\n        Frac(num * other.denom + denom * other.num, other.denom * denom)\n\n    operator fun unaryPlus() = this\n\n    operator fun unaryMinus() = Frac(-num, denom)\n\n    operator fun minus(other: Frac) = this + (-other)\n\n    operator fun times(other: Frac) = Frac(this.num * other.num, this.denom * other.denom)\n\n    operator fun rem(other: Frac) = this - Frac((this / other).toLong(), 1) * other\n\n    operator fun inc() = this + ONE\n    operator fun dec() = this - ONE\n\n    fun inverse(): Frac {\n        require(num != 0L)\n        return Frac(denom, num)\n    }\n\n    operator fun div(other: Frac) = this * other.inverse()\n\n    fun abs() = if (num >= 0) this else -this\n\n    override fun compareTo(other: Frac): Int {\n        val diff = this.toDouble() - other.toDouble()\n        return when {\n            diff < 0.0  -> -1\n            diff > 0.0  -> +1\n            else        ->  0\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n       if (other == null || other !is Frac) return false\n       return this.compareTo(other) == 0\n    }\n\n    override fun hashCode() = num.hashCode() xor denom.hashCode()\n\n    override fun toString() = if (denom == 1L) \"$num\" else \"$num/$denom\"\n\n    fun toDouble() = num.toDouble() / denom\n\n    fun toLong() = num / denom\n}\n\nfun isPerfect(n: Long): Boolean {\n    var sum = Frac(1, n)\n    val limit = Math.sqrt(n.toDouble()).toLong()\n    for (i in 2L..limit) {\n        if (n % i == 0L) sum += Frac(1, i) + Frac(1, n / i)\n    }\n    return sum == Frac.ONE\n}\n\nfun main(args: Array<String>) {\n    var frac1 = Frac(12, 3)\n    println (\"frac1 = $frac1\")\n    var frac2 = 15 idiv 2\n    println(\"frac2 = $frac2\")\n    println(\"frac1 <= frac2 is ${frac1 <= frac2}\")\n    println(\"frac1 >= frac2 is ${frac1 >= frac2}\")\n    println(\"frac1 == frac2 is ${frac1 == frac2}\")\n    println(\"frac1 != frac2 is ${frac1 != frac2}\")\n    println(\"frac1 + frac2 = ${frac1 + frac2}\")\n    println(\"frac1 - frac2 = ${frac1 - frac2}\")\n    println(\"frac1 * frac2 = ${frac1 * frac2}\")\n    println(\"frac1 / frac2 = ${frac1 / frac2}\")\n    println(\"frac1 % frac2 = ${frac1 % frac2}\")\n    println(\"inv(frac1)    = ${frac1.inverse()}\")\n    println(\"abs(-frac1)   = ${-frac1.abs()}\")\n    println(\"inc(frac2)    = ${++frac2}\")\n    println(\"dec(frac2)    = ${--frac2}\")\n    println(\"dbl(frac2)    = ${frac2.toDouble()}\")\n    println(\"lng(frac2)    = ${frac2.toLong()}\")\n    println(\"\\nThe Perfect numbers less than 2^19 are:\")\n    // We can skip odd numbers as no known perfect numbers are odd\n    for (i in 2 until (1 shl 19) step 2) {\n        if (isPerfect(i.toLong())) print(\"  $i\")\n    }\n    println()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val a: Array<Int> = arrayOf(1, 2, 3) // initialise a\n    val b: Array<Int> = arrayOf(4, 5, 6) // initialise b\n    val c: Array<Int> = (a.toList() + b.toList()).toTypedArray()\n    println(c)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun arrayConcat(a: Array<Any>, b: Array<Any>): Array<Any> {\n    return Array(a.size + b.size, { if (it in a.indices) a[it] else b[it - a.size] })\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val a: Collection<Int> = listOf(1, 2, 3) // initialise a\n    val b: Collection<Int> = listOf(4, 5, 6) // initialise b\n    val c: Collection<Int> = a + b\n    println(c)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(x: Array<String>) {\n    var a = arrayOf(1, 2, 3, 4)\n    println(a.asList())\n    a += 5\n    println(a.asList())\n    println(a.reversedArray().asList())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6 (assert.kt)\n\nfun main(args: Array<String>) {\n   val a = 42\n   assert(a == 43)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    // map definition:\n    val map = mapOf(\"foo\" to 5,\n                    \"bar\" to 10,\n                    \"baz\" to 15,\n                    \"foo\" to 6)\n\n    // retrieval:\n    println(map[\"foo\"]) // => 6\n    println(map[\"invalid\"]) // => null\n\n    // check keys:\n    println(\"foo\" in map) // => true\n    println(\"invalid\" in map) // => false\n\n    // iterate over keys:\n    for (k in map.keys) print(\"$k \")\n    println()\n\n    // iterate over values:\n    for (v in map.values) print(\"$v \")\n    println()\n\n    // iterate over key, value pairs:\n    for ((k, v) in map) println(\"$k => $v\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(a: Array<String>) {\n    val map = mapOf(\"hello\" to 1, \"world\" to 2, \"!\" to 3)\n\n    with(map) {\n        entries.forEach { println(\"key = ${it.key}, value = ${it.value}\") }\n        keys.forEach { println(\"key = $it\") }\n        values.forEach { println(\"value = $it\") }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.0\n\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.concurrent.thread\n\nconst val NUM_BUCKETS = 10\n\nclass Buckets(data: IntArray) {\n    private val data = data.copyOf()\n\n    operator fun get(index: Int) = synchronized(data) { data[index] }\n\n    fun transfer(srcIndex: Int, dstIndex: Int, amount: Int): Int {\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Negative amount: $amount\")\n        }\n        if (amount == 0) return 0\n        synchronized(data) {\n            var a = amount\n            if (data[srcIndex] - a < 0) a = data[srcIndex]\n            if (data[dstIndex] + a < 0) a = Int.MAX_VALUE - data[dstIndex]\n            if (a < 0) throw IllegalStateException()\n            data[srcIndex] -= a\n            data[dstIndex] += a\n            return a\n        }\n    }\n\n    val buckets get() = synchronized(data) { data.copyOf() }\n\n    fun transferRandomAmount() {\n        val rnd = ThreadLocalRandom.current()\n        while (true) {\n            val srcIndex = rnd.nextInt(NUM_BUCKETS)\n            val dstIndex = rnd.nextInt(NUM_BUCKETS)\n            val amount = rnd.nextInt() and Int.MAX_VALUE\n            transfer(srcIndex, dstIndex, amount)\n        }\n    }\n\n    fun equalize() {\n        val rnd = ThreadLocalRandom.current()\n        while (true) {\n            val srcIndex = rnd.nextInt(NUM_BUCKETS)\n            val dstIndex = rnd.nextInt(NUM_BUCKETS)\n            val amount = (this[srcIndex] - this[dstIndex]) / 2\n            if (amount >= 0) transfer(srcIndex, dstIndex, amount)\n        }\n    }\n\n    fun print() {\n        while (true) {\n            val nextPrintTime = System.currentTimeMillis() + 3000\n            while (true) {\n                val now = System.currentTimeMillis()\n                if (now >= nextPrintTime) break\n                try {\n                    Thread.sleep(nextPrintTime - now)\n                }\n                catch (e: InterruptedException) {\n                    return\n                }\n            }\n            val bucketValues = buckets\n            println(\"Current values: ${bucketValues.total} ${bucketValues.asList()}\")\n        }\n    }\n}\n\nval IntArray.total: Long get() {\n    var sum = 0L\n    for (d in this) sum += d\n    return sum\n}\n\nfun main(args: Array<String>) {\n    val rnd = ThreadLocalRandom.current()\n    val values = IntArray(NUM_BUCKETS) { rnd.nextInt() and Int.MAX_VALUE }\n    println(\"Initial array:  ${values.total} ${values.asList()}\")\n    val buckets = Buckets(values)\n    thread(name = \"equalizer\")   { buckets.equalize() }\n    thread(name = \"transferrer\") { buckets.transferRandomAmount() }\n    thread(name = \"printer\")     { buckets.print() }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "const val NMAX  = 20\nconst val TESTS = 1000000\nval rand = java.util.Random()\n\nfun avg(n: Int): Double {\n    var sum = 0\n    for (t in 0 until TESTS) {\n        val v = BooleanArray(NMAX)\n        var x = 0\n        while (!v[x]) {\n            v[x] = true\n            sum++\n            x = rand.nextInt(n)\n        }\n    }\n    return sum.toDouble() / TESTS\n}\n\nfun ana(n: Int): Double {\n    val nn = n.toDouble()\n    var term = 1.0\n    var sum = 1.0\n    for (i in n - 1 downTo 1) {\n        term *= i / nn\n        sum += term\n    }\n    return sum\n}\n\nfun main(args: Array<String>) {\n    println(\" N    average    analytical    (error)\")\n    println(\"===  =========  ============  =========\")\n    for (n in 1..NMAX) {\n        val a = avg(n)\n        val b = ana(n)\n        println(String.format(\"%3d   %6.4f   %10.4f      (%4.2f%%)\", n, a, b, Math.abs(a - b) / b * 100.0))\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val nums = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)\n    println(\"average = %f\".format(nums.average()))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun meanAngle(angles: DoubleArray): Double {\n    val sinSum = angles.sumByDouble {  Math.sin(it * Math.PI / 180.0) }\n    val cosSum = angles.sumByDouble {  Math.cos(it * Math.PI / 180.0) }\n    return Math.atan2(sinSum / angles.size, cosSum / angles.size) * 180.0 / Math.PI\n}\n\nfun main(args: Array<String>) {\n    val angles1 = doubleArrayOf(350.0, 10.0)\n    val angles2 = doubleArrayOf(90.0, 180.0, 270.0, 360.0)\n    val angles3 = doubleArrayOf(10.0, 20.0, 30.0)\n    val fmt  = \"%.2f degrees\" // format results to 2 decimal places\n    println(\"Mean for angles 1 is ${fmt.format(meanAngle(angles1))}\")\n    println(\"Mean for angles 2 is ${fmt.format(meanAngle(angles2))}\")\n    println(\"Mean for angles 3 is ${fmt.format(meanAngle(angles3))}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nfun meanAngle(angles: DoubleArray): Double {\n    val sinSum = angles.sumByDouble {  Math.sin(it * Math.PI / 180.0) }\n    val cosSum = angles.sumByDouble {  Math.cos(it * Math.PI / 180.0) }\n    return Math.atan2(sinSum / angles.size, cosSum / angles.size) * 180.0 / Math.PI\n}\n\n/* time string assumed to be in format \"hh:mm:ss\" */\nfun timeToSecs(t: String): Int {\n    val hours = t.slice(0..1).toInt()\n    val mins  = t.slice(3..4).toInt()\n    val secs  = t.slice(6..7).toInt()\n    return 3600 * hours + 60 * mins + secs\n}\n\n/* 1 second of time = 360/(24 * 3600) = 1/240th degree */\nfun timeToDegrees(t: String): Double = timeToSecs(t) / 240.0\n\nfun degreesToTime(d: Double): String {\n    var dd = d\n    if (dd < 0.0) dd += 360.0\n    var secs  = (dd * 240.0).toInt()\n    val hours = secs / 3600\n    var mins  = secs % 3600\n    secs  = mins % 60\n    mins /= 60\n    return String.format(\"%2d:%2d:%2d\", hours, mins, secs)\n}\n\nfun main(args: Array<String>) {\n    val tm = arrayOf(\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\")\n    val angles = DoubleArray(4) { timeToDegrees(tm[it]) }\n    val mean = meanAngle(angles)\n    println(\"Average time is : ${degreesToTime(mean)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun median(l: List<Double>) = l.sorted().let { (it[it.size / 2] + it[(it.size - 1) / 2]) / 2 }\n\nfun main(args: Array<String>) {\n    median(listOf(5.0, 3.0, 4.0)).let { println(it) }  // 4\n    median(listOf(5.0, 4.0, 2.0, 3.0)).let { println(it) }  // 3.5\n    median(listOf(3.0, 4.0, 1.0, -8.4, 7.2, 4.0, 1.0, 1.2)).let { println(it) }  // 2.1\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun <T> modeOf(a: Array<T>) {\n    val sortedByFreq = a.groupBy { it }.entries.sortedByDescending { it.value.size }\n    val maxFreq = sortedByFreq.first().value.size\n    val modes = sortedByFreq.takeWhile { it.value.size == maxFreq }\n    if (modes.size == 1)\n       println(\"The mode of the collection is ${modes.first().key} which has a frequency of $maxFreq\")\n    else {\n       print(\"There are ${modes.size} modes with a frequency of $maxFreq, namely : \")\n       println(modes.map { it.key }.joinToString(\", \"))\n    }\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(7, 1, 1, 6, 2, 4, 2, 4, 2, 1, 5)\n    println(\"[\" + a.joinToString(\", \") + \"]\")\n    modeOf(a)\n    println()\n    val b = arrayOf(true, false, true, false, true, true)\n    println(\"[\" + b.joinToString(\", \") + \"]\")\n    modeOf(b)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun Collection<Double>.geometricMean() =\n    if (isEmpty()) Double.NaN\n    else Math.pow(reduce { n1, n2 -> n1 * n2 }, 1.0 / size)\n\nfun Collection<Double>.harmonicMean() =\n    if (isEmpty() || contains(0.0)) Double.NaN\n    else size / reduce { n1, n2 -> n1 + 1.0 / n2 }\n\nfun main(args: Array<String>) {\n    val list = listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)\n    val a = list.average()  // arithmetic mean\n    val g = list.geometricMean()\n    val h = list.harmonicMean()\n    println(\"A = %f  G = %f  H = %f\".format(a, g, h))\n    println(\"A >= G is %b, G >= H is %b\".format(a >= g, g >= h))\n    require(g in h..a)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun quadraticMean(vector: Array<Double>) : Double {\n    val sum = vector.sumByDouble { it * it }\n    return Math.sqrt(sum / vector.size)\n}\n\nfun main(args: Array<String>) {\n    val vector = Array(10, { (it + 1).toDouble() })\n    print(\"Quadratic mean of numbers 1 to 10 is ${quadraticMean(vector)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nfun initMovingAverage(p: Int): (Double) -> Double {\n    if (p < 1) throw IllegalArgumentException(\"Period must be a positive integer\")\n    val list = mutableListOf<Double>()\n    return {\n        list.add(it)\n        if (list.size > p) list.removeAt(0)\n        list.average()\n    }\n}\n\nfun main(args: Array<String>) {\n    val sma4 = initMovingAverage(4)\n    val sma5 = initMovingAverage(5)\n    val numbers = listOf(1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 4.0, 3.0, 2.0, 1.0)\n    println(\"num\\tsma4\\tsma5\\n\")\n    for (number in numbers) println(\"${number}\\t${sma4(number)}\\t${sma5(number)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\n\nfun isBalanced(s: String): Boolean {\n    if (s.isEmpty()) return true\n    var countLeft = 0  // number of left brackets so far unmatched\n    for (c in s) {\n        if (c == '[') countLeft++\n        else if (countLeft > 0) countLeft--\n        else return false\n    }\n    return countLeft == 0\n}\n\nfun main(args: Array<String>) {\n    println(\"Checking examples in task description:\")\n    val brackets = arrayOf(\"\", \"[]\", \"][\", \"[][]\", \"][][\", \"[[][]]\", \"[]][[]\")\n    for (b in brackets) {\n        print(if (b != \"\") b else \"(empty)\")\n        println(\"\\t  \" + if (isBalanced(b)) \"OK\" else \"NOT OK\")\n    }\n    println()\n\n    println(\"Checking 7 random strings of brackets of length 8:\")\n    val r = Random()\n    (1..7).forEach {\n        var s = \"\"\n        for (j in 1..8) {\n            s += if (r.nextInt(2) == 0) '[' else ']'\n        }\n        println(\"$s  \" + if (isBalanced(s)) \"OK\" else \"NOT OK\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\nimport java.math.BigInteger\n\nval bigZero = BigInteger.ZERO\nval bigOne = BigInteger.ONE\nval bigThree = BigInteger.valueOf(3L)\n\ndata class BTernary(private var value: String) : Comparable<BTernary> {\n\n    init {\n        require(value.all { it in \"0+-\" })\n        value = value.trimStart('0')\n    }\n\n    constructor(v: Int) : this(BigInteger.valueOf(v.toLong()))\n\n    constructor(v: BigInteger) : this(\"\") {\n        value = toBT(v)\n    }\n\n    private fun toBT(v: BigInteger): String {\n        if (v < bigZero) return flip(toBT(-v))\n        if (v == bigZero) return \"\"\n        val rem = mod3(v)\n        return when (rem) {\n            bigZero -> toBT(v / bigThree) + \"0\"\n            bigOne  -> toBT(v / bigThree) + \"+\"\n            else    -> toBT((v + bigOne) / bigThree) + \"-\"\n        }\n    }\n\n    private fun flip(s: String): String {\n        val sb = StringBuilder()\n        for (c in s) {\n            sb.append(when (c) {\n                '+'  -> \"-\"\n                '-'  -> \"+\"\n                else -> \"0\"\n            })\n        }\n        return sb.toString()\n    }\n\n    private fun mod3(v: BigInteger): BigInteger {\n        if (v > bigZero) return v % bigThree\n        return ((v % bigThree) + bigThree) % bigThree\n    }\n\n    fun toBigInteger(): BigInteger {\n        val len = value.length\n        var sum = bigZero\n        var pow = bigOne\n        for (i in 0 until len) {\n            val c = value[len - i - 1]\n            val dig = when (c) {\n                '+'  -> bigOne\n                '-'  -> -bigOne\n                else -> bigZero\n            }\n            if (dig != bigZero) sum += dig * pow\n            pow *= bigThree\n        }\n        return sum\n    }\n\n    private fun addDigits(a: Char, b: Char, carry: Char): String {\n        val sum1 = addDigits(a, b)\n        val sum2 = addDigits(sum1.last(), carry)\n        return when {\n            sum1.length == 1 -> sum2\n            sum2.length == 1 -> sum1.take(1) + sum2\n            else             -> sum1.take(1)\n        }\n    }\n\n    private fun addDigits(a: Char, b: Char): String =\n        when {\n            a == '0' -> b.toString()\n            b == '0' -> a.toString()\n            a == '+' -> if (b == '+') \"+-\" else \"0\"\n            else     -> if (b == '+') \"0\" else \"-+\"\n        }\n\n    operator fun plus(other: BTernary): BTernary {\n        var a = this.value\n        var b = other.value\n        val longer = if (a.length > b.length) a else b\n        var shorter = if (a.length > b.length) b else a\n        while (shorter.length < longer.length) shorter = \"0\" + shorter\n        a = longer\n        b = shorter\n        var carry = '0'\n        var sum = \"\"\n        for (i in 0 until a.length) {\n            val place = a.length - i - 1\n            val digisum = addDigits(a[place], b[place], carry)\n            carry = if (digisum.length != 1) digisum[0] else '0'\n            sum = digisum.takeLast(1) + sum\n        }\n        sum = carry.toString() + sum\n        return BTernary(sum)\n    }\n\n    operator fun unaryMinus() = BTernary(flip(this.value))\n\n    operator fun minus(other: BTernary) = this + (-other)\n\n    operator fun times(other: BTernary): BTernary {\n        var that = other\n        val one = BTernary(1)\n        val zero = BTernary(0)\n        var mul = zero\n        var flipFlag = false\n        if (that < zero) {\n            that = -that\n            flipFlag = true\n        }\n        var i = one\n        while (i <= that) {\n            mul += this\n            i += one\n        }\n        if (flipFlag) mul = -mul\n        return mul\n    }\n\n    override operator fun compareTo(other: BTernary) =\n        this.toBigInteger().compareTo(other.toBigInteger())\n\n    override fun toString() = value\n}\n\nfun main(args: Array<String>) {\n    val a = BTernary(\"+-0++0+\")\n    val b = BTernary(-436)\n    val c = BTernary(\"+-++-\")\n    println(\"a = ${a.toBigInteger()}\")\n    println(\"b = ${b.toBigInteger()}\")\n    println(\"c = ${c.toBigInteger()}\")\n    val bResult = a * (b - c)\n    val iResult = bResult.toBigInteger()\n    println(\"a * (b - c) = $bResult = $iResult\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigInteger\n\ninterface NumberGenerator {\n    val numbers: Array<BigInteger>\n}\n\nclass Benford(ng: NumberGenerator) {\n    override fun toString() = str\n\n    private val firstDigits = IntArray(9)\n    private val count = ng.numbers.size.toDouble()\n    private val str: String\n\n    init {\n        for (n in ng.numbers) {\n            firstDigits[n.toString().substring(0, 1).toInt() - 1]++\n        }\n\n        str = with(StringBuilder()) {\n            for (i in firstDigits.indices) {\n                append(i + 1).append('\\t').append(firstDigits[i] / count)\n                append('\\t').append(Math.log10(1 + 1.0 / (i + 1))).append('\\n')\n            }\n\n            toString()\n        }\n    }\n}\n\nobject FibonacciGenerator : NumberGenerator {\n    override val numbers: Array<BigInteger> by lazy {\n        val fib = Array<BigInteger>(1000, { BigInteger.ONE })\n        for (i in 2 until fib.size)\n            fib[i] = fib[i - 2].add(fib[i - 1])\n        fib\n    }\n}\n\nfun main(a: Array<String>) = println(Benford(FibonacciGenerator))\n"
  },
  {
    "language": "Kotlin",
    "code": "import org.apache.commons.math3.fraction.BigFraction\n\nobject Bernoulli {\n    operator fun invoke(n: Int) : BigFraction {\n        val A = Array(n + 1, init)\n        for (m in 0..n)\n            for (j in m downTo 1)\n                A[j - 1] = A[j - 1].subtract(A[j]).multiply(integers[j])\n        return A.first()\n    }\n\n    val max = 60\n\n    private val init = { m: Int -> BigFraction(1, m + 1) }\n    private val integers = Array(max + 1, { m: Int -> BigFraction(m) } )\n}\n\nfun main(args: Array<String>) {\n    for (n in 0..Bernoulli.max)\n        if (n % 2 == 0 || n == 1)\n            System.out.printf(\"B(%-2d) = %-1s%n\", n, Bernoulli(n))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\n\nobject BestShuffle {\n    operator fun invoke(s1: String) : String {\n        val s2 = s1.toCharArray()\n        s2.shuffle()\n        for (i in s2.indices)\n            if (s2[i] == s1[i])\n                for (j in s2.indices)\n                    if (s2[i] != s2[j] && s2[i] != s1[j] && s2[j] != s1[i]) {\n                        val tmp = s2[i]\n                        s2[i] = s2[j]\n                        s2[j] = tmp\n                        break\n                    }\n        return s1 + ' ' + String(s2) + \" (\" + s2.count(s1) + ')'\n    }\n\n    private fun CharArray.shuffle() {\n        val rand = Random()\n        for (i in size - 1 downTo 1) {\n            val r = rand.nextInt(i + 1)\n            val tmp = this[i]\n            this[i] = this[r]\n            this[r] = tmp\n        }\n    }\n\n    private fun CharArray.count(s1: String) : Int {\n        var count = 0\n        for (i in indices)\n            if (s1[i] == this[i]) count++\n        return count\n    }\n}\n\nfun main(words: Array<String>) = words.forEach { println(BestShuffle(it)) }\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun main(args: Array<String>) {\n    val numbers = intArrayOf(5, 50, 9000)\n    for (number in numbers) println(\"%4d\".format(number) + \" -> \" + Integer.toBinaryString(number))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun <T : Comparable<T>> Array<T>.iterativeBinarySearch(target: T): Int {\n    var hi = size - 1\n    var lo = 0\n    while (hi >= lo) {\n        val guess = lo + (hi - lo) / 2\n        if (this[guess] > target) hi = guess - 1\n        else if (this[guess] < target) lo = guess + 1\n        else return guess\n    }\n    return -1\n}\n\nfun <T : Comparable<T>> Array<T>.recursiveBinarySearch(target: T, lo: Int, hi: Int): Int {\n    if (hi < lo) return -1\n\n    val guess = (hi + lo) / 2\n\n    return if (this[guess] > target) recursiveBinarySearch(target, lo, guess - 1)\n    else if (this[guess] < target) recursiveBinarySearch(target, guess + 1, hi)\n    else guess\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(1, 3, 4, 5, 6, 7, 8, 9, 10)\n    var target = 6\n    var r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n\n    target = 6\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class ByteString(private val bytes: ByteArray) : Comparable<ByteString> {\n    val length get() = bytes.size\n\n    fun isEmpty() = bytes.isEmpty()\n\n    operator fun plus(other: ByteString): ByteString = ByteString(bytes + other.bytes)\n\n    operator fun plus(byte: Byte) = ByteString(bytes + byte)\n\n    operator fun get(index: Int): Byte {\n        require (index in 0 until length)\n        return bytes[index]\n    }\n\n    fun toByteArray() = bytes\n\n    fun copy() = ByteString(bytes.copyOf())\n\n    override fun compareTo(other: ByteString) = this.toString().compareTo(other.toString())\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is ByteString) return false\n        return compareTo(other) == 0\n    }\n\n    override fun hashCode() = this.toString().hashCode()\n\n    fun substring(startIndex: Int) = ByteString(bytes.sliceArray(startIndex until length))\n\n    fun substring(startIndex: Int, endIndex: Int) =\n        ByteString(bytes.sliceArray(startIndex until endIndex))\n\n    fun replace(oldByte: Byte, newByte: Byte): ByteString {\n        val ba = ByteArray(length) { if (bytes[it] == oldByte) newByte else bytes[it] }\n        return ByteString(ba)\n    }\n\n    fun replace(oldValue: ByteString, newValue: ByteString) =\n        this.toString().replace(oldValue.toString(), newValue.toString()).toByteString()\n\n    override fun toString(): String {\n        val chars = CharArray(length)\n        for (i in 0 until length) {\n            chars[i] = when (bytes[i]) {\n                in 0..127  -> bytes[i].toChar()\n                else       -> (256 + bytes[i]).toChar()\n            }\n        }\n        return chars.joinToString(\"\")\n    }\n}\n\nfun String.toByteString(): ByteString {\n    val bytes = ByteArray(this.length)\n    for (i in 0 until this.length) {\n        bytes[i] = when (this[i].toInt()) {\n            in 0..127   -> this[i].toByte()\n            in 128..255 -> (this[i] - 256).toByte()\n            else        -> '?'.toByte()  // say\n        }\n    }\n    return ByteString(bytes)\n}\n\n/* property to be used as an abbreviation for String.toByteString() */\nval String.bs get() = this.toByteString()\n\nfun main(args: Array<String>) {\n    val ba  = byteArrayOf(65, 66, 67)\n    val ba2 = byteArrayOf(68, 69, 70)\n    val bs  = ByteString(ba)\n    val bs2 = ByteString(ba2)\n    val bs3 = bs + bs2\n    val bs4 = \"GHI\u00a3\u20ac\".toByteString()\n    println(\"The length of $bs is ${bs.length}\")\n    println(\"$bs + $bs2 = $bs3\")\n    println(\"$bs + D = ${bs + 68}\")\n    println(\"$bs == ABC is ${bs == bs.copy()}\")\n    println(\"$bs != ABC is ${bs != bs.copy()}\")\n    println(\"$bs >= $bs2 is ${bs > bs2}\")\n    println(\"$bs <= $bs2 is ${bs < bs2}\")\n    println(\"$bs is ${if (bs.isEmpty()) \"empty\" else \"not empty\"}\")\n    println(\"ABC[1] = ${bs[1].toChar()}\")\n    println(\"ABC as a byte array is ${bs.toByteArray().contentToString()}\")\n    println(\"ABCDEF(1..5) = ${bs3.substring(1)}\")\n    println(\"ABCDEF(2..4) = ${bs3.substring(2,5)}\")\n    println(\"ABCDEF with C replaced by G is ${bs3.replace(67, 71)}\")\n    println(\"ABCDEF with CD replaced by GH is ${bs3.replace(\"CD\".bs, \"GH\".bs)}\")\n    println(\"GHI\u00a3\u20ac as a ByteString is $bs4\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.security.MessageDigest\n\nobject Bitcoin {\n    private const val ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\n    private fun ByteArray.contentEquals(other: ByteArray): Boolean {\n        if (this.size != other.size) return false\n        return (0 until this.size).none { this[it] != other[it] }\n    }\n\n    private fun decodeBase58(input: String): ByteArray? {\n        val output = ByteArray(25)\n        for (c in input) {\n            var p = ALPHABET.indexOf(c)\n            if (p == -1) return null\n            for (j in 24 downTo 1) {\n                p += 58 * (output[j].toInt() and 0xff)\n                output[j] = (p % 256).toByte()\n                p = p shr 8\n            }\n            if (p != 0) return null\n        }\n        return output\n    }\n\n    private fun sha256(data: ByteArray, start: Int, len: Int, recursion: Int): ByteArray {\n        if (recursion == 0) return data\n        val md = MessageDigest.getInstance(\"SHA-256\")\n        md.update(data.sliceArray(start until start + len))\n        return sha256(md.digest(), 0, 32, recursion - 1)\n    }\n\n    fun validateAddress(address: String): Boolean {\n        if (address.length !in 26..35) return false\n        val decoded = decodeBase58(address)\n        if (decoded == null) return false\n        val hash = sha256(decoded, 0, 21, 2)\n        return hash.sliceArray(0..3).contentEquals(decoded.sliceArray(21..24))\n    }\n}\n\nfun main(args: Array<String>) {\n    val addresses = arrayOf(\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\",\n        \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\",\n        \"1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n        \"1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n        \"BZbvjr\",\n        \"i55j\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62!\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62iz\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62izz\",\n        \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\"\n    )\n    for (address in addresses)\n        println(\"${address.padEnd(36)} -> ${if (Bitcoin.validateAddress(address)) \"valid\" else \"invalid\"}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport kotlin.math.abs\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass Point(var x: Int, var y: Int)\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun drawLine(x0: Int, y0: Int, x1: Int, y1: Int, c: Color) {\n        val dx = abs(x1 - x0)\n        val dy = abs(y1 - y0)\n        val sx = if (x0 < x1) 1 else -1\n        val sy = if (y0 < y1) 1 else -1\n        var xx = x0\n        var yy = y0\n        var e1 = (if (dx > dy) dx else -dy) / 2\n        var e2: Int\n        while (true) {\n            setPixel(xx, yy, c)\n            if (xx == x1 && yy == y1) break\n            e2 = e1\n            if (e2 > -dx) { e1 -= dy; xx += sx }\n            if (e2 <  dy) { e1 += dx; yy += sy }\n        }\n    }\n\n    fun cubicBezier(p1: Point, p2: Point, p3: Point, p4: Point, clr: Color, n: Int) {\n        val pts = List(n + 1) { Point(0, 0) }\n        for (i in 0..n) {\n            val t = i.toDouble() / n\n            val u = 1.0 - t\n            val a = u * u * u\n            val b = 3.0 * t * u * u\n            val c = 3.0 * t * t * u\n            val d = t * t * t\n            pts[i].x = (a * p1.x + b * p2.x + c * p3.x + d * p4.x).toInt()\n            pts[i].y = (a * p1.y + b * p2.y + c * p3.y + d * p4.y).toInt()\n            setPixel(pts[i].x, pts[i].y, clr)\n        }\n        for (i in 0 until n) {\n            val j = i + 1\n            drawLine(pts[i].x, pts[i].y, pts[j].x, pts[j].y, clr)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val width = 200\n    val height = 200\n    val bbs = BasicBitmapStorage(width, height)\n    with (bbs) {\n        fill(Color.cyan)\n        val p1 = Point(0, 149)\n        val p2 = Point(30, 50)\n        val p3 = Point(120, 130)\n        val p4 = Point(160, 30)\n        cubicBezier(p1, p2, p3, p4, Color.black, 20)\n        val cbFile = File(\"cubic_bezier.jpg\")\n        ImageIO.write(image, \"jpg\", cbFile)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport kotlin.math.abs\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass Point(var x: Int, var y: Int)\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun drawLine(x0: Int, y0: Int, x1: Int, y1: Int, c: Color) {\n        val dx = abs(x1 - x0)\n        val dy = abs(y1 - y0)\n        val sx = if (x0 < x1) 1 else -1\n        val sy = if (y0 < y1) 1 else -1\n        var xx = x0\n        var yy = y0\n        var e1 = (if (dx > dy) dx else -dy) / 2\n        var e2: Int\n        while (true) {\n            setPixel(xx, yy, c)\n            if (xx == x1 && yy == y1) break\n            e2 = e1\n            if (e2 > -dx) { e1 -= dy; xx += sx }\n            if (e2 <  dy) { e1 += dx; yy += sy }\n        }\n    }\n\n    fun quadraticBezier(p1: Point, p2: Point, p3: Point, clr: Color, n: Int) {\n        val pts = List(n + 1) { Point(0, 0) }\n        for (i in 0..n) {\n            val t = i.toDouble() / n\n            val u = 1.0 - t\n            val a = u * u\n            val b = 2.0 * t * u\n            val c = t * t\n            pts[i].x = (a * p1.x + b * p2.x + c * p3.x).toInt()\n            pts[i].y = (a * p1.y + b * p2.y + c * p3.y).toInt()\n            setPixel(pts[i].x, pts[i].y, clr)\n        }\n        for (i in 0 until n) {\n            val j = i + 1\n            drawLine(pts[i].x, pts[i].y, pts[j].x, pts[j].y, clr)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val width = 320\n    val height = 320\n    val bbs = BasicBitmapStorage(width, height)\n    with (bbs) {\n        fill(Color.cyan)\n        val p1 = Point(10, 100)\n        val p2 = Point(250, 270)\n        val p3 = Point(150, 20)\n        quadraticBezier(p1, p2, p3, Color.black, 20)\n        val qbFile = File(\"quadratic_bezier.jpg\")\n        ImageIO.write(image, \"jpg\", qbFile)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nimport java.awt.*\nimport javax.swing.*\n\nclass Bresenham(w: Int, h: Int) : JPanel() {\n    private val centerX = w / 2\n    private val centerY = h / 2\n\n    init {\n        preferredSize = Dimension(w, h)\n        background = Color.blue\n    }\n\n    override fun paintComponent(g: Graphics) {\n        super.paintComponent(g)\n        drawLine(g, 0, 0, 8, 19)   // NNE\n        drawLine(g, 0, 0, 19, 8)   // ENE\n        drawLine(g, 0, 0, 19, -8)  // ESE\n        drawLine(g, 0, 0, 8, -19)  // SSE\n        drawLine(g, 0, 0, -8, -19) // SSW\n        drawLine(g, 0, 0, -19, -8) // WSW\n        drawLine(g, 0, 0, -19, 8)  // WNW\n        drawLine(g, 0, 0, -8, 19)  // NNW\n    }\n\n    private fun plot(g: Graphics, x: Int, y: Int) {\n        g.color = Color.white\n        g.drawOval(centerX + x * 10, centerY -y * 10, 10, 10)\n    }\n\n    private fun drawLine(g: Graphics, x1: Int, y1: Int, x2: Int, y2: Int) {\n        var d = 0\n        val dy = Math.abs(y2 - y1)\n        val dx = Math.abs(x2 - x1)\n        val dy2 = dy shl 1\n        val dx2 = dx shl 1\n        val ix = if (x1 < x2)  1 else -1\n        val iy = if (y1 < y2)  1 else -1\n        var xx = x1\n        var yy = y1\n\n        if (dy <= dx) {\n            while (true) {\n                plot(g, xx, yy)\n                if (xx == x2) break\n                xx += ix\n                d  += dy2\n                if (d > dx) {\n                    yy += iy\n                    d  -= dx2\n                }\n            }\n        }\n        else {\n            while (true) {\n                plot(g, xx, yy)\n                if (yy == y2) break\n                yy += iy\n                d  += dx2\n                if (d > dy) {\n                    xx += ix\n                    d  -= dy2\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    SwingUtilities.invokeLater {\n        val f = JFrame()\n        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        f.isVisible = true\n        f.add(Bresenham(600, 500), BorderLayout.CENTER)\n        f.title = \"Bresenham\"\n        f.isResizable = false\n        f.pack()\n        f.setLocationRelativeTo(null)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.4-3\n\nimport java.awt.Color\nimport java.awt.Point\nimport java.awt.image.BufferedImage\nimport java.util.LinkedList\nimport java.io.File\nimport javax.imageio.ImageIO\nimport javax.swing.JOptionPane\nimport javax.swing.JLabel\nimport javax.swing.ImageIcon\n\nfun floodFill(image: BufferedImage, node: Point, targetColor: Color, replColor: Color) {\n    val target = targetColor.getRGB()\n    val replacement = replColor.getRGB()\n    if (target == replacement) return\n    val width = image.width\n    val height = image.height\n    val queue = LinkedList<Point>()\n    var nnode: Point? = node\n\n    do {\n        var x = nnode!!.x\n        val y = nnode.y\n        while (x > 0 && image.getRGB(x - 1, y) == target) x--\n        var spanUp = false\n        var spanDown = false\n\n        while (x < width && image.getRGB(x, y) == target) {\n            image.setRGB(x, y, replacement)\n\n            if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {\n                queue.add(Point(x, y - 1))\n                spanUp = true\n            }\n            else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {\n                spanUp = false\n            }\n\n            if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {\n                queue.add(Point(x, y + 1))\n                spanDown = true\n            }\n            else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {\n                spanDown = false\n            }\n            x++\n        }\n        nnode = queue.pollFirst()\n    }\n    while (nnode != null)\n}\n\nfun main(args: Array<String>) {\n   val image = ImageIO.read(File(\"Unfilledcirc.png\"))\n   floodFill(image, Point(50, 50), Color.white, Color.yellow)\n   val title = \"Floodfilledcirc.png\"\n   ImageIO.write(image, \"png\", File(title))\n   JOptionPane.showMessageDialog(null, JLabel(ImageIcon(image)), title, JOptionPane.PLAIN_MESSAGE)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.10\n\nimport java.io.File\nimport java.awt.image.BufferedImage\nimport javax.imageio.ImageIO\n\nconst val BLACK = 0xff000000.toInt()\nconst val WHITE = 0xffffffff.toInt()\n\nfun luminance(argb: Int): Int {\n    val red   = (argb shr 16) and 0xFF\n    val green = (argb shr  8) and 0xFF\n    val blue  =  argb and 0xFF\n    return (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n}\n\nval BufferedImage.histogram: IntArray\n    get() {\n        val lumCount = IntArray(256)\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                var argb = getRGB(x, y)\n                lumCount[luminance(argb)]++\n            }\n        }\n        return lumCount\n    }\n\nfun findMedian(histogram: IntArray): Int {\n    var lSum  = 0\n    var rSum  = 0\n    var left  = 0\n    var right = 255\n    do {\n        if (lSum < rSum) lSum += histogram[left++]\n        else             rSum += histogram[right--]\n    }\n    while (left != right)\n    return left\n}\n\nfun BufferedImage.toBlackAndWhite(median: Int) {\n    for (x in 0 until width) {\n        for (y in 0 until height) {\n            val argb = getRGB(x, y)\n            val lum  = luminance(argb)\n            if (lum < median)\n                setRGB(x, y, BLACK)\n            else\n                setRGB(x, y, WHITE)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val image = ImageIO.read(File(\"Lenna100.jpg\"))\n    val median = findMedian(image.histogram)\n    image.toBlackAndWhite(median)\n    val bwFile = File(\"Lenna_bw.jpg\")\n    ImageIO.write(image, \"jpg\", bwFile)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.4-3\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport javax.swing.JOptionPane\nimport javax.swing.JLabel\nimport javax.swing.ImageIcon\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun drawCircle(bbs: BasicBitmapStorage, centerX: Int, centerY: Int, radius: Int, circleColor: Color) {\n    var d = (5 - radius * 4) / 4\n    var x = 0\n    var y = radius\n\n    do {\n        with(bbs) {\n            setPixel(centerX + x, centerY + y, circleColor)\n            setPixel(centerX + x, centerY - y, circleColor)\n            setPixel(centerX - x, centerY + y, circleColor)\n            setPixel(centerX - x, centerY - y, circleColor)\n            setPixel(centerX + y, centerY + x, circleColor)\n            setPixel(centerX + y, centerY - x, circleColor)\n            setPixel(centerX - y, centerY + x, circleColor)\n            setPixel(centerX - y, centerY - x, circleColor)\n        }\n        if (d < 0) {\n            d += 2 * x + 1\n        }\n        else {\n            d += 2 * (x - y) + 1\n            y--\n        }\n        x++\n    }\n    while (x <= y)\n}\n\nfun main(args: Array<String>) {\n    val bbs = BasicBitmapStorage(400, 400)\n    bbs.fill(Color.pink)\n    drawCircle(bbs, 200, 200, 100, Color.black)\n    drawCircle(bbs, 200, 200,  50, Color.white)\n    val label = JLabel(ImageIcon(bbs.image))\n    val title = \"Bresenham's circle algorithm\"\n    JOptionPane.showMessageDialog(null, label, title, JOptionPane.PLAIN_MESSAGE)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    // create BasicBitmapStorage object\n    val width = 640\n    val height = 640\n    val bbs = BasicBitmapStorage(width, height)\n    for (y in 0 until height) {\n        for (x in 0 until width) {\n            val c = Color(x % 256, y % 256, (x * y) % 256)\n            bbs.setPixel(x, y, c)\n        }\n    }\n\n    // now write the object in PPM format to ImageMagick's STDIN via a pipe\n    // so it can be converted to a .jpg file and written to disk\n    val pb = ProcessBuilder(\"convert\", \"-\", \"output_piped.jpg\")\n    pb.directory(null)\n    pb.redirectInput(ProcessBuilder.Redirect.PIPE)\n    val buffer = ByteArray(width * 3) // write one line at a time\n    val proc = pb.start()\n    val pStdIn = proc.outputStream\n    pStdIn.use {\n        val header = \"P6\\n$width $height\\n255\\n\".toByteArray()\n        with (it) {\n            write(header)\n            for (y in 0 until height) {\n                for (x in 0 until width) {\n                    val c = bbs.getPixel(x, y)\n                    buffer[x * 3] = c.red.toByte()\n                    buffer[x * 3 + 1] = c.green.toByte()\n                    buffer[x * 3 + 2] = c.blue.toByte()\n                }\n                write(buffer)\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport java.io.FileInputStream\nimport java.io.PushbackInputStream\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun toGrayScale() {\n        for (x in 0 until image.width) {\n            for (y in 0 until image.height) {\n                var rgb  = image.getRGB(x, y)\n                val red   = (rgb shr 16) and 0xFF\n                val green = (rgb shr  8) and 0xFF\n                val blue  =  rgb and 0xFF\n                val lumin = (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n                rgb = (lumin shl 16) or (lumin shl 8) or lumin\n                image.setRGB(x, y, rgb)\n            }\n        }\n    }\n}\n\nfun PushbackInputStream.skipComment() {\n    while (read().toChar() != '\\n') {}\n}\n\nfun PushbackInputStream.skipComment(buffer: ByteArray) {\n    var nl: Int\n    while (true) {\n        nl = buffer.indexOf(10) // look for newline at end of comment\n        if (nl != -1) break\n        read(buffer)  // read another buffer full if newline not yet found\n    }\n    val len = buffer.size\n    if (nl < len - 1) unread(buffer, nl + 1, len - nl - 1)\n}\n\nfun Byte.toUInt() = if (this < 0) 256 + this else this.toInt()\n\nfun main(args: Array<String>) {\n    // use file, output.ppm, created in the Bitmap/Write a PPM file task\n    val pbis = PushbackInputStream(FileInputStream(\"output.ppm\"), 80)\n    pbis.use {\n        with (it) {\n            val h1 = read().toChar()\n            val h2 = read().toChar()\n            val h3 = read().toChar()\n            if (h1 != 'P' || h2 != '6' || h3 != '\\n') {\n                println(\"Not a P6 PPM file\")\n                System.exit(1)\n            }\n            val sb = StringBuilder()\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == ' ') break  // read until space reached\n                sb.append(r.toChar())\n            }\n            val width = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val height = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val maxCol = sb.toString().toInt()\n            if (maxCol !in 0..255) {\n                println(\"Maximum color value is outside the range 0..255\")\n                System.exit(1)\n            }\n            var buffer = ByteArray(80)\n            // get rid of any more opening comments before reading data\n            while (true) {\n                read(buffer)\n                if (buffer[0].toChar() == '#') {\n                    skipComment(buffer)\n                }\n                else {\n                    unread(buffer)\n                    break\n                }\n            }\n            // read data\n            val bbs = BasicBitmapStorage(width, height)\n            buffer = ByteArray(width * 3)\n            var y = 0\n            while (y < height) {\n                read(buffer)\n                for (x in 0 until width) {\n                    val c = Color(\n                        buffer[x * 3].toUInt(),\n                        buffer[x * 3 + 1].toUInt(),\n                        buffer[x * 3 + 2].toUInt()\n                    )\n                    bbs.setPixel(x, y, c)\n                }\n                y++\n            }\n            // convert to grayscale and save to a file\n            bbs.toGrayScale()\n            val grayFile = File(\"output_gray.jpg\")\n            ImageIO.write(bbs.image, \"jpg\", grayFile)\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport java.io.PushbackInputStream\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun toGrayScale() {\n        for (x in 0 until image.width) {\n            for (y in 0 until image.height) {\n                var rgb  = image.getRGB(x, y)\n                val red   = (rgb shr 16) and 0xFF\n                val green = (rgb shr  8) and 0xFF\n                val blue  =  rgb and 0xFF\n                val lumin = (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n                rgb = (lumin shl 16) or (lumin shl 8) or lumin\n                image.setRGB(x, y, rgb)\n            }\n        }\n    }\n}\n\nfun PushbackInputStream.skipComment() {\n    while (read().toChar() != '\\n') {}\n}\n\nfun PushbackInputStream.skipComment(buffer: ByteArray) {\n    var nl: Int\n    while (true) {\n        nl = buffer.indexOf(10) // look for newline at end of comment\n        if (nl != -1) break\n        read(buffer)  // read another buffer full if newline not yet found\n    }\n    val len = buffer.size\n    if (nl < len - 1) unread(buffer, nl + 1, len - nl - 1)\n}\n\nfun Byte.toUInt() = if (this < 0) 256 + this else this.toInt()\n\nfun main(args: Array<String>) {\n    // use file, output_piped.jpg, created in the\n    // Bitmap/PPM conversion through a pipe task\n    val pb = ProcessBuilder(\"convert\", \"output_piped.jpg\", \"ppm:-\")\n    pb.directory(null)\n    pb.redirectOutput(ProcessBuilder.Redirect.PIPE)\n    val proc = pb.start()\n    val pStdOut = proc.inputStream\n    val pbis = PushbackInputStream(pStdOut, 80)\n    pbis.use {\n        with (it) {\n            val h1 = read().toChar()\n            val h2 = read().toChar()\n            val h3 = read().toChar()\n            if (h1 != 'P' || h2 != '6' || h3 != '\\n') {\n                println(\"Not a P6 PPM file\")\n                System.exit(1)\n            }\n            val sb = StringBuilder()\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == ' ') break  // read until space reached\n                sb.append(r.toChar())\n            }\n            val width = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val height = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val maxCol = sb.toString().toInt()\n            if (maxCol !in 0..255) {\n                println(\"Maximum color value is outside the range 0..255\")\n                System.exit(1)\n            }\n            var buffer = ByteArray(80)\n            // get rid of any more opening comments before reading data\n            while (true) {\n                read(buffer)\n                if (buffer[0].toChar() == '#') {\n                    skipComment(buffer)\n                }\n                else {\n                    unread(buffer)\n                    break\n                }\n            }\n            // read data\n            val bbs = BasicBitmapStorage(width, height)\n            buffer = ByteArray(width * 3)\n            var y = 0\n            while (y < height) {\n                read(buffer)\n                for (x in 0 until width) {\n                    val c = Color(\n                        buffer[x * 3].toUInt(),\n                        buffer[x * 3 + 1].toUInt(),\n                        buffer[x * 3 + 2].toUInt()\n                    )\n                    bbs.setPixel(x, y, c)\n                }\n                y++\n            }\n            // convert to grayscale and save to a file\n            bbs.toGrayScale()\n            val grayFile = File(\"output_piped_gray.jpg\")\n            ImageIO.write(bbs.image, \"jpg\", grayFile)\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport java.io.FileOutputStream\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    // create BasicBitmapStorage object\n    val width = 640\n    val height = 640\n    val bbs = BasicBitmapStorage(width, height)\n    for (y in 0 until height) {\n        for (x in 0 until width) {\n            val c = Color(x % 256, y % 256, (x * y) % 256)\n            bbs.setPixel(x, y, c)\n        }\n    }\n\n    // now write it to a PPM file\n    val fos = FileOutputStream(\"output.ppm\")\n    val buffer = ByteArray(width * 3)  // write one line at a time\n    fos.use {\n        val header = \"P6\\n$width $height\\n255\\n\".toByteArray()\n        with (it) {\n            write(header)\n            for (y in 0 until height) {\n                for (x in 0 until width) {\n                    val c = bbs.getPixel(x, y)\n                    buffer[x * 3] = c.red.toByte()\n                    buffer[x * 3 + 1] = c.green.toByte()\n                    buffer[x * 3 + 2] = c.blue.toByte()\n                }\n                write(buffer)\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.4-3\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    val width = 640\n    val height = 480\n    val bbs = BasicBitmapStorage(width, height)\n    with (bbs) {\n        fill(Color.cyan)\n        setPixel(width / 2, height / 2, Color.black)\n        val c1 = getPixel(width / 2, height / 2)\n        val c2 = getPixel(20, 20)\n        print(\"The color of the pixel at (${width / 2}, ${height / 2}) is \")\n        println(if (c1 == Color.black) \"black\" else \"unknown\")\n        print(\"The color of the pixel at (120, 120) is \")\n        println(if (c2 == Color.cyan) \"cyan\" else \"unknown\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.31\n\nimport java.io.File\n\nclass BitFilter(val f: File, var accu: Int = 0, var bits: Int = 0) {\n\n    private val bw = f.bufferedWriter()\n    private val br = f.bufferedReader()\n\n    fun write(buf: ByteArray, start: Int, _nBits: Int, _shift: Int) {\n        var nBits = _nBits\n        var index = start + _shift / 8\n        var shift = _shift % 8\n\n        while (nBits != 0 || bits >= 8) {\n            while (bits >= 8) {\n                bits -= 8\n                bw.write(accu ushr bits)\n                accu = accu and ((1 shl bits) - 1)\n            }\n            while (bits < 8 && nBits != 0) {\n                val b = buf[index].toInt()\n                accu = (accu shl 1) or (((128 ushr shift) and b) ushr (7 - shift))\n                nBits--\n                bits++\n                if (++shift == 8) { shift = 0; index++ }\n            }\n        }\n    }\n\n    fun read(buf: ByteArray, start: Int, _nBits: Int, _shift: Int) {\n        var nBits = _nBits\n        var index = start + _shift / 8\n        var shift = _shift % 8\n\n        while (nBits != 0) {\n            while (bits != 0 && nBits != 0) {\n                val mask = 128 ushr shift\n                if ((accu and (1 shl (bits - 1))) != 0)\n                    buf[index] = (buf[index].toInt() or mask).toByte()\n                else\n                    buf[index] = (buf[index].toInt() and mask.inv()).toByte()\n                nBits--\n                bits--\n                if (++shift >= 8) { shift = 0; index++ }\n            }\n            if (nBits == 0) break\n            accu = (accu shl 8) or br.read()\n            bits += 8\n        }\n    }\n\n    fun closeWriter() {\n        if (bits != 0) {\n            accu = (accu shl (8 - bits))\n            bw.write(accu)\n        }\n        bw.close()\n        accu = 0\n        bits = 0\n    }\n\n    fun closeReader() {\n        br.close()\n        accu = 0\n        bits = 0\n    }\n}\n\nfun main(args: Array<String>) {\n    val s = \"abcdefghijk\".toByteArray(Charsets.UTF_8)\n    val f = File(\"test.bin\")\n    val bf = BitFilter(f)\n\n    /* for each byte in s, write 7 bits skipping 1 */\n    for (i in 0 until s.size) bf.write(s, i, 7, 1)\n    bf.closeWriter()\n\n    /* read 7 bits and expand to each byte of s2 skipping 1 bit */\n    val s2 = ByteArray(s.size)\n    for (i in 0 until s2.size) bf.read(s2, i, 7, 1)\n    bf.closeReader()\n    println(String(s2, Charsets.UTF_8))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "/*  for symmetry with Kotlin's other binary bitwise operators\n    we wrap Java's 'rotate' methods as infix functions */\ninfix fun Int.rol(distance: Int): Int = Integer.rotateLeft(this, distance)\ninfix fun Int.ror(distance: Int): Int = Integer.rotateRight(this, distance)\n\nfun main(args: Array<String>) {\n    // inferred type of x and y is Int i.e. 32 bit signed integers\n    val x = 10\n    val y = 2\n    println(\"x       = $x\")\n    println(\"y       = $y\")\n    println(\"NOT x   = ${x.inv()}\")\n    println(\"x AND y = ${x and y}\")\n    println(\"x OR  y = ${x or y}\")\n    println(\"x XOR y = ${x xor y}\")\n    println(\"x SHL y = ${x shl y}\")\n    println(\"x ASR y = ${x shr y}\")   // arithmetic shift right (sign bit filled)\n    println(\"x LSR y = ${x ushr y}\")  // logical shift right    (zero filled)\n    println(\"x ROL y = ${x rol y}\")\n    println(\"x ROR y = ${x ror y}\")\n}\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100;\ntmp=ConstantArray[-1,n];\nDo[tmp[[i;;;;i]]*=-1;,{i,n}];\nDo[Print[\"door \",i,\" is \",If[tmp[[i]]==-1,\"closed\",\"open\"]],{i,1,Length[tmp]}]\n"
  },
  {
    "language": "Mathematica",
    "code": "f[n_] = \"Closed\";\nDo[Do[If[f[n] == \"Closed\", f[n] = \"Open\", f[n] = \"Closed\"], {n, k, 100, k}], {k, 1, 100}];\nTable[f[n], {n, 1, 100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Fold[\n ReplacePart[#1, (i_ /; Mod[i, #2] == 0) :> (-#1[[i]])] &,\n ConstantArray[-1, {100}],\n Range[100]\n] /. {1 -> \"Open\", -1 -> \"Closed\"}\n"
  },
  {
    "language": "Mathematica",
    "code": "Do[Print[\"door \",i,\" is \",If[IntegerQ[Sqrt[i]],\"open\",\"closed\"]],{i,100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100;\na=Range[1,Sqrt[n]]^2\nDo[Print[\"door \",i,\" is \",If[MemberQ[a,i],\"open\",\"closed\"]],{i,100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100\nnn=1\na=0\nFor[i=1,i<=n,i++,\n If[i==nn,\n  Print[\"door \",i,\" is open\"];\n  a++;\n  nn+=2a+1;\n ,\n  Print[\"door \",i,\" is closed\"];\n ];\n]\n"
  },
  {
    "language": "Mathematica",
    "code": "Pick[Range[100], Xor@@@Array[Divisible[#1,#2]&, {100,100}]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Range[Sqrt[100]]^2\n"
  },
  {
    "language": "Mathematica",
    "code": "treeR[n_] := Table[o[trees[a], trees[n - a]], {a, 1, n - 1}]\ntreeR[1] := n\ntree[n_] :=\n Flatten[treeR[n] //. {o[a_List, b_] :> (o[#, b] & /@ a),\n    o[a_, b_List] :> (o[a, #] & /@ b)}]\ngame24play[val_List] :=\n Union[StringReplace[StringTake[ToString[#, InputForm], {10, -2}],\n     \"-1*\" ~~ n_ :> \"-\" <> n] & /@ (HoldForm /@\n      Select[Union@\n        Flatten[Outer[# /. {o[q_Integer] :> #2[[q]],\n             n[q_] :> #3[[q]]} &,\n          Block[{O = 1, N = 1}, # /. {o :> o[O++], n :> n[N++]}] & /@\n           tree[4], Tuples[{Plus, Subtract, Times, Divide}, 3],\n          Permutations[Array[v, 4]], 1]],\n       Quiet[(# /. v[q_] :> val[[q]]) == 24] &] /.\n     Table[v[q] -> val[[q]], {q, 4}])]\n"
  },
  {
    "language": "Mathematica",
    "code": "game24play[RandomInteger[{1, 9}, 4]]\n"
  },
  {
    "language": "Mathematica",
    "code": "evaluate[HoldForm[op_[l_, r_]]] := op[evaluate[l], evaluate[r]];\nevaluate[x_] := x;\ncombine[l_, r_ /; evaluate[r] != 0] := {HoldForm[Plus[l, r]],\n   HoldForm[Subtract[l, r]], HoldForm[Times[l, r]],\n   HoldForm[Divide[l, r]] };\ncombine[l_, r_] := {HoldForm[Plus[l, r]], HoldForm[Subtract[l, r]],\n   HoldForm[Times[l, r]]};\nsplit[items_] :=\n  Table[{items[[1 ;; i]], items[[i + 1 ;; Length[items]]]}, {i, 1,\n    Length[items] - 1}];\nexpressions[{x_}] := {x};\nexpressions[items_] :=\n  Flatten[Table[\n    Flatten[Table[\n      combine[l, r], {l, expressions[sp[[1]]]}, {r,\n       expressions[sp[[2]]]}], 2], {sp, split[items]}]];\n\n(* Must use all atoms in given order. *)\nsolveMaintainOrder[goal_, items_] :=\n  Select[expressions[items], (evaluate[#] == goal) &];\n(* Must use all atoms, but can permute them. *)\nsolveCanPermute[goal_, items_] :=\n  Flatten[Table[\n    solveMaintainOrder[goal, pitems], {pitems,\n     Permutations[items]}]];\n(* Can use any subset of atoms. *)\nsolveSubsets[goal_, items_] :=\n  Flatten[Table[\n    solveCanPermute[goal, is], {is,\n     Subsets[items, {1, Length[items]}]}], 2];\n\n(* Demonstration to find all the ways to create 1/5 from {2, 3, 4, 5}. *)\nsolveMaintainOrder[1/5, Range[2, 5]]\nsolveCanPermute[1/5, Range[2, 5]]\nsolveSubsets[1/5, Range[2, 5]]\n"
  },
  {
    "language": "Mathematica",
    "code": "isLegal[n_List, x_String] :=\n Quiet[Check[\n   With[{h = ToExpression[x, StandardForm, HoldForm]},\n    If[Cases[Level[h, {2, \\[Infinity]}, Hold, Heads -> True],\n        Except[_Integer | Plus | _Plus | Times | _Times | Power |\n          Power[_, -1]]] === {} &&\n      Sort[Level[h /. Power[q_, -1] -> q, {-1}] /.\n         q_Integer -> Abs[q]] === Sort[n], ReleaseHold[h]]], Null]]\nGrid[{{Button[\n    \"new numbers\", {a, b, c, d} = Table[RandomInteger[{1, 9}], {4}]],\n   InputField[Dynamic[x], String]}, {Dynamic[{a, b, c, d}],\n   Dynamic[Switch[isLegal[{a, b, c, d}, x], Null,\n     \"Sorry, that is invalid.\", 24, \"Congrats! That's 24!\", _,\n     \"Sorry, that makes \" <> ToString[ToExpression@x, InputForm] <>\n      \", not 24.\"]]}}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Table[Last /@ Reverse@Tally[First /@ IntegerPartitions[n]], {n, 10}] // Grid\n"
  },
  {
    "language": "Mathematica",
    "code": "PartitionsP /@ {23, 123, 1234, 12345}\n"
  },
  {
    "language": "Mathematica",
    "code": "DiscretePlot[PartitionsP[n], {n, 1, 999}, PlotRange -> All]\n"
  },
  {
    "language": "Mathematica",
    "code": "Bottle[n_] := ToString[n] <> If[n==1,\" bottle\",\" bottles\"] <> \" of beer\"\n\nBottleSong[n_] := Speak[\n  Bottle[n] <> \" on the wall,\" <>\n  Bottle[n] <>\n  \", take one down, pass it around,\" <>\n  Bottle[n-1] <> \" on the wall.\"\n]\n\nBottleSong /@ Range[99,1,-1]\n"
  },
  {
    "language": "Mathematica",
    "code": "Input[] + Input[]\n"
  },
  {
    "language": "Mathematica",
    "code": "blocks=Partition[Characters[ToLowerCase[\"BOXKDQCPNAGTRETGQDFSJWHUVIANOBERFSLYPCZM\"]],2];\nClearAll[DoStep,ABCBlockQ]\nDoStep[chars_List,blcks_List,chosen_List]:=Module[{opts},\n If[chars=!={},\n  opts=Select[blcks,MemberQ[#,First[chars]]&];\n  {Rest[chars],DeleteCases[blcks,#,1,1],Append[chosen,#]}&/@opts\n ,\n  {{chars,blcks,chosen}}\n ]\n]\nDoStep[opts_List]:=Flatten[DoStep@@@opts,1]\nABCBlockQ[str_String]:=(FixedPoint[DoStep,{{Characters[ToLowerCase[str]],blocks,{}}}]=!={})\n"
  },
  {
    "language": "Mathematica",
    "code": "(* Define an interface, Foo, which requires that the functions Foo, Bar, and Baz be defined *)\nInterfaceFooQ[obj_] := ValueQ[Foo[obj]] && ValueQ[Bar[obj]] && ValueQ[Baz[obj]];\nPrintFoo[obj_] := Print[\"Object \", obj, \" does not implement interface Foo.\"];\nPrintFoo[obj_?InterfaceFooQ] := Print[\n   \"Foo: \", Foo[obj], \"\\n\",\n   \"Bar: \", Bar[obj], \"\\n\",\n   \"Baz: \", Baz[obj], \"\\n\"];\n\n(* Extend all integers with Interface Foo *)\nFoo[x_Integer] := Mod[x, 2];\nBar[x_Integer] := Mod[x, 3];\nBaz[x_Integer] := Mod[x, 5];\n\n(* Extend a particular string with Interface Foo *)\nFoo[\"Qux\"] = \"foo\";\nBar[\"Qux\"] = \"bar\";\nBaz[\"Qux\"] = \"baz\";\n\n(* Print a non-interface object *)\nPrintFoo[{\"Some\", \"List\"}];\n(* And for an integer *)\nPrintFoo[8];\n(* And for the specific string *)\nPrintFoo[\"Qux\"];\n(* And finally a non-specific string *)\nPrintFoo[\"foobarbaz\"]\n"
  },
  {
    "language": "Mathematica",
    "code": "classify[n_Integer] := Sign[Total[Most@Divisors@n] - n]\n\nStringJoin[\n Flatten[Tally[\n     Table[classify[n], {n, 20000}]] /. {-1 -> \"deficient: \",\n     0 -> \"  perfect: \", 1 -> \"  abundant: \"}] /.\n  n_Integer :> ToString[n]]\n"
  },
  {
    "language": "Mathematica",
    "code": "accFactory[initial_] :=\n  Module[{total = initial},\n    Function[x, total += x]\n  ]\nx=accFactory[1];\nx[5.0];\naccFactory[3];\nx[2.3]\n"
  },
  {
    "language": "Mathematica",
    "code": "$RecursionLimit=Infinity\nAckermann1[m_,n_]:=\n If[m==0,n+1,\n  If[ n==0,Ackermann1[m-1,1],\n   Ackermann1[m-1,Ackermann1[m,n-1]]\n  ]\n ]\n\n Ackermann2[0,n_]:=n+1;\n Ackermann2[m_,0]:=Ackermann1[m-1,1];\n Ackermann2[m_,n_]:=Ackermann1[m-1,Ackermann1[m,n-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Flatten[#,1]&@Table[{\"Ackermann2[\"<>ToString[i]<>\",\"<>ToString[j]<>\"] =\",Ackermann2[i,j]},{i,3},{j,8}]//Grid\n"
  },
  {
    "language": "Mathematica",
    "code": "Ackermann2[1,1] =\t3\nAckermann2[1,2] =\t4\nAckermann2[1,3] =\t5\nAckermann2[1,4] =\t6\nAckermann2[1,5] =\t7\nAckermann2[1,6] =\t8\nAckermann2[1,7] =\t9\nAckermann2[1,8] =\t10\nAckermann2[2,1] =\t5\nAckermann2[2,2] =\t7\nAckermann2[2,3] =\t9\nAckermann2[2,4] =\t11\nAckermann2[2,5] =\t13\nAckermann2[2,6] =\t15\nAckermann2[2,7] =\t17\nAckermann2[2,8] =\t19\nAckermann2[3,1] =\t13\nAckermann2[3,2] =\t29\nAckermann2[3,3] =\t61\nAckermann2[3,4] =\t125\nAckermann2[3,5] =\t253\nAckermann2[3,6] =\t509\nAckermann2[3,7] =\t1021\nAckermann2[3,8] =\t2045\n"
  },
  {
    "language": "Mathematica",
    "code": "Clear[Ackermann3]\n$RecursionLimit=Infinity;\nAckermann3[0,n_]:=n+1;\nAckermann3[1,n_]:=n+2;\nAckermann3[2,n_]:=3+2n;\nAckermann3[3,n_]:=5+8 (2^n-1);\nAckermann3[m_,0]:=Ackermann3[m-1,1];\nAckermann3[m_,n_]:=Ackermann3[m-1,Ackermann3[m,n-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Ackermann3[4, 1]\nAckermann3[4, 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "65533\n2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880........699146577530041384717124577965048175856395072895337539755822087777506072339445587895905719156733\n"
  },
  {
    "language": "Mathematica",
    "code": "Block[{start = SessionTime[], K, t0 = 0, t1, kt0, S = 0},\n K[t_] = Sin[2 Pi f t] /. f -> 0.5; kt0 = K[t0];\n While[True, t1 = SessionTime[] - start;\n  S += (kt0 + (kt0 = K[t1])) (t1 - t0)/2; t0 = t1;\n  If[t1 > 2, K[t_] = 0; If[t1 > 2.5, Break[]]]]; S]\n"
  },
  {
    "language": "Mathematica",
    "code": "f[a]=1;\nf[b]=2;\nf[a]=3;\n? f\n"
  },
  {
    "language": "Mathematica",
    "code": "Print[\"powers of (x-1)\"]\n(x - 1)^( Range[0, 7]) // Expand // TableForm\nPrint[\"primes under 50\"]\npoly[p_] := (x - 1)^p - (x^p - 1) // Expand;\ncoefflist[p_Integer] := Coefficient[poly[p], x, #] & /@ Range[0, p - 1];\nAKSPrimeQ[p_Integer] := (Mod[coefflist[p] , p] // Union) == {0};\nSelect[Range[1, 50], AKSPrimeQ]\n"
  },
  {
    "language": "Mathematica",
    "code": "TableForm[StringSplit[StringSplit[a,\"\\n\"],\"$\"],TableAlignments -> Center]\n"
  },
  {
    "language": "Mathematica",
    "code": "seq[n_] :=\n  NestList[If[# == 0, 0,\n     DivisorSum[#, # &, Function[div, div != #]]] &, n, 16];\nclass[seq_] :=\n  Which[Length[seq] < 2, \"Non-terminating\", MemberQ[seq, 0],\n   \"Terminating\", seq[[1]] == seq[[2]], \"Perfect\",\n   Length[seq] > 2 && seq[[1]] == seq[[3]], \"Amicable\",\n   Length[seq] > 3 && MemberQ[seq[[4 ;;]], seq[[1]]], \"Sociable\",\n   MatchQ[class[Rest[seq]], \"Perfect\" | \"Aspiring\"], \"Aspiring\",\n   MatchQ[class[Rest[seq]], \"Amicable\" | \"Sociable\" | \"Cyclic\"],\n   \"Cyclic\", True, \"Non-terminating\"];\nnotate[seq_] :=\n  Which[seq == {}, {},\n   MemberQ[Rest[seq],\n    seq[[1]]], {Prepend[TakeWhile[Rest[seq], # != seq[[1]] &],\n     seq[[1]]]}, True, Prepend[notate[Rest[seq]], seq[[1]]]];\nPrint[{#, class[seq[#]], notate[seq[#]] /. {0} -> 0}] & /@ {1, 2, 3, 4, 5, 6, 7,\n   8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909,\n   562, 1064, 1488, 15355717786080};\n"
  },
  {
    "language": "Mathematica",
    "code": "kprimes[k_,n_] :=\n  (* generates a list of the n smallest k-almost-primes *)\n  Module[{firstnprimes, runningkprimes = {}},\n  firstnprimes = Prime[Range[n]];\n  runningkprimes = firstnprimes;\n  Do[\n   runningkprimes =\n     Outer[Times, firstnprimes , runningkprimes ] // Flatten // Union  // Take[#, n] & ;\n   (* only keep lowest n numbers in our running list *)\n   , {i, 1, k - 1}];\n  runningkprimes\n  ]\n(* now to create table with n=10 and k ranging from 1 to 5 *)\nTable[Flatten[{\"k = \" <> ToString[i] <> \": \", kprimes[i, 10]}], {i,1,5}] // TableForm\n"
  },
  {
    "language": "Mathematica",
    "code": " CheckValid[i_List]:=If[Length[i]<=1,True,And@@(StringTake[#[[1]],-1]==StringTake[#[[2]],1]&/@Partition[i,2,1])]\n sets={{\"the\",\"that\",\"a\"},{\"frog\",\"elephant\",\"thing\"},{\"walked\",\"treaded\",\"grows\"},{\"slowly\",\"quickly\"}};\n Select[Tuples[sets],CheckValid]\n"
  },
  {
    "language": "Mathematica",
    "code": "{{\"that\", \"thing\", \"grows\", \"slowly\"}}\n"
  },
  {
    "language": "Mathematica",
    "code": "CheckValid2[i_List] := StringFreeQ[StringJoin[Riffle[i, \",\"]], a_ ~~ \",\" ~~ b_ /; a =!= b]\n"
  },
  {
    "language": "Mathematica",
    "code": "amicableQ[n_] :=\n Module[{sum = Total[Most@Divisors@n]},\n  sum != n && n == Total[Most@Divisors@sum]]\n\nGrid@Partition[Cases[Range[4, 20000], _?(amicableQ@# &)], 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "list=Import[\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\ntext={#,StringJoin@@Sort[Characters[#]]}&/@list;\ntext=SortBy[text,#[[2]]&];\nsplits=Split[text,#1[[2]]==#2[[2]]&][[All,All,1]];\nmaxlen=Max[Length/@splits];\nSelect[splits,Length[#]==maxlen&]\n"
  },
  {
    "language": "Mathematica",
    "code": "{{abel,able,bale,bela,elba},{caret,carte,cater,crate,trace},{angel,angle,galen,glean,lange},{alger,glare,lager,large,regal},{elan,lane,lean,lena,neal},{evil,levi,live,veil,vile}}\n"
  },
  {
    "language": "Mathematica",
    "code": "splits = Gather[list, Sort[Characters[#]] == Sort[Characters[#2]] &];\nmaxlen = Max[Length /@ splits];\nSelect[splits, Length[#] == maxlen &]\n"
  },
  {
    "language": "Mathematica",
    "code": "anagramGroups = GatherBy[SortBy[GatherBy[list,Sort[Characters[#]] &],Length],Length];\nanagramGroups[[-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "list=Import[\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\nMaximalBy[GatherBy[list, Sort@*Characters], Length]\n"
  },
  {
    "language": "Mathematica",
    "code": "words=First/@Import[\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\",\"Table\"];\nanagramDegrangement=Function[{w1,w2},\n\tModule[{c1=ToCharacterCode@w1,c2=ToCharacterCode@w2},\n\tSort@c1==Sort@c2&&Select[c1-c2,#==0&,1]==={}]];\ngs=Select[GatherBy[words,{StringLength@#,Union@ToCharacterCode@#}&],Length@#>=2&];\nFirst@Flatten[Function[ws,Select[Join@@Outer[List,ws,ws,1],anagramDegrangement@@#&]]/@SortBy[gs,-StringLength@First@#&],1]\n"
  },
  {
    "language": "Mathematica",
    "code": "list = Import[\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\nMaximalBy[\n Select[GatherBy[list, Sort@*Characters],\n  Length@# > 1 && And @@ MapThread[UnsameQ, Characters /@ #] &],\n StringLength@*First]\n"
  },
  {
    "language": "Mathematica",
    "code": "freq = 8; length = freq^(-1/2);\nAnimate[Graphics[\n  List[{Line[{{0, 0}, length {Sin[T], -Cos[T]}} /. {T -> (Pi/6) Cos[2 Pi freq t]}], PointSize[Large],\n               Point[{length {Sin[T], -Cos[T]}} /. {T -> (Pi/6) Cos[2 Pi freq t]}]}],\n  PlotRange -> {{-0.3, 0.3}, {-0.5, 0}}], {t, 0, 1}, AnimationRate -> 0.07]\n"
  },
  {
    "language": "Mathematica",
    "code": "mystring = \"Hello World! \";\nScroll[str_, dir_] := StringJoin @@ RotateLeft[str // Characters, dir];\nGiveString[dir_] := (mystring = Scroll[mystring, dir]);\nCreateDialog[{\n   DynamicModule[{direction = -1},\n    EventHandler[\n     Dynamic[TextCell[\n       Refresh[GiveString[direction], UpdateInterval -> 1/8]],\n      TrackedSymbols -> {}], {\"MouseClicked\" :> (direction *= -1)}]]\n   }];\n"
  },
  {
    "language": "Mathematica",
    "code": "check := #<0&\nfib := If[check[#],Throw[\"Negative Argument\"],If[#<=1,1,#0[#-2]+#0[#-1]]&[#]]&\nfib /@ Range[0,10]\n\n{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89}\n"
  },
  {
    "language": "Mathematica",
    "code": "check := (Print[#];#<0)&\nfib /@ Range[0,4]\n0\n1\n2\n3\n4\n\n{1, 1, 2, 3, 5}\n"
  },
  {
    "language": "Mathematica",
    "code": "data = <|\"account\" -> \"xyz\", \"password\" -> \"x\", \"UID\" -> 1003,\n   \"GID\" -> 1000, \"fullname\" -> \"X Yz\", \"office\" -> \"Room 1003\",\n   \"extension\" -> \"(234)555-8913\", \"homephone\" -> \"(234)555-0033\",\n   \"email\" -> \"xyz@rosettacode.org\", \"directory\" -> \"/home/xyz\",\n   \"shell\" -> \"/bin/bash\"|>;\nasString[data_] :=\n  StringRiffle[\n   ToString /@\n    Insert[data /@ {\"account\", \"password\", \"UID\", \"GID\", \"directory\",\n       \"shell\"},\n     StringRiffle[\n      data /@ {\"fullname\", \"office\", \"extension\", \"homephone\",\n        \"email\"}, \",\"], 5], \":\"];\nfname = FileNameJoin[{$TemporaryDirectory, \"testfile\"}];\nstr = OpenWrite[fname]; (* Use OpenAppend if file exists *)\nClose[str];\nPrint[\"Appended record: \" <> asString[data]];\n"
  },
  {
    "language": "Mathematica",
    "code": "(#*#)& /@ {1, 2, 3, 4}\n\nMap[Function[#*#], {1, 2, 3, 4}]\n\nMap[((#*#)&,{1,2,3,4}]\n\nMap[Function[w,w*w],{1,2,3,4}]\n"
  },
  {
    "language": "Mathematica",
    "code": "s:=ToString[5^4^3^2];\nPrint[StringTake[s,20]<>\"...\"<>StringTake[s,-20]<>\" (\"<>ToString@StringLength@s<>\" digits)\"];\n"
  },
  {
    "language": "Mathematica",
    "code": "f[x_] := x^2\n"
  },
  {
    "language": "Mathematica",
    "code": "x=1+2I\ny=3+4I\n\nx+y  =>  4 + 6 I\nx-y  =>  -2 - 2 I\ny x  =>  -5 + 10 I\ny/x  => 11/5 - (2 I)/5\nx^3  =>  -11 - 2 I\ny^4  =>  -527 - 336 I\nx^y  =>  (1 + 2 I)^(3 + 4 I)\nN[x^y]  =>  0.12901 + 0.0339241 I\n"
  },
  {
    "language": "Mathematica",
    "code": "Exp  Log\nSin  Cos  Tan  Csc  Sec  Cot\nArcSin  ArcCos  ArcTan  ArcCsc  ArcSec  ArcCot\nSinh  Cosh  Tanh  Csch  Sech  Coth\nArcSinh  ArcCosh  ArcTanh  ArcCsch  ArcSech  ArcCoth\nSinc\nHaversine  InverseHaversine\nFactorial  Gamma  PolyGamma  LogGamma\nErf  BarnesG  Hyperfactorial  Zeta  ProductLog  RamanujanTauL\n"
  },
  {
    "language": "Mathematica",
    "code": "(*parsing:*)\nparse[string_] :=\n Module[{e},\n  StringCases[string,\n     \"+\" | \"-\" | \"*\" | \"/\" | \"(\" | \")\" |\n      DigitCharacter ..] //. {a_String?DigitQ :>\n      e[ToExpression@a], {x___, PatternSequence[\"(\", a_e, \")\"],\n       y___} :> {x, a,\n       y}, {x :\n        PatternSequence[] |\n         PatternSequence[___, \"(\" | \"+\" | \"-\" | \"*\" | \"/\"],\n       PatternSequence[op : \"+\" | \"-\", a_e], y___} :> {x, e[op, a],\n       y}, {x :\n        PatternSequence[] | PatternSequence[___, \"(\" | \"+\" | \"-\"],\n       PatternSequence[a_e, op : \"*\" | \"/\", b_e], y___} :> {x,\n       e[op, a, b],\n       y}, {x :\n        PatternSequence[] | PatternSequence[___, \"(\" | \"+\" | \"-\"],\n       PatternSequence[a_e, b_e], y___} :> {x, e[\"*\", a, b],\n       y}, {x : PatternSequence[] | PatternSequence[___, \"(\"],\n       PatternSequence[a_e, op : \"+\" | \"-\", b_e],\n       y : PatternSequence[] |\n         PatternSequence[\")\" | \"+\" | \"-\", ___]} :> {x, e[op, a, b],\n       y}} //. {e -> List, {a_Integer} :> a, {a_List} :> a}]\n\n(*evaluation*)\nevaluate[a_Integer] := a;\nevaluate[{\"+\", a_}] := evaluate[a];\nevaluate[{\"-\", a_}] := -evaluate[a];\nevaluate[{\"+\", a_, b_}] := evaluate[a] + evaluate[b];\nevaluate[{\"-\", a_, b_}] := evaluate[a] - evaluate[b];\nevaluate[{\"*\", a_, b_}] := evaluate[a]*evaluate[b];\nevaluate[{\"/\", a_, b_}] := evaluate[a]/evaluate[b];\nevaluate[string_String] := evaluate[parse[string]]\n"
  },
  {
    "language": "Mathematica",
    "code": "parse[\"-1+2(3+4*-5/6)\"]\nevaluate[\"-1+2(3+4*-5/6)\"]\n"
  },
  {
    "language": "Mathematica",
    "code": "pi[n_, prec_] :=\n Module[{a = 1, g = N[1/Sqrt[2], prec], k, s = 0, p = 4},\n  For[k = 1, k < n, k++,\n   {a, g} = {N[(a + g)/2, prec], N[Sqrt[a g], prec]};\n   s += p (a^2 - g^2); p += p]; N[4 a^2/(1 - s), prec]]\n\n\npi[7, 100] - N[Pi, 100]\n1.2026886537*10^-86\n\npi[7, 100]\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628046852228654\n"
  },
  {
    "language": "Mathematica",
    "code": "PrecisionDigits = 85;\nAGMean[a_, b_] := FixedPoint[{ Tr@#/2, Sqrt[Times@@#] }&, N[{a,b}, PrecisionDigits]]\u301a1\u301b\n"
  },
  {
    "language": "Mathematica",
    "code": "a = Input[\"Give me an integer please!\"];\nb = Input[\"Give me another integer please!\"];\nPrint[\"You gave me \", a, \" and \", b];\nPrint[\"sum: \", a + b];\nPrint[\"difference: \", a - b];\nPrint[\"product: \", a b];\nPrint[\"integer quotient: \", IntegerPart[a/b]];\nPrint[\"remainder: \", Mod[a, b]];\nPrint[\"exponentiation: \", a^b];\n"
  },
  {
    "language": "Mathematica",
    "code": "4/16\n3/8\n8/4\n4Pi/2\n16!/10!\nSqrt[9/16]\nSqrt[3/4]\n(23/12)^5\n2 + 1/(1 + 1/(3 + 1/4))\n\n1/2+1/3+1/5\n8/Pi+Pi/8 //Together\n13/17 + 7/31\nSum[1/n,{n,1,100}]      (*summation of 1/1 + 1/2 + 1/3 + 1/4+ .........+ 1/99 + 1/100*)\n\n1/2-1/3\na=1/3;a+=1/7\n\n1/4==2/8\n1/4>3/8\nPi/E >23/20\n1/3!=123/370\nSin[3]/Sin[2]>3/20\n\nNumerator[6/9]\nDenominator[6/9]\n"
  },
  {
    "language": "Mathematica",
    "code": "c/(2 c)\n(b^2 - c^2)/(b - c)  // Cancel\n1/2 + b/c // Together\n"
  },
  {
    "language": "Mathematica",
    "code": "1/2\nb+c\n(2 b+c) / (2 c)\n"
  },
  {
    "language": "Mathematica",
    "code": "1+2*{1,2,3}^3\n"
  },
  {
    "language": "Mathematica",
    "code": "{3, 17, 55}\n"
  },
  {
    "language": "Mathematica",
    "code": "found={};\nCheckPerfect[num_Integer]:=If[Total[1/Divisors[num]]==2,AppendTo[found,num]];\nDo[CheckPerfect[i],{i,1,2^25}];\nfound\n"
  },
  {
    "language": "Mathematica",
    "code": "{6, 28, 496, 8128, 33550336}\n"
  },
  {
    "language": "Mathematica",
    "code": "Join[{1,2,3}, {4,5,6}]\n\n-> {1, 2, 3, 4, 5, 6}\n"
  },
  {
    "language": "Mathematica",
    "code": "a = Array[Sin, 10]\na[[1]]\nDelete[a, 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "Assert[var===42]\n"
  },
  {
    "language": "Mathematica",
    "code": "a[2] = \"string\"; a[\"sometext\"] = 23;\n"
  },
  {
    "language": "Mathematica",
    "code": "keys=DownValues[#,Sort->False][[All,1,1,1]]&;\nhashes=#/@keys[#]&;\n\na[2]=\"string\";a[\"sometext\"]=23;\nkeys[a]\n->{2,sometext}\nhashes[a]\n->{string,23}\n"
  },
  {
    "language": "Mathematica",
    "code": "transfer[bucks_, src_, dest_, n_] :=\n  ReplacePart[\n   bucks, {src -> Max[bucks[[src]] - n, 0],\n    dest -> bucks[[dest]] + Min[bucks[[src]], n]}];\nDistributeDefinitions[transfer];\nSetSharedVariable[bucks, comp];\nbucks = RandomInteger[10, 20];\ncomp = True;\nPrint[\"Original sum: \" <> IntegerString[Plus @@ bucks]];\nPrint[Dynamic[\"Current sum: \" <> IntegerString[Plus @@ bucks]]];\nWaitAll[{ParallelSubmit[\n    While[True, While[! comp, Null]; comp = False;\n     Module[{a = RandomInteger[{1, 20}], b = RandomInteger[{1, 20}]},\n      bucks = transfer[bucks, Max[a, b], Min[a, b],\n        Floor[Abs[bucks[[a]] - bucks[[b]]]/2]]]; comp = True]],\n   ParallelSubmit[\n    While[True, While[! comp, Null]; comp = False;\n     Module[{src = RandomInteger[{1, 20}],\n       dest = RandomInteger[{1, 20}]},\n      bucks = transfer[bucks, src, dest,\n        RandomInteger[{1, bucks[[src]]}]]]; comp = True]]}];\n"
  },
  {
    "language": "Mathematica",
    "code": "Grid@Prepend[\n  Table[{n, #[[1]], #[[2]],\n      Row[{Round[10000 Abs[#[[1]] - #[[2]]]/#[[2]]]/100., \"%\"}]} &@\n    N[{Mean[Array[\n        Length@NestWhileList[#, 1, UnsameQ[##] &, All] - 1 &[# /.\n            MapIndexed[#2[[1]] -> #1 &,\n             RandomInteger[{1, n}, n]] &] &, 10000]],\n      Sum[n! n^(n - k - 1)/(n - k)!, {k, n}]/n^(n - 1)}, 5], {n, 1,\n    20}], {\"N\", \"average\", \"analytical\", \"error\"}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Unprotect[Mean];\nMean[{}] := 0\n"
  },
  {
    "language": "Mathematica",
    "code": "Mean[{3,4,5}]\nMean[{3.2,4.5,5.9}]\nMean[{-4, 1.233}]\nMean[{}]\nMean[{1/2,1/3,1/4,1/5}]\nMean[{a,c,Pi,-3,a}]\n"
  },
  {
    "language": "MATLAB",
    "code": "a = false(1,100);\nfor b=1:100\n  for i = b:b:100\n    a(i) = ~a(i);\n  end\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "for x=1:100;\n  if sqrt(x) == floor(sqrt(x))\n    a(i)=1;\n  end\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "a = zeros(100,1);\nfor counter = 1:sqrt(100);\n  a(counter^2) = 1;\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "function [doors,opened,closed] = hundredDoors()\n\n    %Initialize the doors, make them booleans for easy vectorization\n    doors = logical( (1:1:100) );\n\n    %Go through the flipping process, ignore the 1 case because the doors\n    %array is already initialized to all open\n    for initialPosition = (2:100)\n        doors(initialPosition:initialPosition:100) = not( doors(initialPosition:initialPosition:100) );\n    end\n\n    opened = find(doors); %Stores the numbers of the open doors\n    closed = find( not(doors) ); %Stores the numbers of the closed doors\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "doors((1:10).^2) = 1;\n\ndoors\n"
  },
  {
    "language": "MATLAB",
    "code": "  function twentyfour()\n  N = 4;\n  n = ceil(rand(1,N)*9);\n  printf('Generate a equation with the numbers %i, %i, %i, %i and +, -, *, /, () operators ! \\n',n);\n  s = input(': ','s');\n  t = s;\n  for k = 1:N,\n    [x,t] = strtok(t,'+-*/() \\t');\n     if length(x)~=1,\n       error('invalid sign %s\\n',x);\n     end;\n     y = x-'0';\n     if ~(0 < y & y < 10)\n       error('invalid sign %s\\n',x);\n     end;\n     z(1,k) = y;  \t\n  end;\n  if any(sort(z)-sort(n))\n    error('numbers do not match.\\n');\t\n  end;\n\n  val =  eval(s);\n  if val==24,\n    fprintf('expression \"%s\" results in %i.\\n',s,val);\t\n  else\n    fprintf('expression \"%s\" does not result in 24 but %i.\\n',s,val);\n  end; \t\n"
  },
  {
    "language": "MATLAB",
    "code": "function ninetyNineBottlesOfBeer()\n\n    disp( [ sprintf(['%d bottles of beer on the wall, %d bottles of beer.\\n'...\n        'Take one down, pass it around...\\n'],[(99:-1:2);(99:-1:2)])...\n        sprintf(['1 bottle of beer on the wall, 1 bottle of beer.\\nTake'...\n        'one down, pass it around;\\nNo more bottles of beer on the wall.']) ] );\n\n    %The end of this song makes me sad. The shelf should always have more\n    %beer...like college.\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function sumOfInputs = APlusB()\n    inputStream = input('Enter two numbers, separated by a space: ', 's');\n    numbers = str2num(inputStream);                         %#ok<ST2NM>\n    if any(numbers < -1000 | numbers > 1000)\n        warning('APlusB:OutOfRange', 'Some numbers are outside the range');\n    end\n    sumOfInputs = sum(numbers);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function testABC\n    combos = ['BO' ; 'XK' ; 'DQ' ; 'CP' ; 'NA' ; 'GT' ; 'RE' ; 'TG' ; 'QD' ; ...\n        'FS' ; 'JW' ; 'HU' ; 'VI' ; 'AN' ; 'OB' ; 'ER' ; 'FS' ; 'LY' ; ...\n        'PC' ; 'ZM'];\n    words = {'A' 'BARK' 'BOOK' 'TREAT' 'COMMON' 'SQUAD' 'CONFUSE'};\n    for k = 1:length(words)\n        possible = canMakeWord(words{k}, combos);\n        fprintf('Can%s make word %s.\\n', char(~possible.*'NOT'), words{k})\n    end\nend\n\nfunction isPossible = canMakeWord(word, combos)\n    word = lower(word);\n    combos = lower(combos);\n    isPossible = true;\n    k = 1;\n    while isPossible && k <= length(word)\n        [r, c] = find(combos == word(k), 1);\n        if ~isempty(r)\n            combos(r, :) = '';\n        else\n            isPossible = false;\n        end\n        k = k+1;\n    end\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "classdef (Abstract) AbsClass\n   ...\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "methods (Abstract)\n   abstMethod(obj)\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "properties (Abstract)\n   AbsProp\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function A = ackermannFunction(m,n)\n    if m == 0\n        A = n+1;\n    elseif (m > 0) && (n == 0)\n        A = ackermannFunction(m-1,1);\n    else\n        A = ackermannFunction( m-1,ackermannFunction(m,n-1) );\n    end\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function amicable\n    tic\n    N=2:1:20000; aN=[];\n    N(isprime(N))=[]; %erase prime numbers\n    I=1;\n    a=N(1); b=sum(pd(a));\n    while length(N)>1\n        if a==b %erase perfect numbers;\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        elseif b<a %the first member of an amicable pair is abundant not defective\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        elseif ~ismember(b,N) %the other member was previously erased\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        else\n            c=sum(pd(b));\n            if a==c\n                aN(I,:)=[I a b]; I=I+1;\n                N(N==b)=[];\n            else\n                if ~ismember(c,N) %the other member was previously erased\n                    N(N==b)=[];\n                end\n            end\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n            clear c\n        end\n    end\n    disp(array2table(aN,'Variablenames',{'N','Amicable1','Amicable2'}))\n    toc\nend\n\nfunction D=pd(x)\n    K=1:ceil(x/2);\n    D=K(~(rem(x, K)));\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "%This is a numerical simulation of a pendulum with a massless pivot arm.\n\n%% User Defined Parameters\n%Define external parameters\ng = -9.8;\ndeltaTime = 1/50; %Decreasing this will increase simulation accuracy\nendTime = 16;\n\n%Define pendulum\nrodPivotPoint = [2 2]; %rectangular coordinates\nrodLength = 1;\nmass = 1; %of the bob\nradius = .2; %of the bob\ntheta = 45; %degrees, defines initial position of the bob\nvelocity = [0 0]; %cylindrical coordinates; first entry is radial velocity,\n                  %second entry is angular velocity\n\n%% Simulation\nassert(radius < rodLength,'Pendulum bob radius must be less than the length of the rod.');\n\nposition = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]); %in rectangular coordinates\n\n%Generate graphics, render pendulum\nfigure;\naxesHandle = gca;\nxlim(axesHandle, [(rodPivotPoint(1) - rodLength - radius) (rodPivotPoint(1) + rodLength + radius)] );\nylim(axesHandle, [(rodPivotPoint(2) - rodLength - radius) (rodPivotPoint(2) + rodLength + radius)] );\n\nrectHandle = rectangle('Position',[(position - radius/2) radius radius],...\n    'Curvature',[1,1],'FaceColor','g'); %Pendulum bob\nhold on\nplot(rodPivotPoint(1),rodPivotPoint(2),'^'); %pendulum pivot\nlineHandle = line([rodPivotPoint(1) position(1)],...\n    [rodPivotPoint(2) position(2)]); %pendulum rod\nhold off\n\n%Run simulation, all calculations are performed in cylindrical coordinates\nfor time = (deltaTime:deltaTime:endTime)\n\n    drawnow; %Forces MATLAB to render the pendulum\n\n    %Find total force\n    gravitationalForceCylindrical = [mass*g*cosd(theta) mass*g*sind(theta)];\n\n    %This code is just incase you want to add more forces,e.g friction\n    totalForce = gravitationalForceCylindrical;\n\n    %If the rod isn't massless or is a spring, etc., modify this line\n    %accordingly\n    rodForce = [-totalForce(1) 0]; %cylindrical coordinates\n\n    totalForce = totalForce + rodForce;\n\n    acceleration = totalForce / mass; %F = ma\n    velocity = velocity + acceleration * deltaTime;\n    rodLength = rodLength + velocity(1) * deltaTime;\n    theta = theta + velocity(2) * deltaTime; % Attention!! Mistake here.\n    % Velocity needs to be divided by pendulum length and scaled to degrees:\n    % theta = theta + velocity(2) * deltaTime/rodLength/pi*180;\n\n    position = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]);\n\n    %Update figure with new position info\n    set(rectHandle,'Position',[(position - radius/2) radius radius]);\n    set(lineHandle,'XData',[rodPivotPoint(1) position(1)],'YData',...\n        [rodPivotPoint(2) position(2)]);\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "  DS{1}.account='jsmith';\n  DS{1}.password='x';\n  DS{1}.UID=1001;\n  DS{1}.GID=1000;\n  DS{1}.fullname='Joe Smith';\n  DS{1}.office='Room 1007';\n  DS{1}.extension='(234)555-8917';\n  DS{1}.homephone='(234)555-0077';\n  DS{1}.email='jsmith@rosettacode.org';\n  DS{1}.directory='/home/jsmith';\n  DS{1}.shell='/bin/bash';\n\n  DS{2}.account='jdoe';\n  DS{2}.password='x';\n  DS{2}.UID=1002;\n  DS{2}.GID=1000;\n  DS{2}.fullname='Jane Doe';\n  DS{2}.office='Room 1004';\n  DS{2}.extension='(234)555-8914';\n  DS{2}.homephone='(234)555-0044';\n  DS{2}.email='jdoe@rosettacode.org';\n  DS{2}.directory='/home/jdoe';\n  DS{2}.shell='/bin/bash';\n\n  function WriteRecord(fid, rec)\n     fprintf(fid,\"%s:%s:%i:%i:%s,%s,%s,%s,%s:%s%s\\n\", rec.account, rec.password, rec.UID, rec.GID, rec.fullname, rec.office, rec.extension, rec.homephone, rec.email, rec.directory, rec.shell);\n     return;\n  end\n\n  %% write\n  fid = fopen('passwd.txt','w');\n  WriteRecord(fid,DS{1});\n  WriteRecord(fid,DS{2});\n  fclose(fid);\n\n  new.account='xyz';\n  new.password='x';\n  new.UID=1003;\n  new.GID=1000;\n  new.fullname='X Yz';\n  new.office='Room 1003';\n  new.extension='(234)555-8913';\n  new.homephone='(234)555-0033';\n  new.email='xyz@rosettacode.org';\n  new.directory='/home/xyz';\n  new.shell='/bin/bash';\n\n  %% append\n  fid = fopen('passwd.txt','a+');\n  WriteRecord(fid,new);\n  fclose(fid);\n\n  % read password file\n  fid = fopen('passwd.txt','r');\n  while ~feof(fid)\n\tprintf('%s\\n',fgetl(fid));\n  end;\n  fclose(fid);\n"
  },
  {
    "language": "MATLAB",
    "code": ">> array = [1 2 3 4 5]\n\narray =\n\n     1     2     3     4     5\n\n>> arrayfun(@sin,array)\n\nans =\n\n  Columns 1 through 4\n\n   0.841470984807897   0.909297426825682   0.141120008059867  -0.756802495307928\n\n  Column 5\n\n  -0.958924274663138\n\n>> cellarray = {1,2,3,4,5}\n\ncellarray =\n\n    [1]    [2]    [3]    [4]    [5]\n\n>> cellfun(@tan,cellarray)\n\nans =\n\n  Columns 1 through 4\n\n   1.557407724654902  -2.185039863261519  -0.142546543074278   1.157821282349578\n\n  Column 5\n\n  -3.380515006246586\n"
  },
  {
    "language": "MATLAB",
    "code": ">> answer = vpi(5)^(vpi(4)^(vpi(3)^vpi(2)));\n>> numDigits = order(answer) + 1\n\nnumDigits =\n\n      183231\n\n>> [sprintf('%d',leadingdigit(answer,20)) '...' sprintf('%d',trailingdigit(answer,20))]\n%First and Last 20 Digits\n\nans =\n\n62060698786608744707...92256259918212890625\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = 1+i\n\na =\n\n  1.000000000000000 + 1.000000000000000i\n\n>> b = 3+7i\n\nb =\n\n  3.000000000000000 + 7.000000000000000i\n\n>> a+b\n\nans =\n\n  4.000000000000000 + 8.000000000000000i\n\n>> a-b\n\nans =\n\n -2.000000000000000 - 6.000000000000000i\n\n>> a*b\n\nans =\n\n -4.000000000000000 +10.000000000000000i\n\n>> a/b\n\nans =\n\n  0.172413793103448 - 0.068965517241379i\n\n>> -a\n\nans =\n\n -1.000000000000000 - 1.000000000000000i\n\n>> a'\n\nans =\n\n  1.000000000000000 - 1.000000000000000i\n\n>> a^b\n\nans =\n\n  0.000808197112874 - 0.011556516327187i\n\n>> norm(a)\n\nans =\n\n   1.414213562373095\n"
  },
  {
    "language": "MATLAB",
    "code": "function [a,g]=agm(a,g)\n%%arithmetic_geometric_mean(a,g)\n\twhile (1)\n\t\ta0=a;\n\t\ta=(a0+g)/2;\n\t\tg=sqrt(a0*g);\n\tif (abs(a0-a) < a*eps) break; end;\n\tend;\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "disp(\"integer a: \"); a = scanf(\"%d\", 1);\ndisp(\"integer b: \"); b = scanf(\"%d\", 1);\na+b\na-b\na*b\nfloor(a/b)\nmod(a,b)\na^b\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = [1 2 3]\n\na =\n\n     1     2     3\n\n>> b = [4 5 6]\n\nb =\n\n     4     5     6\n\n>> concat = [a b]\n\nconcat =\n\n     1     2     3     4     5     6\n\n>> concat = [a;b]\n\nconcat =\n\n     1     2     3\n     4     5     6\n"
  },
  {
    "language": "MATLAB",
    "code": ">> c = randn([3,4,5]);\n>> d = randn([3,4,7]);\n>> e = cat(3,c,d);\n>> size(e)\n   ans =\n\n    3    4   12\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = [1 2 35] %Declaring a vector (i.e. one-dimensional array)\n\na =\n\n     1     2    35\n\n>> a = [1 2 35;5 7 9] % Declaring a matrix (i.e. two-dimensional array)\n\na =\n\n     1     2    35\n     5     7     9\n\n>> a3 = reshape(1:2*3*4,[2,3,4]);   % declaring a three-dimensional array of size 2x3x4\n\na3 =\n\nans(:,:,1) =\n\n   1   3   5\n   2   4   6\n\nans(:,:,2) =\n\n    7    9   11\n    8   10   12\n\nans(:,:,3) =\n\n   13   15   17\n   14   16   18\n\nans(:,:,4) =\n\n   19   21   23\n   20   22   24\n\n\n>> a(2,3) %Retrieving value using row and column indicies\n\n     9\n\n>> a(6) %Retrieving value using array subscript\n\nans =\n\n     9\n\n>> a = [a [10;42]] %Added a column vector to the array\n\na =\n\n     1     2    35    10\n     5     7     9    42\n\n>> a(:,1) = [] %Deleting array elements\n\na =\n\n     2    35    10\n     7     9    42\n"
  },
  {
    "language": "MATLAB",
    "code": "assert(x == 42,'x = %d, not 42.',x);\n"
  },
  {
    "language": "MATLAB",
    "code": "x = 3;\nassert(x == 42,'Assertion Failed: x = %d, not 42.',x);\n??? Assertion Failed: x = 3, not 42.\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash.a = 1;\n   hash.b = 2;\n   hash.C = [3,4,5];\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash = [];\n   hash = setfield(hash,'a',1); \t\n   hash = setfield(hash,'b',2); \t\n   hash = setfield(hash,'C',[3,4,5]);\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash.('a') = 1; \t\n   hash.('b') = 2; \t\n   hash.('C') = [3,4,5];\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map({'a' 'b' 'C'}, [1 2 3]);\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map;\nm('a') = 1;\nm('b') = 2;\nm('C') = 3;\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map([51 72 37], {'fiftyone' 'seventytwo' 'thirtyseven'});\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map('KeyType', 'double', 'ValueType', 'any');\nm(51) = 'fiftyone';\nm(72) = 'seventytwo';\nm(37) = 'thirtyseven';\n"
  },
  {
    "language": "MATLAB",
    "code": "   keys = fieldnames(hash);\n   for k=1:length(keys),\n        key = keys{k};\n\tvalue = getfield(hash,key);        % get value of key\n\thash = setfield(hash,key,-value);  % set value of key\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "   keys = fieldnames(hash);\n   for k=1:length(keys),\n        key = keys{k};\n        value = hash.(key);     % get value of key\n        hash.(key) = -value;    % set value of key\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "function meanValue = findmean(setOfValues)\n   meanValue = mean(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function u = mean_angle(phi)\n\tu = angle(mean(exp(i*pi*phi/180)))*180/pi;\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function t = mean_time_of_day(t)\n    c = pi/(12*60*60);\n    for k=1:length(t)\n\ta = sscanf(t{k},'%d:%d:%d');\n\tphi(k) = (a(1)*3600+a(2)*60+a(3));\n    end;\n    d = angle(mean(exp(i*phi*c)))/(2*pi); % days\n    if (d<0) d += 1;\n    t = datestr(d,\"HH:MM:SS\");\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "function medianValue = findmedian(setOfValues)\n   medianValue = median(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function modeValue = findmode(setOfValues)\n   modeValue = mode(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function [A,G,H] = pythagoreanMeans(list)\n\n    A = mean(list);\n    G = geomean(list);\n    H = harmmean(list);\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function [A,G,H] = pythagoreanMeans(list)\n    A = mean(list);           % arithmetic mean\n    G = exp(mean(log(list))); % geometric mean\n    H = 1./mean(1./list);     % harmonic mean\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> [A,G,H]=pythagoreanMeans((1:10))\n\nA =\n\n   5.500000000000000\n\n\nG =\n\n   4.528728688116765\n\n\nH =\n\n   3.414171521474055\n"
  },
  {
    "language": "MATLAB",
    "code": "function rms = quadraticMean(list)\n    rms = sqrt(mean(list.^2));\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> quadraticMean((1:10))\n\nans =\n\n   6.204836822995429\n"
  },
  {
    "language": "MATLAB",
    "code": " [m,z] = filter(ones(1,P),P,x);\n"
  },
  {
    "language": "MATLAB",
    "code": " [m,z] = filter(ones(1,P),P,x,z);\n"
  },
  {
    "language": "MATLAB",
    "code": "function x = isbb(s)\n   t = cumsum((s=='[') - (s==']'));\n   x = all(t>=0) && (t(end)==0);\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "  dec2bin(5)\n  dec2bin(50)\n  dec2bin(9000)\n"
  },
  {
    "language": "MATLAB",
    "code": "function mid = binarySearchRec(list,value,low,high)\n\n    if( high < low )\n        mid = [];\n        return\n    end\n\n    mid = floor((low + high)/2);\n\n    if( list(mid) > value )\n        mid = binarySearchRec(list,value,low,mid-1);\n        return\n    elseif( list(mid) < value )\n        mid = binarySearchRec(list,value,mid+1,high);\n        return\n    else\n        return\n    end\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> binarySearchRec([1 2 3 4 5 6 6.5 7 8 9 11 18],6.5,1,numel([1 2 3 4 5 6 6.5 7 8 9 11 18]))\n\nans =\n\n     7\n"
  },
  {
    "language": "MATLAB",
    "code": "function mid = binarySearchIter(list,value)\n\n    low = 1;\n    high = numel(list) - 1;\n\n    while( low <= high )\n        mid = floor((low + high)/2);\n\n        if( list(mid) > value )\n            high = mid - 1;\n        elseif( list(mid) < value )\n        \tlow = mid + 1;\n        else\n            return\n        end\n    end\n\n    mid = [];\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> binarySearchIter([1 2 3 4 5 6 6.5 7 8 9 11 18],6.5)\n\nans =\n\n     7\n"
  },
  {
    "language": "MATLAB",
    "code": "\ta=['123',0,' abc '];\n\tb=['456',9];\n\tc='789';\n\tdisp(a);\n\tdisp(b);\n\tdisp(c);\n\n\t% string comparison\n\tprintf('(a==b) is %i\\n',strcmp(a,b));\n\n\t% string copying\n\tA = a;\n\tB = b;\n\tC = c;\n\tdisp(A);\n\tdisp(B);\n\tdisp(C);\n\n\t% check if string is empty\n\tif (length(a)==0)\n\t\tprintf('\\nstring a is empty\\n');\n\telse\n\t\tprintf('\\nstring a is not empty\\n');\n\tend\n\n\t% append a byte to a string\n\ta=[a,64];\n        disp(a);\n\n\t% substring\n\te = a(1:6);\n        disp(e);\n\n\t% join strings\n\td=[a,b,c];\n\tdisp(d);\n"
  },
  {
    "language": "MATLAB",
    "code": "%Bitmap class\n%\n%Implements a class to manage bitmap images without the need for the\n%various conversion and display functions\n%\n%Available functions:\n%\n%fill(obj,color)\n%setPixel(obj,pixel,color)\n%getPixel(obj,pixel,[optional: color channel])\n%display(obj)\n%disp(obj)\n%plot(obj)\n%image(obj)\n%save(obj)\n%open(obj)\n\nclassdef Bitmap\n\n    %% Public Properties\n    properties\n\n        %Channel arrays\n        red;\n        green;\n        blue;\n\n    end\n\n    %% Public Methods\n    methods\n\n        %Creates image and defaults it to black\n        function obj = Bitmap(width,height)\n            obj.red   = zeros(height,width,'uint8');\n            obj.green = zeros(height,width,'uint8');\n            obj.blue  = zeros(height,width,'uint8');\n        end % End Bitmap Constructor\n\n        %Fill the image with a specified color\n        %color = [red green blue] max for each is 255\n        function fill(obj,color)\n            obj.red(:,:)   = color(1);\n            obj.green(:,:) = color(2);\n            obj.blue(:,:)  = color(3);\n            assignin('caller',inputname(1),obj); %saves the changes to the object\n        end\n\n        %Set a pixel to a specified color\n        %pixel = [x y]\n        %color = [red green blue]\n        function setPixel(obj,pixel,color)\n            obj.red(pixel(2),pixel(1))   = color(1);\n            obj.green(pixel(2),pixel(1)) = color(2);\n            obj.blue(pixel(2),pixel(1))  = color(3);\n            assignin('caller',inputname(1),obj); %saves the changes to the object\n        end\n\n        %Get pixel color\n        %pixel = [x y]\n        %varargin can be:\n        %  no input for all channels\n        %  'r' or 'red' for red channel\n        %  'g' or 'green' for green channel\n        %  'b' or 'blue' for blue channel\n        function color = getPixel(obj,pixel,varargin)\n\n            if( ~isempty(varargin) )\n                switch (varargin{1})\n                    case {'r','red'}\n                        color = obj.red(pixel(2),pixel(1));\n                    case {'g','green'}\n                        color = obj.red(pixel(2),pixel(1));\n                    case {'b','blue'}\n                        color = obj.red(pixel(2),pixel(1));\n                end\n            else\n                color = [obj.red(pixel(2),pixel(1)) obj.green(pixel(2),pixel(1)) obj.blue(pixel(2),pixel(1))];\n            end\n\n        end\n\n        %Display the image\n        %varargin can be:\n        %  no input for all channels\n        %  'r' or 'red' for red channel\n        %  'g' or 'green' for green channel\n        %  'b' or 'blue' for blue channel\n        function display(obj,varargin)\n\n            if( ~isempty(varargin) )\n                switch (varargin{1})\n                    case {'r','red'}\n                        image(obj.red)\n                    case {'g','green'}\n                        image(obj.green)\n                    case {'b','blue'}\n                        image(obj.blue)\n                end\n\n                colormap bone;\n            else\n                bitmap = cat(3,obj.red,obj.green,obj.blue);\n                image(bitmap);\n            end\n        end\n\n        %Overload several commonly used display functions\n        function disp(obj,varargin)\n            display(obj,varargin{:});\n        end\n\n        function plot(obj,varargin)\n            display(obj,varargin{:});\n        end\n\n        function image(obj,varargin)\n            display(obj,varargin{:});\n        end\n\n        %Saves the image\n        function save(obj)\n\n            %Open file dialogue\n            [fileName,pathName,success] = uiputfile({'*.bmp','Bitmap Image (*.bmp)'},'Save Bitmap As');\n\n            if( not(success == 0) )\n                imwrite(cat(3,obj.red,obj.green,obj.blue),[pathName fileName],'bmp'); %Write image file to disk\n                disp('Save Complete');\n            end\n        end\n\n        %Opens an image and overwrites what is currently stored\n        function success = open(obj)\n\n            %Open file dialogue\n            [fileName,pathName,success] = uigetfile({'*.bmp','Bitmap Image (*.bmp)'},'Open Bitmap ');\n\n            if( not(success == 0) )\n\n                channels = imread([pathName fileName], 'bmp'); %returns color indexed data\n\n                %Store each channel\n                obj.red   = channels(:,:,1);\n                obj.green = channels(:,:,2);\n                obj.blue  = channels(:,:,3);\n\n                assignin('caller',inputname(1),obj); %saves the changes to the object\n                success = true;\n                return\n            else\n                success = false;\n                return\n            end\n        end\n\n\n    end %methods\nend %classdef\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(20,30);\n>> img.fill([30 30 150]);\n>> img.setPixel([10 15],[20 130 66]);\n>> disp(img)\n>> img.getPixel([10 15])\n\nans =\n\n   20  130   66\n\n>> img.getPixel([10 15],'red')\n\nans =\n\n   20\n\n>> img.save()\nSave Complete\n"
  },
  {
    "language": "MATLAB",
    "code": "function bezierCubic(obj,pixel_0,pixel_1,pixel_2,pixel_3,color,varargin)\n\n    if( isempty(varargin) )\n        resolution = 20;\n    else\n        resolution = varargin{1};\n    end\n\n    %Calculate time axis\n    time = (0:1/resolution:1)';\n    timeMinus = 1-time;\n\n    %The formula for the curve is expanded for clarity, the lack of\n    %loops is because its calculation has been vectorized\n    curve = (timeMinus).^3*pixel_0; %First term of polynomial\n    curve = curve + (3.*time.*timeMinus.^2)*pixel_1; %second term of polynomial\n    curve = curve + (3.*timeMinus.*time.^2)*pixel_2; %third term of polynomial\n    curve = curve + time.^3*pixel_3; %Fourth term of polynomial\n\n    curve = round(curve); %round each of the points to the nearest integer\n\n    %connect each of the points in the curve with a line using the\n    %Bresenham Line algorithm\n    for i = (1:length(curve)-1)\n        obj.bresenhamLine(curve(i,:),curve(i+1,:),color);\n    end\n\n    assignin('caller',inputname(1),obj); %saves the changes to the object\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(200,200);\n>> img.fill([255 255 255]);\n>> img.bezierCubic([160 10],[10 40],[30 160],[150 110],[255 0 0],110);\n>> disp(img)\n"
  },
  {
    "language": "MATLAB",
    "code": "function bezierQuad(obj,pixel_0,pixel_1,pixel_2,color,varargin)\n\n    if( isempty(varargin) )\n        resolution = 20;\n    else\n        resolution = varargin{1};\n    end\n\n    %Calculate time axis\n    time = (0:1/resolution:1)';\n    timeMinus = 1-time;\n\n    %The formula for the curve is expanded for clarity, the lack of\n    %loops is because its calculation has been vectorized\n    curve = (timeMinus.^2)*pixel_0; %First term of polynomial\n    curve = curve + (2.*time.*timeMinus)*pixel_1; %second term of polynomial\n    curve = curve + (time.^2)*pixel_2; %third term of polynomial\n\n    curve = round(curve); %round each of the points to the nearest integer\n\n    %connect each of the points in the curve with a line using the\n    %Bresenham Line algorithm\n    for i = (1:length(curve)-1)\n        obj.bresenhamLine(curve(i,:),curve(i+1,:),color);\n    end\n\n    assignin('caller',inputname(1),obj); %saves the changes to the object\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(400,300);\n>> img.fill([223 255 239]);\n>> img.bezierQuad([20 150],[500 -100],[300 280],[63 143 239],21);\n>> disp(img)\n"
  },
  {
    "language": "MATLAB",
    "code": "%screen     = Bitmap object\n%startPoint = [x0,y0]\n%endPoint   = [x1,y1]\n%color      = [red,green,blue]\n\nfunction bresenhamLine(screen,startPoint,endPoint,color)\n\n  if( any(color > 255) )\n      error 'RGB colors must be between 0 and 255';\n  end\n\n  %Check for vertical line, x0 == x1\n  if( startPoint(1) == endPoint(1) )\n      %Draw vertical line\n      for i = (startPoint(2):endPoint(2))\n          setPixel(screen,[startPoint(1) i],color);\n      end\n  end\n\n  %Simplified Bresenham algorithm\n  dx = abs(endPoint(1) - startPoint(1));\n  dy = abs(endPoint(2) - startPoint(2));\n\n  if(startPoint(1) < endPoint(1))\n      sx = 1;\n  else\n      sx = -1;\n  end\n\n  if(startPoint(2) < endPoint(2))\n      sy = 1;\n  else\n      sy = -1;\n  end\n\n  err = dx - dy;\n  pixel = startPoint;\n\n  while(true)\n\n      screen.setPixel(pixel,color); %setPixel(x0,y0)\n\n      if( pixel == endPoint )\n          break;\n      end\n\n      e2 = 2*err;\n\n      if( e2 > -dy )\n          err = err - dy;\n          pixel(1) = pixel(1) + sx;\n      end\n\n      if( e2 < dx )\n          err = err + dx;\n          pixel(2) = pixel(2) + sy;\n      end\n  end\n\n  assignin('caller',inputname(1),screen); %saves the changes to the object\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(800,600);\n>> img.bresenhamLine([400 550],[200 400],[255 255 255]);\n>> img.bresenhamLine([400 550],[600 400],[255 255 255]);\n>> img.bresenhamLine([200 400],[350 150],[255 255 255]);\n>> img.bresenhamLine([600 400],[450 150],[255 255 255]);\n>> img.bresenhamLine([350 150],[450 150],[255 255 255]);\n>> img.bresenhamLine([400 550],[400 150],[255 255 255]);\n>> disp(img)\n"
  },
  {
    "language": "MATLAB",
    "code": "R=[255,0,0;255,255,0];\nG=[0,255,0;255,255,0];\nB=[0,0,255;0,0,0];\n\n\nr = R'; r(:);\ng = R'; g(:);\nb = R'; b(:);\nfid=fopen('p6.ppm','w');\nfprintf(fid,'P6\\n%i %i\\n255\\n',size(R));\nfwrite(fid,[r,g,b]','uint8');\nfclose(fid);\n"
  },
  {
    "language": "MATLAB",
    "code": "function bitwiseOps(a,b)\n\n    disp(sprintf('%d and %d = %d', [a b bitand(a,b)]));\n    disp(sprintf('%d or %d = %d', [a b bitor(a,b)]));\n    disp(sprintf('%d xor %d = %d', [a b bitxor(a,b)]));\n    disp(sprintf('%d << %d = %d', [a b bitshift(a,b)]));\n    disp(sprintf('%d >> %d = %d', [a b bitshift(a,-b)]));\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> bitwiseOps(255,2)\n255 and 2 = 2\n255 or 2 = 255\n255 xor 2 = 253\n255 << 2 = 1020\n255 >> 2 = 63\n"
  },
  {
    "language": "MATLAB",
    "code": ">> islogical(true)\n\nans =\n\n     1\n\n>> islogical(false)\n\nans =\n\n     1\n\n>> islogical(logical(1))\n\nans =\n\n     1\n\n>> islogical(logical(0))\n\nans =\n\n     1\n\n>> islogical(1)\n\nans =\n\n     0\n\n>> islogical(0)\n\nans =\n\n     0\n"
  },
  {
    "language": "MATLAB",
    "code": "function b = compassbox(d)\n    b = ceil(mod(d+360/64,360)*32/360);\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "function BullsAndCowsPlayer\n% Plays the game Bulls and Cows as the player\n\n    % Generate list of all possible numbers\n    nDigits = 4;\n    lowVal = 1;\n    highVal = 9;\n    combs = nchoosek(lowVal:highVal, nDigits);\n    nCombs = size(combs, 1);\n    nPermsPerComb = factorial(nDigits);\n    gList = zeros(nCombs.*nPermsPerComb, nDigits);\n    for k = 1:nCombs\n        gList(nPermsPerComb*(k-1)+1:nPermsPerComb*k, :) = perms(combs(k, :));\n    end\n\n    % Prompt user\n    fprintf('Think of a number with:\\n')\n    fprintf('  %d digits\\n', nDigits)\n    fprintf('  Each digit between %d and %d inclusive\\n', lowVal, highVal)\n    fprintf('  No repeated digits\\n')\n    fprintf('I''ll try to guess that number and you score me:\\n')\n    fprintf('  1 Bull per correct digit in the correct place\\n')\n    fprintf('  1 Cow per correct digit in the wrong place\\n')\n    fprintf('Think of your number and press Enter when ready\\n')\n    pause\n\n    % Play game until all digits are correct\n    nBulls = 0;\n    nGuesses = 0;\n    while nBulls < 4 && ~isempty(gList)\n        nList = size(gList, 1);\n        g = gList(randi(nList), :);     % Random guess from list\n        fprintf('My guess: %s?\\n', sprintf('%d', g))\n        nBulls = input('How many bulls? ');\n        if nBulls < 4\n            nCows = input('How many cows? ');\n            del = false(nList, 1);\n            for k = 1:nList\n                del(k) = any([nBulls nCows] ~= CountBullsCows(g, gList(k, :)));\n            end\n            gList(del, :) = [];\n        end\n        nGuesses = nGuesses+1;\n    end\n    if isempty(gList)\n        fprintf('That''s bull! You messed up your scoring.\\n')\n    else\n        fprintf('Yay, I won! Only took %d guesses.\\n', nGuesses)\n    end\nend\n\nfunction score = CountBullsCows(guess, correct)\n% Checks the guessed array of digits against the correct array to find the score\n% Assumes arrays of same length and valid numbers\n    bulls = guess == correct;\n    cows = ismember(guess(~bulls), correct);\n    score = [sum(bulls) sum(cows)];\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function BullsAndCows\n% Plays the game Bulls and Cows as the \"game master\"\n\n    % Create a secret number\n    nDigits = 4;\n    lowVal = 1;\n    highVal = 9;\n    digitList = lowVal:highVal;\n    secret = zeros(1, 4);\n    for k = 1:nDigits\n        idx = randi(length(digitList));\n        secret(k) = digitList(idx);\n        digitList(idx) = [];\n    end\n\n    % Give game information\n    fprintf('Welcome to Bulls and Cows!\\n')\n    fprintf('Try to guess the %d-digit number (no repeated digits).\\n', nDigits)\n    fprintf('Digits are between %d and %d (inclusive).\\n', lowVal, highVal)\n    fprintf('Score: 1 Bull per correct digit in correct place.\\n')\n    fprintf('       1 Cow per correct digit in incorrect place.\\n')\n    fprintf('The number has been chosen. Now it''s your moooooove!\\n')\n    gs = input('Guess: ', 's');\n\n    % Loop until user guesses right or quits (no guess)\n    nGuesses = 1;\n    while gs\n        gn = str2double(gs);\n        if isnan(gn) || length(gn) > 1  % Not a scalar\n            fprintf('Malformed guess. Keep to valid scalars.\\n')\n            gs = input('Try again: ', 's');\n        else\n            g = sprintf('%d', gn) - '0';\n            if length(g) ~= nDigits || any(g < lowVal) || any(g > highVal) || ...\n                    length(unique(g)) ~= nDigits    % Invalid number for game\n                fprintf('Malformed guess. Remember:\\n')\n                fprintf('  %d digits\\n', nDigits)\n                fprintf('  Between %d and %d inclusive\\n', lowVal, highVal)\n                fprintf('  No repeated digits\\n')\n                gs = input('Try again: ', 's');\n            else\n                score = CountBullsCows(g, secret);\n                if score(1) == nDigits\n                    fprintf('You win! Bully for you! Only %d guesses.\\n', nGuesses)\n                    gs = '';\n                else\n                    fprintf('Score: %d Bulls, %d Cows\\n', score)\n                    gs = input('Guess: ', 's');\n                end\n            end\n        end\n        nGuesses = nGuesses+1;  % Counts malformed guesses\n    end\nend\n\nfunction score = CountBullsCows(guess, correct)\n% Checks the guessed array of digits against the correct array to find the score\n% Assumes arrays of same length and valid numbers\n    bulls = guess == correct;\n    cows = ismember(guess(~bulls), correct);\n    score = [sum(bulls) sum(cows)];\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "   function s = cipherCaesar(s, key)\n          s = char( mod(s - 'A' + key, 25 ) + 'A');\n   end; \t\n   function s = decipherCaesar(s, key)\n          s = char( mod(s - 'A' - key, 25 ) + 'A');\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "   decipherCaesar(cipherCaesar('ABC',4),4)\n   ans = ABC\n"
  },
  {
    "language": "MATLAB",
    "code": "    % Calling a function that requires no arguments\n       function a=foo();\n         a=4;\n       end;\n       x = foo();\n    % Calling a function with a fixed number of arguments\n       function foo(a,b,c);\n         %% function definition;\n       end;\n       foo(x,y,z);\n    % Calling a function with optional arguments\n       function foo(a,b,c);\n\tif nargin<2, b=0; end;\n\tif nargin<3, c=0; end;\n         %% function definition;\n       end;\n       foo(x,y);\n    % Calling a function with a variable number of arguments\n       function foo(varargin);\n\t  for k=1:length(varargin)\n            arg{k} = varargin{k};\t\n       end;\n       foo(x,y);\n    % Calling a function with named arguments\n\t%% does not apply\n    % Using a function in statement context\n\t%% does not apply\n    % Using a function in first-class context within an expression\n    % Obtaining the return value of a function\n       function [a,b]=foo();\n         a=4;\n         b='result string';\n       end;\n       [x,y] = foo();\n    % Distinguishing built-in functions and user-defined functions\n\tfun = 'foo';\t\n\tif (exist(fun,'builtin'))\n \t\tprintf('function %s is a builtin\\n');\n        elseif (exist(fun,'file'))\n \t\tprintf('function %s is user-defined\\n');\n        elseif (exist(fun,'var'))\n \t\tprintf('function %s is a variable\\n');\n        else\n \t\tprintf('%s is not a function or variable.\\n');\n        end\n    % Distinguishing subroutines and functions\n        % there are only scripts and functions, any function declaration starts with the keyword function, otherwise it is a script that runs in the workspace\n    % Stating whether arguments are passed by value or by reference\n      % arguments are passed by value, however Matlab has delayed evaluation, such that a copy of large data structures are done only when an element is written to.\n"
  },
  {
    "language": "MATLAB",
    "code": "BWImage = edge(GrayscaleImage,'canny');\n"
  },
  {
    "language": "MATLAB",
    "code": "  dog = 'Benjamin';\n  Dog = 'Samba';\n  DOG = 'Bernie';\n\n  printf('There are three dogs %s, %s, %s.\\n',dog, Dog, DOG);\n"
  },
  {
    "language": "MATLAB",
    "code": "function n = catalanNumber(n)\n    for i = (1:length(n))\n        n(i) = (1/(n(i)+1))*nchoosek(2*n(i),n(i));\n    end\nend\n"
  },
  {
    "language": "Perl",
    "code": "my @doors;\nfor my $pass (1 .. 100) {\n    for (1 .. 100) {\n        if (0 == $_ % $pass) {\n            $doors[$_] = not $doors[$_];\n        };\n    };\n};\n\nprint \"Door $_ is \", $doors[$_] ? \"open\" : \"closed\", \"\\n\" for 1 .. 100;\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\nuse strict;\nuse warnings;\n\nmy @doors = (1) x 100;\nfor my $N (1 .. 100) {\n   $doors[$_]=1-$doors[$_] for map { $_*$N - 1 } 1 .. int(100/$N);\n}\nprint join(\"\\n\", map { \"Door $_ is Open\" } grep { ! $doors[$_-1] } 1 .. 100), \"\\n\";\nprint \"The rest are closed\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "print \"Door $_ is open\\n\" for map $_**2, 1 .. 10;\n"
  },
  {
    "language": "Perl",
    "code": "print \"Door $_ is \", qw\"closed open\"[int sqrt == sqrt], \"\\n\" for 1..100;\n"
  },
  {
    "language": "Perl",
    "code": "while( ++$i <= 100 )\n{\n    $root = sqrt($i);\n    if ( int( $root ) == $root )\n    {\n        print \"Door $i is open\\n\";\n    }\n    else\n    {\n        print \"Door $i is closed\\n\";\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "# Fischer-Krause ordered permutation generator\n# http://faq.perl.org/perlfaq4.html#How_do_I_permute_N_e\nsub permute (&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$#_;\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $#idx;\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n# generate all possible combinations of operators\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/env perl\nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q')\n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  # remove all white space\n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  # not correct digits\n      $entry =~ /\\d\\d/ ||                # combined digits\n      $entry =~ m|[-+*/]{2}| ||          # combined operators\n      $entry =~ tr|-0-9()+*/||c)         # Invalid characters\n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/:all/;\n\nsub triangle_row {\n  my($n,@row) = (shift);\n  # Tally by first element of the unrestricted integer partitions.\n  forpart { $row[ $_[0] - 1 ]++ } $n;\n  @row;\n}\n\nprintf \"%2d: %s\\n\", $_, join(\" \",triangle_row($_)) for 1..25;\nprint \"\\n\";\nsay \"P($_) = \", partitions($_) for (23, 123, 1234, 12345);\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\n# Where perl6 uses arbitrary precision integers everywhere\n# that you don't tell it not to do so, perl5 will only use\n# them where you *do* tell it do so.\nuse Math::BigInt;\nuse constant zero => Math::BigInt->bzero;\nuse constant one  => Math::BigInt->bone;\n\nmy @todo = [one];\nmy @sums = (zero);\nsub nextrow {\n   my $n = shift;\n   for my $l (@todo .. $n) {\n      $sums[$l] = zero;\n      #print \"$l\\r\" if $l < $n;\n      my @r;\n      for my $x (reverse 0 .. $l-1) {\n         my $todo = $todo[$x];\n         $sums[$x] += shift @$todo if @$todo;\n         push @r, $sums[$x];\n      }\n      push @todo, \\@r;\n   }\n   @{ $todo[$n] };\n}\n\nprint \"rows:\\n\";\nfor(1..25) {\n   printf(\"%2d: \", $_);\n   print join(' ', nextrow($_)), \"\\n\";\n}\nprint \"\\nsums:\\n\";\nfor (23, 123, 1234, 12345) {\n   print $_, \".\" x (8 - length);\n   my $i = 0;\n   $i += $_ for nextrow($_);\n   print $i, \"\\n\";\n}\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl -w\n\nmy $verse = <<\"VERSE\";\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\nVERSE\n\n{\n    $verse =~ s/(\\d+)/$1-1/ge;\n    $verse =~ s/\\b1 bottles/1 bottle/g;\n    my $done = $verse =~ s/\\b0 bottle/No bottles/g; # if we make this replacement, we're also done.\n\n    print $verse;\n    redo unless $done;\n}\n"
  },
  {
    "language": "Perl",
    "code": "for $n (reverse(0..99))\n{\n    $bottles = sprintf(\"%s bottle%s of beer on the wall\\n\",(($n==0)?\"No\":$n), (($n==1)?\"\":\"s\"));\n    print( (($n==99)?\"\":\"$bottles\\n\") .\n\t   (($n==0)?\"\":(substr(${bottles}x2,0,-12) . \"\\nTake one down, pass it around\\n\")) );\n}\n"
  },
  {
    "language": "Perl",
    "code": "use 5.10.0;\n\n$num = 99;\nwhile ($num > 0) {\n    my $s = \"s\" unless ($num == 1);\n    say \"$num bottle$s of beer on the wall, $num bottle$s of beer\";\n    $num--;\n    my $s = \"s\" unless ($num == 1);\n    $num = \"No more\" if ($num == 0);\n    say \"Take one down, pass it around, $num bottle$s of beer on the wall\\n\"\n}\n\nsay \"No more bottles of beer on the wall, no more bottles of beer.\";\nsay \"Go to the store and buy some more, 99 bottles of beer on the wall.\";\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/env perl\nuse strict;\nuse warnings;\n\nsub bottles() { sprintf qq{%s bottle%s of beer}\n               , $_ || 'No'\n               , $_==1 ? '' : 's';\n               }\nsub store() { $_=99; qq{Go to the store, buy some more...\\n}; }\nsub wall() { qq{ on the wall\\n} }\nsub take() { $_-- ? qq{Take one down, pass it around\\n} : store }\ndo { print bottles, wall\n         , bottles, qq{\\n}\n         , take\n         , bottles, qq{\\n\\n}\n   } for reverse 0..99;\n"
  },
  {
    "language": "Perl",
    "code": "my ($a,$b) = split(' ', scalar(<STDIN>));\nprint \"$a $b \" . ($a + $b) . \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "say sum split /\\s+/,  scalar <STDIN>;\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\nuse warnings;\nuse strict;\n\n\nsub can_make_word {\n    my ($word, @blocks) = @_;\n    $_ = uc join q(), sort split // for @blocks;\n    my %blocks;\n    $blocks{$_}++ for @blocks;\n    return _can_make_word(uc $word, %blocks)\n}\n\n\nsub _can_make_word {\n    my ($word, %blocks) = @_;\n    my $char = substr $word, 0, 1, q();\n\n    my @candidates = grep 0 <= index($_, $char), keys %blocks;\n    for my $candidate (@candidates) {\n        next if $blocks{$candidate} <= 0;\n        local $blocks{$candidate} = $blocks{$candidate} - 1;\n        return 1 if q() eq $word or _can_make_word($word, %blocks);\n    }\n    return\n}\n"
  },
  {
    "language": "Perl",
    "code": "use Test::More tests => 8;\n\nmy @blocks1 = qw(BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM);\nis(can_make_word(\"A\",       @blocks1), 1);\nis(can_make_word(\"BARK\",    @blocks1), 1);\nis(can_make_word(\"BOOK\",    @blocks1), undef);\nis(can_make_word(\"TREAT\",   @blocks1), 1);\nis(can_make_word(\"COMMON\",  @blocks1), undef);\nis(can_make_word(\"SQUAD\",   @blocks1), 1);\nis(can_make_word(\"CONFUSE\", @blocks1), 1);\n\nmy @blocks2 = qw(US TZ AO QA);\nis(can_make_word('auto', @blocks2), 1);\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse strict;\n\nsub frob { die \"abstract\" }\nsub baz { die \"abstract\" }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse strict;\n\nsub frob { ... }\nsub baz { ... }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse Moose::Role;\n\nrequires qw/frob baz/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse Role::Tiny;\n\nrequires qw/frob baz/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\nmy @type = <Perfect Abundant Deficient>;\nsay join \"\\n\", map { sprintf \"%2d %s\", $_, $type[divisor_sum($_)-$_ <=> $_] } 1..12;\nmy %h;\n$h{divisor_sum($_)-$_ <=> $_}++ for 1..20000;\nsay \"Perfect: $h{0}    Deficient: $h{-1}    Abundant: $h{1}\";\n"
  },
  {
    "language": "Perl",
    "code": "sub div_sum {\n    my($n) = @_;\n    my $sum = 0;\n    map { $sum += $_ unless $n % $_ } 1 .. $n-1;\n    $sum;\n}\n\nmy @type = <Perfect Abundant Deficient>;\nsay join \"\\n\", map { sprintf \"%2d %s\", $_, $type[div_sum($_) <=> $_] } 1..12;\nmy %h;\n$h{div_sum($_) <=> $_}++ for 1..20000;\nsay \"Perfect: $h{0}    Deficient: $h{-1}    Abundant: $h{1}\";\n"
  },
  {
    "language": "Perl",
    "code": "sub accumulator {\n  my $sum = shift;\n  sub { $sum += shift }\n}\n\nmy $x = accumulator(1);\n$x->(5);\naccumulator(3);\nprint $x->(2.3), \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "{\n    my @memo;\n    sub A {\n        my( $m, $n ) = @_;\n        $memo[ $m ][ $n ] and return $memo[ $m ][ $n ];\n        $m or return $n + 1;\n        return $memo[ $m ][ $n ] = (\n            $n\n               ? A( $m - 1, A( $m, $n - 1 ) )\n               : A( $m - 1, 1 )\n        );\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub A {\n    my ($m, $n) = @_;\n    if    ($m == 0) { $n + 1 }\n    elsif ($n == 0) { A($m - 1, 1) }\n    else            { A($m - 1, A($m, $n - 1)) }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub A {\n  my ($m, $n) = @_;\n  $m == 0 ? $n + 1 :\n  $n == 0 ? A($m - 1, 1) :\n            A($m - 1, A($m, $n - 1))\n}\n"
  },
  {
    "language": "Perl",
    "code": "use Memoize;  memoize('ack2');\nuse bigint try=>\"GMP\";\n\nsub ack2 {\n   my ($m, $n) = @_;\n   $m == 0 ? $n + 1 :\n   $m == 1 ? $n + 2 :\n   $m == 2 ? 2*$n + 3 :\n   $m == 3 ? 8 * (2**$n - 1) + 5 :\n   $n == 0 ? ack2($m-1, 1)\n           : ack2($m-1, ack2($m, $n-1));\n}\nprint \"ack2(3,4) is \", ack2(3,4), \"\\n\";\nprint \"ack2(4,1) is \", ack2(4,1), \"\\n\";\nprint \"ack2(4,2) has \", length(ack2(4,2)), \" digits\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Math::BigInt;\n\nuse constant two => Math::BigInt->new(2);\n\nsub ack {\n\tmy $n = pop;\n\twhile( @_ ) {\n\t\tmy $m = pop;\n\t\tif( $m > 3 ) {\n\t\t\tpush @_, (--$m) x $n;\n\t\t\tpush @_, reverse 3 .. --$m;\n\t\t\t$n = 13;\n\t\t} elsif( $m == 3 ) {\n\t\t\tif( $n < 29 ) {\n\t\t\t\t$n = ( 1 << ( $n + 3 ) ) - 3;\n\t\t\t} else {\n\t\t\t\t$n = two ** ( $n + 3 ) - 3;\n\t\t\t}\n\t\t} elsif( $m == 2 ) {\n\t\t\t$n = 2 * $n + 3;\n\t\t} elsif( $m >= 0 ) {\n\t\t\t$n = $n + $m + 1;\n\t\t} else {\n\t\t\tdie \"negative m!\";\n\t\t}\n\t}\n\t$n;\n}\n\nprint \"ack(3,4) is \", ack(3,4), \"\\n\";\nprint \"ack(4,1) is \", ack(4,1), \"\\n\";\nprint \"ack(4,2) has \", length(ack(4,2)), \" digits\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use Net::LDAP;\n\nmy $ldap = Net::LDAP->new('ldap://ldap.example.com') or die $@;\nmy $mesg = $ldap->bind( $bind_dn, password => $bind_pass );\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\n\nuse strict;\nuse 5.10.0;\n\npackage Integrator;\nuse threads;\nuse threads::shared;\n\nsub new {\n\tmy $cls = shift;\n\tmy $obj = bless {\tt\t=> 0,\n\t\t\t\tsum\t=> 0,\n\t\t\t\tref $cls ? %$cls : (),\n\t\t\t\tstop\t=> 0,\n\t\t\t\ttid\t=> 0,\n\t\t\t\tfunc\t=> shift,\n\t\t\t}, ref $cls || $cls;\n\n\tshare($obj->{sum});\n\tshare($obj->{stop});\n\n\t$obj->{tid} = async {\n\t\tmy $upd = 0.1; # update every 0.1 second\n\t\twhile (!$obj->{stop}) {\n\t\t\t{\n\t\t\t\tmy $f = $obj->{func};\n\t\t\t\tmy $t = $obj->{t};\n\n\t\t\t\t$obj->{sum} += ($f->($t) + $f->($t + $upd))* $upd/ 2;\n\t\t\t\t$obj->{t} += $upd;\n\t\t\t}\n\t\t\tselect(undef, undef, undef, $upd);\n\t\t}\n\t#\tsay \"stopping $obj\";\n\t};\n\t$obj\n}\n\nsub output { shift->{sum} }\n\nsub delete {\n\tmy $obj = shift;\n\t$obj->{stop} = 1;\n\t$obj->{tid}->join;\n}\n\nsub setinput {\n\t# This is surprisingly difficult because of the perl sharing model.\n\t# Func refs can't be shared, thus can't be replaced by another thread.\n\t# Have to create a whole new object... there must be a better way.\n\tmy $obj = shift;\n\t$obj->delete;\n\t$obj->new(shift);\n}\n\npackage main;\n\nmy $x = Integrator->new(sub { sin(atan2(1, 1) * 8 * .5 * shift) });\n\nsleep(2);\nsay \"sin after 2 seconds: \", $x->output;\n\n$x = $x->setinput(sub {0});\n\nselect(undef, undef, undef, .5);\nsay \"0 after .5 seconds: \", $x->output;\n\n$x->delete;\n"
  },
  {
    "language": "Perl",
    "code": "package Empty;\n\n# Constructor. Object is hash.\nsub new { return bless {}, shift; }\n\npackage main;\n\n# Object.\nmy $o = Empty->new;\n\n# Set runtime variable (key => value).\n$o->{'foo'} = 1;\n"
  },
  {
    "language": "Perl",
    "code": "use Scalar::Util qw(refaddr);\nprint refaddr(\\my $v), \"\\n\";  # 140502490125712\n"
  },
  {
    "language": "Perl",
    "code": "printf \"%p\", $v; # 7fc949039590\n"
  },
  {
    "language": "Perl",
    "code": "my $a = 12;\nmy $b = \\$a; # get reference\n$$b = $$b + 30; # access referenced value\nprint $a; # prints 42\n"
  },
  {
    "language": "Perl",
    "code": "my $a = 12;\nour $b; # you can overlay only global variables (this line is only for strictness)\n*b = \\$a;\nprint $b; # prints 12\n$b++;\nprint $a; # prints 13\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n# Select one of these lines.  Math::BigInt is in core, but quite slow.\nuse Math::BigInt;  sub binomial { Math::BigInt->new(shift)->bnok(shift) }\n# use Math::Pari \"binomial\";\n# use ntheory \"binomial\";\n\nsub binprime {\n  my $p = shift;\n  return 0 unless $p >= 2;\n  # binomial is symmetric, so only test half the terms\n  for (1 .. ($p>>1)) { return 0 if binomial($p,$_) % $p }\n  1;\n}\nsub coef {                   # For prettier printing\n  my($n,$e) = @_;\n  return $n unless $e;\n  $n = \"\" if $n==1;\n  $e==1 ? \"${n}x\" : \"${n}x^$e\";\n}\nsub binpoly {\n  my $p = shift;\n  join(\" \", coef(1,$p),\n            map { join(\"\",(\"+\",\"-\")[($p-$_)&1],\" \",coef(binomial($p,$_),$_)) }\n            reverse 0..$p-1 );\n}\nprint \"expansions of (x-1)^p:\\n\";\nprint binpoly($_),\"\\n\" for 0..9;\nprint \"Primes to 80: [\", join(\",\", grep { binprime($_) } 2..80), \"]\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory \":all\";\n# Uncomment next line to see the r and s values used.  Set to 2 for more detail.\n# prime_set_config(verbose => 1);\nsay join(\" \", grep { is_aks_prime($_) } 1_000_000_000 .. 1_000_000_100);\n"
  },
  {
    "language": "Perl",
    "code": "#/usr/bin/perl -w\nuse strict ;\n\ndie \"Call : perl columnaligner.pl <inputfile> <printorientation>!\\n\" unless\n   @ARGV == 2 ; #$ARGV[ 0 ] contains example file , $ARGV[1] any of 'left' , 'right' or 'center'\ndie \"last argument must be one of center, left or right!\\n\" unless\n   $ARGV[ 1 ] =~ /center|left|right/ ;\nsub printLines( $$$ ) ;\nopen INFILE , \"<\" , \"$ARGV[ 0 ]\" or die \"Can't open $ARGV[ 0 ]!\\n\" ;\nmy @lines = <INFILE> ;\nclose INFILE ;\nchomp @lines ;\nmy @fieldwidths = map length, split /\\$/ , $lines[ 0 ] ;\nforeach my $i ( 1..$#lines ) {\n   my @words = split /\\$/ , $lines[ $i ] ;\n   foreach my $j ( 0..$#words ) {\n      if ( $j <= $#fieldwidths ) {\n         if ( length $words[ $j ] > $fieldwidths[ $j ] ) {\n               $fieldwidths[ $j ] = length $words[ $j ] ;\n         }\n      }\n      else {\n         push @fieldwidths, length $words[ $j ] ;\n      }\n   }\n}\nprintLine( $_ , $ARGV[ 1 ] , \\@fieldwidths ) foreach @lines ;\n##################################################################    ####\nsub printLine {\n   my $line = shift ;\n   my $orientation = shift ;\n   my $widthref = shift ;\n   my @words = split /\\$/, $line ;\n   foreach my $k ( 0..$#words ) {\n      my $printwidth = $widthref->[ $k ] + 1 ;\n      if ( $orientation eq 'center' ) {\n         $printwidth++ ;\n      }\n      if ( $orientation eq 'left' ) {\n         print $words[ $k ] ;\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n      }\n      elsif ( $orientation eq 'right' ) {\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n         print $words[ $k ] ;\n      }\n      elsif ( $orientation eq 'center' ) {\n         my $left = int( ( $printwidth - length $words[ $k ] )     / 2 ) ;\n         my $right = $printwidth - length( $words[ $k ] ) - $left      ;\n         print \" \" x $left ;\n         print $words[ $k ] ;\n         print \" \" x $right ;\n      }\n   }\n   print \"\\n\" ;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use List::Util qw(max);\n\nsub columns {\n    my @lines = map [split /\\$/] => split /\\n/ => shift;\n    my $pos = {qw/left 0 center 1 right 2/}->{+shift};\n    for my $col (0 .. max map {$#$_} @lines) {\n        my $max = max my @widths = map {length $_->[$col]} @lines;\n        for my $row (0 .. $#lines) {\n            my @pad = map {' ' x $_, ' ' x ($_ + 0.5)} ($max - $widths[$row]) / 2;\n            for ($lines[$row][$col])\n                {$_ = join '' => @pad[0 .. $pos-1], $_, @pad[$pos .. $#pad]}\n        }\n    }\n    join '' => map {\"@$_\\n\"} @lines\n}\n\nprint columns <<'END', $_ for qw(left right center);\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    # push onto allterms here if we want the cyclic term to display\n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/factor/;\nsub almost {\n  my($k,$n) = @_;\n  my $i = 1;\n  map { $i++ while scalar factor($i) != $k; $i++ } 1..$n;\n}\nsay \"$_ : \", join(\" \", almost($_,10)) for 1..5;\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nsub k_almost_prime;\n\nfor my $k ( 1 .. 5 ) {\n\tmy $almost = 0;\n\tprint join(\", \", map {\n\t\t1 until k_almost_prime ++$almost, $k;\n\t\t\"$almost\";\n\t} 1 .. 10), \"\\n\";\n}\n\nsub nth_prime;\n\nsub k_almost_prime {\n\tmy ($n, $k) = @_;\n\treturn if $n <= 1 or $k < 1;\n\tmy $which_prime = 0;\n\tfor my $count ( 1 .. $k ) {\n\t\twhile( $n % nth_prime $which_prime ) {\n\t\t\t++$which_prime;\n\t\t}\n\t\t$n /= nth_prime $which_prime;\n\t\treturn if $n == 1 and $count != $k;\n\t}\n\t($n == 1) ? 1 : ();\n}\n\nBEGIN {\n\t# This is loosely based on one of the python solutions\n\t# to the RC Sieve of Eratosthenes task.\n\tmy @primes = (2, 3, 5, 7);\n\tmy $p_iter = 1;\n\tmy $p = $primes[$p_iter];\n\tmy $q = $p*$p;\n\tmy %sieve;\n\tmy $candidate = $primes[-1] + 2;\n\tsub nth_prime {\n\t\tmy $n = shift;\n\t\treturn if $n < 0;\n\t\tOUTER: while( $#primes < $n ) {\n\t\t\twhile( my $s = delete $sieve{$candidate} ) {\n\t\t\t\tmy $next = $s + $candidate;\n\t\t\t\t$next += $s while exists $sieve{$next};\n\t\t\t\t$sieve{$next} = $s;\n\t\t\t\t$candidate += 2;\n\t\t\t}\n\t\t\twhile( $candidate < $q ) {\n\t\t\t\tpush @primes, $candidate;\n\t\t\t\t$candidate += 2;\n\t\t\t\tnext OUTER if exists $sieve{$candidate};\n\t\t\t}\n\t\t\tmy $twop = 2 * $p;\n\t\t\tmy $next = $q + $twop;\n\t\t\t$next += $twop while exists $sieve{$next};\n\t\t\t$sieve{$next} = $twop;\n\t\t\t$p = $primes[++$p_iter];\n\t\t\t$q = $p * $p;\t\n\t\t\t$candidate += 2;\n\t\t}\n\t\treturn $primes[$n];\n\t}\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nuse constant EXIT_FAILURE => 1;\nuse constant EXIT_SUCCESS => 0;\n\nsub amb {\n   exit(EXIT_FAILURE) if !@_;\n   for my $word (@_) {\n      my $pid = fork;\n      die $! unless defined $pid;\n      return $word if !$pid;\n      my $wpid = waitpid $pid, 0;\n      die $! unless $wpid == $pid;\n      exit(EXIT_SUCCESS) if $? == EXIT_SUCCESS;\n   }\n   exit(EXIT_FAILURE);\n}\n\nsub joined {\n   my ($join_a, $join_b) = @_;\n   substr($join_a, -1) eq substr($join_b, 0, 1);\n}\n\nmy $w1 = amb(qw(the that a));\nmy $w2 = amb(qw(frog elephant thing));\nmy $w3 = amb(qw(walked treaded grows));\nmy $w4 = amb(qw(slowly quickly));\n\namb() unless joined $w1, $w2;\namb() unless joined $w2, $w3;\namb() unless joined $w3, $w4;\n\nprint \"$w1 $w2 $w3 $w4\\n\";\nexit(EXIT_SUCCESS);\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse feature 'say';\nuse re 'eval';\n\nsub amb ($@) {\n    my $var = shift;\n    join ' || ', map { \"(?{ $var = '$_' })\" } @_;\n}\n\nsub joins {\n    substr(shift,-1,1) eq substr(shift,0,1)\n}\n\nmy ($a,$b,$c,$d);\n'' =~ m/\n    (??{  amb '$a', qw[the that a]           })\n    (??{  amb '$b', qw[frog elephant thing]  })\n    (??{  amb '$c', qw[walked treaded grows] })\n    (??{  amb '$d', qw[slowly quickly]       })\n    (?(?{ joins($b, $c)                      })|(*FAIL))\n    (?(?{ joins($a, $b)                      })|(*FAIL))\n    (?(?{ joins($c, $d)                      })|(*FAIL))\n    (?{   say \"$a $b $c $d\"                  })\n/x;\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nsub amb {\n   if( @_ == 0 ) {\n      no warnings 'exiting';\n      next AMB;\n   }\n   my $code = pop;\n   my @words = @_;\n   my @index = (0) x @words;\n   AMB: while( 1 ) {\n      my @w = map $words[$_][$index[$_]], 0 .. $#_;\n      return $code->( @w );\n   } continue {\n      my $i = 0;\n      while( ++$index[$i] == @{$words[$i]} ) {\n         $index[$i] = 0;\n         return if ++$i == @index;\n      }\n   }\n}\n\nmy @w1 = qw(the that a);\nmy @w2 = qw(frog elephant thing);\nmy @w3 = qw(walked treaded grows);\nmy @w4 = qw(slowly quickly);\n\nsub joined {\n   my ($join_a, $join_b) = @_;\n   substr($join_a, -1) eq substr($join_b, 0, 1);\n}\n\namb( \\(@w1, @w2, @w3, @w4), sub {\n   my ($w1, $w2, $w3, $w4) = @_;\n   amb() unless joined($w1, $w2);\n   amb() unless joined($w2, $w3);\n   amb() unless joined($w3, $w4);\n   print \"$w1 $w2 $w3 $w4\\n\";\n});\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\nfor my $x (1..20000) {\n  my $y = divisor_sum($x)-$x;\n  say \"$x $y\" if $y > $x && $x == divisor_sum($y)-$y;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use List::Util 'max';\n\nmy @words = split \"\\n\", do { local( @ARGV, $/ ) = ( 'unixdict.txt' ); <> };\nmy %anagram;\nfor my $word (@words) {\n    push @{ $anagram{join '', sort split '', $word} }, $word;\n}\n\nmy $count = max(map {scalar @$_} values %anagram);\nfor my $ana (values %anagram) {\n    print \"@$ana\\n\" if @$ana == $count;\n}\n"
  },
  {
    "language": "Perl",
    "code": "push @{$anagram{ join '' => sort split '' }}, $_ for @words;\n$max > @$_  or  $max = @$_    for values %anagram;\n@$_ == $max and print \"@$_\\n\" for values %anagram;\n"
  },
  {
    "language": "Perl",
    "code": "sub deranged {                          # only anagrams ever get here\n        my @a = split('', shift);       # split word into letters\n        my @b = split('', shift);\n        for (0 .. $#a) {\n                $a[$_] eq $b[$_] and return;\n        }\n        return 1\n}\n\nsub find_deranged {\n        for my $i ( 0 .. $#_ ) {\n                for my $j ( $i+1 .. $#_ ) {\n                        next unless deranged $_[$i], $_[$j];\n\n                        print \"length \", length($_[$i]), \": $_[$i] => $_[$j]\\n\";\n                        return 1;\n                }\n        }\n}\n\nmy %letter_list;\nopen my $in, 'unixdict.txt';\n\nlocal $/ = undef;\n\nfor (split(' ', <$in>)) {\n        # store anagrams in hash table by letters they contain\n        push @{ $letter_list{ join('', sort split('', $_)) } }, $_\n}\n\nfor (   sort { length($b) <=> length($a) }      # sort by length, descending\n        grep { @{ $letter_list{$_} } > 1 }      # take only ones with anagrams\n        keys %letter_list               )\n{\n        # if we find a pair, they are the longested due to the sort before\n        last if find_deranged(@{ $letter_list{$_} });\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Tk;\nuse Math::Trig qw/:pi/;\n\nmy $root =  new MainWindow( -title => 'Pendulum Animation' );\nmy $canvas = $root->Canvas(-width => 320, -height => 200);\nmy $after_id;\n\nfor ($canvas) {\n\t$_->createLine(   0,  25, 320,  25, -tags => [qw/plate/], -width => 2, -fill => 'grey50' );\n\t$_->createOval( 155,  20, 165,  30, -tags => [qw/pivot outline/], -fill => 'grey50' );\n\t$_->createLine(   1,   1,    1,  1, -tags => [qw/rod width/], -width => 3, -fill => 'black' );\n\t$_->createOval(   1,   1,    2,  2, -tags => [qw/bob outline/], -fill => 'yellow' );\n}\n\n$canvas->raise('pivot');\n$canvas->pack(-fill => 'both', -expand => 1);\nmy ($Theta, $dTheta, $length, $homeX, $homeY) =\n\t(45, 0, 150, 160, 25);\n\nsub show_pendulum {\n  my $angle = $Theta * pi() / 180;\n  my $x = $homeX + $length * sin($angle);\n  my $y = $homeY + $length * cos($angle);\n  $canvas->coords('rod', $homeX, $homeY, $x, $y);\n  $canvas->coords('bob', $x-15, $y-15, $x+15, $y+15);\n}\n\n\n\nsub recompute_angle {\n  my $scaling = 3000.0 / ($length ** 2);\n  # first estimate\n  my $firstDDTheta = -sin($Theta * pi / 180) * $scaling;\n  my $midDTheta = $dTheta + $firstDDTheta;\n  my $midTheta = $Theta + ($dTheta + $midDTheta)/2;\n  # second estimate\n  my $midDDTheta = -sin($midTheta * pi/ 180) * $scaling;\n  $midDTheta = $dTheta + ($firstDDTheta + $midDDTheta)/2;\n  $midTheta = $Theta + ($dTheta + $midDTheta)/2;\n  # again, first\n  $midDDTheta = -sin($midTheta * pi/ 180) * $scaling;\n  my $lastDTheta = $midDTheta + $midDDTheta;\n  my $lastTheta = $midTheta + ($midDTheta + $lastDTheta)/2;\n  # again, second\n  my $lastDDTheta = -sin($lastTheta * pi/180) * $scaling;\n  $lastDTheta = $midDTheta + ($midDDTheta + $lastDDTheta)/2;\n  $lastTheta = $midTheta + ($midDTheta + $lastDTheta)/2;\n  # Now put the values back in our globals\n  $dTheta  = $lastDTheta;\n  $Theta = $lastTheta;\n}\n\n\nsub animate {\n  recompute_angle;\n  show_pendulum;\n  $after_id = $root->after(15 => sub {animate() });\n}\n\nshow_pendulum;\n$after_id = $root->after(500 => sub {animate});\n\n$canvas->bind('<Destroy>' => sub {$after_id->cancel});\nMainLoop;\n"
  },
  {
    "language": "Perl",
    "code": "use Tk;\nuse Time::HiRes qw(sleep);\n\nmy $msg    = 'Hello World! ';\nmy $first  = '.+';\nmy $second = '.';\n\nmy $mw = Tk::MainWindow->new(-title => 'Animated side-scroller',-bg=>\"white\");\n$mw->geometry (\"400x150+0+0\");\n\n$mw->optionAdd('*Label.font', 'Courier 24 bold' );\n\nmy $scroller = $mw->Label(-text => \"$msg\")->grid(-row=>0,-column=>0);\n$mw->bind('all'=> '<Key-Escape>' => sub {exit;});\n$mw->bind(\"<Button>\" => sub { ($second,$first) = ($first,$second) });\n\n$scroller->after(1, \\&display );\nMainLoop;\n\nsub display {\n    while () {\n        sleep 0.25;\n        $msg =~ s/($first)($second)/$2$1/;\n        $scroller->configure(-text=>\"$msg\");\n        $mw->update();\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub recur (&@) {\n    my $f = shift;\n    local *recurse = $f;\n    $f->(@_);\n}\n\nsub fibo {\n    my $n = shift;\n    $n < 0 and die 'Negative argument';\n    recur {\n        my $m = shift;\n        $m < 3 ? 1 : recurse($m - 1) + recurse($m - 2);\n    } $n;\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub fib {\n\tmy ($n) = @_;\n\tdie \"negative arg $n\" if $n < 0;\n\t# put anon sub on stack and do a magic goto to it\n\t@_ = ($n, sub {\n\t\tmy ($n, $f) = @_;\n\t\t# anon sub recurs with the sub ref on stack\n\t\t$n < 2 ? $n : $f->($n - 1, $f) + $f->($n - 2, $f)\n\t});\n\tgoto $_[1];\n}\n\nprint(fib($_), \" \") for (0 .. 10);\n"
  },
  {
    "language": "Perl",
    "code": "sub fibo {\n    my $n = shift;\n    $n < 0 and die 'Negative argument';\n    no strict 'refs';\n    $n < 3 ? 1 : (caller(0))[3]->($n - 1) + (caller(0))[3]->($n - 2);\n}\n"
  },
  {
    "language": "Perl",
    "code": "use v5.16;\nsay sub {\n  my $n = shift;\n  $n < 2 ? $n : __SUB__->($n-2) + __SUB__->($n-1)\n}->($_) for 0..10\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nuse Fcntl qw( :flock SEEK_END );\n\nuse constant {\n    RECORD_FIELDS => [qw( account password UID GID GECOS directory shell )],\n    GECOS_FIELDS  => [qw( fullname office extension homephone email )],\n    RECORD_SEP    => ':',\n    GECOS_SEP     => ',',\n    PASSWD_FILE   => 'passwd.txt',\n};\n\n# here's our three records\nmy $records_to_write = [\n    {\n        account  => 'jsmith',\n        password => 'x',\n        UID      => 1001,\n        GID      => 1000,\n        GECOS    => {\n            fullname  => 'John Smith',\n            office    => 'Room 1007',\n            extension => '(234)555-8917',\n            homephone => '(234)555-0077',\n            email     => 'jsmith@rosettacode.org',\n        },\n        directory => '/home/jsmith',\n        shell     => '/bin/bash',\n    },\n    {\n        account  => 'jdoe',\n        password => 'x',\n        UID      => 1002,\n        GID      => 1000,\n        GECOS    => {\n            fullname  => 'Jane Doe',\n            office    => 'Room 1004',\n            extension => '(234)555-8914',\n            homephone => '(234)555-0044',\n            email     => 'jdoe@rosettacode.org',\n        },\n        directory => '/home/jdoe',\n        shell     => '/bin/bash',\n    },\n];\nmy $record_to_append = {\n    account  => 'xyz',\n    password => 'x',\n    UID      => 1003,\n    GID      => 1000,\n    GECOS    => {\n        fullname  => 'X Yz',\n        office    => 'Room 1003',\n        extension => '(234)555-8913',\n        homephone => '(234)555-0033',\n        email     => 'xyz@rosettacode.org',\n    },\n    directory => '/home/xyz',\n    shell     => '/bin/bash',\n};\n\nsub record_to_string {\n    my $rec    = shift;\n    my $sep    = shift // RECORD_SEP;\n    my $fields = shift // RECORD_FIELDS;\n    my @ary;\n    for my $field (@$fields) {\n        my $r = $rec->{$field};\n        die \"Field '$field' not found\" unless defined $r;    # simple sanity check\n        push @ary, ( $field eq 'GECOS' ? record_to_string( $r, GECOS_SEP, GECOS_FIELDS ) : $r );\n    }\n    return join $sep, @ary;\n}\n\nsub write_records_to_file {\n    my $records  = shift;\n    my $filename = shift // PASSWD_FILE;\n    open my $fh, '>>', $filename or die \"Can't open $filename: $!\";\n    flock( $fh, LOCK_EX ) or die \"Can't lock $filename: $!\";\n    # if someone appended while we were waiting...\n    seek( $fh, 0, SEEK_END ) or die \"Can't seek $filename: $!\" ;\n    print $fh record_to_string($_), \"\\n\" for @$records;\n    flock( $fh, LOCK_UN ) or die \"Can't unlock $filename: $!\";\n    # note: the file is closed automatically when function returns (and refcount of $fh becomes 0)\n}\n\n# write two records to file\nwrite_records_to_file( $records_to_write );\n\n# append one more record to file\nwrite_records_to_file( [$record_to_append] );\n\n# test\n{\n    use Test::Simple tests => 1;\n\n    open my $fh, '<', PASSWD_FILE or die \"Can't open \", PASSWD_FILE, \": $!\";\n    my @lines = <$fh>;\n    chomp @lines;\n    ok(\n        $lines[-1] eq\n'xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash',\n        \"Appended record: $lines[-1]\"\n    );\n}\n"
  },
  {
    "language": "Perl",
    "code": "# create array\nmy @a = (1, 2, 3, 4, 5);\n\n# create callback function\nsub mycallback {\n  return 2 * shift;\n}\n\n# use array indexing\nfor (my $i = 0; $i < scalar @a; $i++) {\n  print \"mycallback($a[$i]) = \", mycallback($a[$i]), \"\\n\";\n}\n\n# using foreach\nforeach my $x (@a) {\n  print \"mycallback($x) = \", mycallback($x), \"\\n\";\n}\n\n# using map (useful for transforming an array)\nmy @b = map mycallback($_), @a;                # @b is now (2, 4, 6, 8, 10)\n\n# and the same using an anonymous function\nmy @c = map { $_ * 2 } @a;                     # @c is now (2, 4, 6, 8, 10)\n\n# use a callback stored in a variable\nmy $func = \\&mycallback;\nmy @d = map $func->($_), @a;                  # @d is now (2, 4, 6, 8, 10)\n\n# filter an array\nmy @e = grep { $_ % 2 == 0 } @a;               # @e is now (2, 4)\n"
  },
  {
    "language": "Perl",
    "code": "use Math::BigInt;\nmy $x = Math::BigInt->new('5') ** Math::BigInt->new('4') ** Math::BigInt->new('3') ** Math::BigInt->new('2');\nmy $y = \"$x\";\nprintf(\"5**4**3**2 = %s...%s and has %i digits\\n\", substr($y,0,20), substr($y,-20), length($y));\n"
  },
  {
    "language": "Perl",
    "code": "use bigint;\nmy $x = 5**4**3**2;\nmy $y = \"$x\";\nprintf(\"5**4**3**2 = %s...%s and has %i digits\\n\", substr($y,0,20), substr($y,-20), length($y));\n"
  },
  {
    "language": "Perl",
    "code": "$ time perl transparent-bigint.pl\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n    1m4.28s real     1m4.30s user     0m0.00s system\n"
  },
  {
    "language": "Perl",
    "code": "use Math::Complex;\nmy $a = 1 + 1*i;\nmy $b = 3.14159 + 1.25*i;\n\nprint \"$_\\n\" foreach\n    $a + $b,    # addition\n    $a * $b,    # multiplication\n    -$a,        # negation\n    1 / $a,     # multiplicative inverse\n    ~$a;        # complex conjugate\n"
  },
  {
    "language": "Perl",
    "code": "sub ev\n# Evaluates an arithmetic expression like \"(1+3)*7\" and returns\n# its value.\n {my $exp = shift;\n  # Delete all meaningless characters. (Scientific notation,\n  # infinity, and not-a-number aren't supported.)\n  $exp =~ tr {0-9.+-/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  # ??{ ... } interpolates lazily (only when necessary),\n  # permitting recursion to arbitrary depths.\n\n  sub astize\n  # Constructs an abstract syntax tree by recursively\n  # transforming textual arithmetic expressions into array\n  # references of the form [operator, left oprand, right oprand].\n   {my $exp = shift;\n    # If $exp is just a number, return it as-is.\n    $exp =~ /[^0-9.]/ or return $exp;\n    # If parentheses surround the entire expression, get rid of\n    # them.\n    $exp = substr($exp, 1, -1)\n        while $exp =~ /\\A($balanced_paren_regex)\\z/;\n    # Replace stuff in parentheses with placeholders.\n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$#paren_contents]\"}eg;\n    # Scan for operators in order of increasing precedence,\n    # preferring the rightmost.\n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*/]) (.+)}x or\n        # The expression must've been malformed somehow.\n        # (Note that unary minus isn't supported.)\n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    # Restore the parenthetical expressions.\n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    # And recurse.\n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '/' => sub {$_[0] / $_[1]});\n\n  sub ev_ast\n  # Evaluates an abstract syntax tree of the form returned by\n  # &astize.\n   {my $ast = shift;\n    # If $ast is just a number, return it as-is.\n    ref $ast or return $ast;\n    # Otherwise, recurse.\n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}\n"
  },
  {
    "language": "Perl",
    "code": "use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   # Get number of digits from command line\nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Math::BigFloat;\n\nMath::BigFloat->div_scale(100);\n\nmy $a = my $n = 1;\nmy $g = 1 / sqrt(Math::BigFloat->new(2));\nmy $z = 0.25;\nfor( 0 .. 17 ) {\n\tmy $x = [ ($a + $g) * 0.5, sqrt($a * $g) ];\n\tmy $var = $x->[0] - $a;\n\t$z -= $var * $var * $n;\n\t$n += $n;\n\t($a, $g) = @$x;\n}\nprint $a * $a / $z, \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl -w\n\nmy ($a0, $g0, $a1, $g1);\n\nsub agm($$) {\n    $a0 = shift;\n    $g0 = shift;\n    do {\n        $a1 = ($a0 + $g0)/2;\n        $g1 = sqrt($a0 * $g0);\n        $a0 = ($a1 + $g1)/2;\n        $g0 = sqrt($a1 * $g1);\n    } while ($a0 != $a1);\n    return $a0;\n}\n\nprint agm(1, 1/sqrt(2)).\"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "my $a = <>;\nmy $b = <>;\n\nprint\n    \"sum:              \", $a + $b, \"\\n\",\n    \"difference:       \", $a - $b, \"\\n\",\n    \"product:          \", $a * $b, \"\\n\",\n    \"integer quotient: \", int($a / $b), \"\\n\",\n    \"remainder:        \", $a % $b, \"\\n\",\n    \"exponent:         \", $a ** $b, \"\\n\"\n    ;\n"
  },
  {
    "language": "Perl",
    "code": "use bigrat;\n\nforeach my $candidate (2 .. 2**19) {\n    my $sum = 1 / $candidate;\n    foreach my $factor (2 .. sqrt($candidate)+1) {\n        if ($candidate % $factor == 0) {\n            $sum += 1 / $factor + 1 / ($candidate / $factor);\n        }\n    }\n    if ($sum->denominator() == 1) {\n        print \"Sum of recipr. factors of $candidate = $sum exactly \", ($sum == 1 ? \"perfect!\" : \"\"), \"\\n\";\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "my @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\nmy @arr3 = (@arr1, @arr2);\n"
  },
  {
    "language": "Perl",
    "code": "my @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\npush @arr1, @arr2;\nprint \"@arr1\\n\"; # prints \"1 2 3 4 5 6\"\n"
  },
  {
    "language": "Perl",
    "code": " my @empty;\n my @empty_too = ();\n\n my @populated   = ('This', 'That', 'And', 'The', 'Other');\n print $populated[2];  # And\n\n my $aref = ['This', 'That', 'And', 'The', 'Other'];\n print $aref->[2];  # And\n"
  },
  {
    "language": "Perl",
    "code": "my @arr;\n\npush @arr, 1;\npush @arr, 3;\n\n$arr[0] = 2;\n\nprint $arr[0];\n"
  },
  {
    "language": "Perl",
    "code": " my @multi_dimensional = (\n     [0, 1, 2, 3],\n     [qw(a b c d e f g)],\n     [qw(! $ % & *)],\n );\n"
  },
  {
    "language": "Perl",
    "code": "print \"Give me a number: \";\nchomp(my $a = <>);\n\n$a == 42 or die \"Error message\\n\";\n\n# Alternatives\ndie \"Error message\\n\" unless $a == 42;\ndie \"Error message\\n\" if not $a == 42;\ndie \"Error message\\n\" if $a != 42;\n"
  },
  {
    "language": "Perl",
    "code": "open my $fh, '<', 'file'\n    or die \"Cannot open file: $!\\n\"; # $! contains the error message from the last error\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfor ($i = 1; $i <= 100; $i++) {\n\t$root = sqrt($i);\n\t$state = ($root == ceil($root)) ? 'open' : 'closed';\n\techo \"Door {$i}: {$state}\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$doors = array_fill(1, 100, false);\nfor ($pass = 1; $pass <= 100; ++$pass) {\n\tfor ($nr = 1; $nr <= 100; ++$nr) {\n\t\tif ($nr % $pass == 0) {\n\t\t\t$doors[$nr] = !$doors[$nr];\n\t\t}\n\t}\n}\nfor ($nr = 1; $nr <= 100; ++$nr)\n\tprintf(\"Door %d: %s\\n\", $nr, ($doors[$nr])?'open':'closed');\n?>\n"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/env php\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n<?php\n\nwhile (true) {\n    $numbers = make_numbers();\n\n    for ($iteration_num = 1; ; $iteration_num++) {\n        echo \"Expresion $iteration_num: \";\n\n        $entry = rtrim(fgets(STDIN));\n\n        if ($entry === '!') break;\n        if ($entry === 'q') exit;\n\n        $result = play($numbers, $entry);\n\n        if ($result === null) {\n            echo \"That's not valid\\n\";\n            continue;\n        }\n        elseif ($result != 24) {\n            echo \"Sorry, that's $result\\n\";\n            continue;\n        }\n        else {\n            echo \"That's right! 24!!\\n\";\n            exit;\n        }\n    }\n}\n\nfunction make_numbers() {\n    $numbers = array();\n\n    echo \"Your four digits: \";\n\n    for ($i = 0; $i < 4; $i++) {\n        $number = rand(1, 9);\n        // The check is needed to avoid E_NOTICE from PHP\n        if (!isset($numbers[$number])) {\n            $numbers[$number] = 0;\n        }\n        $numbers[$number]++;\n        print \"$number \";\n    }\n\n    print \"\\n\";\n\n    return $numbers;\n}\n\nfunction play($numbers, $expression) {\n    $operator = true;\n    for ($i = 0, $length = strlen($expression); $i < $length; $i++) {\n        $character = $expression[$i];\n\n        if (in_array($character, array('(', ')', ' ', \"\\t\"))) continue;\n\n        $operator = !$operator;\n\n        if (!$operator) {\n            if (!empty($numbers[$character])) {\n                $numbers[$character]--;\n                continue;\n            }\n            return;\n        }\n        elseif (!in_array($character, array('+', '-', '*', '/'))) {\n            return;\n        }\n    }\n\n    foreach ($numbers as $remaining) {\n        if ($remaining > 0) {\n            return;\n        }\n    }\n\n    return eval(\"return $expression;\");\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$plural = 's';\nforeach (range(99, 1) as $i) {\n    echo \"$i bottle$plural of beer on the wall,\\n\";\n    echo \"$i bottle$plural of beer!\\n\";\n    echo \"Take one down, pass it around!\\n\";\n    if ($i - 1 == 1)\n        $plural = '';\n\n    if ($i > 1)\n        echo ($i - 1) . \" bottle$plural of beer on the wall!\\n\\n\";\n    else\n        echo \"No more bottles of beer on the wall!\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nforeach(range(99,1) as $i) {\n    $p = ($i>1)?\"s\":\"\";\n    echo <<< EOV\n$i bottle$p of beer on the wall\n$i bottle$p of beer\nTake one down, pass it around\n\n\nEOV;\n}\necho \"No more Bottles of beer on the wall\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$verse = <<<VERSE\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\n\nVERSE;\n\nforeach (range(1,99) as $i) { // loop 99 times\n    $verse = preg_replace('/\\d+/e', '$0 - 1', $verse);\n    $verse = preg_replace('/\\b1 bottles/', '1 bottle', $verse);\n    $verse = preg_replace('/\\b0 bottle/', 'No bottles', $verse);\n\n    echo $verse;\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  for($i=100;$i>0;$i--){\n    $p2=$i.\" bottle\".(($i>1)?\"s\":\"\").\" of beer\";\n    $p1=$p2.\" on the wall\\n\";\n    $p3=\"Take one down, pass it around\\n\";\n    echo (($i<100)?$p1.\"\\n\":\"\").$p1.$p2.\"\\n\".$p3.(($i<2)?($i-1).substr($p1,1,28):\"\");\n  }\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$bottles = 99;\n\nwhile ($bottles > 0) {\n\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer on the wall\\n\", $bottles);\t\t//X bottles of beer on the wall\n\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer\\n\", $bottles);\t\t\t\t//X bottles of beer\n\tprintf(\"Take one down, pass it around\\n\");\t\t\t\t\t\t\t\t\t\t//Take one down, pass it around\n\n\t$bottles--;\n\n\tif ($bottles > 0) {\n\t\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer on the wall\\n\\n\", $bottles);\t//X bottles of beer on the wall\n\t}\n}\nprintf('No more bottles of beer on the wall');\t\t\t\t\t\t\t\t\t\t\t//No more bottles of beer on the wall\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$lyrics = <<<ENDVERSE\n%2\\$d bottle%1\\$s of beer on the wall\n%2\\$d bottle%1\\$s of beer\nTake one down, pass it around\n%4\\$s bottle%3\\$s of beer on the wall\n\n\nENDVERSE;\n\n$x = 99;\nwhile ( $x > 0 ) {\n   printf( $lyrics, $x != 1 ? 's' : '', $x--, $x != 1 ? 's' : '', $x > 0 ? $x : 'No more' );\n}\n"
  },
  {
    "language": "PHP",
    "code": "fscanf(STDIN, \"%d %d\\n\", $a, $b); //Reads 2 numbers from STDIN\necho ($a + $b) . \"\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "$in = fopen(\"input.dat\", \"r\");\nfscanf($in, \"%d %d\\n\", $a, $b); //Reads 2 numbers from file $in\nfclose($in);\n\n$out = fopen(\"output.dat\", \"w\");\nfwrite($out, ($a + $b) . \"\\n\");\nfclose($out);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = array(\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\");\n\nfunction canMakeWord($word) {\n    $word = strtoupper($word);\n    $blocks = array(\n            \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n            \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n            \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n            \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n    );\n\n    foreach (str_split($word) as $char) {\n        foreach ($blocks as $k => $block) {\n            if (strpos($block, $char) !== FALSE) {\n                unset($blocks[$k]);\n                continue(2);\n            }\n        }\n        return false;\n    }\n    return true;\n}\n\nforeach ($words as $word) {\n    echo $word.': ';\n    echo canMakeWord($word) ? \"True\" : \"False\";\n    echo \"\\r\\n\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "abstract class Abs {\n\tabstract public function method1($value);\n\tabstract protected function method2($name);\n\tfunction add($a, $b){\n\t\treturn a + b;\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "interface Inter {\n\tpublic function method1($value);\n\tpublic function method2($name);\n\tpublic function add($a, $b);\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction accumulator($start){\n return create_function('$x','static $v='.$start.';return $v+=$x;');\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; //prints 10\necho $acc(10), \"\\n\"; //prints 20\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction accumulator($sum){\n return function ($x) use (&$sum) { return $sum += $x; };\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; //prints 10\necho $acc(10), \"\\n\"; //prints 20\n?>\n"
  },
  {
    "language": "PHP",
    "code": "function ackermann( $m , $n )\n{\n    if ( $m==0 )\n    {\n        return $n + 1;\n    }\n    elseif ( $n==0 )\n    {\n        return ackermann( $m-1 , 1 );\n    }\n    return ackermann( $m-1, ackermann( $m , $n-1 ) );\n}\n\necho ackermann( 3, 4 );\n// prints 125\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$ldap = ldap_connect($hostname, $port);\n$success = ldap_bind($ldap, $username, $password);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$l = ldap_connect('ldap.example.com');\nldap_set_option($l, LDAP_OPT_PROTOCOL_VERSION, 3);\nldap_set_option($l, LDAP_OPT_REFERRALS, false);\n\n$bind = ldap_bind($l, 'me@example.com', 'password');\n\n$base = 'dc=example, dc=com';\n$criteria = '(&(objectClass=user)(sAMAccountName=username))';\n$attributes = array('displayName', 'company');\n\n$search = ldap_search($l, $base, $criteria, $attributes);\n$entries = ldap_get_entries($l, $search);\n\nvar_dump($entries);\n"
  },
  {
    "language": "PHP",
    "code": "class E {};\n\n$e=new E();\n\n$e->foo=1;\n\n$e->{\"foo\"} = 1; // using a runtime name\n$x = \"foo\";\n$e->$x = 1; // using a runtime name in a variable\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$j2justtype = array('L' => STR_PAD_RIGHT,\n                    'R' => STR_PAD_LEFT,\n                    'C' => STR_PAD_BOTH);\n\n/**\n Justify columns of textual tabular input where the record separator is the newline\n and the field separator is a 'dollar' character.\n justification can be L, R, or C; (Left, Right, or Centered).\n\n Return the justified output as a string\n*/\nfunction aligner($str, $justification = 'L') {\n  global $j2justtype;\n  assert(array_key_exists($justification, $j2justtype));\n  $justtype = $j2justtype[$justification];\n\n  $fieldsbyrow = array();\n  foreach (explode(\"\\n\", $str) as $line)\n    $fieldsbyrow[] = explode('$', $line);\n  $maxfields = max(array_map('count', $fieldsbyrow));\n\n  foreach (range(0, $maxfields-1) as $col) {\n    $maxwidth = 0;\n    foreach ($fieldsbyrow as $fields)\n      $maxwidth = max($maxwidth, strlen($fields[$col]));\n    foreach ($fieldsbyrow as &$fields)\n      $fields[$col] = str_pad($fields[$col], $maxwidth, ' ', $justtype);\n    unset($fields); // see http://bugs.php.net/29992\n  }\n  $result = '';\n  foreach ($fieldsbyrow as $fields)\n    $result .= implode(' ', $fields) . \"\\n\";\n  return $result;\n}\n\n$textinfile = 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$\\'dollar\\'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.';\n\nforeach (array('L', 'R', 'C') as $j)\n  echo aligner($textinfile, $j);\n\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = file(\n    'http://www.puzzlers.org/pub/wordlists/unixdict.txt',\n    FILE_IGNORE_NEW_LINES\n);\n$length = 0;\n\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $chars = implode(\"\", $chars);\n    $length = strlen($chars);\n    $anagrams[$length][$chars][] = $word;\n}\n\nkrsort($anagrams);\n\nforeach ($anagrams as $anagram) {\n    $final_words = array();\n    foreach ($anagram as $words) {\n        if (count($words) >= 2) {\n            $counts = array();\n            foreach ($words as $word) {\n                $counts[$word] = array($word);\n                foreach ($words as $second_word) {\n                    for ($i = 0, $length = strlen($word); $i < $length; $i++) {\n                        if ($word[$i] === $second_word[$i]) continue 2;\n                    }\n                    $counts[$word][] = $second_word;\n                }\n            }\n            $max = 0;\n            $max_key = '';\n            foreach ($counts as $name => $count) {\n                if (count($count) > $max) {\n                    $max = count($count);\n                    $max_key = $name;\n                }\n            }\n            if ($max > 1) {\n                $final_words[] = $counts[$max_key];\n            }\n        }\n    }\n    if ($final_words) break;\n}\n\nforeach ($final_words as $final_word) {\n    echo implode(\" \", $final_word), \"\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = explode(\"\\n\", file_get_contents('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'));\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $anagram[implode($chars)][] = $word;\n}\n\n$best = max(array_map('count', $anagram));\nforeach ($anagram as $ana)\n    if (count($ana) == $best)\n        print_r($ana);\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) { // This function must be called using call_user_func() only\n        if ($n < 2)\n            return 1;\n        else {\n            $g = debug_backtrace()[1]['args'][0];\n            return call_user_func($g, $n-1) + call_user_func($g, $n-2);\n        }\n    };\n    return call_user_func($f, $n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) use (&$f) {\n        if ($n < 2)\n            return 1;\n        else\n            return $f($n-1) + $f($n-2);\n    };\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass fib_helper {\n    function __invoke($n) {\n        if ($n < 2)\n            return 1;\n        else\n            return $this($n-1) + $this($n-2);\n    }\n}\n\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = new fib_helper();\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$filename = '/tmp/passwd';\n\n$data = array(\n    'account:password:UID:GID:fullname,office,extension,homephone,email:directory:shell' . PHP_EOL,\n    'jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash' . PHP_EOL,\n    'jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jdoe:/bin/bash' . PHP_EOL,\n);\nfile_put_contents($filename, $data, LOCK_EX);\n\necho 'File contents before new record added:', PHP_EOL, file_get_contents($filename), PHP_EOL;\n\n$data = array(\n    'xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash' . PHP_EOL\n);\nfile_put_contents($filename, $data, FILE_APPEND | LOCK_EX);\n\necho 'File contents after new record added:', PHP_EOL, file_get_contents($filename), PHP_EOL;\n"
  },
  {
    "language": "PHP",
    "code": "function cube($n)\n{\n   return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$y = bcpow('5', bcpow('4', bcpow('3', '2')));\nprintf(\"5**4**3**2 = %s...%s and has %d digits\\n\", substr($y,0,20), substr($y,-20), strlen($y));\n?>\n"
  },
  {
    "language": "PHP",
    "code": "define('PRECISION', 13);\n\nfunction agm($a0, $g0, $tolerance = 1e-10)\n{\n    // the bc extension deals in strings and cannot convert\n    // floats in scientific notation by itself - hence\n    // this manual conversion to a string\n    $limit = number_format($tolerance, PRECISION, '.', '');\n    $an    = $a0;\n    $gn    = $g0;\n    do {\n        list($an, $gn) = array(\n            bcdiv(bcadd($an, $gn), 2),\n            bcsqrt(bcmul($an, $gn)),\n        );\n    } while (bccomp(bcsub($an, $gn), $limit) > 0);\n\n    return $an;\n}\n\nbcscale(PRECISION);\necho agm(1, 1 / bcsqrt(2));\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$a = fgets(STDIN);\n$b = fgets(STDIN);\n\necho\n    \"sum:                 \", $a + $b, \"\\n\",\n    \"difference:          \", $a - $b, \"\\n\",\n    \"product:             \", $a * $b, \"\\n\",\n    \"truncating quotient: \", (int)($a / $b), \"\\n\",\n    \"flooring quotient:   \", floor($a / $b), \"\\n\",\n    \"remainder:           \", $a % $b, \"\\n\",\n    \"power:               \", $a ** $b, \"\\n\"; // PHP 5.6+ only\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$arr1 = array(1, 2, 3);\n$arr2 = array(4, 5, 6);\n$arr3 = array_merge($arr1, $arr2);\n"
  },
  {
    "language": "PHP",
    "code": "$NumberArray = array(0, 1, 2, 3, 4, 5, 6);\n$LetterArray = array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n$simpleForm = ['apple', 'orange'];\n"
  },
  {
    "language": "PHP",
    "code": "echo $CustomKeyArray[\"b\"]; // Returns C\n"
  },
  {
    "language": "PHP",
    "code": "$BlankArray = array();\n"
  },
  {
    "language": "PHP",
    "code": "$BlankArray[] = \"Not Blank Anymore\";\n"
  },
  {
    "language": "PHP",
    "code": "$AssignArray[\"CertainKey\"] = \"Value\";\n"
  },
  {
    "language": "PHP",
    "code": "$MultiArray = array(\n                array(0, 0, 0, 0, 0, 0),\n                array(1, 1, 1, 1, 1, 1),\n                array(2, 2, 2, 2, 2, 2),\n                array(3, 3, 3, 3, 3, 3)\n          );\n"
  },
  {
    "language": "PHP",
    "code": "$arr = ['apple', 'orange'];\narray_push($arr, 'pear');\nprint implode(',', $arr); // Returns apple,orange,pear\n"
  },
  {
    "language": "PHP",
    "code": "echo $NumberArray[5]; // Returns 5\necho $LetterArray[5]; // Returns f\n"
  },
  {
    "language": "PHP",
    "code": "echo $MultiArray[1][5]; // 2\n"
  },
  {
    "language": "PHP",
    "code": "print_r($MultiArray);\n"
  },
  {
    "language": "PHP",
    "code": "Array(\n    0 => array(\n            0 => 0\n            1 => 0\n            2 => 0\n            3 => 0\n            4 => 0\n            5 => 0\n         )\n    1 => array(\n            0 => 1\n            1 => 1\n            2 => 1\n            3 => 1\n            4 => 1\n            5 => 1\n         )\n    2 => array(\n            0 => 2\n            1 => 2\n            2 => 2\n            3 => 2\n            4 => 2\n            5 => 2\n         )\n    3 => array(\n            0 => 3\n            1 => 3\n            2 => 3\n            3 => 3\n            4 => 3\n            5 => 3\n         )\n)\n"
  },
  {
    "language": "PHP",
    "code": "$StartIndexAtOne = array(1 => \"A\", \"B\", \"C\", \"D\");\n"
  },
  {
    "language": "PHP",
    "code": "$CustomKeyArray = array(\"d\" => \"A\", \"c\" => \"B\", \"b\" =>\"C\", \"a\" =>\"D\");\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$a = 5\n#...input or change $a here\nassert($a == 42) # when $a is not 42, take appropriate actions,\n                 # which is set by assert_options()\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$array = array();\n$array = []; // Simpler form of array initialization\n$array['foo'] = 'bar';\n$array['bar'] = 'foo';\n\necho($array['foo']); // bar\necho($array['moo']); // Undefined index\n\n// Alternative (inline) way\n$array2 = array('fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green');\n\n// Another alternative (simpler) way\n$array2 = ['fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green'];\n\n// Check if key exists in the associative array\necho(isset($array['foo'])); // Faster, but returns false if the value of the element is set to null\necho(array_key_exists('foo', $array)); // Slower, but returns true if the value of the element is null\n"
  },
  {
    "language": "PHP",
    "code": "foreach($array as $key => $value)\n{\n   echo \"Key: $key Value: $value\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$pairs = array( \"hello\" => 1,\n\t\t\"world\" => 2,\n\t\t\"!\"     => 3 );\n\n// iterate over key-value pairs\nforeach($pairs as $k => $v) {\n  echo \"(k,v) = ($k, $v)\\n\";\n}\n\n// iterate over keys\nforeach(array_keys($pairs) as $key) {\n  echo \"key = $key, value = $pairs[$key]\\n\";\n}\n\n// iterate over values\nforeach($pairs as $value) {\n  echo \"values = $value\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$nums = array(3, 1, 4, 1, 5, 9);\nif ($nums)\n    echo array_sum($nums) / count($nums), \"\\n\";\nelse\n    echo \"0\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$samples = array(\n\t'1st' => array(350, 10),\n\t'2nd' => array(90, 180, 270, 360),\n\t'3rd' => array(10, 20, 30)\n);\n\nforeach($samples as $key => $sample){\n\techo 'Mean angle for ' . $key . ' sample: ' . meanAngle($sample) . ' degrees.' . PHP_EOL;\n}\n\nfunction meanAngle ($angles){\n\t$y_part = $x_part = 0;\n\t$size = count($angles);\n\tfor ($i = 0; $i < $size; $i++){\n\t\t$x_part += cos(deg2rad($angles[$i]));\n\t\t$y_part += sin(deg2rad($angles[$i]));\n\t}\n\t$x_part /= $size;\n\t$y_part /= $size;\n\treturn rad2deg(atan2($y_part, $x_part));\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction time2ang($tim) {\n        if (!is_string($tim)) return $tim;\n        $parts = explode(':',$tim);\n        if (count($parts)!=3) return $tim;\n        $sec = ($parts[0]*3600)+($parts[1]*60)+$parts[2];\n        $ang = 360.0 * ($sec/86400.0);\n        return $ang;\n}\nfunction ang2time($ang) {\n        if (!is_numeric($ang)) return $ang;\n        $sec = 86400.0 * $ang / 360.0;\n        $parts = array(floor($sec/3600),floor(($sec % 3600)/60),$sec % 60);\n        $tim = sprintf('%02d:%02d:%02d',$parts[0],$parts[1],$parts[2]);\n        return $tim;\n}\nfunction meanang($ang) {\n        if (!is_array($ang)) return $ang;\n        $sins = 0.0;\n        $coss = 0.0;\n        foreach($ang as $a) {\n                $sins += sin(deg2rad($a));\n                $coss += cos(deg2rad($a));\n        }\n        $avgsin = $sins / (0.0+count($ang));\n        $avgcos = $coss / (0.0+count($ang));\n        $avgang = rad2deg(atan2($avgsin,$avgcos));\n        while ($avgang < 0.0) $avgang += 360.0;\n        return $avgang;\n}\n$bats = array('23:00:17','23:40:20','00:12:45','00:17:19');\n$angs = array();\nforeach ($bats as $t) $angs[] = time2ang($t);\n$ma = meanang($angs);\n$result = ang2time($ma);\nprint \"The mean time of day is $result (angle $ma).\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "function median($arr)\n{\n    sort($arr);\n    $count = count($arr); //count the number of values in array\n    $middleval = floor(($count-1)/2); // find the middle value, or the lowest middle value\n    if ($count % 2) { // odd number, middle is the median\n        $median = $arr[$middleval];\n    } else { // even number, calculate avg of 2 medians\n        $low = $arr[$middleval];\n        $high = $arr[$middleval+1];\n        $median = (($low+$high)/2);\n    }\n    return $median;\n}\n\necho median(array(4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)) . \"\\n\";  // 4.4\necho median(array(4.1, 7.2, 1.7, 9.3, 4.4, 3.2)) . \"\\n\";       // 4.25\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction mode($arr) {\n    $count = array_count_values($arr);\n    $best = max($count);\n    return array_keys($count, $best);\n}\n\nprint_r(mode(array(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17)));\nprint_r(mode(array(1, 1, 2, 4, 4)));\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n// Created with PHP 7.0\n\nfunction ArithmeticMean(array $values)\n{\n    return array_sum($values) / count($values);\n}\n\nfunction GeometricMean(array $values)\n{\n    return array_product($values) ** (1 / count($values));\n}\n\nfunction HarmonicMean(array $values)\n{\n    $sum = 0;\n\n    foreach ($values as $value) {\n        $sum += 1 / $value;\n    }\n\n    return count($values) / $sum;\n}\n\n$values = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\necho \"Arithmetic: \" . ArithmeticMean($values) . \"\\n\";\necho \"Geometric: \" . GeometricMean($values) . \"\\n\";\necho \"Harmonic: \" . HarmonicMean($values) . \"\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n// Created with PHP 7.0\n\nfunction rms(array $numbers)\n{\n    $sum = 0;\n\n    foreach ($numbers as $number) {\n        $sum += $number**2;\n    }\n\n    return sqrt($sum / count($numbers));\n}\n\necho rms(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\n\n# brackets generator\nfunction bgenerate ($n) {\n    if ($n==0) return '';\n    $s = str_repeat('[', $n) . str_repeat(']', $n);\n    return str_shuffle($s);\n}\n\nfunction printbool($b) {return ($b) ? 'OK' : 'NOT OK';}\n\nfunction isbalanced($s) {\n    $bal = 0;\n    for ($i=0; $i < strlen($s); $i++) {\n        $ch = substr($s, $i, 1);\n        if ($ch == '[') {\n            $bal++;\n        } else {\n            $bal--;\n        }\n        if ($bal < 0) return false;\n    }\n    return ($bal == 0);\n}\n\n# test parameters are N (see spec)\n$tests = array(0, 2,2,2, 3,3,3, 4,4,4,4);\n\nforeach ($tests as $v) {\n    $s = bgenerate($v);\n    printf(\"%s\\t%s%s\", $s, printbool(isbalanced($s)), PHP_EOL);\n}\n"
  },
  {
    "language": "PHP",
    "code": "foreach (split(' ', 'abracadabra seesaw pop grrrrrr up a') as $w)\n    echo bestShuffle($w) . '<br>';\n\nfunction bestShuffle($s1) {\n    $s2 = str_shuffle($s1);\n    for ($i = 0; $i < strlen($s2); $i++) {\n        if ($s2[$i] != $s1[$i]) continue;\n        for ($j = 0; $j < strlen($s2); $j++)\n            if ($i != $j && $s2[$i] != $s1[$j] && $s2[$j] != $s1[$i]) {\n                $t = $s2[$i];\n                $s2[$i] = $s2[$j];\n                $s2[$j] = $t;\n                break;\n            }\n    }\n    return \"$s1 $s2 \" . countSame($s1, $s2);\n}\n\nfunction countSame($s1, $s2) {\n    $cnt = 0;\n    for ($i = 0; $i < strlen($s2); $i++)\n        if ($s1[$i] == $s2[$i])\n            $cnt++;\n    return \"($cnt)\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\necho decbin(5);\necho decbin(50);\necho decbin(9000);\n"
  },
  {
    "language": "PHP",
    "code": "function binary_search( $array, $secret, $start, $end )\n{\n        do\n        {\n                $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n                if ( $array[$guess] > $secret )\n                        $end = $guess;\n\n                if ( $array[$guess] < $secret )\n                        $start = $guess;\n\n                if ( $end < $start)\n                        return -1;\n\n        } while ( $array[$guess] != $secret );\n\n        return $guess;\n}\n"
  },
  {
    "language": "PHP",
    "code": "function binary_search( $array, $secret, $start, $end )\n{\n        $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n        if ( $end < $start)\n                return -1;\n\n        if ( $array[$guess] > $secret )\n                return (binary_search( $array, $secret, $start, $guess ));\n\n        if ( $array[$guess] < $secret )\n                return (binary_search( $array, $secret, $guess, $end ) );\n\n        return $guess;\n}\n"
  },
  {
    "language": "PHP",
    "code": "function validate($address){\n        $decoded = decodeBase58($address);\n\n        $d1 = hash(\"sha256\", substr($decoded,0,21), true);\n        $d2 = hash(\"sha256\", $d1, true);\n\n        if(substr_compare($decoded, $d2, 21, 4)){\n                throw new \\Exception(\"bad digest\");\n        }\n        return true;\n}\nfunction decodeBase58($input) {\n        $alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        $out = array_fill(0, 25, 0);\n        for($i=0;$i<strlen($input);$i++){\n                if(($p=strpos($alphabet, $input[$i]))===false){\n                        throw new \\Exception(\"invalid character found\");\n                }\n                $c = $p;\n                for ($j = 25; $j--; ) {\n                        $c += (int)(58 * $out[$j]);\n                        $out[$j] = (int)($c % 256);\n                        $c /= 256;\n                        $c = (int)$c;\n                }\n                if($c != 0){\n                    throw new \\Exception(\"address too long\");\n                }\n        }\n\n        $result = \"\";\n        foreach($out as $val){\n                $result .= chr($val);\n        }\n\n        return $result;\n}\n\nfunction main () {\n  $s = array(\n                \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\",\n                \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n                \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\",\n                \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\",\n        );\n  foreach($s as $btc){\n    $message = \"OK\";\n    try{\n        validate($btc);\n    }catch(\\Exception $e){ $message = $e->getMessage(); }\n    echo \"$btc: $message\\n\";\n  }\n}\n\nmain();\n"
  },
  {
    "language": "PHP",
    "code": "<?\n\n$image = imagecreate(200, 200);\n// The first allocated color will be the background color:\nimagecolorallocate($image, 255, 255, 255);\n$color = imagecolorallocate($image, 255, 0, 0);\ncubicbezier($image, $color, 160, 10, 10, 40, 30, 160, 150, 110);\nimagepng($image);\n\nfunction cubicbezier($img, $col, $x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3, $n = 20) {\n\t$pts = array();\n\n\tfor($i = 0; $i <= $n; $i++) {\n\t\t$t = $i / $n;\n\t\t$t1 = 1 - $t;\n\t\t$a = pow($t1, 3);\n\t\t$b = 3 * $t * pow($t1, 2);\n\t\t$c = 3 * pow($t, 2) * $t1;\n\t\t$d = pow($t, 3);\n\n\t\t$x = round($a * $x0 + $b * $x1 + $c * $x2 + $d * $x3);\n\t\t$y = round($a * $y0 + $b * $y1 + $c * $y2 + $d * $y3);\n\t\t$pts[$i] = array($x, $y);\n\t}\n\n\tfor($i = 0; $i < $n; $i++) {\n\t\timageline($img, $pts[$i][0], $pts[$i][1], $pts[$i+1][0], $pts[$i+1][1], $col);\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "define('src_name', 'input.jpg');\t// source image\ndefine('dest_name', 'output.jpg');\t// destination image\n\n$img = imagecreatefromjpeg(src_name);\t// read image\n\nif(empty($img)){\n\techo 'Image could not be loaded!';\n\texit;\n}\n\n$black = imagecolorallocate($img, 0, 0, 0);\n$white = imagecolorallocate($img, 255, 255, 255);\n$width = imagesx($img);\n$height = imagesy($img);\n\n$array_lum = array(); \t// for storage of luminosity of each pixel\n$sum_lum = 0;\t\t// total sum of luminosity\n$average_lum = 0;\t// average luminosity of whole image\n\nfor($x = 0; $x < $width; $x++){\t\n\tfor($y = 0; $y < $height; $y++){\n\t\t// read pixel value\n\t\t$color = imagecolorat($img, $x, $y);\n\t\t$r = ($color >> 16) & 0xFF;\n\t\t$g = ($color >> 8) & 0xFF;\n\t\t$b = $color & 0xFF;\n\t\t// save pixel luminosity in temporary array\n\t\t$array_lum[$x][$y] = ($r + $g + $b);\n\t\t// add pixel luminosity to sum\n\t\t$sum_lum += $array_lum[$x][$y];\n\t}\n}\n\n// calculate average luminosity\n$average_lum = $sum_lum / ($width * $height);\n\nfor($x = 0; $x < $width; $x++){\t\n\tfor($y = 0; $y < $height; $y++){\n\t\t// pixel is brighter than average -> set white\n\t\t// else -> set black\n\t\tif($array_lum[$x][$y] > $average_lum){\n\t\t\timagesetpixel($img, $x, $y, $white);\n\t\t}\n\t\telse{\n\t\t\timagesetpixel($img, $x, $y, $black);\n\t\t}\n\t}\n}\n// save black and white image to dest_name\nimagejpeg($img, dest_name);\n\nif(!file_exists(dest_name)){\n\techo 'Image not saved! Check permission!';\n}\n"
  },
  {
    "language": "PHP",
    "code": "class Bitmap {\n  public $data;\n  public $w;\n  public $h;\n  public function __construct($w = 16, $h = 16){\n    $white = array_fill(0, $w, array(255,255,255));\n    $this->data = array_fill(0, $h, $white);\n    $this->w = $w;\n    $this->h = $h;\n  }\n  //Fills a rectangle, or the whole image with black by default\n  public function fill($x = 0, $y = 0, $w = null, $h = null, $color = array(0,0,0)){\n    if (is_null($w)) $w = $this->w;\n    if (is_null($h)) $h = $this->h;\n    $w += $x;\n    $h += $y;\n    for ($i = $y; $i < $h; $i++){\n      for ($j = $x; $j < $w; $j++){\n        $this->setPixel($j, $i, $color);\n      }\n    }\n  }\n  public function setPixel($x, $y, $color = array(0,0,0)){\n    if ($x >= $this->w) return false;\n    if ($x < 0) return false;\n    if ($y >= $this->h) return false;\n    if ($y < 0) return false;\n    $this->data[$y][$x] = $color;\n  }\n  public function getPixel($x, $y){\n    return $this->data[$y][$x];\n  }\n  public function writeP6($filename){\n    $fh = fopen($filename, 'w');\n    if (!$fh) return false;\n    fputs($fh, \"P6 {$this->w} {$this->h} 255\\n\");\n    foreach ($this->data as $row){\n      foreach($row as $pixel){\n        fputs($fh, pack('C', $pixel[0]));\n        fputs($fh, pack('C', $pixel[1]));\n        fputs($fh, pack('C', $pixel[2]));\n      }\n    }\n    fclose($fh);\n  }\n}\n\n$b = new Bitmap(16,16);\n$b->fill();\n$b->fill(2, 2, 18, 18, array(240,240,240));\n$b->setPixel(0, 15, array(255,0,0));\n$b->writeP6('p6.ppm');\n"
  },
  {
    "language": "PHP",
    "code": "class Bitmap {\n  public $data;\n  public $w;\n  public $h;\n  public function __construct($w = 16, $h = 16){\n    $white = array_fill(0, $w, array(255,255,255));\n    $this->data = array_fill(0, $h, $white);\n    $this->w = $w;\n    $this->h = $h;\n  }\n  //Fills a rectangle, or the whole image with black by default\n  public function fill($x = 0, $y = 0, $w = null, $h = null, $color = array(0,0,0)){\n    if (is_null($w)) $w = $this->w;\n    if (is_null($h)) $h = $this->h;\n    $w += $x;\n    $h += $y;\n    for ($i = $y; $i < $h; $i++){\n      for ($j = $x; $j < $w; $j++){\n        $this->setPixel($j, $i, $color);\n      }\n    }\n  }\n  public function setPixel($x, $y, $color = array(0,0,0)){\n    if ($x >= $this->w) return false;\n    if ($x < 0) return false;\n    if ($y >= $this->h) return false;\n    if ($y < 0) return false;\n    $this->data[$y][$x] = $color;\n  }\n  public function getPixel($x, $y){\n    return $this->data[$y][$x];\n  }\n}\n\n$b = new Bitmap(16,16);\n$b->fill();\n$b->fill(2, 2, 18, 18, array(240,240,240));\n$b->setPixel(0, 15, array(255,0,0));\nprint_r($b->getPixel(3,3)); //(240,240,240)\n"
  },
  {
    "language": "PHP",
    "code": "function bitwise($a, $b)\n{\n    function zerofill($a,$b) {\n        if($a>=0) return $a>>$b;\n        if($b==0) return (($a>>1)&0x7fffffff)*2+(($a>>$b)&1); // this line shifts a 0 into the sign bit for compatibility, replace with \"if($b==0) return $a;\" if you need $b=0 to mean that nothing happens\n        return ((~$a)>>$b)^(0x7fffffff>>($b-1));\n\n    echo '$a AND $b: ' . $a & $b . '\\n';\n    echo '$a OR $b: ' . $a | $b . '\\n';\n    echo '$a XOR $b: ' . $a ^ $b . '\\n';\n    echo 'NOT $a: ' . ~$a . '\\n';\n    echo '$a << $b: ' . $a << $b . '\\n'; // left shift\n    echo '$a >> $b: ' . $a >> $b . '\\n'; // arithmetic right shift\n    echo 'zerofill($a, $b): ' . zerofill($a, $b) . '\\n'; // logical right shift\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass SimpleClass {\n    private $answer = \"hello\\\"world\\nforever :)\";\n}\n\n$class = new SimpleClass;\nob_start();\n\n// var_export() expects class to contain __set_state() method which would import\n// data from array. But let's ignore this and remove from result the method which\n// sets state and just leave data which can be used everywhere...\nvar_export($class);\n$class_content = ob_get_clean();\n\n$class_content = preg_replace('\"^SimpleClass::__set_state\\(\"', 'return ', $class_content);\n$class_content = preg_replace('\"\\)$\"', ';', $class_content);\n\n$new_class = eval($class_content);\necho $new_class['answer'];\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass SimpleClass {\n    private $answer = 42;\n}\n\n$class = new SimpleClass;\n$classvars = (array)$class;\necho $classvars[\"\\0SimpleClass\\0answer\"];\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass fragile {\n    private $foo = 'bar';\n}\n$fragile = new fragile;\n$ro = new ReflectionObject($fragile);\n$rp = $ro->getProperty('foo');\n$rp->setAccessible(true);\nvar_dump($rp->getValue($fragile));\n$rp->setValue($fragile, 'haxxorz!');\nvar_dump($rp->getValue($fragile));\nvar_dump($fragile);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$size = 4;\n\n$chosen = implode(array_rand(array_flip(range(1,9)), $size));\n\necho \"I've chosen a number from $size unique digits from 1 to 9; you need\nto input $size unique digits to guess my number\\n\";\n\nfor ($guesses = 1; ; $guesses++) {\n    while (true) {\n        echo \"\\nNext guess [$guesses]: \";\n        $guess = rtrim(fgets(STDIN));\n        if (!checkguess($guess))\n            echo \"$size digits, no repetition, no 0... retry\\n\";\n        else\n            break;\n    }\n    if ($guess == $chosen) {\n        echo \"You did it in $guesses attempts!\\n\";\n        break;\n    } else {\n        $bulls = 0;\n        $cows = 0;\n        foreach (range(0, $size-1) as $i) {\n            if ($guess[$i] == $chosen[$i])\n                $bulls++;\n            else if (strpos($chosen, $guess[$i]) !== FALSE)\n                $cows++;\n        }\n        echo \"$cows cows, $bulls bulls\\n\";\n    }\n}\n\nfunction checkguess($g)\n{\n  global $size;\n  return count(array_unique(str_split($g))) == $size &&\n    preg_match(\"/^[1-9]{{$size}}$/\", $g);\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction caesarEncode( $message, $key ){\n    $plaintext = strtolower( $message );\n    $ciphertext = \"\";\n    $ascii_a = ord( 'a' );\n    $ascii_z = ord( 'z' );\n    while( strlen( $plaintext ) ){\n        $char = ord( $plaintext );\n        if( $char >= $ascii_a && $char <= $ascii_z ){\n            $char = ( ( $key + $char - $ascii_a ) % 26 ) + $ascii_a;\n        }\n        $plaintext = substr( $plaintext, 1 );\n        $ciphertext .= chr( $char );\n    }\n    return $ciphertext;\n}\n\necho caesarEncode( \"The quick brown fox Jumped over the lazy Dog\", 12 ), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction caesarEncode($message, $key) {\n    $from = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    $to   = substr($from, $key) . substr($from, 0, $key);\n    return strtr($message, $from, $to);\n}\n\necho caesarEncode('THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG', 12), PHP_EOL;\n"
  },
  {
    "language": "PHP",
    "code": "<?PHP\nECHO <<<REALPROGRAMMERSTHINKINUPPERCASEANDCHEATBYUSINGPRINT\n       JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE\n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n        1  2  3  4  5                  1  2                  1  2      1  2  3  4  5  6            1  2  3  4                     1\n  6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8\n 13 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15\n 20 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22\n 27 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29\n                                             31                                                                30\n\n         JULY                 AUGUST               SEPTEMBER              OCTOBER              NOVEMBER              DECEMBER\n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n     1  2  3  4  5  6               1  2  3   1  2  3  4  5  6  7         1  2  3  4  5                  1  2   1  2  3  4  5  6  7\n  7  8  9 10 11 12 13   4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9   8  9 10 11 12 13 14\n 14 15 16 17 18 19 20  11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16  15 16 17 18 19 20 21\n 21 22 23 24 25 26 27  18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23  22 23 24 25 26 27 28\n 28 29 30 31           25 26 27 28 29 30 31  29 30                 27 28 29 30 31        24 25 26 27 28 29 30  29 30 31\nREALPROGRAMMERSTHINKINUPPERCASEANDCHEATBYUSINGPRINT\n                                                                                                             ; // MAGICAL SEMICOLON\n"
  },
  {
    "language": "PHP",
    "code": "// Static method\nMyClass::method($someParameter);\n// In PHP 5.3+, static method can be called on a string of the class name\n$foo = 'MyClass';\n$foo::method($someParameter);\n\n\n// Instance method\n$myInstance->method($someParameter);\n"
  },
  {
    "language": "PowerShell",
    "code": "$doors = @(0..99)\nfor($i=0; $i -lt 100; $i++) {\n  $doors[$i] = 0  # start with all doors closed\n}\nfor($i=0; $i -lt 100; $i++) {\n  $step = $i + 1\n  for($j=$i; $j -lt 100; $j = $j + $step) {\n    $doors[$j] = $doors[$j] -bxor 1\n  }\n}\nforeach($doornum in 1..100) {\n  if($doors[($doornum-1)] -eq $true) {\"$doornum open\"}\n  else {\"$doornum closed\"}\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-DoorState($NumberOfDoors)\n{\n   begin\n   {\n      $Doors = @()\n      $Multiple = 1\n   }\n\n   process\n   {\n      for ($i = 1; $i -le $NumberOfDoors; $i++)\n      {\n         $Door = [pscustomobject]@{\n                    Name = $i\n                    Open = $false\n                 }\n\n         $Doors += $Door\n      }\n\n      While ($Multiple -le $NumberOfDoors)\n      {\n\t Foreach ($Door in $Doors)\n\t {\n\t    if ($Door.name % $Multiple -eq 0)\n               {\n\t          If ($Door.open -eq $False){$Door.open = $True}\n\t          Else {$Door.open = $False}\n\t       }\n\t }\n\t\t\t\n         $Multiple++\n      }\n    }\n\n    end {$Doors}\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$doors = 1..100 | ForEach-Object {0}\n1..100 | ForEach-Object { $a=$_;1..100 | Where-Object { -not ( $_ % $a )  } | ForEach-Object { $doors[$_-1] = $doors[$_-1] -bxor 1 }; if ( $doors[$a-1] ) { \"door opened\" } else { \"door closed\" } }\n"
  },
  {
    "language": "PowerShell",
    "code": "$doors = 1..100 | ForEach-Object {0}\n$visited = 1..100\n1..100 | ForEach-Object { $a=$_;$visited[0..([math]::floor(100/$a)-1)] | Where-Object { -not ( $_ % $a )  } | ForEach-Object { $doors[$_-1] = $doors[$_-1] -bxor 1;$visited[$_/$a-1]+=($_/$a) }; if ( $doors[$a-1] ) { \"door opened\" } else { \"door closed\" } }\n"
  },
  {
    "language": "PowerShell",
    "code": "1..100|foreach-object {$pipe += \"toggle $_ |\"} -begin {$pipe=\"\"}\nfilter toggle($pass) {$_.door = $_.door -xor !($_.index % $pass);$_}\ninvoke-expression \"1..100| foreach-object {@{index=`$_;door=`$false}} | $pipe  out-host\"\n"
  },
  {
    "language": "PowerShell",
    "code": "Workflow Calc-Doors {\n    Foreach \u2013parallel ($number in 1..100) {\n        \"Door \" + $number.ToString(\"0000\") + \": \" + @{$true=\"Closed\";$false=\"Open\"}[([Math]::pow($number, 0.5)%1) -ne 0]\n    }\n}\nCalc-Doors | sort\n"
  },
  {
    "language": "PowerShell",
    "code": "1..10|%{\"Door \"+ $_*$_ + \" is open\"}\n"
  },
  {
    "language": "PowerShell",
    "code": "CLS\n\nFunction isNumeric ($x)\n{\n    $x2 = 0\n    $isNum = [System.Int32]::TryParse($x,[ref]$x2)\nReturn $isNum\n}\n\n$NumberArray = @()\nWhile( $NumberArray.Count -lt 4 ){\n    $NumberArray += Random -Minimum 1 -Maximum 10\n}\n\nWrite-Host @\"\nWelcome to the 24 game!\n\nHere are your numbers: $($NumberArray -join \",\").\nUse division, multiplication, subtraction and addition to get 24 as a result with these 4 numbers.\n\"@\n\nDo\n{\n$Wrong = 0\n$EndResult = $null\n$TempChar = $null\n$TempChar2 = $null\n$Count = $null\n\n$AllowableCharacters = $NumberArray + \"+-*/()\".ToCharArray()\n    $Result = Read-Host\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If( $AllowableCharacters -notcontains $Char ){ $Wrong = 1 }\n        }\n\n        If($Wrong -eq 1)\n        {\n            Write-Warning \"Wrong input! Please use only the given numbers.\"\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If((IsNumeric $TempChar) -AND (IsNumeric $Char))\n            {\n                Write-Warning \"Wrong input! Combining two or more numbers together is not allowed!\"\n            }\n            $TempChar = $Char\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If(IsNumeric $Char)\n            {\n                $Count++\n            }\n        }\n        If($Count -eq 4)\n        {\n            $EndResult = Invoke-Expression $Result\n                If($EndResult -eq 24)\n                {\n                    Write-Host \"`nYou've won the game!\"\n                }\n                Else\n                {\n                    Write-Host \"`n$EndResult is not 24! Too bad.\"\n                }\n        }\n        Else\n        {\n            Write-Warning \"Wrong input! You did not supply four numbers.\"\n        }\n}\nWhile($EndResult -ne 24)\n"
  },
  {
    "language": "PowerShell",
    "code": "$a,$b = -split \"$input\"\n[int]$a + [int]$b\n"
  },
  {
    "language": "PowerShell",
    "code": "$a,$b = -split (Read-Host)\n[int]$a + [int]$b\n"
  },
  {
    "language": "PowerShell",
    "code": "filter add {\n    return [int]$args[0] + [int]$args[1]\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "add 2 3\n"
  },
  {
    "language": "PowerShell",
    "code": "<#\n.Synopsis\n  ABC Problem\n.DESCRIPTION\n   You are given a collection of ABC blocks. Just like the ones you had when you were a kid.\n   There are twenty blocks with two letters on each block. You are guaranteed to have a\n   complete alphabet amongst all sides of the blocks\n   blocks = \"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"\n   The goal of this task is to write a function that takes a string and can determine whether\n   you can spell the word with the given collection of blocks.\n\n   The rules are simple:\n        1.Once a letter on a block is used that block cannot be used again\n        2.The function should be case-insensitive\n        3. Show your output on this page for the following words:\n        >>> can_make_word(\"A\")\n        True\n        >>> can_make_word(\"BARK\")\n        True\n        >>> can_make_word(\"BOOK\")\n        False\n        >>> can_make_word(\"TREAT\")\n        True\n        >>> can_make_word(\"COMMON\")\n        False\n        >>> can_make_word(\"SQUAD\")\n        True\n        >>> can_make_word(\"CONFUSE\")\n        True\n\n   Using the examples below  you can either see just the value or\n   status and the values using the verbose switch\n\n.EXAMPLE\n   test-blocks -testword confuse\n\n.EXAMPLE\n   test-blocks -testword confuse -verbose\n\n#>\n\nfunction test-blocks\n{\n\t[CmdletBinding()]\n\t#  [OutputType([int])]\n\tParam\n\t(\n\t\t# word to test against blocks\n\t\t[Parameter(Mandatory = $true,\n\t\t\t\t   ValueFromPipelineByPropertyName = $true)]\n\t\t$testword\n\t\t\n\t)\n\n\t$word = $testword\n\t\n\t#define array of blocks\n\t[System.Collections.ArrayList]$blockarray = \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t\n\t#send word to chararray\n\t$chararray = $word.ToCharArray()\n\t$chars = $chararray\n\t\n\t#get the character count\n\t$charscount = $chars.count\n\t\n\t#get the initial count of the blocks\n\t$blockcount = $blockarray.Count\n\t\n\t#find out how many blocks should be left from the difference\n\t#of the blocks and characters in the word - 1 letter/1 block\n\t$correctblockcount = $blockcount - $charscount\n\t\n\t#loop through the characters in the word\n\tforeach ($char in $chars)\n\t{\n\t\t\n\t\t#loop through the blocks\n\t\tforeach ($block in $blockarray)\n\t\t{\n\t\t\t\n\t\t\t#check the current character against each letter on the current block\n\t\t\t#and break if found so the array can reload\n\t\t\tif ($char -in $block[0] -or $char -in $block[1])\n\t\t\t{\n\t\t\t\t\n\t\t\t\twrite-verbose \"match for letter - $char - removing block $block\"\n\t\t\t\t$blockarray.Remove($block)\n\t\t\t\tbreak\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t#get final count of blocks left in array to determine if the word was\n\t#correctly made\n\t$finalblockcount = $blockarray.count\n\tif ($finalblockcount -ne $correctblockcount)\n\t{\n\t\twrite-verbose \"$word : $false \"\n\t\treturn $false\n\t}\n\telse\n\t{\n\t\twrite-verbose \"$word : $true \"\n\t\treturn $true\n\t}\n\t\n}\n\n#loop all the words and pass them to the function\n$wordlist = \"a\", \"bark\", \"book\", \"treat\", \"common\", \"squad\", \"confuse\"\nforeach ($word in $wordlist)\n{\n\ttest-blocks -testword $word -Verbose\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "#Requires -Version 5.0\n\nClass Player\n{\n  <#\n    Properties: Name, Team, Position and Number\n  #>\n    [string]$Name\n\n    [ValidateSet(\"Baltimore Ravens\",\"Cincinnati Bengals\",\"Cleveland Browns\",\"Pittsburgh Steelers\",\n                 \"Chicago Bears\",\"Detroit Lions\",\"Green Bay Packers\",\"Minnesota Vikings\",\n                 \"Houston Texans\",\"Indianapolis Colts\",\"Jacksonville Jaguars\",\"Tennessee Titans\",\n                 \"Atlanta Falcons\",\"Carolina Panthers\",\"New Orleans Saints\",\"Tampa Bay Buccaneers\",\n                 \"Buffalo Bills\",\"Miami Dolphins\",\"New England Patriots\",\"New York Jets\",\n                 \"Dallas Cowboys\",\"New York Giants\",\"Philadelphia Eagles\",\"Washington Redskins\",\n                 \"Denver Broncos\",\"Kansas City Chiefs\",\"Oakland Raiders\",\"San Diego Chargers\",\n                 \"Arizona Cardinals\",\"Los Angeles Rams\",\"San Francisco 49ers\",\"Seattle Seahawks\")]\n    [string]$Team\n\n    [ValidateSet(\"C\",\"G\",\"T\",\"QB\",\"RB\",\"WR\",\"TE\",\"DT\",\"DE\",\"ILB\",\"OLB\",\"CB\",\"S\",\"K\",\"H\",\"LS\",\"P\",\"KOS\",\"R\")]\n    [string]$Position\n\n    [ValidateRange(0,99)]\n    [int]$Number\n\n  <#\n    Constructor: Creates a new Player object, with the specified Name, Team, Position and Number.\n  #>\n    Player([string]$Name, [string]$Team, [string]$Position, [int]$Number)\n    {\n        $this.Name     = (Get-Culture).TextInfo.ToTitleCase(\"$Name\")\n        $this.Team     = (Get-Culture).TextInfo.ToTitleCase(\"$Team\")\n        $this.Position = $Position.ToUpper()\n        $this.Number   = $Number\n    }\n\n  <#\n    Methods: Trade the player to a different team (optional parameters for methods in PowerShell 5 classes are not available.  Boo!!)\n             An overloaded method is a method with the same name as another method but in a different context,\n             in this case with different parameters.\n  #>\n    Trade([string]$NewTeam)\n    {\n        [string[]]$league = \"Baltimore Ravens\",\"Cincinnati Bengals\",\"Cleveland Browns\",\"Pittsburgh Steelers\",\n                            \"Chicago Bears\",\"Detroit Lions\",\"Green Bay Packers\",\"Minnesota Vikings\",\n                            \"Houston Texans\",\"Indianapolis Colts\",\"Jacksonville Jaguars\",\"Tennessee Titans\",\n                            \"Atlanta Falcons\",\"Carolina Panthers\",\"New Orleans Saints\",\"Tampa Bay Buccaneers\",\n                            \"Buffalo Bills\",\"Miami Dolphins\",\"New England Patriots\",\"New York Jets\",\n                            \"Dallas Cowboys\",\"New York Giants\",\"Philadelphia Eagles\",\"Washington Redskins\",\n                            \"Denver Broncos\",\"Kansas City Chiefs\",\"Oakland Raiders\",\"San Diego Chargers\",\n                            \"Arizona Cardinals\",\"Los Angeles Rams\",\"San Francisco 49ers\",\"Seattle Seahawks\"\n\n        if ($NewTeam -in $league | Where-Object {$_ -notmatch $this.Team})\n        {\n            $this.Team = (Get-Culture).TextInfo.ToTitleCase(\"$NewTeam\")\n        }\n        else\n        {\n            throw \"Invalid Team\"\n        }\n    }\n\n    Trade([string]$NewTeam, [int]$NewNumber)\n    {\n        [string[]]$league = \"Baltimore Ravens\",\"Cincinnati Bengals\",\"Cleveland Browns\",\"Pittsburgh Steelers\",\n                            \"Chicago Bears\",\"Detroit Lions\",\"Green Bay Packers\",\"Minnesota Vikings\",\n                            \"Houston Texans\",\"Indianapolis Colts\",\"Jacksonville Jaguars\",\"Tennessee Titans\",\n                            \"Atlanta Falcons\",\"Carolina Panthers\",\"New Orleans Saints\",\"Tampa Bay Buccaneers\",\n                            \"Buffalo Bills\",\"Miami Dolphins\",\"New England Patriots\",\"New York Jets\",\n                            \"Dallas Cowboys\",\"New York Giants\",\"Philadelphia Eagles\",\"Washington Redskins\",\n                            \"Denver Broncos\",\"Kansas City Chiefs\",\"Oakland Raiders\",\"San Diego Chargers\",\n                            \"Arizona Cardinals\",\"Los Angeles Rams\",\"San Francisco 49ers\",\"Seattle Seahawks\"\n\n        if ($NewTeam -in $league | Where-Object {$_ -notmatch $this.Team})\n        {\n            $this.Team = (Get-Culture).TextInfo.ToTitleCase(\"$NewTeam\")\n        }\n        else\n        {\n            throw \"Invalid Team\"\n        }\n\n        if ($NewNumber -in 0..99)\n        {\n            $this.Number = $NewNumber\n        }\n        else\n        {\n            throw \"Invalid Number\"\n        }\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$player1 = [Player]::new(\"sam bradford\", \"philadelphia eagles\", \"qb\", 7)\n$player1\n"
  },
  {
    "language": "PowerShell",
    "code": "$player1.Trade(\"minnesota vikings\", 8)\n$player1\n"
  },
  {
    "language": "PowerShell",
    "code": "$player2 = [Player]::new(\"demarco murray\", \"philadelphia eagles\", \"rb\", 29)\n$player2\n"
  },
  {
    "language": "PowerShell",
    "code": "$player2.Trade(\"tennessee titans\")\n$player2\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-ProperDivisorSum ( [int]$N )\n    {\n    If ( $N -lt 2 ) { return 0 }\n\n    $Sum = 1\n    If ( $N -gt 3 )\n        {\n        $SqrtN = [math]::Sqrt( $N )\n        ForEach ( $Divisor in 2..$SqrtN )\n            {\n            If ( $N % $Divisor -eq 0 ) { $Sum += $Divisor + $N / $Divisor }\n            }\n        If ( $N % $SqrtN -eq 0 ) { $Sum -= $SqrtN }\n        }\n    return $Sum\n    }\n\n\n$Deficient = $Perfect = $Abundant = 0\n\nForEach ( $N in 1..20000 )\n    {\n    Switch ( [math]::Sign( ( Get-ProperDivisorSum $N ) - $N ) )\n        {\n        -1 { $Deficient++ }\n         0 { $Perfect++   }\n         1 { $Abundant++  }\n        }\n    }\n\n\"Deficient: $Deficient\"\n\"Perfect  : $Perfect\"\n\"Abundant : $Abundant\"\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-NumberClassification\n{\n    [CmdletBinding()]\n    [OutputType([PSCustomObject])]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true,\n                   Position=0)]\n        [int]\n        $Number\n    )\n\n    Begin\n    {\n        function Get-ProperDivisorSum ([int]$Number)\n        {\n            if ($Number -lt 2) {return 0}\n\n            $sum = 1\n\n            if ($Number -gt 3)\n            {\n                $sqrtNumber = [Math]::Sqrt($Number)\n\n                foreach ($divisor in 2..$sqrtNumber)\n                {\n                    if ($Number % $divisor -eq 0) {$sum += $divisor + $Number / $divisor}\n                }\n\n                if ($Number % $sqrtNumber -eq 0) {$sum -= $sqrtNumber}\n            }\n\n            $sum\n        }\n\n        [System.Collections.ArrayList]$numbers = @()\n    }\n    Process\n    {\n        switch ([Math]::Sign((Get-ProperDivisorSum $Number) - $Number))\n        {\n            -1 { [void]$numbers.Add([PSCustomObject]@{Class=\"Deficient\"; Number=$Number}) }\n             0 { [void]$numbers.Add([PSCustomObject]@{Class=\"Perfect\"  ; Number=$Number}) }\n             1 { [void]$numbers.Add([PSCustomObject]@{Class=\"Abundant\" ; Number=$Number}) }\n        }\n    }\n    End\n    {\n        $numbers | Group-Object  -Property Class |\n                   Select-Object -Property Count,\n                                           @{Name='Class' ; Expression={$_.Name}},\n                                           @{Name='Number'; Expression={$_.Group.Number}}\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "1..20000 | Get-NumberClassification\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-Accumulator ([double]$Start)\n{\n    {param([double]$Plus) return $script:Start += $Plus}.GetNewClosure()\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$total = Get-Accumulator -Start 1\n& $total -Plus 5.0 | Out-Null\n& $total -Plus 2.3\n"
  },
  {
    "language": "PowerShell",
    "code": "function ackermann ([long] $m, [long] $n) {\n    if ($m -eq 0) {\n        return $n + 1\n    }\n\n    if ($n -eq 0) {\n        return (ackermann ($m - 1) 1)\n    }\n\n    return (ackermann ($m - 1) (ackermann $m ($n - 1)))\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "foreach ($m in 0..3) {\n    foreach ($n in 0..6) {\n        Write-Host -NoNewline (\"{0,5}\" -f (ackermann $m $n))\n    }\n    Write-Host\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-Ackermann ([int64]$m, [int64]$n)\n{\n    if ($m -eq 0)\n    {\n        return $n + 1\n    }\n\n    if ($n -eq 0)\n    {\n        return Get-Ackermann ($m - 1) 1\n    }\n\n    return (Get-Ackermann ($m - 1) (Get-Ackermann $m ($n - 1)))\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$ackermann = 0..3 | ForEach-Object {$m = $_; 0..6 | ForEach-Object {Get-Ackermann $m  $_}}\n\n$ackermann | Format-Wide {\"{0,3}\" -f $_} -Column 7 -Force\n"
  },
  {
    "language": "PowerShell",
    "code": "Import-Module ActiveDirectory\n\n$searchData = \"user name\"\n$searchBase = \"DC=example,DC=com\"\n\n#searches by some of the most common unique identifiers\nget-aduser -Filter((DistinguishedName -eq $searchdata) -or (UserPrincipalName -eq $searchdata) -or (SamAccountName -eq $searchdata)) -SearchBase $searchBase\n"
  },
  {
    "language": "PowerShell",
    "code": "$x = 42 `\n     | Add-Member -PassThru `\n        NoteProperty `\n        Title `\n        \"The answer to the question about life, the universe and everything\"\n"
  },
  {
    "language": "PowerShell",
    "code": "$file =\n@'\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n'@.Split(\"`n\")\n\n$arr = @()\n$file | foreach {\n    $line = $_\n    $i = 0\n    $hash = [ordered]@{}\n    $line.split('$') | foreach{\n        $hash[\"$i\"] = \"$_\"\n        $i++\n     }\n    $arr += @([pscustomobject]$hash)\n}\n$arr | Format-Table -HideTableHeaders -Wrap *\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-NextAliquot ( [int]$X )\n    {\n    If ( $X -gt 1 )\n        {\n        $NextAliquot = 0\n        (1..($X/2)).Where{ $x % $_ -eq 0 }.ForEach{ $NextAliquot += $_ }.Where{ $_ }\n        return $NextAliquot\n        }\n    }\n\nfunction Get-AliquotSequence ( [int]$K, [int]$N )\n    {\n    $X = $K\n    $X\n    (1..($N-1)).ForEach{ $X = Get-NextAliquot $X; $X }\n    }\n\nfunction Classify-AlliquotSequence ( [int[]]$Sequence )\n    {\n    $K = $Sequence[0]\n    $LastN = $Sequence.Count\n    If ( $Sequence[-1] -eq 0 ) { return \"terminating\" }\n    If ( $Sequence[-1] -eq 1 ) { return \"terminating\" }\n    If ( $Sequence[1] -eq $K ) { return \"perfect\"     }\n    If ( $Sequence[2] -eq $K ) { return \"amicable\"    }\n    If ( $Sequence[3..($Sequence.Count-1)] -contains $K ) { return \"sociable\" }\n    If ( $Sequence[-1] -eq $Sequence[-2] ) { return \"aspiring\" }\n    If ( $Sequence.Count -gt ( $Sequence | Select -Unique ).Count ) { return \"cyclic\" }\n    return \"non-terminating and non-repeating through N = $($Sequence.Count)\"\n    }\n\n(1..10).ForEach{ [string]$_ + \" is \" + ( Classify-AlliquotSequence -Sequence ( Get-AliquotSequence -K $_ -N 16 ) ) }\n\n( 11, 12, 28, 496, 220, 1184, 790, 909, 562, 1064, 1488 ).ForEach{ [string]$_ + \" is \" + ( Classify-AlliquotSequence -Sequence ( Get-AliquotSequence -K $_ -N 16 ) ) }\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-NextAliquot ( [int]$X )\n    {\n    If ( $X -gt 1 )\n        {\n        $NextAliquot = 1\n        If ( $X -gt 2 )\n            {\n            $XSquareRoot = [math]::Sqrt( $X )\n\n            (2..$XSquareRoot).Where{ $X % $_ -eq 0 }.ForEach{ $NextAliquot += $_ + $x / $_ }\n\n            If ( $XSquareRoot % 1 -eq 0 ) { $NextAliquot -= $XSquareRoot }\n            }\n        return $NextAliquot\n        }\n    }\n\nfunction Get-AliquotSequence ( [int]$K, [int]$N )\n    {\n    $X = $K\n    $X\n    $i = 1\n    While ( $X -and $i -lt $N )\n        {\n        $i++\n        $Next = Get-NextAliquot $X\n        If ( $Next )\n            {\n            If ( $X -eq $Next )\n                {\n                ($i..$N).ForEach{ $X }\n                $i = $N\n                }\n            Else\n                {\n                $X = $Next\n                $X\n                }\n            }\n        Else\n            {\n            $i = $N\n            }\n        }\n    }\n\nfunction Classify-AlliquotSequence ( [int[]]$Sequence )\n    {\n    $K = $Sequence[0]\n    $LastN = $Sequence.Count\n    If ( $Sequence[-1] -eq 0 ) { return \"terminating\" }\n    If ( $Sequence[-1] -eq 1 ) { return \"terminating\" }\n    If ( $Sequence[1] -eq $K ) { return \"perfect\"     }\n    If ( $Sequence[2] -eq $K ) { return \"amicable\"    }\n    If ( $Sequence[3..($Sequence.Count-1)] -contains $K ) { return \"sociable\" }\n    If ( $Sequence[-1] -eq $Sequence[-2] ) { return \"aspiring\" }\n    If ( $Sequence.Count -gt ( $Sequence | Select -Unique ).Count ) { return \"cyclic\" }\n    return \"non-terminating and non-repeating through N = $($Sequence.Count)\"\n    }\n\n(1..10).ForEach{ [string]$_ + \" is \" + ( Classify-AlliquotSequence -Sequence ( Get-AliquotSequence -K $_ -N 16 ) ) }\n\n( 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488 ).ForEach{ [string]$_ + \" is \" + ( Classify-AlliquotSequence -Sequence ( Get-AliquotSequence -K $_ -N 16 ) ) }\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-Aliquot\n{\n    [CmdletBinding()]\n    [OutputType([PScustomObject])]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true)]\n        [int]\n        $InputObject\n    )\n\n    Begin\n    {\n        function Get-NextAliquot ([int]$X)\n        {\n            if ($X -gt 1)\n            {\n                $nextAliquot = 1\n\n                if ($X -gt 2)\n                {\n                    $xSquareRoot = [Math]::Sqrt($X)\n\n                    2..$xSquareRoot | Where-Object {$X % $_ -eq 0} | ForEach-Object {$nextAliquot += $_ + $x / $_}\n\n                    if ($xSquareRoot % 1 -eq 0) {$nextAliquot -= $xSquareRoot}\n                }\n\n                $nextAliquot\n            }\n        }\n\n        function Get-AliquotSequence ([int]$K, [int]$N)\n        {\n            $X = $K\n            $X\n            $i = 1\n\n            while ($X -and $i -lt $N)\n            {\n                $i++\n                $next = Get-NextAliquot $X\n\n                if ($next)\n                {\n                    if ($X -eq $next)\n                    {\n                        $i..$N  | ForEach-Object {$X}\n                        $i = $N\n                    }\n                    else\n                    {\n                        $X = $next\n                        $X\n                    }\n                }\n                else\n                {\n                    $i = $N\n                }\n            }\n        }\n\n        function Classify-AlliquotSequence ([int[]]$Sequence)\n        {\n            $k = $Sequence[0]\n\n            if ($Sequence[-1] -eq 0)                                     {return \"terminating\"}\n            if ($Sequence[-1] -eq 1)                                     {return \"terminating\"}\n            if ($Sequence[1]  -eq $k)                                    {return \"perfect\"    }\n            if ($Sequence[2]  -eq $k)                                    {return \"amicable\"   }\n            if ($Sequence[3..($Sequence.Count-1)] -contains $k)          {return \"sociable\"   }\n            if ($Sequence[-1] -eq $Sequence[-2] )                        {return \"aspiring\"   }\n            if ($Sequence.Count -gt ($Sequence | Select -Unique).Count ) {return \"cyclic\"     }\n\n            return \"non-terminating and non-repeating through N = $($Sequence.Count)\"\n        }\n    }\n    Process\n    {\n        $_ | ForEach-Object {\n            [PSCustomObject]@{\n                Number         = $_\n                Classification = (Classify-AlliquotSequence -Sequence (Get-AliquotSequence -K $_ -N 16))\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$oneToTen = 1..10 | Get-Aliquot\n$selected = 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488 | Get-Aliquot\n\n$numbers = $oneToTen, $selected\n$numbers\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-ProperDivisorSum ( [int]$N )\n    {\n    $Sum = 1\n    If ( $N -gt 3 )\n        {\n        $SqrtN = [math]::Sqrt( $N )\n        ForEach ( $Divisor1 in 2..$SqrtN )\n            {\n            $Divisor2 = $N / $Divisor1\n            If ( $Divisor2 -is [int] ) { $Sum += $Divisor1 + $Divisor2 }\n            }\n        If ( $SqrtN -is [int] ) { $Sum -= $SqrtN }\n        }\n    return $Sum\n    }\n\nfunction Get-AmicablePairs ( $N = 300 )\n    {\n    ForEach ( $X in 1..$N )\n        {\n        $Sum = Get-ProperDivisorSum $X\n        If ( $Sum -gt $X -and $X -eq ( Get-ProperDivisorSum $Sum ) )\n            {\n            \"$X, $Sum\"\n            }\n        }\n    }\n\nGet-AmicablePairs 20000\n"
  },
  {
    "language": "PowerShell",
    "code": "$c = New-Object Net.WebClient\n$words = -split ($c.DownloadString('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'))\n$top_anagrams = $words `\n    | ForEach-Object {\n          $_ | Add-Member -PassThru NoteProperty Characters `\n                   (-join (([char[]] $_) | Sort-Object))\n      } `\n    | Group-Object Characters `\n    | Group-Object Count `\n    | Sort-Object Count `\n    | Select-Object -First 1\n\n$top_anagrams.Group | ForEach-Object { $_.Group -join ', ' }\n"
  },
  {
    "language": "PowerShell",
    "code": "$Timer = [System.Diagnostics.Stopwatch]::StartNew()\n\n$uri = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\n$words = -split [Net.WebClient]::new().DownloadString($uri)\n\n$anagrams = @{}\n$maxAnagramCount = 0\n\nforeach ($w in $words)\n{\n    # Sort the characters in the word into alphabetical order\n    $chars=[char[]]$w\n    [array]::sort($chars)\n    $orderedChars = [string]::Join('', $chars)\n\n\n    # If no anagrams list for these chars, make one\n    if (-not $anagrams.ContainsKey($orderedChars))\n    {\n        $anagrams[$orderedChars] = [Collections.Generic.List[String]]::new()\n    }\n\n\n    # Add current word as an anagram of these chars,\n    # in a way which keeps the list available\n    ($list = $anagrams[$orderedChars]).Add($w)\n\n\n    # Keep running score of max number of anagrams seen\n    if ($list.Count -gt $maxAnagramCount)\n    {\n        $maxAnagramCount = $list.Count\n    }\n\n}\n\nforeach ($entry in $anagrams.GetEnumerator())\n{\n    if ($entry.Value.Count -eq $maxAnagramCount)\n    {\n        [string]::join('', $entry.Value)\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "function Test-Deranged ([string[]]$Strings)\n{\n    $array1 = $Strings[0].ToCharArray()\n\n    for ($i = 1; $i -lt $Strings.Count; $i++)\n    {\n        $array2 = $Strings[$i].ToCharArray()\n\n        for ($i = 0; $i -lt $array1.Count; $i++)\n        {\n            if ($array1[$i] -match $array2[$i])\n            {\n                return $false\n            }\n        }\n    }\n\n    return $true\n}\n\n\n$words = [System.Collections.ArrayList]@()\n\nGet-Content -Path \".\\unixdict.txt\" |\n    ForEach-Object { [void]$words.Add([PSCustomObject]@{Word=$_; SortedWord=(($_.ToCharArray() | Sort-Object) -join \"\")}) }\n\n[object[]]$anagrams = $words | Group-Object -Property SortedWord | Where-Object -Property Count -GT 1 | Sort-Object {$_.Name.Length}\n[string[]]$deranged = ($anagrams | ForEach-Object { if ((Test-Deranged $_.Group.Word)) {$_} } | Select-Object -Last 1).Group.Word\n\n[PSCustomObject]@{\n    Length = $deranged[0].Length\n    Words  = $deranged\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "function Test-FileLock\n{\n    Param\n    (\n        [parameter(Mandatory=$true)]\n        [string]\n        $Path\n    )\n\n    $outFile = New-Object System.IO.FileInfo $Path\n\n    if (-not(Test-Path -Path $Path))\n    {\n        return $false\n    }\n\n    try\n    {\n        $outStream = $outFile.Open([System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)\n\n        if ($outStream)\n        {\n            $outStream.Close()\n        }\n\n        return $false\n    }\n    catch\n    {\n        # File is locked by a process.\n        return $true\n    }\n}\n\nfunction New-Record\n{\n    Param\n    (\n        [string]$Account,\n        [string]$Password,\n        [int]$UID,\n        [int]$GID,\n        [string]$FullName,\n        [string]$Office,\n        [string]$Extension,\n        [string]$HomePhone,\n        [string]$Email,\n        [string]$Directory,\n        [string]$Shell\n    )\n\n    $GECOS = [PSCustomObject]@{\n        FullName  = $FullName\n        Office    = $Office\n        Extension = $Extension\n        HomePhone = $HomePhone\n        Email     = $Email\n    }\n\n    [PSCustomObject]@{\n        Account   = $Account\n        Password  = $Password\n        UID       = $UID\n        GID       = $GID\n        GECOS     = $GECOS\n        Directory = $Directory\n        Shell     = $Shell\n    }\n}\n\n\nfunction Import-File\n{\n    Param\n    (\n        [Parameter(Mandatory=$false,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true)]\n        [string]\n        $Path = \".\\passwd.txt\"\n    )\n\n    if (-not(Test-Path $Path))\n    {\n        throw [System.IO.FileNotFoundException]\n    }\n\n    $header = \"Account\",\"Password\",\"UID\",\"GID\",\"GECOS\",\"Directory\",\"Shell\"\n\n    $csv = Import-Csv -Path $Path -Delimiter \":\" -Header $header -Encoding ASCII\n    $csv | ForEach-Object {\n        New-Record -Account   $_.Account `\n                   -Password  $_.Password `\n                   -UID       $_.UID `\n                   -GID       $_.GID `\n                   -FullName  $_.GECOS.Split(\",\")[0] `\n                   -Office    $_.GECOS.Split(\",\")[1] `\n                   -Extension $_.GECOS.Split(\",\")[2] `\n                   -HomePhone $_.GECOS.Split(\",\")[3] `\n                   -Email     $_.GECOS.Split(\",\")[4] `\n                   -Directory $_.Directory `\n                   -Shell     $_.Shell\n    }\n}\n\n\nfunction Export-File\n{\n    [CmdletBinding()]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true)]\n        $InputObject,\n\n        [Parameter(Mandatory=$false,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true)]\n        [string]\n        $Path = \".\\passwd.txt\"\n    )\n\n    Begin\n    {\n        if (-not(Test-Path $Path))\n        {\n            New-Item -Path . -Name $Path -ItemType File | Out-Null\n        }\n\n        [string]$recordString = \"{0}:{1}:{2}:{3}:{4}:{5}:{6}\"\n        [string]$gecosString  = \"{0},{1},{2},{3},{4}\"\n        [string[]]$lines = @()\n        [string[]]$file  = Get-Content $Path\n    }\n    Process\n    {\n        foreach ($object in $InputObject)\n        {\n            $lines += $recordString -f $object.Account,\n                                       $object.Password,\n                                       $object.UID,\n                                       $object.GID,\n                                       $($gecosString -f $object.GECOS.FullName,\n                                                         $object.GECOS.Office,\n                                                         $object.GECOS.Extension,\n                                                         $object.GECOS.HomePhone,\n                                                         $object.GECOS.Email),\n                                       $object.Directory,\n                                       $object.Shell\n        }\n    }\n    End\n    {\n        foreach ($line in $lines)\n        {\n            if (-not ($line -in $file))\n            {\n                $line | Out-File -FilePath $Path -Encoding ASCII -Append\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$records = @()\n\n$records+= New-Record -Account   'jsmith' `\n                      -Password  'x' `\n                      -UID       1001 `\n                      -GID       1000 `\n                      -FullName  'Joe Smith' `\n                      -Office    'Room 1007' `\n                      -Extension '(234)555-8917' `\n                      -HomePhone '(234)555-0077' `\n                      -Email     'jsmith@rosettacode.org' `\n                      -Directory '/home/jsmith' `\n                      -Shell     '/bin/bash'\n\n$records+= New-Record -Account   'jdoe' `\n                      -Password  'x' `\n                      -UID       1002 `\n                      -GID       1000 `\n                      -FullName  'Jane Doe' `\n                      -Office    'Room 1004' `\n                      -Extension '(234)555-8914' `\n                      -HomePhone '(234)555-0044' `\n                      -Email     'jdoe@rosettacode.org' `\n                      -Directory '/home/jdoe' `\n                      -Shell     '/bin/bash'\n"
  },
  {
    "language": "PowerShell",
    "code": "$records | Format-Table -AutoSize\n"
  },
  {
    "language": "PowerShell",
    "code": "if (-not(Test-FileLock -Path \".\\passwd.txt\"))\n{\n    $records | Export-File -Path \".\\passwd.txt\"\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "Get-Content -Path \".\\passwd.txt\"\n"
  },
  {
    "language": "PowerShell",
    "code": "$records+= New-Record -Account   'xyz' `\n                      -Password  'x' `\n                      -UID       1003 `\n                      -GID       1000 `\n                      -FullName  'X Yz' `\n                      -Office    'Room 1003' `\n                      -Extension '(234)555-8913' `\n                      -HomePhone '(234)555-0033' `\n                      -Email     'xyz@rosettacode.org' `\n                      -Directory '/home/xyz' `\n                      -Shell     '/bin/bash'\n"
  },
  {
    "language": "PowerShell",
    "code": "$records | Sort-Object { $_.GECOS.FullName.Split(\" \")[1] } | Format-Table -AutoSize\n"
  },
  {
    "language": "PowerShell",
    "code": "if (-not(Test-FileLock -Path \".\\passwd.txt\"))\n{\n    $records | Export-File -Path \".\\passwd.txt\"\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "Get-Content -Path \".\\passwd.txt\"\n"
  },
  {
    "language": "PowerShell",
    "code": "1..5 | ForEach-Object { $_ * $_ }\n"
  },
  {
    "language": "PowerShell",
    "code": "function map ([array] $a, [scriptblock] $s) {\n    $a | ForEach-Object $s\n}\nmap (1..5) { $_ * $_ }\n"
  },
  {
    "language": "PowerShell",
    "code": "#  Perform calculation\n$BigNumber = [BigInt]::Pow( 5, [BigInt]::Pow( 4, [BigInt]::Pow( 3, 2 ) ) )\n\n#  Display first and last 20 digits\n$BigNumberString = [string]$BigNumber\n$BigNumberString.Substring( 0, 20 ) + \"...\" + $BigNumberString.Substring( $BigNumberString.Length - 20, 20 )\n\n#  Display number of digits\n$BigNumberString.Length\n"
  },
  {
    "language": "PowerShell",
    "code": "class Complex {\n  [Double]$x\n  [Double]$y\n  Complex() {\n      $this.x = 0\n      $this.y = 0\n  }\n  Complex([Double]$x, [Double]$y) {\n      $this.x = $x\n      $this.y = $y\n  }\n  [Double]abs2() {return $this.x*$this.x + $this.y*$this.y}\n  [Double]abs() {return [math]::sqrt($this.abs2())}\n  static [Complex]add([Complex]$m,[Complex]$n) {return [Complex]::new($m.x+$n.x, $m.y+$n.y)}\n  static [Complex]mul([Complex]$m,[Complex]$n) {return [Complex]::new($m.x*$n.x - $m.y*$n.y, $m.x*$n.y + $n.x*$m.y)}\n  [Complex]mul([Double]$k) {return [Complex]::new($k*$this.x, $k*$this.y)}\n  [Complex]negate() {return $this.mul(-1)}\n  [Complex]conjugate() {return [Complex]::new($this.x, -$this.y)}\n  [Complex]inverse() {return $this.conjugate().mul(1/$this.abs2())}\n  [String]show() {\n    if(0 -ge $this.y) {\n        return \"$($this.x)+$($this.y)i\"\n    } else {\n        return \"$($this.x)$($this.y)i\"\n    }\n  }\n  static [String]show([Complex]$other) {\n    return $other.show()\n  }\n}\n$m = [complex]::new(3, 4)\n$n = [complex]::new(7, 6)\n\"`$m: $($m.show())\"\n\"`$n: $($n.show())\"\n\"`$m + `$n: $([complex]::show([complex]::add($m,$n)))\"\n\"`$m * `$n: $([complex]::show([complex]::mul($m,$n)))\"\n\"negate `$m: $($m.negate().show())\"\n\"1/`$m: $([complex]::show($m.inverse()))\"\n\"conjugate `$m: $([complex]::show($m.conjugate()))\"\n"
  },
  {
    "language": "PowerShell",
    "code": "function show([System.Numerics.Complex]$c) {\n    if(0 -le $c.Imaginary) {\n        return \"$($c.Real)+$($c.Imaginary)i\"\n    } else {\n        return \"$($c.Real)$($c.Imaginary)i\"\n    }\n  }\n$m = [System.Numerics.Complex]::new(3, 4)\n$n = [System.Numerics.Complex]::new(7, 6)\n\"`$m: $(show $m)\"\n\"`$n: $(show $n)\"\n\"`$m + `$n: $(show ([System.Numerics.Complex]::Add($m,$n)))\"\n\"`$m * `$n: $(show ([System.Numerics.Complex]::Multiply($m,$n)))\"\n\"negate `$m: $(show ([System.Numerics.Complex]::Negate($m)))\"\n\"1/`$m: $(show ([System.Numerics.Complex]::Reciprocal($m)))\"\n\"conjugate `$m: $(show ([System.Numerics.Complex]::Conjugate($m)))\"\n"
  },
  {
    "language": "PowerShell",
    "code": "function agm ([Double]$a, [Double]$g) {\n    [Double]$eps = 1E-15\n    [Double]$a1 = [Double]$g1 = 0\n    while([Math]::Abs($a - $g) -gt $eps) {\n        $a1, $g1 = $a, $g\n        $a = ($a1 + $g1)/2\n        $g = [Math]::Sqrt($a1*$g1)\n    }\n    [pscustomobject]@{\n        a = \"$a\"\n        g = \"$g\"\n    }\n}\nagm 1 (1/[Math]::Sqrt(2))\n"
  },
  {
    "language": "PowerShell",
    "code": "$a = [int] (Read-Host First Number)\n$b = [int] (Read-Host Second Number)\n\nWrite-Host \"Sum:                              $($a + $b)\"\nWrite-Host \"Difference:                       $($a - $b)\"\nWrite-Host \"Product:                          $($a * $b)\"\nWrite-Host \"Quotient:                         $($a / $b)\"\nWrite-Host \"Quotient, round to even:          $([Math]::Round($a / $b))\"\nWrite-Host \"Remainder, sign follows first:    $($a % $b)\"\n"
  },
  {
    "language": "PowerShell",
    "code": "[Math]::Pow($a, $b)\n"
  },
  {
    "language": "PowerShell",
    "code": "$a = 1,2,3\n$b = 4,5,6\n\n$c = $a + $b\nWrite-Host $c\n"
  },
  {
    "language": "PowerShell",
    "code": "$a = @()\n"
  },
  {
    "language": "PowerShell",
    "code": "$a = ,2\n$a = @(2)  # alternative\n"
  },
  {
    "language": "PowerShell",
    "code": "$a = 1,2,3\n"
  },
  {
    "language": "PowerShell",
    "code": "$a += 5\n"
  },
  {
    "language": "PowerShell",
    "code": "$a[1]\n"
  },
  {
    "language": "PowerShell",
    "code": "$a[1] = 42\n"
  },
  {
    "language": "PowerShell",
    "code": "$r = 1..100\n"
  },
  {
    "language": "PowerShell",
    "code": "$r[0..9+25..27+80,85,90]\n"
  },
  {
    "language": "PowerShell",
    "code": "$r[-1]  # last index\n"
  },
  {
    "language": "PowerShell",
    "code": "$hashtable = @{}\n"
  },
  {
    "language": "PowerShell",
    "code": "$hashtable = @{\n    \"key1\" = \"value 1\"\n    key2 = 5            # if the key name has no spaces, no quotes are needed.\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$hashtable.foo    = \"bar\"\n$hashtable['bar'] = 42\n$hashtable.\"a b\"  = 3.14  # keys can contain spaces, property-style access needs quotation marks, then\n$hashtable[5]     = 8     # keys don't need to be strings\n"
  },
  {
    "language": "PowerShell",
    "code": "# Case insensitive keys, both end up as the same key:\n$h=@{}\n$h['a'] = 1\n$h['A'] = 2\n$h\n\nName                           Value\n----                           -----\na                              2\n\n# Case sensitive keys:\n$h = New-Object -TypeName System.Collections.Hashtable\n$h['a'] = 1\n$h['A'] = 2\n$h\n\nName                           Value\n----                           -----\nA                              2\na                              1\n"
  },
  {
    "language": "PowerShell",
    "code": "$hashtable.key1     # value 1\n$hashtable['key2']  # 5\n"
  },
  {
    "language": "PowerShell",
    "code": "$obj = [PSCustomObject]@{\n    \"key1\" = \"value 1\"\n    key2 = 5\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$h = @{ 'a' = 1; 'b' = 2; 'c' = 3 }\n"
  },
  {
    "language": "PowerShell",
    "code": "$h.GetEnumerator() | ForEach-Object { Write-Host Key: $_.Name, Value: $_.Value }\n"
  },
  {
    "language": "PowerShell",
    "code": "foreach ($e in $h.GetEnumerator()) {\n    Write-Host Key: $e.Name, Value: $e.Value\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$h.Keys | ForEach-Object { Write-Host Key: $_ }\n\nforeach ($k in $h.Keys) {\n    Write-Host Key: $k\n}\n"
  },
  {
    "language": "Python",
    "code": "doors = [False] * 100\nfor i in range(100):\n   for j in range(i, 100, i+1):\n       doors[j] = not doors[j]\n   print(\"Door %d:\" % (i+1), 'open' if doors[i] else 'close')\n"
  },
  {
    "language": "Python",
    "code": "for i in xrange(1, 101):\n    root = i ** 0.5\n    print \"Door %d:\" % i, 'open' if root == int(root) else 'close'\n"
  },
  {
    "language": "Python",
    "code": "print '\\n'.join(['Door %s is %s' % (i, ('closed', 'open')[(i**0.5).is_integer()]) for i in xrange(1, 101)])\n"
  },
  {
    "language": "Python",
    "code": "print '\\n'.join('Door %s is %s' % (i, 'closed' if i**0.5 % 1 else 'open') for i in range(1, 101))\n"
  },
  {
    "language": "Python",
    "code": "for i in range(1, 101):\n    if i**0.5 % 1:\n        state='open'\n    else:\n        state='close'\n    print(\"Door {}:{}\".format(i, state))\n"
  },
  {
    "language": "Python",
    "code": "for i in range(1,11): print(\"Door %s is open\" % i**2)\n"
  },
  {
    "language": "Python",
    "code": "'''\n The 24 Game Player\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n\n\n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets\n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))\n    return '!'\n\ndef main():\n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport operator\nfrom itertools import product, permutations\n\ndef mydiv(n, d):\n    return n / d if d != 0 else 9999999\n\nsyms = [operator.add, operator.sub, operator.mul, mydiv]\nop = {sym: ch for sym, ch in zip(syms, '+-*/')}\n\ndef solve24(nums):\n    for x, y, z in product(syms, repeat=3):\n        for a, b, c, d in permutations(nums):\n            if round(x(y(a,b),z(c,d)),5) == 24:\n                return f\"({a} {op[y]} {b}) {op[x]} ({c} {op[z]} {d})\"\n            elif round(x(a,y(b,z(c,d))),5) == 24:\n                return f\"{a} {op[x]} ({b} {op[y]} ({c} {op[z]} {d}))\"\n            elif round(x(y(z(c,d),b),a),5) == 24:\n                return f\"(({c} {op[z]} {d}) {op[y]} {b}) {op[x]} {a}\"\n            elif round(x(y(b,z(c,d)),a),5) == 24:\n                return f\"({b} {op[y]} ({c} {op[z]} {d})) {op[x]} {a}\"\n    return '--Not Found--'\n\nif __name__ == '__main__':\n    #nums = eval(input('Four integers in the range 1:9 inclusive, separated by commas: '))\n    for nums in [\n        [9,4,4,5],\n        [1,7,2,7],\n        [5,7,5,4],\n        [1,4,6,6],\n        [2,3,7,3],\n        [8,7,9,7],\n        [1,6,2,6],\n        [7,9,4,1],\n        [6,4,2,2],\n        [5,7,9,7],\n        [3,3,8,8],  # Difficult case requiring precise division\n            ]:\n        print(f\"solve24({nums}) -> {solve24(nums)}\")\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# Python 3\nfrom operator import mul, sub, add\n\n\ndef div(a, b):\n    if b == 0:\n        return 999999.0\n    return a / b\n\nops = {mul: '*', div: '/', sub: '-', add: '+'}\n\ndef solve24(num, how, target):\n    if len(num) == 1:\n        if round(num[0], 5) == round(target, 5):\n            yield str(how[0]).replace(',', '').replace(\"'\", '')\n    else:\n        for i, n1 in enumerate(num):\n            for j, n2 in enumerate(num):\n                if i != j:\n                    for op in ops:\n                        new_num = [n for k, n in enumerate(num) if k != i and k != j] + [op(n1, n2)]\n                        new_how = [h for k, h in enumerate(how) if k != i and k != j] + [(how[i], ops[op], how[j])]\n                        yield from solve24(new_num, new_how, target)\n\ntests = [\n         [1, 7, 2, 7],\n         [5, 7, 5, 4],\n         [1, 4, 6, 6],\n         [2, 3, 7, 3],\n         [1, 6, 2, 6],\n         [7, 9, 4, 1],\n         [6, 4, 2, 2],\n         [5, 7, 9, 7],\n         [3, 3, 8, 8],  # Difficult case requiring precise division\n         [8, 7, 9, 7],  # No solution\n         [9, 4, 4, 5],  # No solution\n            ]\nfor nums in tests:\n    print(nums, end=' : ')\n    try:\n        print(next(solve24(nums, nums, 24)))\n    except StopIteration:\n        print(\"No solution found\")\n"
  },
  {
    "language": "Python",
    "code": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n"
  },
  {
    "language": "Python",
    "code": "def partitions(N):\n    diffs,k,s = [],1,1\n    while k * (3*k-1) < 2*N:\n        diffs.extend([(2*k - 1, s), (k, s)])\n\tk,s = k+1,-s\n\n    out = [1] + [0]*N\n    for p in range(0, N+1):\n        x = out[p]\n\tfor (o,s) in diffs:\n           p += o\n           if p > N: break\n           out[p] += x*s\n\n    return out\n\np = partitions(12345)\nfor x in [23,123,1234,12345]: print x, p[x]\n"
  },
  {
    "language": "Python",
    "code": "def partitions(n):\n    partitions.p.append(0)\n\n    for k in xrange(1, n + 1):\n        d = n - k * (3 * k - 1) // 2\n        if d < 0:\n            break\n\n        if k & 1:\n            partitions.p[n] += partitions.p[d]\n        else:\n            partitions.p[n] -= partitions.p[d]\n\n        d -= k\n        if d < 0:\n            break\n\n        if k & 1:\n            partitions.p[n] += partitions.p[d]\n        else:\n            partitions.p[n] -= partitions.p[d]\n\n    return partitions.p[-1]\n\npartitions.p = [1]\n\ndef main():\n    ns = set([23, 123, 1234, 12345])\n    max_ns = max(ns)\n\n    for i in xrange(1, max_ns + 1):\n        if i > max_ns:\n            break\n        p = partitions(i)\n        if i in ns:\n            print \"%6d: %s\" % (i, p)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "catchphrase = \"%d bottles of beer on the wall\"\n\nstrofas = (\"\\n\".join((\n    catchphrase % n,\n    catchphrase[:18] % n,\n    \"Take one down and pass it around\",\n    catchphrase % (n-1)\n)) for n in range(99, 0, -1))\n\nprint(\"\\n\\n\".join(strofas))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"Pythonic 99 beer song (maybe the simplest naive implementation in Python 3).\"\"\"\n\n\nREGULAR_VERSE = '''\\\n{n} bottles of beer on the wall, {n} bottles of beer\nTake one down and pass it around, {n_minus_1} bottles of beer on the wall.\n\n'''\n\nENDING_VERSES = '''\\\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\n\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n\n'''\n\n\nfor n in range(99, 2, -1):\n    print(REGULAR_VERSE.format(n=n, n_minus_1=n - 1))\nprint(ENDING_VERSES)\n"
  },
  {
    "language": "Python",
    "code": "'''99 Units of Disposable Asset'''\n\n\nfrom itertools import chain\n\n\n# main :: IO ()\ndef main():\n    '''Modalised asset dispersal procedure.'''\n\n    # localisation :: (String, String, String)\n    localisation = (\n        'on the wall',\n        'Take one down, pass it around',\n        'Better go to the store to buy some more'\n    )\n\n    print(unlines(map(\n        incantation(localisation),\n        enumFromThenTo(99)(98)(0)\n    )))\n\n\n# incantation :: (String, String, String) -> Int -> String\ndef incantation(localisation):\n    '''Versification of asset disposal\n       and inventory update.'''\n\n    location, distribution, solution = localisation\n\n    def inventory(n):\n        return unwords([asset(n), location])\n    return lambda n: solution if 0 == n else (\n        unlines([\n            inventory(n),\n            asset(n),\n            distribution,\n            inventory(pred(n))\n        ])\n    )\n\n\n# asset :: Int -> String\ndef asset(n):\n    '''Quantified asset.'''\n    def suffix(n):\n        return [] if 1 == n else 's'\n    return unwords([\n        str(n),\n        concat(reversed(concat(cons(suffix(n))([\"elttob\"]))))\n    ])\n\n\n# GENERIC -------------------------------------------------\n\n# concat :: [[a]] -> [a]\n# concat :: [String] -> String\ndef concat(xxs):\n    '''The concatenation of all the elements in a list.'''\n    xs = list(chain.from_iterable(xxs))\n    unit = '' if isinstance(xs, str) else []\n    return unit if not xs else (\n        ''.join(xs) if isinstance(xs[0], str) else xs\n    )\n\n\n# cons :: a -> [a] -> [a]\ndef cons(x):\n    '''Construction of a list from x as head,\n       and xs as tail.'''\n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else chain([x], xs)\n\n\n# enumFromThenTo :: Int -> Int -> Int -> [Int]\ndef enumFromThenTo(m):\n    '''Integer values enumerated from m to n\n       with a step defined by nxt-m.'''\n    def go(nxt, n):\n        d = nxt - m\n        return list(range(m, d + n, d))\n    return lambda nxt: lambda n: (\n        go(nxt, n)\n    )\n\n\n# pred ::  Enum a => a -> a\ndef pred(x):\n    '''The predecessor of a value. For numeric types, (- 1).'''\n    return x - 1 if isinstance(x, int) else (\n        chr(ord(x) - 1)\n    )\n\n\n# unlines :: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.'''\n    return '\\n'.join(xs)\n\n\n# unwords :: [String] -> String\ndef unwords(xs):\n    '''A space-separated string derived from\n       a list of words.'''\n    return ' '.join(xs)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\n    99 Bottles of Beer on the Wall made functional\n\n    Main function accepts a number of parameters, so you can specify a name of\n    the drink, its container and other things. English only.\n\"\"\"\n\nfrom functools import partial\nfrom typing import Callable\n\n\ndef regular_plural(noun: str) -> str:\n    \"\"\"English rule to get the plural form of a word\"\"\"\n    if noun[-1] == \"s\":\n        return noun + \"es\"\n\n    return noun + \"s\"\n\n\ndef beer_song(\n    *,\n    location: str = 'on the wall',\n    distribution: str = 'Take one down, pass it around',\n    solution: str = 'Better go to the store to buy some more!',\n    container: str = 'bottle',\n    plurifier: Callable[[str], str] = regular_plural,\n    liquid: str = \"beer\",\n    initial_count: int = 99,\n) -> str:\n    \"\"\"\n    Return the lyrics of the beer song\n    :param location: initial location of the drink\n    :param distribution: specifies the process of its distribution\n    :param solution: what happens when we run out of drinks\n    :param container: bottle/barrel/flask or other containers\n    :param plurifier: function converting a word to its plural form\n    :param liquid: the name of the drink in the given container\n    :param initial_count: how many containers available initially\n    \"\"\"\n\n    verse = partial(\n        get_verse,\n        initial_count = initial_count,\n        location = location,\n        distribution = distribution,\n        solution = solution,\n        container = container,\n        plurifier = plurifier,\n        liquid = liquid,\n    )\n\n    verses = map(verse, range(initial_count, -1, -1))\n    return '\\n\\n'.join(verses)\n\n\ndef get_verse(\n    count: int,\n    *,\n    initial_count: str,\n    location: str,\n    distribution: str,\n    solution: str,\n    container: str,\n    plurifier: Callable[[str], str],\n    liquid: str,\n) -> str:\n    \"\"\"Returns the verse for the given amount of drinks\"\"\"\n\n    asset = partial(\n        get_asset,\n        container = container,\n        plurifier = plurifier,\n        liquid = liquid,\n    )\n\n    current_asset = asset(count)\n    next_number = count - 1 if count else initial_count\n    next_asset = asset(next_number)\n    action = distribution if count else solution\n\n    inventory = partial(\n        get_inventory,\n        location = location,\n    )\n\n    return '\\n'.join((\n        inventory(current_asset),\n        current_asset,\n        action,\n        inventory(next_asset),\n    ))\n\n\ndef get_inventory(\n    asset: str,\n    *,\n    location: str,\n) -> str:\n    \"\"\"\n    Used to return the first or the fourth line of the verse\n\n    >>> get_inventory(\"10 bottles of beer\", location=\"on the wall\")\n    \"10 bottles of beer on the wall\"\n    \"\"\"\n    return ' '.join((asset, location))\n\n\ndef get_asset(\n    count: int,\n    *,\n    container: str,\n    plurifier: Callable[[str], str],\n    liquid: str,\n) -> str:\n    \"\"\"\n    Quantified asset\n\n    >>> get_asset(0, container=\"jar\", plurifier=regular_plural, liquid='milk')\n    \"No more jars of milk\"\n    \"\"\"\n\n    containers = plurifier(container) if count != 1 else container\n    spelled_out_quantity = str(count) if count else \"No more\"\n    return ' '.join((spelled_out_quantity, containers, \"of\", liquid))\n\n\nif __name__ == '__main__':\n    print(beer_song())\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nExcercise of style. An overkill for the task :-D\n\n1. OOP, with abstract class and implementation with much common magic methods\n2. you can customize:\n    a. the initial number\n    b. the name of the item and its plural\n    c. the string to display when there's no more items\n    d. the normal action\n    e. the final action\n    f. the template used, for foreign languages\n3. strofas of the song are created with multiprocessing\n4. when you launch it as a script, you can specify an optional parameter for\n   the number of initial items\n\"\"\"\n\nfrom string import Template\nfrom abc import ABC, abstractmethod\nfrom multiprocessing.pool import Pool as ProcPool\nfrom functools import partial\nimport sys\n\nclass Song(ABC):\n    @abstractmethod\n    def sing(self):\n        \"\"\"\n        it must return the song as a text-like object\n        \"\"\"\n\n        pass\n\nclass MuchItemsSomewhere(Song):\n    eq_attrs = (\n        \"initial_number\",\n        \"zero_items\",\n        \"action1\",\n        \"action2\",\n        \"item\",\n        \"items\",\n        \"strofa_tpl\"\n    )\n\n    hash_attrs = eq_attrs\n    repr_attrs = eq_attrs\n\n    __slots__ = eq_attrs + (\"_repr\", \"_hash\")\n\n    def __init__(\n        self,\n        items = \"bottles of beer\",\n        item = \"bottle of beer\",\n        where = \"on the wall\",\n        initial_number = None,\n        zero_items = \"No more\",\n        action1 = \"Take one down, pass it around\",\n        action2 = \"Go to the store, buy some more\",\n        template = None,\n    ):\n        initial_number_true = 99 if initial_number is None else initial_number\n\n        try:\n            is_initial_number_int = (initial_number_true % 1) == 0\n        except Exception:\n            is_initial_number_int = False\n\n        if not is_initial_number_int:\n            raise ValueError(\"`initial_number` parameter must be None or a int-like object\")\n\n        if initial_number_true < 0:\n            raise ValueError(\"`initial_number` parameter must be >=0\")\n\n\n        true_tpl = template or \"\"\"\\\n$i $items1 $where\n$i $items1\n$action\n$j $items2 $where\"\"\"\n\n        strofa_tpl_tmp = Template(true_tpl)\n        strofa_tpl = Template(strofa_tpl_tmp.safe_substitute(where=where))\n\n        self.zero_items = zero_items\n        self.action1 = action1\n        self.action2 = action2\n        self.initial_number = initial_number_true\n        self.item = item\n        self.items = items\n        self.strofa_tpl = strofa_tpl\n        self._hash = None\n        self._repr = None\n\n    def strofa(self, number):\n        zero_items = self.zero_items\n        item = self.item\n        items = self.items\n\n        if number == 0:\n            i = zero_items\n            action = self.action2\n            j = self.initial_number\n        else:\n            i = number\n            action = self.action1\n            j = i - 1\n\n        if i == 1:\n            items1 = item\n            j = zero_items\n        else:\n            items1 = items\n\n        if j == 1:\n            items2 = item\n        else:\n            items2 = items\n\n        return self.strofa_tpl.substitute(\n            i = i,\n            j = j,\n            action = action,\n            items1 = items1,\n            items2 = items2\n        )\n\n    def sing(self):\n        with ProcPool() as proc_pool:\n            strofa = self.strofa\n            initial_number = self.initial_number\n            args = range(initial_number, -1, -1)\n            return \"\\n\\n\".join(proc_pool.map(strofa, args))\n\n    def __copy__(self, *args, **kwargs):\n        return self\n\n    def __deepcopy__(self, *args, **kwargs):\n        return self\n\n    def __eq__(self, other, *args, **kwargs):\n        if self is other:\n            return True\n\n        getmyattr = partial(getattr, self)\n        getotherattr = partial(getattr, other)\n        eq_attrs = self.eq_attrs\n\n        for attr in eq_attrs:\n            val = getmyattr(attr)\n\n            try:\n                val2 = getotherattr(attr)\n            except Exception:\n                return False\n\n            if attr == \"strofa_tpl\":\n                val_true = val.safe_substitute()\n                val2_true = val.safe_substitute()\n            else:\n                val_true = val\n                val2_true = val\n\n            if val_true != val2_true:\n                return False\n\n        return True\n\n    def __hash__(self, *args, **kwargs):\n        _hash = self._hash\n\n        if _hash is None:\n            getmyattr = partial(getattr, self)\n            attrs = self.hash_attrs\n            hash_true = self._hash = hash(tuple(map(getmyattr, attrs)))\n        else:\n            hash_true = _hash\n\n        return hash_true\n\n    def __repr__(self, *args, **kwargs):\n        _repr = self._repr\n\n        if _repr is None:\n            repr_attrs = self.repr_attrs\n            getmyattr = partial(getattr, self)\n\n            attrs = []\n\n            for attr in repr_attrs:\n                val = getmyattr(attr)\n\n                if attr == \"strofa_tpl\":\n                    val_true = val.safe_substitute()\n                else:\n                    val_true = val\n\n                attrs.append(f\"{attr}={repr(val_true)}\")\n\n            repr_true = self._repr = f\"{self.__class__.__name__}({', '.join(attrs)})\"\n        else:\n            repr_true = _repr\n\n        return repr_true\n\ndef muchBeersOnTheWall(num):\n    song = MuchItemsSomewhere(initial_number=num)\n\n    return song.sing()\n\ndef balladOfProgrammer(num):\n    \"\"\"\n    Prints\n    \"99 Subtle Bugs in Production\"\n    or\n    \"The Ballad of Programmer\"\n    \"\"\"\n\n    song = MuchItemsSomewhere(\n        initial_number = num,\n        items = \"subtle bugs\",\n        item = \"subtle bug\",\n        where = \"in Production\",\n        action1 = \"Debug and catch, commit a patch\",\n        action2 = \"Release the fixes, wait for some tickets\",\n        zero_items = \"Zarro\",\n    )\n\n    return song.sing()\n\ndef main(num):\n    print(f\"### {num} Bottles of Beers on the Wall ###\")\n    print()\n    print(muchBeersOnTheWall(num))\n    print()\n    print()\n    print('### \"The Ballad of Programmer\", by Marco Sulla')\n    print()\n    print(balladOfProgrammer(num))\n\nif __name__ == \"__main__\":\n    # Ok, argparse is **really** too much\n    argv = sys.argv\n\n    if len(argv) == 1:\n        num = None\n    elif len(argv) == 2:\n        try:\n            num = int(argv[1])\n        except Exception:\n            raise ValueError(\n                f\"{__file__} parameter must be an integer, or can be omitted\"\n            )\n    else:\n        raise RuntimeError(f\"{__file__} takes one parameter at max\")\n\n    main(num)\n\n__all__ = (Song.__name__, MuchItemsSomewhere.__name__, muchBeersOnTheWall.__name__, balladOfProgrammer.__name__)\n"
  },
  {
    "language": "Python",
    "code": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfor line in sys.stdin:\n    print(sum(map(int, line.split())))\n"
  },
  {
    "language": "Python",
    "code": "'''\nNote that this code is broken, e.g., it won't work when\nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\",\n                     \"COMMON\", \"squad\", \"Confused\"]))\n"
  },
  {
    "language": "Python",
    "code": "BLOCKS = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\n\ndef _abc(word, blocks):\n    for i, ch in enumerate(word):\n        for blk in (b for b in blocks if ch in b):\n            whatsleft = word[i + 1:]\n            blksleft = blocks[:]\n            blksleft.remove(blk)\n            if not whatsleft:\n                return True, blksleft\n            if not blksleft:\n                return False, blksleft\n            ans, blksleft = _abc(whatsleft, blksleft)\n            if ans:\n                return ans, blksleft\n        else:\n            break\n    return False, blocks\n\ndef abc(word, blocks=BLOCKS):\n    return _abc(word.upper(), blocks)[0]\n\nif __name__ == '__main__':\n    for word in [''] + 'A BARK BoOK TrEAT COmMoN SQUAD conFUsE'.split():\n        print('Can we spell %9r? %r' % (word, abc(word)))\n"
  },
  {
    "language": "Python",
    "code": "def mkword(w, b):\n    if not w: return []\n\n    c,w = w[0],w[1:]\n    for i in range(len(b)):\n        if c in b[i]:\n            m = mkword(w, b[0:i] + b[i+1:])\n            if m != None: return [b[i]] + m\n\ndef abc(w, blk):\n    return mkword(w.upper(), [a.upper() for a in blk])\n\nblocks = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\n\nfor w in \", A, bark, book, treat, common, SQUAD, conFUsEd\".split(', '):\n    print '\\'' + w + '\\'' + ' ->', abc(w, blocks)\n"
  },
  {
    "language": "Python",
    "code": "class BaseQueue(object):\n    \"\"\"Abstract/Virtual Class\n    \"\"\"\n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"
  },
  {
    "language": "Python",
    "code": "from abc import ABCMeta, abstractmethod\n\nclass BaseQueue():\n    \"\"\"Abstract Class\n    \"\"\"\n    __metaclass__ = ABCMeta\n\n    def __init__(self):\n        self.contents = list()\n\n    @abstractmethod\n    def Enqueue(self, item):\n        pass\n\n    @abstractmethod\n    def Dequeue(self):\n        pass\n\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"
  },
  {
    "language": "Python",
    "code": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>>\n>>> rangemax = 20000\n>>>\n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n...\n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n...\n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"
  },
  {
    "language": "Python",
    "code": "'''Abundant, deficient and perfect number classifications'''\n\nfrom itertools import accumulate, chain, groupby, product\nfrom functools import reduce\nfrom math import floor, sqrt\nfrom operator import mul\n\n\n# deficientPerfectAbundantCountsUpTo :: Int -> (Int, Int, Int)\ndef deficientPerfectAbundantCountsUpTo(n):\n    '''Counts of deficient, perfect, and abundant\n       integers in the range [1..n].\n    '''\n    def go(dpa, x):\n        deficient, perfect, abundant = dpa\n        divisorSum = sum(properDivisors(x))\n        return (\n            succ(deficient), perfect, abundant\n        ) if x > divisorSum else (\n            deficient, perfect, succ(abundant)\n        ) if x < divisorSum else (\n            deficient, succ(perfect), abundant\n        )\n    return reduce(go, range(1, 1 + n), (0, 0, 0))\n\n\n# --------------------------TEST--------------------------\n# main :: IO ()\ndef main():\n    '''Size of each sub-class of integers drawn from [1..20000]:'''\n\n    print(main.__doc__)\n    print(\n        '\\n'.join(map(\n            lambda a, b: a.rjust(10) + ' -> ' + str(b),\n            ['Deficient', 'Perfect', 'Abundant'],\n            deficientPerfectAbundantCountsUpTo(20000)\n        ))\n    )\n\n\n# ------------------------GENERIC-------------------------\n\n# primeFactors :: Int -> [Int]\ndef primeFactors(n):\n    '''A list of the prime factors of n.\n    '''\n    def f(qr):\n        r = qr[1]\n        return step(r), 1 + r\n\n    def step(x):\n        return 1 + (x << 2) - ((x >> 1) << 1)\n\n    def go(x):\n        root = floor(sqrt(x))\n\n        def p(qr):\n            q = qr[0]\n            return root < q or 0 == (x % q)\n\n        q = until(p)(f)(\n            (2 if 0 == x % 2 else 3, 1)\n        )[0]\n        return [x] if q > root else [q] + go(x // q)\n\n    return go(n)\n\n\n# properDivisors :: Int -> [Int]\ndef properDivisors(n):\n    '''The ordered divisors of n, excluding n itself.\n    '''\n    def go(a, x):\n        return [a * b for a, b in product(\n            a,\n            accumulate(chain([1], x), mul)\n        )]\n    return sorted(\n        reduce(go, [\n            list(g) for _, g in groupby(primeFactors(n))\n        ], [1])\n    )[:-1] if 1 < n else []\n\n\n# succ :: Int -> Int\ndef succ(x):\n    '''The successor of a value.\n       For numeric types, (1 +).\n    '''\n    return 1 + x\n\n\n# until :: (a -> Bool) -> (a -> a) -> a -> a\ndef until(p):\n    '''The result of repeatedly applying f until p holds.\n       The initial seed value is x.\n    '''\n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# nthArrow :: (a -> b) -> Tuple -> Int -> Tuple\ndef nthArrow(f):\n    '''A simple function lifted to one which applies to a\n       tuple, transforming only its nth value.\n    '''\n    def go(v, n):\n        m = n - 1\n        return v if n > len(v) else [\n            x if m != i else f(x) for i, x in enumerate(v)\n        ]\n    return lambda tpl: lambda n: tuple(go(tpl, n))\n"
  },
  {
    "language": "Python",
    "code": "# deficientPerfectAbundantCountsUpTo :: Int -> (Int, Int, Int)\ndef deficientPerfectAbundantCountsUpTo(n):\n    '''Counts of deficient, perfect, and abundant\n       integers in the range [1..n].\n    '''\n    def go(dpa, x):\n        divisorSum = sum(properDivisors(x))\n        return nthArrow(succ)(dpa)(\n            1 if x > divisorSum else (\n                3 if x < divisorSum else 2\n            )\n        )\n    return reduce(go, range(1, 1 + n), (0, 0, 0))\n"
  },
  {
    "language": "Python",
    "code": ">>> def accumulator(sum):\n  def f(n):\n    f.sum += n\n    return f.sum\n  f.sum = sum\n  return f\n\n>>> x = accumulator(1)\n>>> x(5)\n6\n>>> x(2.3)\n8.3000000000000007\n>>> x = accumulator(1)\n>>> x(5)\n6\n>>> x(2.3)\n8.3000000000000007\n>>> x2 = accumulator(3)\n>>> x2(5)\n8\n>>> x2(3.3)\n11.300000000000001\n>>> x(0)\n8.3000000000000007\n>>> x2(0)\n11.300000000000001\n"
  },
  {
    "language": "Python",
    "code": "def accumulator(sum):\n  def f(n):\n    nonlocal sum\n    sum += n\n    return sum\n  return f\n\nx = accumulator(1)\nx(5)\nprint(accumulator(3))\nprint(x(2.3))\n"
  },
  {
    "language": "Python",
    "code": "def accumulator(sum):\n  while True:\n    sum += yield sum\n\nx = accumulator(1)\nx.send(None)\nx.send(5)\nprint(accumulator(3))\nprint(x.send(2.3))\n"
  },
  {
    "language": "Python",
    "code": "def ack1(M, N):\n   return (N + 1) if M == 0 else (\n      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\n@lru_cache(None)\ndef ack2(M, N):\n    if M == 0:\n        return N + 1\n    elif N == 0:\n        return ack2(M - 1, 1)\n    else:\n        return ack2(M - 1, ack2(M, N - 1))\n"
  },
  {
    "language": "Python",
    "code": ">>> import sys\n>>> sys.setrecursionlimit(3000)\n>>> ack1(0,0)\n1\n>>> ack1(3,4)\n125\n>>> ack2(0,0)\n1\n>>> ack2(3,4)\n125\n"
  },
  {
    "language": "Python",
    "code": "def ack2(M, N):\n   return (N + 1)   if M == 0 else (\n          (N + 2)   if M == 1 else (\n          (2*N + 3) if M == 2 else (\n          (8*(2**N - 1) + 5) if M == 3 else (\n          ack2(M-1, 1) if N == 0 else ack2(M-1, ack2(M, N-1))))))\n"
  },
  {
    "language": "Python",
    "code": "import ldap\n\nl = ldap.initialize(\"ldap://ldap.example.com\")\ntry:\n    l.protocol_version = ldap.VERSION3\n    l.set_option(ldap.OPT_REFERRALS, 0)\n\n    bind = l.simple_bind_s(\"me@example.com\", \"password\")\nfinally:\n    l.unbind()\n"
  },
  {
    "language": "Python",
    "code": "import ldap\n\nl = ldap.initialize(\"ldap://ldap.example.com\")\ntry:\n    l.protocol_version = ldap.VERSION3\n    l.set_option(ldap.OPT_REFERRALS, 0)\n\n    bind = l.simple_bind_s(\"me@example.com\", \"password\")\n\n    base = \"dc=example, dc=com\"\n    criteria = \"(&(objectClass=user)(sAMAccountName=username))\"\n    attributes = ['displayName', 'company']\n    result = l.search_s(base, ldap.SCOPE_SUBTREE, criteria, attributes)\n\n    results = [entry for dn, entry in result if isinstance(entry, dict)]\n    print results\nfinally:\n    l.unbind()\n"
  },
  {
    "language": "Python",
    "code": "from time import time, sleep\nfrom threading import Thread\n\nclass Integrator(Thread):\n    'continuously integrate a function `K`, at each `interval` seconds'\n    def __init__(self, K=lambda t:0, interval=1e-4):\n        Thread.__init__(self)\n        self.interval  = interval\n        self.K   = K\n        self.S   = 0.0\n        self.__run = True\n        self.start()\n\n    def run(self):\n        \"entry point for the thread\"\n        interval = self.interval\n        start = time()\n        t0, k0 = 0, self.K(0)\n        while self.__run:\n            sleep(interval)\n            t1 = time() - start\n            k1 = self.K(t1)\n            self.S += (k1 + k0)*(t1 - t0)/2.0\n            t0, k0 = t1, k1\n\n    def join(self):\n        self.__run = False\n        Thread.join(self)\n\nif __name__ == \"__main__\":\n    from math import sin, pi\n\n    ai = Integrator(lambda t: sin(pi*t))\n    sleep(2)\n    print ai.S\n    ai.K = lambda t: 0\n    sleep(0.5)\n    print ai.S\n"
  },
  {
    "language": "Python",
    "code": "class empty(object):\n    pass\ne = empty()\n"
  },
  {
    "language": "Python",
    "code": "   e.foo = 1\n"
  },
  {
    "language": "Python",
    "code": "   setattr(e, name, value)\n"
  },
  {
    "language": "Python",
    "code": "class empty(object):\n    def __init__(this):\n        this.foo = \"whatever\"\n\ndef patch_empty(obj):\n    def fn(self=obj):\n        print self.foo\n    obj.print_output = fn\n\ne = empty()\npatch_empty(e)\ne.print_output()\n# >>> whatever\n"
  },
  {
    "language": "Python",
    "code": "foo = object()  # Create (instantiate) an empty object\naddress = id(foo)\n"
  },
  {
    "language": "Python",
    "code": "def expand_x_1(n):\n# This version uses a generator and thus less computations\n    c =1\n    for i in range(n//2+1):\n        c = c*(n-i)//(i+1)\n        yield c\n\ndef aks(p):\n    if p==2:\n        return True\n\n    for i in expand_x_1(p):\n        if i % p:\n# we stop without computing all possible solutions\n            return False\n    return True\n"
  },
  {
    "language": "Python",
    "code": "def aks(p):\n    if p==2:return True\n    c=1\n    for i in range(p//2+1):\n        c=c*(p-i)//(i+1)\n        if c%p:return False\n    return True\n"
  },
  {
    "language": "Python",
    "code": "def expand_x_1(p):\n    ex = [1]\n    for i in range(p):\n        ex.append(ex[-1] * -(p-i) / (i+1))\n    return ex[::-1]\n\ndef aks_test(p):\n    if p < 2: return False\n    ex = expand_x_1(p)\n    ex[0] += 1\n    return not any(mult % p for mult in ex[0:-1])\n\n\nprint('# p: (x-1)^p for small p')\nfor p in range(12):\n    print('%3i: %s' % (p, ' '.join('%+i%s' % (e, ('x^%i' % n) if n else '')\n                                   for n,e in enumerate(expand_x_1(p)))))\n\nprint('\\n# small primes using the aks test')\nprint([p for p in range(101) if aks_test(p)])\n"
  },
  {
    "language": "Python",
    "code": "print('''\n{| class=\"wikitable\" style=\"text-align:left;\"\n|+ Polynomial Expansions and AKS prime test\n|-\n! <math>p</math>\n! <math>(x-1)^p</math>\n|-''')\nfor p in range(12):\n    print('! <math>%i</math>\\n| <math>%s</math>\\n| %r\\n|-'\n          % (p,\n             ' '.join('%s%s' % (('%+i' % e) if (e != 1 or not p or (p and not n) ) else '+',\n                                (('x^{%i}' % n) if n > 1 else 'x') if n else '')\n                      for n,e in enumerate(expand_x_1(p))),\n             aks_test(p)))\nprint('|}')\n"
  },
  {
    "language": "Python",
    "code": "from itertools import zip_longest\n\ntxt = \"\"\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\"\"\n\nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col)\n          for col in zip_longest(*parts, fillvalue='')]\n\nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"
  },
  {
    "language": "Python",
    "code": "from StringIO import StringIO\n\ntextinfile = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n\nj2justifier = dict(L=str.ljust, R=str.rjust, C=str.center)\n\ndef aligner(infile, justification = 'L'):\n  ''' \\\n  Justify columns of textual tabular input where the row separator is the newline\n  and the field separator is a 'dollar' character.\n  justification can be L, R, or C; (Left, Right, or Centered).\n\n  Return the justified output as a string\n  '''\n  assert justification in j2justifier, \"justification can be L, R, or C; (Left, Right, or Centered).\"\n  justifier = j2justifier[justification]\n\n  fieldsbyrow= [line.strip().split('$') for line in infile]\n  # pad to same number of fields per row\n  maxfields = max(len(row) for row in fieldsbyrow)\n  fieldsbyrow = [fields + ['']*(maxfields - len(fields))\n                    for fields in fieldsbyrow]\n  # rotate\n  fieldsbycolumn = zip(*fieldsbyrow)\n  # calculate max fieldwidth per column\n  colwidths = [max(len(field) for field in column)\n               for column in fieldsbycolumn]\n  # pad fields in columns to colwidth with spaces\n  fieldsbycolumn = [ [justifier(field, width) for field in column]\n                     for width, column in zip(colwidths, fieldsbycolumn) ]\n  # rotate again\n  fieldsbyrow = zip(*fieldsbycolumn)\n\n  return \"\\n\".join( \" \".join(row) for row in fieldsbyrow)\n\n\nfor align in 'Left Right Center'.split():\n  infile = StringIO(textinfile)\n  print \"\\n# %s Column-aligned output:\" % align\n  print aligner(infile, align[0])\n"
  },
  {
    "language": "Python",
    "code": "'''\ncat <<'EOF' > align_columns.dat\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEOF\n'''\n\nfor align in '<^>':\n  rows = [ line.strip().split('$') for line in open('align_columns.dat') ]\n  fmts = [ '{:%s%d}' % (align, max( len(row[i]) if i < len(row) else 0 for row in rows ))\n           for i in range(max(map(len, rows))) ]\n  for row in rows:\n    print(' '.join(fmts).format(*(row + [''] * len(fmts))))\n  print('')\n"
  },
  {
    "language": "Python",
    "code": "txt = \"\"\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\"\"\n\nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\n\nmax_widths = {}\nfor line in parts:\n    for i, word in enumerate(line):\n        max_widths[i] = max(max_widths.get(i, 0), len(word))\n\nfor i, justify in enumerate([str.ljust, str.center, str.rjust]):\n    print([\"Left\", \"Center\", \"Right\"][i], \" column-aligned output:\\n\")\n    for line in parts:\n        for j, word in enumerate(line):\n            print(justify(word, max_widths[j]), end=' ')\n        print()\n    print(\"- \" * 52)\n"
  },
  {
    "language": "Python",
    "code": "'''Variously aligned columns\n   from delimited text.\n'''\n\nfrom functools import reduce\nfrom itertools import repeat\n\n\n# TEST ----------------------------------------------------\n# main :: IO ()\ndef main():\n    '''Test of three alignments.'''\n\n    txt = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n\n    rows = [x.split('$') for x in txt.splitlines()]\n    table = paddedRows(max(map(len, rows)))('')(rows)\n\n    print('\\n\\n'.join(map(\n        alignedTable(table)('  '),\n        [-1, 0, 1]  # Left, Center, Right\n    )))\n\n\n# alignedTable :: [[String]] -> Alignment -> String -> String\ndef alignedTable(rows):\n    '''Tabulation of rows of cells, with cell alignment\n       specified by:\n           eAlign -1 = left\n           eAlign  0 = center\n           eAlign  1 = right\n       and separator between columns\n       supplied by the `sep` argument.\n    '''\n    def go(sep, eAlign):\n        lcr = ['ljust', 'center', 'rjust'][1 + eAlign]\n\n        # nextAlignedCol :: [[String]] -> [String] -> [[String]]\n        def nextAlignedCol(cols, col):\n            w = max(len(cell) for cell in col)\n            return cols + [\n                [getattr(s, lcr)(w, ' ') for s in col]\n            ]\n\n        return '\\n'.join([\n            sep.join(cells) for cells in\n            zip(*reduce(nextAlignedCol, zip(*rows), []))\n        ])\n    return lambda sep: lambda eAlign: go(sep, eAlign)\n\n\n# GENERIC -------------------------------------------------\n\n# paddedRows :: Int -> a -> [[a]] -> [[a]]\ndef paddedRows(n):\n    '''A list of rows of even length,\n       in which each may be padded (but\n       not truncated) to length n with\n       appended copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return [pad(row) for row in xs]\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n):\n    return sum(proper_divs(n))\n\n\ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n\nif __name__ == '__main__':\n    for n in range(1, 11):\n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]:\n        print('%s: %r' % aliquot(n))\n"
  },
  {
    "language": "Python",
    "code": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry:\n    from functools import reduce\nexcept:\n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"
  },
  {
    "language": "Python",
    "code": "# k-Almost-primes\n# Python 3.6.3\n# no imports\n\ndef prime_factors(m=2):\n\n    for i in range(2, m):\n        r, q = divmod(m, i)\n        if not q:\n            return [i] + prime_factors(r)\n    return [m]\n\ndef k_almost_primes(n, k=2):\n    multiples = set()\n    lists = list()\n    for x in range(k+1):\n        lists.append([])\n\n    for i in range(2, n+1):\n        if i not in multiples:\n            if len(lists[1]) < 10:\n                lists[1].append(i)\n            multiples.update(range(i*i, n+1, i))\n    print(\"k=1: {}\".format(lists[1]))\n\n    for j in range(2, k+1):\n        for m in multiples:\n            l = prime_factors(m)\n            ll = len(l)\n            if ll == j and len(lists[j]) < 10:\n                lists[j].append(m)\n\n        print(\"k={}: {}\".format(j, lists[j]))\n\nk_almost_primes(200, 5)\n# try:\n#k_almost_primes(6000, 10)\n"
  },
  {
    "language": "Python",
    "code": "import itertools as _itertools\n\nclass Amb(object):\n    def __init__(self):\n        self._names2values   = {}       # set of values for each global name\n        self._func           = None     # Boolean constraint function\n        self._valueiterator  = None     # itertools.product of names values\n        self._funcargnames   = None     # Constraint parameter names\n\n    def __call__(self, arg=None):\n        if hasattr(arg, '__code__'):\n            ##\n            ## Called with a constraint function.\n            ##\n            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals\n            # Names used in constraint\n            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]\n            for name in argv:\n                if name not in self._names2values:\n                    assert name in globls, \\\n                           \"Global name %s not found in function globals\" % name\n                    self._names2values[name] = globls[name]\n            # Gather the range of values of all names used in the constraint\n            valuesets = [self._names2values[name] for name in argv]\n            self._valueiterator = _itertools.product(*valuesets)\n            self._func = arg\n            self._funcargnames = argv\n            return self\n        elif arg is not None:\n            ##\n            ## Assume called with an iterable set of values\n            ##\n            arg = frozenset(arg)\n            return arg\n        else:\n            ##\n            ## blank call tries to return next solution\n            ##\n            return self._nextinsearch()\n\n    def _nextinsearch(self):\n        arg = self._func\n        globls = arg.__globals__\n        argv = self._funcargnames\n        found = False\n        for values in self._valueiterator:\n            if arg(*values):\n                # Set globals.\n                found = True\n                for n, v in zip(argv, values):\n                    globls[n] = v\n                break\n        if not found: raise StopIteration\n        return values\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return self()\n    next = __next__ # Python 2\n\nif __name__ == '__main__':\n    if True:\n        amb = Amb()\n\n        print(\"\\nSmall Pythagorean triples problem:\")\n        x = amb(range(1,11))\n        y = amb(range(1,11))\n        z = amb(range(1,11))\n\n        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):\n            print ('%s %s %s' % (x, y, z))\n\n\n    if True:\n        amb = Amb()\n\n        print(\"\\nRosetta Code Amb problem:\")\n        w1 = amb([\"the\", \"that\", \"a\"])\n        w2 = amb([\"frog\", \"elephant\", \"thing\"])\n        w3 = amb([\"walked\", \"treaded\", \"grows\"])\n        w4 = amb([\"slowly\", \"quickly\"])\n\n        for _dummy in amb( lambda w1, w2, w3, w4: \\\n                             w1[-1] == w2[0] and \\\n                             w2[-1] == w3[0] and \\\n                             w3[-1] == w4[0] ):\n            print ('%s %s %s %s' % (w1, w2, w3, w4))\n\n    if True:\n        amb = Amb()\n\n        print(\"\\nAmb problem from \"\n            \"http://www.randomhacks.net/articles/2005/10/11/amb-operator:\")\n        x = amb([1, 2, 3])\n        y = amb([4, 5, 6])\n\n        for _dummy in amb( lambda x, y: x * y != 8 ):\n            print ('%s %s' % (x, y))\n"
  },
  {
    "language": "Python",
    "code": "# joins :: String -> String -> Bool\ndef joins(a, b):\n    return a[-1] == b[0]\n\n\nprint (\n    [\n        ' '.join([w1, w2, w3, w4])\n        for w1 in ['the', 'that', 'a']\n        for w2 in ['frog', 'elephant', 'thing']\n        for w3 in ['walked', 'treaded', 'grows']\n        for w4 in ['slowly', 'quickly']\n        if joins(w1, w2) and joins(w2, w3) and joins(w3, w4)\n    ]\n)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    print (\n        unlines([\n            unwords([w1, w2, w3, w4])\n\n            for w1 in ['the', 'that', 'a']\n            if True\n\n            for w2 in ['frog', 'elephant', 'thing']\n            if joins(w1, w2)\n\n            for w3 in ['walked', 'treaded', 'grows']\n            if joins(w2, w3)\n\n            for w4 in ['slowly', 'quickly']\n            if joins(w3, w4)\n        ])\n    )\n\n\n# joins :: String -> String -> Bool\ndef joins(a, b):\n    return a[-1] == b[0]\n\n\n# unlines :: [String] -> String\ndef unlines(xs):\n    return '\\n'.join(xs)\n\n\n# unwords :: [String] -> String\ndef unwords(xs):\n    return ' '.join(xs)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import chain\n\n\n# amb :: [a] -> (a -> [b]) -> [b]\ndef amb(xs):\n    return lambda f: list(\n        chain.from_iterable(\n            map(f, xs)\n        )\n    )\n\n\n# main :: IO ()\ndef main():\n\n    xs = enumFromTo(1)(10)\n    print ('Pythagorean triples from integers 1-10:')\n    print (\n        amb(xs)(\n            lambda x: amb(xs)\n            (lambda y: amb(xs)\n                (lambda z: when(\n                    x * x + y * y == z * z\n                )(\n                    (x, y, z)\n                )\n            ))\n        )\n    )\n\n    # joins :: String -> String -> Bool\n    def joins(a, b):\n        return a[-1] == b[0]\n\n    print ('\\nRC problem given above:')\n    print (\n        amb(['the', 'that', 'a'])(\n            lambda w1: amb(\n                ['frog', 'elephant', 'thing']\n            )(lambda w2: amb(\n                ['walked', 'treaded', 'grows']\n            )(lambda w3: amb(\n                ['slowly', 'quickly']\n            )(lambda w4: when(\n                joins(w1, w2) and joins(w2, w3) and joins(w3, w4)\n            )(\n                (w1, w2, w3, w4)\n            ))))\n        )\n    )\n    print('\\nAdditional problem reference in procedural version above:')\n    print(\n        amb([1, 2, 3])\n        (\n            lambda x: amb([4, 5, 6])\n            (\n                lambda y: when(x * y != 8)\n                (\n                    (x, y)\n                )\n            )\n        )\n    )\n\n# GENERIC -------------------------------------------------\n\n\n# enumFromTo :: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    return lambda n: list(range(m, 1 + n))\n\n\n# when :: Bool -> [a] -> [a]\ndef when(p):\n    return lambda x: [x] if p else []\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import chain\n\n\n# amb :: [a] -> (a -> [b]) -> [b]\ndef amb(xs):\n    return lambda f: list(\n        chain.from_iterable(\n            map(f, xs)\n        )\n    )\n\n\n# when :: Bool -> [a] -> [a]\ndef when(p):\n    return lambda xs: xs if p else []\n\n\n# TEST ----------------------------------------------------\n\n# joins :: String -> String -> Bool\ndef joins(a, b):\n    return a[-1] == b[0]\n\n\nprint (\n    amb(['the', 'that', 'a'])(\n        lambda w1: when(True)\n\n        (amb(['frog', 'elephant', 'thing'])\n         (lambda w2: when(joins(w1, w2))\n\n          (amb(['walked', 'treaded', 'grows'])\n           (lambda w3: when(joins(w2, w3))\n\n            (amb(['slowly', 'quickly'])\n             (lambda w4: when(joins(w3, w4))(\n\n                 [w1, w2, w3, w4]\n             ))))))\n         )\n    )\n)\n"
  },
  {
    "language": "Python",
    "code": "from proper_divisors import proper_divs\n\ndef amicable(rangemax=20000):\n    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}\n    for num, divsum in n2divsum.items():\n        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:\n            yield num, divsum\n\nif __name__ == '__main__':\n    for num, divsum in amicable():\n        print('Amicable pair: %i and %i With proper divisors:\\n    %r\\n    %r'\n              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))\n"
  },
  {
    "language": "Python",
    "code": "'''Amicable pairs'''\n\nfrom itertools import chain\nfrom math import sqrt\n\n\n# amicablePairsUpTo :: Int -> [(Int, Int)]\ndef amicablePairsUpTo(n):\n    '''List of all amicable pairs\n       of integers below n.\n    '''\n    sigma = compose(sum)(properDivisors)\n\n    def amicable(x):\n        y = sigma(x)\n        return [(x, y)] if (x < y and x == sigma(y)) else []\n\n    return concatMap(amicable)(\n        enumFromTo(1)(n)\n    )\n\n\n# TEST ----------------------------------------------------\n# main :: IO ()\ndef main():\n    '''Amicable pairs of integers up to 20000'''\n\n    for x in amicablePairsUpTo(20000):\n        print(x)\n\n\n# GENERIC -------------------------------------------------\n\n# compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# concatMap :: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    '''A concatenated list or string over which a function f\n       has been mapped.\n       The list monad can be derived by using an (a -> [b])\n       function which wraps its output in a list (using an\n       empty list to represent computational failure).\n    '''\n    return lambda xs: (''.join if isinstance(xs, str) else list)(\n        chain.from_iterable(map(f, xs))\n    )\n\n\n# enumFromTo :: Int -> Int -> [Int]\ndef enumFromTo(m):\n    '''Enumeration of integer values [m..n]'''\n    def go(n):\n        return list(range(m, 1 + n))\n    return lambda n: go(n)\n\n\n# properDivisors :: Int -> [Int]\ndef properDivisors(n):\n    '''Positive divisors of n, excluding n itself'''\n    root_ = sqrt(n)\n    intRoot = int(root_)\n    blnSqr = root_ == intRoot\n    lows = [x for x in range(1, 1 + intRoot) if 0 == n % x]\n    return lows + [\n        n // x for x in reversed(\n            lows[1:-1] if blnSqr else lows[1:]\n        )\n    ]\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": ">>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])\n"
  },
  {
    "language": "Python",
    "code": ">>> import urllib\n>>> from collections import defaultdict\n>>> words = urllib.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.itervalues())\n>>> for ana in anagram.itervalues():\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['evil', 'levi', 'live', 'veil', 'vile']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['abel', 'able', 'bale', 'bela', 'elba']\n>>> count\n5\n>>>\n"
  },
  {
    "language": "Python",
    "code": ">>> import urllib, itertools\n>>> words = urllib.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagrams = [list(g) for k,g in itertools.groupby(sorted(words, key=sorted), key=sorted)]\n\n\n>>> count = max(len(ana) for ana in anagrams)\n>>> for ana in anagrams:\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['abel', 'able', 'bale', 'bela', 'elba']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['evil', 'levi', 'live', 'veil', 'vile']\n>>> count\n5\n>>>\n"
  },
  {
    "language": "Python",
    "code": "'''Largest anagram groups found in list of words.'''\n\nfrom os.path import expanduser\nfrom itertools import groupby\nfrom operator import eq\n\n\n# main :: IO ()\ndef main():\n    '''Largest anagram groups in local unixdict.txt'''\n\n    print(unlines(\n        largestAnagramGroups(\n            lines(readFile('unixdict.txt'))\n        )\n    ))\n\n\n# largestAnagramGroups :: [String] -> [[String]]\ndef largestAnagramGroups(ws):\n    '''A list of the anagram groups of\n       of the largest size found in a\n       given list of words.\n    '''\n\n    # wordChars :: String -> (String, String)\n    def wordChars(w):\n        '''A word paired with its\n           AZ sorted characters\n        '''\n        return (''.join(sorted(w)), w)\n\n    groups = list(map(\n        compose(list)(snd),\n        groupby(\n            sorted(\n                map(wordChars, ws),\n                key=fst\n            ),\n            key=fst\n        )\n    ))\n\n    intMax = max(map(len, groups))\n    return list(map(\n        compose(unwords)(curry(map)(snd)),\n        filter(compose(curry(eq)(intMax))(len), groups)\n    ))\n\n\n# GENERIC -------------------------------------------------\n\n# compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# curry :: ((a, b) -> c) -> a -> b -> c\ndef curry(f):\n    '''A curried function derived\n       from an uncurried function.'''\n    return lambda a: lambda b: f(a, b)\n\n\n# fst :: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# lines :: String -> [String]\ndef lines(s):\n    '''A list of strings,\n       (containing no newline characters)\n       derived from a single new-line delimited string.'''\n    return s.splitlines()\n\n\n# from os.path import expanduser\n# readFile :: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# snd :: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# unlines :: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.'''\n    return '\\n'.join(xs)\n\n\n# unwords :: [String] -> String\ndef unwords(xs):\n    '''A space-separated string derived from\n       a list of words.'''\n    return ' '.join(xs)\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import urllib.request\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\n\ndef find_anagrams(words):\n    anagram = defaultdict(list) # map sorted chars to anagrams\n    for word in words:\n        anagram[tuple(sorted(word))].append( word )\n    return dict((key, words) for key, words in anagram.items()\n                if len(words) > 1)\n\ndef is_deranged(words):\n    'returns pairs of words that have no character in the same position'\n    return [ (word1, word2)\n             for word1,word2 in combinations(words, 2)\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\n\ndef largest_deranged_ana(anagrams):\n    ordered_anagrams = sorted(anagrams.items(),\n                              key=lambda x:(-len(x[0]), x[0]))\n    for _, words in ordered_anagrams:\n        deranged_pairs = is_deranged(words)\n        if deranged_pairs:\n            return deranged_pairs\n    return []\n\nif __name__ == '__main__':\n    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')\n    print(\"Word count:\", len(words))\n\n    anagrams = find_anagrams(words)\n    print(\"Anagram count:\", len(anagrams),\"\\n\")\n\n    print(\"Longest anagrams with no characters in the same position:\")\n    print('  ' + '\\n  '.join(', '.join(pairs)\n                             for pairs in largest_deranged_ana(anagrams)))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom itertools import combinations\nfrom pathlib import Path\nfrom typing import (Callable,\n                    Dict,\n                    Iterable,\n                    Iterator,\n                    List,\n                    Optional,\n                    Tuple,\n                    TypeVar)\n\nWORDS_FILE = 'unixdict.txt'\n\nT1 = TypeVar('T1')\nT2 = TypeVar('T2')\n\n\ndef main():\n    words = read_words(Path(WORDS_FILE))\n    anagram = longest_deranged_anagram(words)\n    if anagram:\n        print('The longest deranged anagram is: {}, {}'.format(*anagram))\n    else:\n        print('No deranged anagrams were found')\n\n\ndef read_words(path: Path) -> Iterator[str]:\n    \"\"\"Yields words from file at specified path\"\"\"\n    with path.open() as file:\n        for word in file:\n            yield word.strip()\n\n\ndef longest_deranged_anagram(words: Iterable[str]\n                             ) -> Optional[Tuple[str, str]]:\n    \"\"\"\n    Returns the longest pair of words\n    that have no character in the same position\n    \"\"\"\n    words_by_lengths = mapping_by_function(len, words)\n    decreasing_lengths = sorted(words_by_lengths, reverse=True)\n    for length in decreasing_lengths:\n        words = words_by_lengths[length]\n        anagrams_by_letters = mapping_by_function(sort_str, words)\n        for anagrams in anagrams_by_letters.values():\n            deranged_pair = next(deranged_word_pairs(anagrams), None)\n            if deranged_pair is not None:\n                return deranged_pair\n    return None\n\n\ndef mapping_by_function(function: Callable[..., T2],\n                        iterable: Iterable[T1]) -> Dict[T2, List[T1]]:\n    \"\"\"\n    Constructs a dictionary with keys\n    obtained from applying an input function\n    to items of an iterable,\n    and the values filled from the same iterable\n    \"\"\"\n    mapping = defaultdict(list)\n    for item in iterable:\n        mapping[function(item)].append(item)\n    return mapping\n\n\ndef sort_str(string: str) -> str:\n    \"\"\"Sorts input string alphabetically\"\"\"\n    return ''.join(sorted(string))\n\n\ndef deranged_word_pairs(words: Iterable[str]) -> Iterator[Tuple[str, str]]:\n    \"\"\"Yields deranged words from an input list of words\"\"\"\n    pairs = combinations(words, 2)  # type: Iterator[Tuple[str, str]]\n    yield from filter(is_deranged, pairs)\n\n\ndef is_deranged(word_pair: Tuple[str, str]) -> bool:\n    \"\"\"\n    Checks if all corresponding letters are different,\n    assuming that words have the same length\n    \"\"\"\n    return all(a != b for a, b in zip(*word_pair))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)),\n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\n\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\n\nclass Marquee(QLabel):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText(\"Hello World! \")\n        self.setFont(QFont(None, 50, QFont.Bold))\n        # make more irritating for the authenticity with <marquee> element\n        self.setStyleSheet(\"QLabel {color: cyan; }\")\n\n    def timerEvent(self, event):\n        i = 1 if self.right_to_left_direction else -1\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\n\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\n        self.right_to_left_direction = not self.right_to_left_direction\n\n    def keyPressEvent(self, event):  # exit on Esc\n        if event.key() == Qt.Key_Escape:\n            self.close()\n\n\napp = QApplication(sys.argv)\nw = Marquee()\n# center widget on the screen\nw.adjustSize()  # update w.rect() now\nw.move(QApplication.instance().desktop().screen().rect().center()\n       - w.rect().center())\nw.show()\nsys.exit(app.exec())\n"
  },
  {
    "language": "Python",
    "code": "import pygame, sys\nfrom pygame.locals import *\npygame.init()\n\nYSIZE = 40\nXSIZE = 150\n\nTEXT = \"Hello World! \"\nFONTSIZE = 32\n\nLEFT = False\nRIGHT = True\n\nDIR = RIGHT\n\nTIMETICK = 180\nTICK = USEREVENT + 2\n\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\n\npygame.time.set_timer(TICK, TIMETICK)\n\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption(\"Animation\")\n\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = DIR and -1 or 1\n    global TEXT\n    TEXT = TEXT[index:]+TEXT[:index]\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = not DIR\n\ndef draw():\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n\ndef input(event):\n    if event.type == QUIT:\n        sys.exit(0)\n    elif event.type == MOUSEBUTTONDOWN:\n        click(event.pos)\n    elif event.type == TICK:\n        draw()\n        rotate()\n\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\n"
  },
  {
    "language": "Python",
    "code": "import Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n"
  },
  {
    "language": "Python",
    "code": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"
  },
  {
    "language": "Python",
    "code": ">>>from functools import partial\n>>> Y = lambda f: (lambda x: x(x))(lambda y: partial(f, lambda *args: y(y)(*args)))\n>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"
  },
  {
    "language": "Python",
    "code": ">>> from functools import partial\n>>> Y = lambda f: partial(f, f)\n>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(f, n-1) + f(f, n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"
  },
  {
    "language": "Ruby",
    "code": "doors = Array.new(101,0)\nprint \"Open doors \"\n(1..100).step(){ |i|\n(i..100).step(i) { |d|\n    doors[d] = doors[d]^= 1\n    if i == d and doors[d] == 1 then\n      print \"#{i} \"\n    end\n  }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class Door\n  attr_reader :state\n\n  def initialize\n    @state = :closed\n  end\n\n  def close\n    @state = :closed\n  end\n\n  def open\n    @state = :open\n  end\n\n  def closed?\n    @state == :closed\n  end\n\n  def open?\n    @state == :open\n  end\n\n  def toggle\n    if closed? then open else close end\n  end\n\n  def to_s\n    @state.to_s\n  end\nend\n\ndoors = Array.new(100) { Door.new }\n1.upto(100) do |multiplier|\n  doors.each_with_index do |door, i|\n    door.toggle if (i + 1) % multiplier == 0\n  end\nend\n\ndoors.each_with_index { |door, i| puts \"Door #{i+1} is #{door}.\" }\n"
  },
  {
    "language": "Ruby",
    "code": "n = 100\nOpen = \"open\"\nClosed = \"closed\"\ndef Open.toggle\n  Closed\nend\ndef Closed.toggle\n  Open\nend\ndoors = [Closed] * (n + 1)\nfor mul in 1..n\n  for x in (mul..n).step(mul)\n    doors[x] = doors[x].toggle\n  end\nend\ndoors.each_with_index do |b, i|\n  puts \"Door #{i} is #{b}\" if i > 0\nend\n"
  },
  {
    "language": "Ruby",
    "code": "n = 100\n(1..n).each do |i|\n  puts \"Door #{i} is #{i**0.5 == (i**0.5).round ? \"open\" : \"closed\"}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "doors = [false] * 100\n100.times do |i|\n  (i ... doors.length).step(i + 1) do |j|\n    doors[j] = !doors[j]\n  end\nend\nputs doors.map.with_index(1){|d,i| \"Door #{i} is #{d ? 'open' : 'closed'}.\"}\n"
  },
  {
    "language": "Ruby",
    "code": "class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n\n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n\n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      # evaluate using rational arithmetic\n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 # catch division by zero\n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n# validate user input\ndigits = ARGV.map do |arg|\n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '#{arg}'\"\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have #{digits.size}\"\n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found #{solutions.size} solutions, including #{solutions.first}\"\n  puts solutions.sort\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives #{result}!\"\n    end\n    puts \"You win!\"\n  end\n\n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using #{nums}: \"\n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n\n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n\n    error ? puts(\"Invalid input of a(n) #{name.to_s.tr('_',' ')}!\") : true\n  end\n\n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        # r : Rational suffix\n    eval \"(#{as_rat}).to_f\"\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n"
  },
  {
    "language": "Ruby",
    "code": "# Generate IPF triangle\n# Nigel_Galloway: May 1st., 2013.\ndef g(n,g)\n  return 1 unless 1 < g and g < n-1\n  (2..g).inject(1){|res,q| res + (q > n-g ? 0 : g(n-g,q))}\nend\n\n(1..25).each {|n|\n  puts (1..n).map {|g| \"%4s\" % g(n,g)}.join\n}\n"
  },
  {
    "language": "Ruby",
    "code": "# Find large values of IPF\n# Nigel_Galloway: May 1st., 2013.\nN = 12345\n@ng = []\n@ipn1 = []\n@ipn2 = []\ndef g(n,g)\n  t = n-g-2\n  return 1 if n<4 or t<0\n  return @ng[g-2][n-4] unless n/2<g\n  return @ipn1[t]\nend\n@ng[0] = []\n(4..N).each {|q| @ng[0][q-4] = 1 + g(q-2,2)}\n@ipn1[0] = @ng[0][0]\n@ipn2[0] = @ng[0][N-4]\n(1...(N/2-1)).each {|n|\n  @ng[n] = []\n  (n*2+4..N).each {|q| @ng[n][q-4] = g(q-1,n+1) + g(q-n-2,n+2)}\n  @ipn1[n] = @ng[n][n*2]\n  @ipn2[n] = @ng[n][N-4]\n  @ng[n-1] = nil\n}\n@ipn2.pop if N.even?\n\nputs \"G(23) = #{@ipn1[21]}\"\nputs \"G(123) = #{@ipn1[121]}\"\nputs \"G(1234) = #{@ipn1[1232]}\"\nn = 3 + @ipn1.inject(:+) + @ipn2.inject(:+)\nputs \"G(12345) = #{n}\"\n"
  },
  {
    "language": "Ruby",
    "code": "plural = 's'\n99.downto(1) do |i|\n  puts \"#{i} bottle#{plural} of beer on the wall,\"\n  puts \"#{i} bottle#{plural} of beer\"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"#{i-1} bottle#{plural} of beer on the wall!\"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "trace_var :$bottle_num do |val|\n  $bottles = %Q{#{val == 0 ? 'No more' : val.to_s} bottle#{val == 1 ? '' : 's'}}\nend\n\n($bottle_num = 99).times do\n  puts \"#{$bottles} of beer on the wall\"\n  puts \"#{$bottles} of beer\"\n  puts \"Take one down, pass it around\"\n  $bottle_num -= 1\n  puts \"#{$bottles} of beer on the wall\"\n  puts \"\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def bottles(of_beer, ending)\n  puts \"#{of_beer} bottle#{ending} of beer on the wall,\"\n  puts \"#{of_beer} bottle#{ending} of beer\"\n  puts \"Take one down, pass it around!\"\nend\n\n99.downto(0) do |left|\n  if left > 1\n    bottles(left, \"s\")\n  elsif left == 1\n    bottles(left, \"\")\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def bottles(beer, wall = false)\n  \"#{beer>0 ? beer : \"no more\"} bottle#{\"s\" if beer!=1} of beer#{\" on the wall\" if wall}\"\nend\n\n99.downto(0) do |remaining|\n  puts \"#{bottles(remaining,true).capitalize}, #{bottles(remaining)}.\"\n  if remaining==0\n    print \"Go to the store and buy some more\"\n    remaining=100\n  else\n    print \"Take one down, pass it around\"\n  end\n  puts \", #{bottles(remaining-1,true)}.\\n\\n\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "99.downto(1) do |bottles|\n  puts \"#{bottles} bottle#{\"s\" if bottles != 1} of beer on the wall.\",\n       \"#{bottles} bottle#{\"s\" if bottles != 1} of beer.\",\n       \"Take one down, pass it around.\",\n       \"#{bottles - 1} bottle#{\"s\" if bottles - 1 != 1} of beer on the wall.\\n\\n\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "puts gets.split.sum(&:to_i)\n"
  },
  {
    "language": "Ruby",
    "code": "words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?#{c}\\w?/i, \"\")}  #regexps can be interpolated like strings\n  puts \"#{word.inspect}: #{res}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'abstraction'\n\nclass AbstractQueue\n  abstract\n  def enqueue(object)\n    raise NotImplementedError\n  end\n  def dequeue\n    raise NotImplementedError\n  end\nend\n\nclass ConcreteQueue < AbstractQueue\n  def enqueue(object)\n    puts \"enqueue #{object.inspect}\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "res = Hash.new(0)\n(1 .. 20_000).each{|n| res[n.proper_divisors.sum <=> n] += 1}\nputs \"Deficient: #{res[-1]}   Perfect: #{res[0]}   Abundant: #{res[1]}\"\n"
  },
  {
    "language": "Ruby",
    "code": "def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n# mixing Integer and Float\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  # prints 8.3\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rational'\nrequire 'complex'\ny = accumulator(Rational(2, 3))\nputs y[Rational(1, 2)]  # 7/6\nputs y[4]               # 31/6\nputs y[Complex(0, 1)]   # 31/6+1i\n\nt = accumulator(Time.utc(1999, 8, 7, 6, 5))\n                       # (Ruby 1.8.6)                  (Ruby 1.9.2)\nputs t[4]              # Sat Aug 07 06:05:04 UTC 1999  1999-08-07 06:05:04 UTC\nputs t[-12 * 60 * 60]  # Fri Aug 06 18:05:04 UTC 1999  1999-08-06 18:05:04 UTC\n\nrequire 'matrix'\nm = accumulator(Matrix[[1, 2], [3, 4]])\nputs m[Matrix[[5, 6], [7, 8]]]  # Matrix[[6, 8], [10, 12]]\n"
  },
  {
    "language": "Ruby",
    "code": "def accumulator(sum)\n  lambda {|n| sum += n}\nend\nclass << self\n  define_method :x, &accumulator(1)\nend\nx(5)\naccumulator(3)\nputs x(2.3)  # prints 8.3\n"
  },
  {
    "language": "Ruby",
    "code": "def ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rubygems'\nrequire 'net/ldap'\nldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')\nldap.authenticate('bind_dn', 'bind_pass')\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rubygems'\nrequire 'net/ldap'\n\nldap = Net::LDAP.new(:host => 'hostname', :base => 'base')\nldap.authenticate('bind_dn', 'bind_pass')\n\nfilter = Net::LDAP::Filter.pres('objectclass')\nfilter &= Net::LDAP::Filter.eq('sn','Jackman')\n# or\nfilter = Net::LDAP::Filter.construct('(&(objectclass=*)(sn=Jackman))')\n\nresults = ldap.search(:filter => filter)  # returns an array of Net::LDAP::Entry objects\n\nputs results[0][:sn]  # ==> \"Jackman\"\n"
  },
  {
    "language": "Ruby",
    "code": "class Empty\nend\n\ne = Empty.new\nclass << e\n  attr_accessor :foo\nend\ne.foo = 1\nputs e.foo  # output: \"1\"\n\nf = Empty.new\nf.foo = 1   # raises NoMethodError\n"
  },
  {
    "language": "Ruby",
    "code": "yes_no = \"Yes\"\n\ndef yes_no.not\n  replace( self==\"Yes\" ? \"No\": \"Yes\")\nend\n\n#Demo:\np yes_no.not # => \"No\"\np yes_no.not # => \"Yes\"\np \"aaa\".not  # => undefined method `not' for \"aaa\":String (NoMethodError)\n"
  },
  {
    "language": "Ruby",
    "code": ">foo = Object.new  # => #<Object:0x10ae32000>\n>id = foo.object_id  # => 2238812160\n>\"%x\" % (id << 1)  # => \"10ae32000\"\n"
  },
  {
    "language": "Ruby",
    "code": "require 'polynomial'\n\ndef x_minus_1_to_the(p)\n  return Polynomial.new(-1,1)**p\nend\n\ndef prime?(p)\n  return false if p < 2\n  (x_minus_1_to_the(p) - Polynomial.from_string(\"x**#{p}-1\")).coefs.all?{|n| n%p==0}\nend\n\n8.times do |n|\n  # the default Polynomial#to_s would be OK here; the substitutions just make the\n  # output match the other version below.\n  puts \"(x-1)^#{n} = #{x_minus_1_to_the(n).to_s.gsub(/\\*\\*/,'^').gsub(/\\*/,'')}\"\nend\n\nputs \"\\nPrimes below 50:\", 50.times.select {|n| prime? n}.join(',')\n"
  },
  {
    "language": "Ruby",
    "code": "def x_minus_1_to_the(p)\n  p.times.inject([1]) do |ex, _|\n    ([0] + ex).zip(ex + [0]).map { |x,y| x - y }\n  end\nend\n\ndef prime?(p)\n  return false if p < 2\n  coeff = x_minus_1_to_the(p)[1..p/2] # only need half of coeff terms\n  coeff.all?{ |n| n%p == 0 }\nend\n\n8.times do |n|\n  puts \"(x-1)^#{n} = \" +\n  x_minus_1_to_the(n).map.with_index { |c, p|\n    p.zero? ? c.to_s :\n      (c < 0 ? \" - \" : \" + \") + (c.abs == 1 ? \"x\" : \"#{c.abs}x\") + (p == 1 ? \"\" : \"^#{p}\")\n  }.join\nend\n\nputs \"\\nPrimes below 50:\", 50.times.select {|n| prime? n}.join(',')\n"
  },
  {
    "language": "Ruby",
    "code": "J2justifier = {Left: :ljust, Right: :rjust, Center: :center}\n\n=begin\nJustify columns of textual tabular input where the record separator is the newline\nand the field separator is a 'dollar' character.\njustification can be Symbol; (:Left, :Right, or :Center).\n\nReturn the justified output as a string\n=end\ndef aligner(infile, justification = :Left)\n  fieldsbyrow = infile.map {|line| line.strip.split('$')}\n  # pad to same number of fields per record\n  maxfields = fieldsbyrow.map(&:length).max\n  fieldsbyrow.map! {|row| row + ['']*(maxfields - row.length)}\n  # calculate max fieldwidth per column\n  colwidths = fieldsbyrow.transpose.map {|column|\n    column.map(&:length).max\n  }\n  # pad fields in columns to colwidth with spaces\n  justifier = J2justifier[justification]\n  fieldsbyrow.map {|row|\n    row.zip(colwidths).map {|field, width|\n      field.send(justifier, width)\n    }.join(\" \")\n  }.join(\"\\n\")\nend\n\nrequire 'stringio'\n\ntextinfile = <<END\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\nfor align in [:Left, :Right, :Center]\n  infile = StringIO.new(textinfile)\n  puts \"\\n# %s Column-aligned output:\" % align\n  puts aligner(infile, align)\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def aliquot(n, maxlen=16, maxterm=2**47)\n  return \"terminating\", [0] if n == 0\n  s = []\n  while (s << n).size <= maxlen and n < maxterm\n    n = n.proper_divisors.inject(0, :+)\n    if s.include?(n)\n      case n\n      when s[0]\n        case s.size\n        when 1   then   return \"perfect\", s\n        when 2   then   return \"amicable\", s\n        else            return \"sociable of length #{s.size}\", s\n        end\n      when s[-1] then   return \"aspiring\", s\n      else              return \"cyclic back to #{n}\", s\n      end\n    elsif n == 0 then   return \"terminating\", s << 0\n    end\n  end\n  return \"non-terminating\", s\nend\n\nfor n in 1..10\n  puts \"%20s: %p\" % aliquot(n)\nend\nputs\nfor n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]\n  puts \"%20s: %p\" % aliquot(n)\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\n\ndef almost_primes(k=2)\n  return to_enum(:almost_primes, k) unless block_given?\n  1.step {|n| yield n if n.prime_division.sum( &:last ) == k }\nend\n\n(1..5).each{|k| puts almost_primes(k).take(10).join(\", \")}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\n\np ar = pr = Prime.take(10)\n4.times{p ar = ar.product(pr).map{|(a,b)| a*b}.uniq.sort.take(10)}\n"
  },
  {
    "language": "Ruby",
    "code": "require \"continuation\"\n\nclass Amb\n  class ExhaustedError < RuntimeError; end\n\n  def initialize\n    @fail = proc { fail ExhaustedError, \"amb tree exhausted\" }\n  end\n\n  def choose(*choices)\n    prev_fail = @fail\n    callcc { |sk|\n      choices.each { |choice|\n\tcallcc { |fk|\n\t  @fail = proc {\n\t    @fail = prev_fail\n\t    fk.call(:fail)\n\t  }\n\t  if choice.respond_to? :call\n\t    sk.call(choice.call)\n\t  else\n\t    sk.call(choice)\n\t  end\n\t}\n      }\n      @fail.call\n    }\n  end\n\n  def failure\n    choose\n  end\n\n  def assert(cond)\n    failure unless cond\n  end\nend\n\nA = Amb.new\nw1 = A.choose(\"the\", \"that\", \"a\")\nw2 = A.choose(\"frog\", \"elephant\", \"thing\")\nw3 = A.choose(\"walked\", \"treaded\", \"grows\")\nw4 = A.choose(\"slowly\", \"quickly\")\n\nA.choose() unless w1[-1] == w2[0]\nA.choose() unless w2[-1] == w3[0]\nA.choose() unless w3[-1] == w4[0]\n\nputs w1, w2, w3, w4\n"
  },
  {
    "language": "Ruby",
    "code": "h = {}\n(1..20_000).each{|n| h[n] = n.proper_divisors.sum }\nh.select{|k,v| h[v] == k && k < v}.each do |key,val|  # k<v filters out doubles and perfects\n  puts \"#{key} and #{val}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'open-uri'\n\nanagram = Hash.new {|hash, key| hash[key] = []} # map sorted chars to anagrams\n\nopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  words = f.read.split\n  for word in words\n    anagram[word.split('').sort] << word\n  end\nend\n\ncount = anagram.values.map {|ana| ana.length}.max\nanagram.each_value do |ana|\n  if ana.length >= count\n    p ana\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'open-uri'\n\nanagrams = open('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'){|f| f.read.split.group_by{|w| w.each_char.sort} }\nanagrams.values.group_by(&:size).max.last.each{|group| puts group.join(\", \") }\n"
  },
  {
    "language": "Ruby",
    "code": "def deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef find_derangements(list)\n  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}\n  nil\nend\n\nrequire 'open-uri'\nanagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  f.read.split.group_by {|s| s.each_char.sort}\nend\n\nanagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size}\n\nanagram.each do |k,list|\n  if derangements = find_derangements(list)\n    puts \"Longest derangement anagram: #{derangements}\"\n    break\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'tk'\n\n$root = TkRoot.new(\"title\" => \"Pendulum Animation\")\n$canvas = TkCanvas.new($root) do\n  width 320\n  height 200\n  create TkcLine, 0,25,320,25,   'tags' => 'plate', 'width' => 2, 'fill' => 'grey50'\n  create TkcOval, 155,20,165,30, 'tags' => 'pivot', 'outline' => \"\", 'fill' => 'grey50'\n  create TkcLine, 1,1,1,1, 'tags' => 'rod', 'width' => 3, 'fill' => 'black'\n  create TkcOval, 1,1,2,2, 'tags' => 'bob', 'outline' => 'black', 'fill' => 'yellow'\nend\n$canvas.raise('pivot')\n$canvas.pack('fill' => 'both', 'expand' => true)\n\n$Theta = 45.0\n$dTheta = 0.0\n$length = 150\n$homeX = 160\n$homeY = 25\n\ndef show_pendulum\n  angle = $Theta * Math::PI / 180\n  x = $homeX + $length * Math.sin(angle)\n  y = $homeY + $length * Math.cos(angle)\n  $canvas.coords('rod', $homeX, $homeY, x, y)\n  $canvas.coords('bob', x-15, y-15, x+15, y+15)\nend\n\ndef recompute_angle\n  scaling = 3000.0 / ($length ** 2)\n  # first estimate\n  firstDDTheta = -Math.sin($Theta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + firstDDTheta\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  # second estimate\n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + (firstDDTheta + midDDTheta)/2\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  # again, first\n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  lastDTheta = midDTheta + midDDTheta\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  # again, second\n  lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling\n  lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  # Now put the values back in our globals\n  $dTheta  = lastDTheta\n  $Theta = lastTheta\nend\n\ndef animate\n  recompute_angle\n  show_pendulum\n  $after_id = $root.after(15) {animate}\nend\n\nshow_pendulum\n$after_id = $root.after(500) {animate}\n\n$canvas.bind('<Destroy>') {$root.after_cancel($after_id)}\n\nTk.mainloop\n"
  },
  {
    "language": "Ruby",
    "code": "Shoes.app(:width => 320, :height => 200) do\n  @centerX = 160\n  @centerY = 25\n  @length = 150\n  @diameter = 15\n\n  @Theta = 45.0\n  @dTheta = 0.0\n\n  stroke gray\n  strokewidth 3\n  line 0,25,320,25\n  oval 155,20,10\n\n  stroke black\n  @rod = line(@centerX, @centerY, @centerX, @centerY + @length)\n  @bob = oval(@centerX - @diameter, @centerY + @length - @diameter, 2*@diameter)\n\n  animate(24) do |i|\n    recompute_angle\n    show_pendulum\n  end\n\n  def show_pendulum\n    angle = (90 + @Theta) * Math::PI / 180\n    x = @centerX + (Math.cos(angle) * @length).to_i\n    y = @centerY + (Math.sin(angle) * @length).to_i\n\n    @rod.remove\n    strokewidth 3\n    @rod = line(@centerX, @centerY, x, y)\n    @bob.move(x-@diameter, y-@diameter)\n  end\n\n  def recompute_angle\n    scaling = 3000.0 / (@length **2)\n    # first estimate\n    firstDDTheta = -Math.sin(@Theta * Math::PI / 180) * scaling\n    midDTheta = @dTheta + firstDDTheta\n    midTheta = @Theta + (@dTheta + midDTheta)/2\n    # second estimate\n    midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n    midDTheta = @dTheta + (firstDDTheta + midDDTheta)/2\n    midTheta = @Theta + (@dTheta + midDTheta)/2\n    # again, first\n    midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n    lastDTheta = midDTheta + midDDTheta\n    lastTheta = midTheta + (midDTheta + lastDTheta)/2\n    # again, second\n    lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling\n    lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2\n    lastTheta = midTheta + (midDTheta + lastDTheta)/2\n    # Now put the values back in our globals\n    @dTheta  = lastDTheta\n    @Theta = lastTheta\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "#!/bin/ruby\n\nbegin; require 'rubygems'; rescue; end\n\nrequire 'gosu'\ninclude Gosu\n\n# Screen size\nW = 640\nH = 480\n\n# Full-screen mode\nFS = false\n\n# Screen update rate (Hz)\nFPS = 60\n\nclass Pendulum\n\n  attr_accessor :theta, :friction\n\n  def initialize( win, x, y, length, radius, bob = true, friction = false)\n    @win = win\n    @centerX = x\n    @centerY = y\n    @length = length\n    @radius = radius\n    @bob = bob\n    @friction = friction\n\n    @theta = 60.0\n    @omega = 0.0\n    @scale = 2.0 / FPS\n  end\n\n  def draw\n    @win.translate(@centerX, @centerY) {\n      @win.rotate(@theta) {\n        @win.draw_quad(-1, 0, 0x3F_FF_FF_FF, 1, 0, 0x3F_FF_FF_00, 1, @length, 0x3F_FF_FF_00, -1, @length, 0x3F_FF_FF_FF )\n        if @bob\n          @win.translate(0, @length) {\n            @win.draw_quad(0, -@radius, Color::RED, @radius, 0, Color::BLUE, 0, @radius, Color::WHITE, -@radius, 0, Color::BLUE )\n          }\n        end\n      }\n    }\n  end\n\n  def update\n    # Thanks to Hugo Elias for the formula (and explanation thereof)\n    @theta += @omega\n    @omega = @omega - (Math.sin(@theta * Math::PI / 180) / (@length * @scale))\n    @theta *= 0.999 if @friction\n  end\n\nend # Pendulum class\n\nclass GfxWindow < Window\n\n  def initialize\n    # Initialize the base class\n    super W, H, FS, 1.0 / FPS * 1000\n    # self.caption = \"You're getting sleeeeepy...\"\n    self.caption = \"Ruby/Gosu Pendulum Simulator (Space toggles friction)\"\n\n    @n = 1  # Try changing this number!\n    @pendulums = []\n    (1..@n).each do |i|\n      @pendulums.push Pendulum.new( self, W / 2, H / 10, H * 0.75 * (i / @n.to_f), H / 60 )\n    end\n\n  end\n\n  def draw\n    @pendulums.each { |pen| pen.draw }\n  end\n\n  def update\n    @pendulums.each { |pen| pen.update }\n  end\n\n  def button_up(id)\n    if id == KbSpace\n      @pendulums.each { |pen|\n        pen.friction = !pen.friction\n        pen.theta = (pen.theta <=> 0) * 45.0 unless pen.friction\n      }\n    else\n      close\n    end\n  end\n\n  def needs_cursor?()\n    true\n  end\n\nend # GfxWindow class\n\nbegin\n  GfxWindow.new.show\nrescue Exception => e\n  puts e.message, e.backtrace\n  gets\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'tk'\n$str = TkVariable.new(\"Hello World! \")\n$dir = :right\n\ndef animate\n  $str.value = shift_char($str.value, $dir)\n  $root.after(125) {animate}\nend\n\ndef shift_char(str, dir)\n  case dir\n  when :right then str[-1,1] + str[0..-2]\n  when :left  then str[1..-1] + str[0,1]\n  end\nend\n\n$root = TkRoot.new(\"title\" => \"Basic Animation\")\n\nTkLabel.new($root) do\n  textvariable $str\n  font \"Courier 14\"\n  pack {side 'top'}\n  bind(\"ButtonPress-1\") {$dir = {:right=>:left,:left=>:right}[$dir]}\nend\n\nanimate\nTk.mainloop\n"
  },
  {
    "language": "Ruby",
    "code": "Shoes.app do\n  @direction = 1\n  @label = para \"Hello World! \", :family => 'monospace'\n\n  click {|button, left, top| @direction *= -1 if button == 1}\n\n  animate(8) do |f|\n    t = @label.text\n    @label.text = @direction > 0 ? t[-1] + t[0..-2] : t[1..-1] + t[0]\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |m| m < 2 ? m : fib2[m - 1] + fib2[m - 2] })[n]\nend\n"
  },
  {
    "language": "Ruby",
    "code": "(-2..12).map { |i| fib i rescue :error }\n=> [:error, :error, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n"
  },
  {
    "language": "Ruby",
    "code": "def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |n| n < 2 ? n : fib2[n - 1] + fib2[n - 2] })[n]\nend\n"
  },
  {
    "language": "Ruby",
    "code": "# Ruby 1.9\n(-2..12).map { |i| fib i rescue :error }\n=> [:error, :error, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n\n# Ruby 1.8\n(-2..12).map { |i| fib i rescue :error }\n=> [:error, :error, 0, 1, 0, -3, -8, -15, -24, -35, -48, -63, -80, -99, -120]\n"
  },
  {
    "language": "Ruby",
    "code": "def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  Hash.new { |fib2, m|\n    fib2[m] = (m < 2 ? m : fib2[m - 1] + fib2[m - 2]) }[n]\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'continuation' unless defined? Continuation\n\nmodule Kernel\n  module_function\n\n  def recur(*args, &block)\n    cont = catch(:recur) { return block[*args] }\n    cont[block]\n  end\n\n  def recurse(*args)\n    block = callcc { |cont| throw(:recur, cont) }\n    block[*args]\n  end\nend\n\ndef fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  recur(n) { |m| m < 2 ? m : (recurse m - 1) + (recurse m - 2) }\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'continuation' unless defined? Continuation\n\nmodule Kernel\n  module_function\n\n  def function(&block)\n    f = (proc do |*args|\n           (class << args; self; end).class_eval do\n             define_method(:callee) { f }\n           end\n           ret = nil\n           cont = catch(:function) { ret = block.call(*args); nil }\n           cont[args] if cont\n           ret\n         end)\n  end\n\n  def arguments\n    callcc { |cont| throw(:function, cont) }\n  end\nend\n\ndef fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  function { |m|\n    if m < 2\n      m\n    else\n      arguments.callee[m - 1] + arguments.callee[m - 2]\n    end\n  }[n]\nend\n"
  },
  {
    "language": "Ruby",
    "code": "Gecos = Struct.new :fullname, :office, :extension, :homephone, :email\nclass Gecos\n  def to_s\n    \"%s,%s,%s,%s,%s\" % to_a\n  end\nend\n\n# Another way define 'to_s' method\nPasswd = Struct.new(:account, :password, :uid, :gid, :gecos, :directory, :shell) do\n  def to_s\n    to_a.join(':')\n  end\nend\n\njsmith = Passwd.new('jsmith','x',1001, 1000, Gecos.new('Joe Smith', 'Room 1007', '(234)555-8917', '(234)555-0077', 'jsmith@rosettacode.org'), '/home/jsmith', '/bin/bash')\njdoe = Passwd.new('jdoe','x',1002, 1000, Gecos.new('Jane Doe', 'Room 1004', '(234)555-8914', '(234)555-0044', 'jdoe@rosettacode.org'), '/home/jdoe', '/bin/bash')\nxyz = Passwd.new('xyz','x',1003, 1000, Gecos.new('X Yz', 'Room 1003', '(234)555-8913', '(234)555-0033', 'xyz@rosettacode.org'), '/home/xyz', '/bin/bash')\n\nfilename = 'append.records.test'\n\n# create the passwd file with two records\nFile.open(filename, 'w') do |io|\n  io.puts jsmith\n  io.puts jdoe\nend\n\nputs \"before appending:\"\nputs File.readlines(filename)\n\n# append the third record\nFile.open(filename, 'a') do |io|\n  io.puts xyz\nend\n\nputs \"after appending:\"\nputs File.readlines(filename)\n"
  },
  {
    "language": "Ruby",
    "code": "for i in [1,2,3,4,5] do\n   puts i**2\nend\n"
  },
  {
    "language": "Ruby",
    "code": "[1,2,3,4,5].each{ |i| puts i**2 }\n"
  },
  {
    "language": "Ruby",
    "code": "[1,2,3,4,5].map{ |i| i**2 }\n"
  },
  {
    "language": "Ruby",
    "code": "irb(main):001:0> y = ( 5**4**3**2 ).to_s\nputs \"5**4**3**2 = #{y[0..19]}...#{y[-20..-1]} and has #{y.length} digits\"\n"
  },
  {
    "language": "Ruby",
    "code": "# Four ways to write complex numbers:\na = Complex(1, 1)       # 1. call Kernel#Complex\ni = Complex::I          # 2. use Complex::I\nb = 3.14159 + 1.25 * i\nc = '1/2+3/4i'.to_c     # 3. Use the .to_c method from String, result ((1/2)+(3/4)*i)\nc =  1.0/2+3/4i         # (0.5-(3/4)*i)\n\n# Operations:\nputs a + b              # addition\nputs a * b              # multiplication\nputs -a                 # negation\nputs 1.quo a            # multiplicative inverse\nputs a.conjugate        # complex conjugate\nputs a.conj             # alias for complex conjugate\n"
  },
  {
    "language": "Ruby",
    "code": "# Other ways to find the multiplicative inverse:\nputs 1.quo a            # always works\nputs 1.0 / a            # works, but forces floating-point math\nputs 1 / a              # might truncate to integer\n"
  },
  {
    "language": "Ruby",
    "code": "require \"cmath\"\nCMath.sqrt(-9)      #=> 0+3.0i\nCMath.acos(0+3.0i)  #=> (1.5707963267948966-1.8184464592320668i)\n#etc\n"
  },
  {
    "language": "Ruby",
    "code": "$op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"/\" => 1}\n\nclass TreeNode\n  OP_FUNCTION = {\n    \"+\" => lambda {|x, y| x + y},\n    \"-\" => lambda {|x, y| x - y},\n    \"*\" => lambda {|x, y| x * y},\n    \"/\" => lambda {|x, y| x / y}}\n  attr_accessor :info, :left, :right\n\n  def initialize(info)\n    @info = info\n  end\n\n  def leaf?\n    @left.nil? and @right.nil?\n  end\n\n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n\n      strs = case order\n             when :prefix  then [@info, left_s, right_s]\n             when :infix   then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else               []\n             end\n\n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n\n  def eval\n    if !leaf? and operator?(@info)\n      OP_FUNCTION[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .gsub('+', ' + ')\n    .gsub('-', ' - ')\n    .gsub('*', ' * ')\n    .gsub('/', ' / ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n\n  tokens.each do |token|\n    if operator?(token)\n      # clear stack of higher priority operators\n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n\n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n\n      # throw away the '('\n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n\n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n\n  node_stack.last\nend\n"
  },
  {
    "language": "Ruby",
    "code": "exp = \"1 + 2 - 3 * (4 / 6)\"\nputs(\"Original: \" + exp)\n\ntree = infix_exp_to_tree(exp)\nputs(\"Prefix: \" + tree.to_s(:prefix))\nputs(\"Infix: \" + tree.to_s(:infix))\nputs(\"Postfix: \" + tree.to_s(:postfix))\nputs(\"Result: \" + tree.eval.to_s)\n"
  },
  {
    "language": "Ruby",
    "code": "# The flt package (http://flt.rubyforge.org/) is useful for high-precision floating-point math.\n# It lets us control 'context' of numbers, individually or collectively -- including precision\n# (which adjusts the context's value of epsilon accordingly).\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  # default 53 (bits)\n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n"
  },
  {
    "language": "Ruby",
    "code": "require 'bigdecimal'\n\nPRECISION = 100\nEPSILON = 0.1 ** (PRECISION/2)\nBigDecimal::limit(PRECISION)\n\ndef agm(a,g)\n  while a - g > EPSILON\n    a, g = (a+g)/2, (a*g).sqrt(PRECISION)\n  end\n  [a, g]\nend\n\na = BigDecimal(1)\ng = 1 / BigDecimal(2).sqrt(PRECISION)\nputs agm(a, g)\n"
  },
  {
    "language": "Ruby",
    "code": "# Calculate Pi using the Arithmetic Geometric Mean of 1 and 1/sqrt(2)\n#\n#\n#  Nigel_Galloway\n#  March 8th., 2012.\n#\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n"
  },
  {
    "language": "Ruby",
    "code": "puts 'Enter x and y'\nx = gets.to_i  # to check errors, use x=Integer(gets)\ny = gets.to_i\n\nputs \"Sum: #{x+y}\",\n     \"Difference: #{x-y}\",\n     \"Product: #{x*y}\",\n     \"Quotient: #{x/y}\",       # truncates towards negative infinity\n     \"Quotient: #{x.fdiv(y)}\", # float\n     \"Remainder: #{x%y}\",      # same sign as second operand\n     \"Exponentiation: #{x**y}\"\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rational' #Only needed in Ruby < 1.9\n\nfor candidate in 2 .. 2**19\n  sum = Rational(1, candidate)\n  for factor in 2 ... candidate**0.5\n    if candidate % factor == 0\n      sum += Rational(1, factor) + Rational(1, candidate / factor)\n    end\n  end\n  if sum.denominator == 1\n    puts \"Sum of recipr. factors of %d = %d exactly %s\" %\n           [candidate, sum.to_i, sum == 1 ? \"perfect!\" : \"\"]\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2  # => [1, 2, 3, 4, 5, 6]\narr4.concat(arr3)  # => [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
  },
  {
    "language": "Ruby",
    "code": "# concat multiple arrays:\n[arr1,arr2,arr3].flatten(1)\n# ignore nil:\n[arr1,arr2,arr3].compact.flatten(1)\n"
  },
  {
    "language": "Ruby",
    "code": "# create an array with one object in it\na = ['foo']\n\n# the Array#new method allows several additional ways to create arrays\n\n# push objects into the array\na << 1         # [\"foo\", 1]\na.push(3,4,5)  # [\"foo\", 1, 3, 4, 5]\n\n# set the value at a specific index in the array\na[0] = 2       # [2, 1, 3, 4, 5]\n\n# a couple of ways to set a slice of the array\na[0,3] = 'bar'    # [\"bar\", 4, 5]\na[1..-1] = 'baz'  # [\"bar\", \"baz\"]\na[0] = nil        # [nil, \"baz\"]\na[0,1] = nil      # [\"baz\"]\n\n# retrieve an element\nputs a[0]\n"
  },
  {
    "language": "Ruby",
    "code": "require \"test/unit/assertions\"\ninclude Test::Unit::Assertions\n\nn = 5\nbegin\n  assert_equal(42, n)\nrescue Exception => e\n  # Ruby 1.8: e is a Test::Unit::AssertionFailedError\n  # Ruby 1.9: e is a MiniTest::Assertion\n  puts e\nend\n"
  },
  {
    "language": "Ruby",
    "code": "hash={}\nhash[666]='devil'\nhash[777]  # => nil\nhash[666]  # => 'devil'\n"
  },
  {
    "language": "Ruby",
    "code": "hash=Hash.new('unknown key')\nhash[666]='devil'\nhash[777]  # => 'unknown key'\nhash[666]  # => 'devil'\n"
  },
  {
    "language": "Ruby",
    "code": "hash=Hash.new{|h,k| \"unknown key #{k}\"}\nhash[666]='devil'\nhash[777]  # => 'unknown key 777'\nhash[666]  # => 'devil'\n"
  },
  {
    "language": "Ruby",
    "code": "hash=Hash.new{|h,k|h[k]=\"key #{k} was added at #{Time.now}\"}\nhash[777]  # => 'key 777 was added at Sun Apr 03 13:49:57 -0700 2011'\nhash[555]  # => 'key 555 was added at Sun Apr 03 13:50:01 -0700 2011'\nhash[777]  # => 'key 777 was added at Sun Apr 03 13:49:57 -0700 2011'\n"
  },
  {
    "language": "Ruby",
    "code": "my_dict = { \"hello\" => 13,\n\t   \"world\" => 31,\n\t   \"!\"     => 71 }\n\n# iterating over key-value pairs:\nmy_dict.each {|key, value| puts \"key = #{key}, value = #{value}\"}\n# or\nmy_dict.each_pair {|key, value| puts \"key = #{key}, value = #{value}\"}\n\n# iterating over keys:\nmy_dict.each_key {|key| puts \"key = #{key}\"}\n\n# iterating over values:\nmy_dict.each_value {|value| puts \"value =#{value}\"}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let mut door_open = [false; 100];\n    for pass in 1..100 {\n        let mut door = pass;\n        while door <= 100 {\n            door_open[door - 1] = !door_open[door - 1];\n            door += pass;\n        }\n    }\n    for (i, &is_open) in door_open.iter().enumerate() {\n        println!(\"Door {} is {}.\", i + 1, if is_open {\"open\"} else {\"closed\"});\n    }\n}\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let doors = vec![false; 100].iter_mut().enumerate()\n                                .map(|(door, door_state)| (1..100).into_iter()\n                                                                   .filter(|pass| door % pass == 0)\n                                                                   .map(|_| { *door_state = !*door_state; *door_state })\n                                                                   .last().unwrap()).collect::<Vec<_>>();\n\n    println!(\"{:?}\", doors);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let squares: Vec<_> = (1..10).map(|n| n*n).collect();\n    let is_square = |num| squares.binary_search(&num).is_ok();\n\n    for i in 1..100 {\n        let state = if is_square(i) {\"open\"} else {\"closed\"};\n        println!(\"Door {} is {}\", i, state);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    for i in 1u32..10u32{\n        println!(\"Door {} is open\", i.pow(2));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone, Copy, Debug)]\nenum Operator {\n    Sub,\n    Plus,\n    Mul,\n    Div,\n}\n\n#[derive(Clone, Debug)]\nstruct Factor {\n    content: String,\n    value: i32,\n}\n\nfn apply(op: Operator, left: &[Factor], right: &[Factor]) -> Vec<Factor> {\n    let mut ret = Vec::new();\n    for l in left.iter() {\n        for r in right.iter() {\n            use Operator::*;\n            ret.push(match op {\n                Sub if l.value > r.value => Factor {\n                    content: format!(\"({} - {})\", l.content, r.content),\n                    value: l.value - r.value,\n                },\n                Plus => Factor {\n                    content: format!(\"({} + {})\", l.content, r.content),\n                    value: l.value + r.value,\n                },\n                Mul => Factor {\n                    content: format!(\"({} x {})\", l.content, r.content),\n                    value: l.value * r.value,\n                },\n                Div if l.value >= r.value && r.value > 0 && l.value % r.value == 0 => Factor {\n                    content: format!(\"({} / {})\", l.content, r.content),\n                    value: l.value / r.value,\n                },\n                _ => continue,\n            })\n        }\n    }\n    ret\n}\n\nfn calc(op: [Operator; 3], numbers: [i32; 4]) -> Vec<Factor> {\n    fn calc(op: &[Operator], numbers: &[i32], acc: &[Factor]) -> Vec<Factor> {\n        use Operator::*;\n        if op.is_empty() {\n            return Vec::from(acc)\n        }\n        let mut ret = Vec::new();\n        let mono_factor = [Factor {\n            content: numbers[0].to_string(),\n            value: numbers[0],\n        }];\n        match op[0] {\n            Mul => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n            Div => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Sub => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Plus => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n        }\n        calc(&op[1..], &numbers[1..], &ret)\n    }\n    calc(&op, &numbers[1..], &[Factor { content: numbers[0].to_string(), value: numbers[0] }])\n}\n\nfn solutions(numbers: [i32; 4]) -> Vec<Factor> {\n    use std::collections::hash_set::HashSet;\n    let mut ret = Vec::new();\n    let mut hash_set = HashSet::new();\n\n    for ops in OpIter(0) {\n        for o in orders().iter() {\n            let numbers = apply_order(numbers, o);\n            let r = calc(ops, numbers);\n            ret.extend(r.into_iter().filter(|&Factor { value, ref content }| value == 24 && hash_set.insert(content.to_owned())))\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut numbers = Vec::new();\n    if let Some(input) = std::env::args().skip(1).next() {\n        for c in input.chars() {\n            if let Ok(n) = c.to_string().parse() {\n                numbers.push(n)\n            }\n            if numbers.len() == 4 {\n                let numbers = [numbers[0], numbers[1], numbers[2], numbers[3]];\n                let solutions = solutions(numbers);\n                let len = solutions.len();\n                if len == 0 {\n                    println!(\"no solution for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                    return\n                }\n                println!(\"solutions for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                for s in solutions {\n                    println!(\"{}\", s.content)\n                }\n                println!(\"{} solutions found\", len);\n                return\n            }\n        }\n    } else {\n        println!(\"empty input\")\n    }\n}\n\n\nstruct OpIter (usize);\n\nimpl Iterator for OpIter {\n    type Item = [Operator; 3];\n    fn next(&mut self) -> Option<[Operator; 3]> {\n        use Operator::*;\n        const OPTIONS: [Operator; 4] = [Mul, Sub, Plus, Div];\n        if self.0 >= 1 << 6 {\n            return None\n        }\n        let f1 = OPTIONS[(self.0 & (3 << 4)) >> 4];\n        let f2 = OPTIONS[(self.0 & (3 << 2)) >> 2];\n        let f3 = OPTIONS[(self.0 & (3 << 0)) >> 0];\n        self.0 += 1;\n        Some([f1, f2, f3])\n    }\n}\n\nfn orders() -> [[usize; 4]; 24] {\n    [\n        [0, 1, 2, 3],\n        [0, 1, 3, 2],\n        [0, 2, 1, 3],\n        [0, 2, 3, 1],\n        [0, 3, 1, 2],\n        [0, 3, 2, 1],\n        [1, 0, 2, 3],\n        [1, 0, 3, 2],\n        [1, 2, 0, 3],\n        [1, 2, 3, 0],\n        [1, 3, 0, 2],\n        [1, 3, 2, 0],\n        [2, 0, 1, 3],\n        [2, 0, 3, 1],\n        [2, 1, 0, 3],\n        [2, 1, 3, 0],\n        [2, 3, 0, 1],\n        [2, 3, 1, 0],\n        [3, 0, 1, 2],\n        [3, 0, 2, 1],\n        [3, 1, 0, 2],\n        [3, 1, 2, 0],\n        [3, 2, 0, 1],\n        [3, 2, 1, 0]\n    ]\n}\n\nfn apply_order(numbers: [i32; 4], order: &[usize; 4]) -> [i32; 4] {\n    [numbers[order[0]], numbers[order[1]], numbers[order[2]], numbers[order[3]]]\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self,BufRead};\nextern crate rand;\nuse rand::Rng;\n\nfn op_type(x: char) -> i32{\n    match x {\n        '-' | '+' => return 1,\n        '/' | '*' => return 2,\n        '(' | ')' => return -1,\n        _   => return 0,\n    }\n}\n\nfn to_rpn(input: &mut String){\n\n    let mut rpn_string : String = String::new();\n    let mut rpn_stack : String = String::new();\n    let mut last_token = '#';\n    for token in input.chars(){\n        if token.is_digit(10) {\n            rpn_string.push(token);\n        }\n        else if op_type(token) == 0 {\n            continue;\n        }\n        else if op_type(token) > op_type(last_token) || token == '(' {\n                rpn_stack.push(token);\n                last_token=token;\n        }\n        else {\n            while let Some(top) = rpn_stack.pop() {\n                if top=='(' {\n                    break;\n                }\n                rpn_string.push(top);\n            }\n            if token != ')'{\n                rpn_stack.push(token);\n            }\n        }\n    }\n    while let Some(top) = rpn_stack.pop() {\n        rpn_string.push(top);\n    }\n\n    println!(\"you formula results in {}\", rpn_string);\n\n    *input=rpn_string;\n}\n\nfn calculate(input: &String, list : &mut [u32;4]) -> f32{\n    let mut stack : Vec<f32> = Vec::new();\n    let mut accumulator : f32 = 0.0;\n\n    for token in input.chars(){\n        if token.is_digit(10) {\n            let test = token.to_digit(10).unwrap() as u32;\n            match list.iter().position(|&x| x == test){\n                Some(idx) => list[idx]=10 ,\n                _         => println!(\" invalid digit: {} \",test),\n            }\n            stack.push(accumulator);\n            accumulator = test as f32;\n        }else{\n            let a = stack.pop().unwrap();\n            accumulator = match token {\n                '-' => a-accumulator,\n                '+' => a+accumulator,\n                '/' => a/accumulator,\n                '*' => a*accumulator,\n                _ => {accumulator},//NOP\n            };\n        }\n    }\n    println!(\"you formula results in {}\",accumulator);\n    accumulator\n}\n\nfn main() {\n\n    let mut rng = rand::thread_rng();\n    let mut list :[u32;4]=[rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10];\n\n    println!(\"form 24 with using + - / * {:?}\",list);\n    //get user input\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    //convert to rpn\n    to_rpn(&mut input);\n    let result = calculate(&input, &mut list);\n\n    if list.iter().any(|&list| list !=10){\n        println!(\"and you used all numbers\");\n        match result {\n            24.0 => println!(\"you won\"),\n            _ => println!(\"but your formulla doesn't result in 24\"),\n        }\n    }else{\n        println!(\"you didn't use all the numbers\");\n    }\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate num;\n\nuse std::cmp;\nuse num::bigint::BigUint;\n\nfn cumu(n: usize, cache: &mut Vec<Vec<BigUint>>) {\n    for l in cache.len()..n+1 {\n        let mut r = vec![BigUint::from(0u32)];\n        for x in 1..l+1 {\n            let prev = r[r.len() - 1].clone();\n            r.push(prev + cache[l-x][cmp::min(x, l-x)].clone());\n        }\n        cache.push(r);\n    }\n}\n\nfn row(n: usize, cache: &mut Vec<Vec<BigUint>>) -> Vec<BigUint> {\n    cumu(n, cache);\n    let r = &cache[n];\n    let mut v: Vec<BigUint> = Vec::new();\n\n    for i in 0..n {\n        v.push(&r[i+1] - &r[i]);\n    }\n    v\n}\n\nfn main() {\n    let mut cache = vec![vec![BigUint::from(1u32)]];\n\n    println!(\"rows:\");\n    for x in 1..26 {\n        let v: Vec<String> = row(x, &mut cache).iter().map(|e| e.to_string()).collect();\n        let s: String = v.join(\" \");\n        println!(\"{}: {}\", x, s);\n    }\n\n    println!(\"sums:\");\n    for x in vec![23, 123, 1234, 12345] {\n        cumu(x, &mut cache);\n        let v = &cache[x];\n        let s = v[v.len() - 1].to_string();\n        println!(\"{}: {}\", x, s);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n\tfor n in (0..100).rev() {\n\t\tmatch n {\n\t\t\t0 => {\n\t\t\t\tprintln!(\"No more bottles of beer on the wall, no more bottles of beer.\");\n\t\t\t\tprintln!(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n\t\t\t},\n\t\t\t1 => {\n\t\t\t\tprintln!(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n\t\t\t\tprintln!(\"Take one down and pass it around, no more bottles of beer on the wall.\\n\");\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\tprintln!(\"{0:?} bottles of beer on the wall, {0:?} bottles of beer.\", n);\n\t\t\t\tprintln!(\"Take one down and pass it around, {} bottles of beer on the wall.\\n\", n-1);\n\t\t\t},\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "trait Bottles {\n\tfn bottles_of_beer(&self) -> Self;\n\tfn on_the_wall(&self);\n}\n\nimpl Bottles for u32 {\n\tfn bottles_of_beer(&self) -> u32 {\n\t\tmatch *self {\n\t\t\t0 => print!(\"No bottles of beer\"),\n\t\t\t1 => print!(\"{} bottle of beer\", self),\n\t\t\t_ => print!(\"{} bottles of beer\", self)\n\t\t}\n\t\t*self   // return a number for chaining\n\t}\n\n\tfn on_the_wall(&self) {\n\t\tprintln!(\" on the wall!\");\n\t}\n}\n\nfn main() {\n\tfor i in (1..100).rev() {\n\t\ti.bottles_of_beer().on_the_wall();\n\t\ti.bottles_of_beer();\n\t\tprintln!(\"\\nTake one down, pass it around...\");\n\t\t(i - 1).bottles_of_beer().on_the_wall();\n\t\tprintln!(\"-----------------------------------\");\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).expect(\"reading stdin\");\n\n    let mut i: i64 = 0;\n    for word in line.split_whitespace() {\n        i += word.parse::<i64>().expect(\"trying to interpret your input as numbers\");\n    }\n    println!(\"{}\", i);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).expect(\"reading stdin\");\n\n    let sum: i64 = line.split_whitespace()\n                       .map(|x| x.parse::<i64>().expect(\"Not an integer\"))\n                       .sum();\n    println!(\"{}\", sum);\n}\n"
  },
  {
    "language": "Rust",
    "code": "trait Shape {\n    fn area(self) -> i32;\n}\n"
  },
  {
    "language": "Rust",
    "code": "struct Square {\n    side_length: i32\n}\n\nimpl Shape for Square {\n    fn area(self) -> i32 {\n        self.side_length * self.side_length\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "trait Shape {\n    fn area(self) -> i32;\n\n    fn is_shape(self) -> bool {\n        true\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    // deficient starts at 1 because 1 is deficient but proper_divisors returns\n    // and empty Vec\n    let (mut abundant, mut deficient, mut perfect) = (0u32, 1u32, 0u32);\n    for i in 1..20_001 {\n        if let Some(divisors) = i.proper_divisors() {\n            let sum: u64 = divisors.iter().sum();\n            if sum < i {\n                deficient += 1\n            } else if sum > i {\n                abundant += 1\n            } else {\n                perfect += 1\n            }\n        }\n    }\n    println!(\"deficient:\\t{:5}\\nperfect:\\t{:5}\\nabundant:\\t{:5}\",\n             deficient, perfect, abundant);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// rustc -V\n// rustc 1.2.0-nightly (0cc99f9cc 2015-05-17) (built 2015-05-18)\n\nuse std::ops::Add;\n\nfn foo<Num>(n: Num) -> Box<FnMut(Num) -> Num>\n        where Num: Add<Output=Num> + Copy + 'static {\n    let mut acc = n;\n    Box::new(move |i: Num| {\n        acc = acc + i;\n        acc\n    })\n}\n\nfn main() {\n    let mut x = foo(1.);\n    x(5.);\n    foo(3.);\n    println!(\"{}\", x(2.3));\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a); // 125\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn ack(m: u64, n: u64) -> u64 {\n\tmatch (m, n) {\n\t\t(0, n) => n + 1,\n\t\t(m, 0) => ack(m - 1, 1),\n\t\t(m, n) => ack(m - 1, ack(m, n - 1)),\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "let conn = ldap3::LdapConn::new(\"ldap://ldap.example.com\")?;\nconn.simple_bind(\"bind_dn\", \"bind_pass\")?.success()?;\n"
  },
  {
    "language": "Rust",
    "code": "#![feature(mpsc_select)]\n\nextern crate num;\nextern crate schedule_recv;\n\nuse num::traits::Zero;\nuse num::Float;\nuse schedule_recv::periodic_ms;\nuse std::f64::consts::PI;\nuse std::ops::Mul;\nuse std::sync::mpsc::{self, SendError, Sender};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\npub type Actor<S> = Sender<Box<Fn(u32) -> S + Send>>;\npub type ActorResult<S> = Result<(), SendError<Box<Fn(u32) -> S + Send>>>;\n\n/// Rust supports both shared-memory and actor models of concurrency, and the `Integrator` utilizes\n/// both.  We use an `Actor` to send the `Integrator` new functions, while we use a `Mutex`\n/// (shared-memory concurrency) to hold the result of the integration.\n///\n/// Note that these are not the only options here--there are many, many ways you can deal with\n/// concurrent access.  But when in doubt, a plain old `Mutex` is often a good bet.  For example,\n/// this might look like a good situation for a `RwLock`--after all, there's no reason for a read\n/// in the main task to block writes.  Unfortunately, unless you have significantly more reads than\n/// writes (which is certainly not the case here), a `Mutex` will usually outperform a `RwLock`.\npub struct Integrator<S: 'static, T: Send> {\n    input: Actor<S>,\n    output: Arc<Mutex<T>>,\n}\n\n/// In Rust, time durations are strongly typed.  This is usually exactly what you want, but for a\n/// problem like this--where the integrated value has unusual (unspecified?) units--it can actually\n/// be a bit tricky.  Right now, `Duration`s can only be multiplied or divided by `i32`s, so in\n/// order to be able to actually do math with them we say that the type parameter `S` (the result\n/// of the function being integrated) must yield `T` (the type of the integrated value) when\n/// multiplied by `f64`.  We could possibly replace `f64` with a generic as well, but it would make\n/// things a bit more complex.\nimpl<S, T> Integrator<S, T>\nwhere\n    S: Mul<f64, Output = T> + Float + Zero,\n    T: 'static + Clone + Send + Float,\n{\n    pub fn new(frequency: u32) -> Integrator<S, T> {\n        // We create a pipe allowing functions to be sent from tx (the sending end) to input (the\n        // receiving end).  In order to change the function we are integrating from the task in\n        // which the Integrator lives, we simply send the function through tx.\n        let (tx, input) = mpsc::channel();\n        // The easiest way to do shared-memory concurrency in Rust is to use atomic reference\n        // counting, or Arc, around a synchronized type (like Mutex<T>).  Arc gives you a guarantee\n        // that memory will not be freed as long as there is at least one reference to it.\n        // It is similar to C++'s shared_ptr, but it is guaranteed to be safe and is never\n        // incremented unless explicitly cloned (by default, it is moved).\n        let s: Arc<Mutex<T>> = Arc::new(Mutex::new(Zero::zero()));\n        let integrator = Integrator {\n            input: tx,\n            // Here is the aforementioned clone.  We have to do it before s enters the closure,\n            // because once that happens it is moved into the closure (and later, the new task) and\n            // becomes inaccessible to the outside world.\n            output: Arc::clone(&s),\n        };\n        thread::spawn(move || -> () {\n            // The frequency is how often we want to \"tick\" as we update our integrated total.  In\n            // Rust, timers can yield Receivers that are periodically notified with an empty\n            // message (where the period is the frequency).  This is useful because it lets us wait\n            // on either a tick or another type of message (in this case, a request to change the\n            // function we are integrating).\n            let periodic = periodic_ms(frequency);\n            let mut t = 0;\n            let mut k: Box<Fn(u32) -> S + Send> = Box::new(|_| Zero::zero());\n            let mut k_0: S = Zero::zero();\n            loop {\n                // Here's the selection we talked about above.  Note that we are careful to call\n                // the *non*-failing function, recv(), here.  The reason we do this is because\n                // recv() will return Err when the sending end of a channel is dropped.  While\n                // this is unlikely to happen for the timer (so again, you could argue for failure\n                // there), it's normal behavior for the sending end of input to be dropped, since\n                // it just happens when the Integrator falls out of scope.  So we handle it cleanly\n                // and break out of the loop, rather than failing.\n                select! {\n                    res = periodic.recv() => match res {\n                        Ok(_) => {\n                            t += frequency;\n                            let k_1: S = k(t);\n                            // Rust Mutexes are a bit different from Mutexes in many other\n                            // languages, in that the protected data is actually encapsulated by\n                            // the Mutex.  The reason for this is that Rust is actually capable of\n                            // enforcing (via its borrow checker) the invariant that the contents\n                            // of a Mutex may only be read when you have acquired its lock.  This\n                            // is enforced by way of a MutexGuard, the return value of lock(),\n                            // which implements some special traits (Deref and DerefMut) that allow\n                            // access to the inner element \"through\" the guard.  The element so\n                            // acquired has a lifetime bounded by that of the MutexGuard, the\n                            // MutexGuard can only be acquired by taking a lock, and the only way\n                            // to release the lock is by letting the MutexGuard fall out of scope,\n                            // so it's impossible to access the data incorrectly.  There are some\n                            // additional subtleties around the actual implementation, but that's\n                            // the basic idea.\n                            let mut s = s.lock().unwrap();\n                            *s = *s + (k_1 + k_0) * (f64::from(frequency) / 2.);\n                            k_0 = k_1;\n                        }\n                        Err(_) => break,\n                    },\n                    res = input.recv() => match res {\n                        Ok(k_new) => k = k_new,\n                        Err(_) => break,\n                    }\n                }\n            }\n        });\n        integrator\n    }\n\n    pub fn input(&self, k: Box<Fn(u32) -> S + Send>) -> ActorResult<S> {\n        // The meat of the work is done in the other thread, so to set the\n        // input we just send along the Sender we set earlier...\n        self.input.send(k)\n    }\n\n    pub fn output(&self) -> T {\n        // ...and to read the input, we simply acquire a lock on the output Mutex and return a\n        // copy. Why do we have to copy it?  Because, as mentioned above, Rust won't let us\n        // retain access to the interior of the Mutex unless we have possession of its lock.  There\n        // are ways and circumstances in which one can avoid this (e.g. by using atomic types) but\n        // a copy is a perfectly reasonable solution as well, and a lot easier to reason about :)\n        *self.output.lock().unwrap()\n    }\n}\n\n/// This function is fairly straightforward.  We create the integrator, set its input function k(t)\n/// to 2pi * f * t, and then wait as described in the Rosetta stone problem.\nfn integrate() -> f64 {\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / f64::from(two_seconds_ms);\n            (2. * PI * f * f64::from(t)).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_secs(2));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(500));\n    object.output()\n}\n\nfn main() {\n    println!(\"{}\", integrate());\n}\n\n/// Will fail on a heavily loaded machine\n#[test]\n#[ignore]\nfn solution() {\n    // We should just be able to call integrate, but can't represent the closure properly due to\n    // rust-lang/rust issue #17060 if we make frequency or period a variable.\n    // FIXME(pythonesque): When unboxed closures are fixed, fix integrate() to take two arguments.\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / (two_seconds_ms / 10) as f64;\n            (2. * PI * f * t as f64).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(200));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(100));\n    assert_eq!(object.output() as u32, 0)\n}\n"
  },
  {
    "language": "Rust",
    "code": "let v1 = vec![vec![1,2,3]; 10];\nprintln!(\"Original address: {:p}\", &v1);\nlet mut v2;\n// Override rust protections on reading from uninitialized memory\nunsafe {v2 = mem::uninitialized();}\nlet addr = &mut v2 as *mut _;\n\n// ptr::write() though it takes v1 by value, v1s destructor is not run when it goes out of\n// scope, which is good since then we'd have a vector of free'd vectors\nunsafe {ptr::write(addr, v1)}\nprintln!(\"New address: {:p}\", &v2);\n"
  },
  {
    "language": "Rust",
    "code": "let var = 1;\nprintln!(\"address of var: {:p}\", &var);\n"
  },
  {
    "language": "Rust",
    "code": "let address: usize = 0x7ffc8f303130;\nunsafe {\n    let val = *(address as *const usize);\n    println!(\"value at {}: {:?}\", address, val);\n}\n"
  },
  {
    "language": "Rust",
    "code": "unsafe {\n    *(0x7ffc8f303130 as *mut usize) = 1;\n    // Note that this invokes undefined behavior if 0x7ffc8f303130 is uninitialized. In that case, std::ptr::write should be used.\n    std::ptr::write(0x7ffc8f303130 as *mut usize, 1);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn aks_coefficients(k: usize) -> Vec<i64> {\n    let mut coefficients = vec![0i64; k + 1];\n    coefficients[0] = 1;\n    for i in 1..(k + 1) {\n        coefficients[i] = -(1..i).fold(coefficients[0], |prev, j|{\n            let old = coefficients[j];\n            coefficients[j] = old - prev;\n            old\n        });\n    }\n    coefficients\n}\n\nfn is_prime(p: usize) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let c = aks_coefficients(p);\n        (1..p / 2 + 1).all(|i| c[i] % p as i64 == 0)\n    }\n}\n\nfn main() {\n    for i in 0..8 {\n        println!(\"{}: {:?}\", i, aks_coefficients(i));\n    }\n    for i in (1..=50).filter(|&i| is_prime(i)) {\n        print!(\"{} \", i);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn aks_coefficients(k: usize) -> Vec<i64> {\n\tif k == 0 {\n\t\tvec![1i64]\n\t} else {\n\t\tlet zero = Some(0i64);\n\t\trange(1, k).fold(vec![1i64, -1], |r, _| {\n\t\t\tlet a = r.iter().chain(zero.iter());\n\t\t\tlet b = zero.iter().chain(r.iter());\n\t\t\ta.zip(b).map(|(x, &y)| x-y).collect()\n\t\t})\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::iter::{Extend, repeat};\n\nenum AlignmentType { Left, Center, Right }\n\nfn get_column_widths(text: &str) -> Vec<usize> {\n    let mut widths = Vec::new();\n    for line in text.lines().map(|s| s.trim_matches(' ').trim_right_matches('$')) {\n        let lens = line.split('$').map(|s| s.chars().count());\n        for    (idx, len) in lens.enumerate() {\n            if idx < widths.len() {\n                widths[idx] = std::cmp::max(widths[idx], len);\n            }\n            else {\n                widths.push(len);\n            }\n        }\n    }\n    widths\n}\n\nfn align_columns(text: &str, alignment: AlignmentType) -> String {\n    let widths = get_column_widths(text);\n    let mut result = String::new();\n    for line in text.lines().map(|s| s.trim_matches(' ').trim_right_matches('$')) {\n        for (s, w) in line.split('$').zip(widths.iter()) {\n            let blank_count = w - s.chars().count();\n            let (pre, post) = match alignment {\n                AlignmentType::Left => (0, blank_count),\n                AlignmentType::Center => (blank_count / 2, (blank_count + 1) / 2),\n                AlignmentType::Right => (blank_count, 0),\n            };\n            result.extend(repeat(' ').take(pre));\n            result.push_str(s);\n            result.extend(repeat(' ').take(post));\n            result.push(' ');\n        }\n        result.push_str(\"\\n\");\n    }\n    result\n}\n\nfn main() {\n    let text = r#\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"#;\n\n    println!(\"{}\", align_columns(text, AlignmentType::Left));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Center));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Right));\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Debug)]\nenum AliquotType { Terminating, Perfect, Amicable, Sociable, Aspiring, Cyclic, NonTerminating }\n\nfn classify_aliquot(num: i64) -> (AliquotType, Vec<i64>) {\n    let limit = 1i64 << 47; //140737488355328\n    let mut terms = Some(num).into_iter().collect::<Vec<_>>();\n    for i in 0..16 {\n        let n = terms[i];\n        let divsum = (1..(n + 1) / 2 + 1).filter(|&x| n % x == 0 && n != x).fold(0, |sum, x| sum + x);\n        let classification = if divsum == 0 {\n            Some(AliquotType::Terminating)\n        }\n        else if divsum > limit {\n            Some(AliquotType::NonTerminating)\n        }\n        else if let Some(prev_idx) = terms.iter().position(|&x| x == divsum) {\n            let cycle_len = terms.len() - prev_idx;\n            Some(if prev_idx == 0 {\n                match cycle_len {\n                    1 => AliquotType::Perfect,\n                    2 => AliquotType::Amicable,\n                    _ => AliquotType::Sociable\n                }\n            }\n            else {\n                if cycle_len == 1 {AliquotType::Aspiring} else {AliquotType::Cyclic}\n            })\n        }\n        else {\n            None\n        };\n        terms.push(divsum);\n        if let Some(result) = classification {\n            return (result, terms);\n        }\n    }\n    (AliquotType::NonTerminating, terms)\n}\n\nfn main() {\n    let nums = [1i64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488/*, 15355717786080*/];\n    for num in &nums {\n        println!(\"{} {:?}\", num, classify_aliquot(*num));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn is_kprime(n: u32, k: u32) -> bool {\n    let mut primes = 0;\n    let mut f = 2;\n    let mut rem = n;\n    while primes < k && rem > 1{\n        while (rem % f) == 0 && rem > 1{\n            rem /= f;\n            primes += 1;\n        }\n        f += 1;\n    }\n    rem == 1 && primes == k\n}\n\nstruct KPrimeGen {\n    k: u32,\n    n: u32,\n}\n\nimpl Iterator for KPrimeGen {\n    type Item = u32;\n    fn next(&mut self) -> Option<u32> {\n        self.n += 1;\n        while !is_kprime(self.n, self.k) {\n            self.n += 1;\n        }\n        Some(self.n)\n    }\n}\n\nfn kprime_generator(k: u32) -> KPrimeGen {\n    KPrimeGen {k: k, n: 1}\n}\n\nfn main() {\n    for k in 1..6 {\n        println!(\"{}: {:?}\", k, kprime_generator(k).take(10).collect::<Vec<_>>());\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::ops::Add;\nstruct Amb<'a> {\n    list: Vec<Vec<&'a str>>,\n}\nfn main() {\n    let amb = Amb {\n        list: vec![\n            vec![\"the\", \"that\", \"a\"],\n            vec![\"frog\", \"elephant\", \"thing\"],\n            vec![\"walked\", \"treaded\", \"grows\"],\n            vec![\"slowly\", \"quickly\"],\n        ],\n    };\n    match amb.do_amb(0, 0 as char) {\n        Some(text) => println!(\"{}\", text),\n        None => println!(\"Nothing found\"),\n    }\n}\nimpl<'a> Amb<'a> {\n    fn do_amb(&self, level: usize, last_char: char) -> Option<String> {\n        if self.list.is_empty() {\n            panic!(\"No word list\");\n        }\n        if self.list.len() <= level {\n            return Some(String::new());\n        }\n        let mut res = String::new();\n        let word_list = &self.list[level];\n        for word in word_list {\n            if word.chars().next().unwrap() == last_char || last_char == 0 as char {\n                res = res.add(word).add(\" \");\n                let answ = self.do_amb(level + 1, word.chars().last().unwrap());\n                match answ {\n                    Some(x) => {\n                        res = res.add(&x);\n                        return Some(res);\n                    }\n                    None => res.clear(),\n                }\n            }\n        }\n        None\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn sum_of_divisors(val: u32) -> u32 {\n    (1..val/2+1).filter(|n| val % n == 0)\n                .fold(0, |sum, n| sum + n)\n}\n\nfn main() {\n    let iter = (1..20_000).map(|i| (i, sum_of_divisors(i)))\n                          .filter(|&(i, div_sum)| i > div_sum);\n\n    for (i, sum1) in iter {\n        if sum_of_divisors(sum1) == i {\n           println!(\"{} {}\", i, sum1);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufRead,BufReader};\nuse std::borrow::ToOwned;\n\nextern crate unicode_segmentation;\nuse unicode_segmentation::{UnicodeSegmentation};\n\nfn main () {\n    let file = BufReader::new(File::open(\"unixdict.txt\").unwrap());\n    let mut map = HashMap::new();\n    for line in file.lines() {\n        let s = line.unwrap();\n        //Bytes:      let mut sorted = s.trim().bytes().collect::<Vec<_>>();\n        //Codepoints: let mut sorted = s.trim().chars().collect::<Vec<_>>();\n        let mut sorted = s.trim().graphemes(true).map(ToOwned::to_owned).collect::<Vec<_>>();\n        sorted.sort();\n\n        map.entry(sorted).or_insert_with(Vec::new).push(s);\n    }\n\n    if let Some(max_len) = map.values().map(|v| v.len()).max() {\n        for anagram in map.values().filter(|v| v.len() == max_len) {\n            for word in anagram {\n                print!(\"{} \", word);\n            }\n            println!();\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashMap;\nuse std::path::Path;\nuse std::io::{self, BufRead, BufReader};\nuse std::fs::File;\n\nfn main() {\n    if let Ok(anagrams) = find_anagrams(\"unixdict.txt\") {\n        for anagram in anagrams {\n            for word in anagram {\n                print!(\"{} \", word);\n            }\n            println!();\n        }\n    }\n}\n\nconst PRIMES: [u64; 256] = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127\n                           ,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257\n                           ,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401\n                           ,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563\n                           ,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709\n                           ,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877\n                           ,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033\n                           ,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171\n                           ,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301\n                           ,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453\n                           ,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583\n                           ,1597,1601,1607,1609,1613,1619];\n\nfn find_anagrams<P: AsRef<Path>>(file: P) -> io::Result<Vec<Vec<String>>> {\n    let file = BufReader::new(File::open(file)?);\n    let mut map = HashMap::new();\n    for line in file.lines() {\n        let string = line?;\n        let mut num = 1;\n        for ch in string.trim().bytes() {\n            num *= PRIMES[ch as usize];\n        }\n        map.entry(num).or_insert_with(Vec::new).push(string);\n    }\n    Ok(map.into_iter().map(|(_, entry)| entry).collect())\n}\n"
  },
  {
    "language": "Rust",
    "code": "//! Deranged anagrams\nuse std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io;\nuse std::io::BufReader;\nuse std::io::BufRead;\nuse std::usize::MAX;\n\n/// Get words from unix dictionary file\npub fn get_words() -> Result<Vec<String>, io::Error> {\n    let mut words = vec!();\n    // open file\n    let f = File::open(\"data/unixdict.txt\")?;\n    // read line by line\n    let reader = BufReader::new(&f);\n    for line in reader.lines() {\n        words.push(line?)\n    }\n    Ok(words)\n}\n\n/// Get the longest deranged anagram in the given list of word if any\npub fn longest_deranged(v: &mut Vec<String>) -> Option<(String,String)>{\n    // sort by length descending then by alphabetical order\n    v.sort_by(|s1, s2| {\n        let mut c = s2.len().cmp(&s1.len());\n        if c == Ordering::Equal {\n            c = s1.cmp(s2);\n        }\n        c\n    });\n    // keep all strings keyed by sorted characters (since anagrams have the same list of sorted characters)\n    let mut signatures : HashMap<Vec<char>, Vec<&String>> = HashMap::new();\n    // save on memory by only keeping in the map strings of the current processed length\n    let mut previous_length = MAX;\n    for s in v {\n        // length change, clear the map\n        if s.len()<previous_length {\n            signatures.clear();\n            previous_length = s.len();\n        }\n        // generate key as sorted characters\n        let mut sorted_chars = s.chars().collect::<Vec<char>>();\n        sorted_chars.sort();\n        let anagrams = signatures.entry(sorted_chars).or_insert(vec!());\n        // find if any anagram (string with the same sorted character vector) is deranged\n        if let Some(a) = anagrams.iter().filter(|anagram| is_deranged(anagram, s)).next(){\n            return Some(((*a).clone(), s.clone()));\n        }\n        anagrams.push(s);\n    }\n    None\n}\n\n/// check if two strings do NOT have the same character in the same position\npub fn is_deranged(s1: &String, s2: &String) -> bool {\n    // we zip the character iterators and check we find no position with the same two characters\n    s1.chars().zip(s2.chars()).filter(|(a,b)| a == b).next().is_none()\n}\n\n/// an example main method printing the results\nfn main() {\n    let r = get_words();\n    match r {\n        Ok(mut v) => {\n            let od = longest_deranged(&mut v);\n            match od {\n                None => println!(\"No deranged anagrams found!\"),\n                Some((s1,s2)) => println!(\"{} {}\",s1,s2),\n            }\n        },\n        Err(e) => panic!(\"Could not read words: {}\",e)\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowType};\n    use std::ops::Not;\n    use std::sync::{Arc, RwLock};\n\n    pub fn create_window() {\n        gtk::init().expect(\"Failed to initialize GTK\");\n\n        let window = Window::new(WindowType::Toplevel);\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n        let button = gtk::Button::new_with_label(\"Hello World! \");\n        window.add(&button);\n\n        let lock = Arc::new(RwLock::new(false));\n\n        let lock_button = lock.clone();\n        button.connect_clicked(move |_| {\n            let mut reverse = lock_button.write().unwrap();\n            *reverse = reverse.not();\n        });\n\n        let lock_thread = lock.clone();\n        gtk::timeout_add(100, move || {\n            let reverse = lock_thread.read().unwrap();\n            let mut text = button.get_label().unwrap();\n            let len = &text.len();\n\n            if *reverse {\n                let begin = &text.split_off(1);\n                text.insert_str(0, begin);\n            } else {\n                let end = &text.split_off(len - 1);\n                text.insert_str(0, end);\n            }\n\n            button.set_label(&text);\n\n            gtk::Continue(true)\n        });\n\n        window.show_all();\n        gtk::main();\n    }\n}\n\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::create_window();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}\n"
  },
  {
    "language": "Rust",
    "code": "fn fib(n: i64) -> Option<i64> {\n    // A function declared inside another function does not pollute the outer namespace.\n    fn actual_fib(n: i64) -> i64 {\n        if n < 2 {\n            n\n        } else {\n            actual_fib(n - 1) + actual_fib(n - 2)\n        }\n    }\n\n    if n < 0 {\n        None\n    } else {\n        Some(actual_fib(n))\n    }\n}\n\nfn main() {\n    println!(\"Fib(-1) = {:?}\", fib(-1));\n    println!(\"Fib(0) = {:?}\", fib(0));\n    println!(\"Fib(1) = {:?}\", fib(1));\n    println!(\"Fib(2) = {:?}\", fib(2));\n    println!(\"Fib(3) = {:?}\", fib(3));\n    println!(\"Fib(4) = {:?}\", fib(4));\n    println!(\"Fib(5) = {:?}\", fib(5));\n    println!(\"Fib(10) = {:?}\", fib(10));\n}\n\n#[test]\nfn test_fib() {\n    assert_eq!(fib(0).unwrap(), 0);\n    assert_eq!(fib(1).unwrap(), 1);\n    assert_eq!(fib(2).unwrap(), 1);\n    assert_eq!(fib(3).unwrap(), 2);\n    assert_eq!(fib(4).unwrap(), 3);\n    assert_eq!(fib(5).unwrap(), 5);\n    assert_eq!(fib(10).unwrap(), 55);\n}\n\n#[test]\nfn test_invalid_argument() {\n    assert_eq!(fib(-1), None);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::BufWriter;\nuse std::io::Result;\nuse std::io::Write;\nuse std::path::Path;\n\n/// Password record with all fields\n#[derive(Eq, PartialEq, Debug)]\npub struct PasswordRecord {\n    pub account: String,\n    pub password: String,\n    pub uid: u64,\n    pub gid: u64,\n    pub gecos: Vec<String>,\n    pub directory: String,\n    pub shell: String,\n}\n\n\nimpl PasswordRecord {\n    /// new instance, cloning all fields\n    pub fn new(\n        account: &str,\n        password: &str,\n        uid: u64,\n        gid: u64,\n        gecos: Vec<&str>,\n        directory: &str,\n        shell: &str,\n    ) -> PasswordRecord {\n        PasswordRecord {\n            account: account.to_string(),\n            password: password.to_string(),\n            uid,\n            gid,\n            gecos: gecos.iter().map(|s| s.to_string()).collect(),\n            directory: directory.to_string(),\n            shell: shell.to_string(),\n        }\n    }\n\n    /// convert to one line string\n    pub fn to_line(&self) -> String {\n        let gecos = self.gecos.join(\",\");\n        format!(\n            \"{}:{}:{}:{}:{}:{}:{}\",\n            self.account, self.password, self.uid, self.gid, gecos, self.directory, self.shell\n        )\n    }\n\n    /// read record from line\n    pub fn from_line(line: &str) -> PasswordRecord {\n        let sp: Vec<&str> = line.split(\":\").collect();\n        if sp.len() < 7 {\n            panic!(\"Less than 7 fields found\");\n        } else {\n            let uid = sp[2].parse().expect(\"Cannot parse uid\");\n            let gid = sp[3].parse().expect(\"Cannot parse gid\");\n            let gecos = sp[4].split(\",\").collect();\n            PasswordRecord::new(sp[0], sp[1], uid, gid, gecos, sp[5], sp[6])\n        }\n    }\n}\n\n/// read all records from file\npub fn read_password_file(file_name: &str) -> Result<Vec<PasswordRecord>> {\n    let p = Path::new(file_name);\n    if !p.exists() {\n        Ok(vec![])\n    } else {\n        let f = OpenOptions::new().read(true).open(p)?;\n        Ok(BufReader::new(&f)\n            .lines()\n            .map(|l| PasswordRecord::from_line(&l.unwrap()))\n            .collect())\n    }\n}\n\n/// overwrite file with records\npub fn overwrite_password_file(file_name: &str, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let f = OpenOptions::new()\n        .create(true)\n        .write(true)\n        .open(file_name)?;\n    write_records(f, recs)\n}\n\n/// append records to file\npub fn append_password_file(file_name: &str, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let f = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(file_name)?;\n    write_records(f, recs)\n}\n\n/// internal, write records line by line\nfn write_records(f: File, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let mut writer = BufWriter::new(f);\n    for rec in recs {\n        write!(writer, \"{}\\n\", rec.to_line())?;\n    }\n    Ok(())\n}\n\nfn main(){\n    let recs1 = vec![\n            PasswordRecord::new(\n                \"jsmith\",\n                \"x\",\n                1001,\n                1000,\n                vec![\n                    \"Joe Smith\",\n                    \"Room 1007\",\n                    \"(234)555-8917\",\n                    \"(234)555-0077\",\n                    \"jsmith@rosettacode.org\",\n                ],\n                \"/home/jsmith\",\n                \"/bin/bash\",\n            ),\n            PasswordRecord::new(\n                \"jdoe\",\n                \"x\",\n                1002,\n                1000,\n                vec![\n                    \"Jane Doe\",\n                    \"Room 1004\",\n                    \"(234)555-8914\",\n                    \"(234)555-0044\",\n                    \"jdoe@rosettacode.org\",\n                ],\n                \"/home/jdoe\",\n                \"/bin/bash\",\n            ),\n        ];\n\n    overwrite_password_file(\"passwd\", &recs1).expect(\"cannot write file\");\n    let recs2 = read_password_file(\"passwd\").expect(\"cannot read file\");\n    println!(\"Original file:\");\n    for r in recs2 {\n        println!(\"{}\",r.to_line());\n    }\n    let append0 = vec![PasswordRecord::new(\n            \"xyz\",\n            \"x\",\n            1003,\n            1000,\n            vec![\n                \"X Yz\",\n                \"Room 1003\",\n                \"(234)555-8913\",\n                \"(234)555-0033\",\n                \"xyz@rosettacode.org\",\n            ],\n            \"/home/xyz\",\n            \"/bin/bash\",\n        )];\n    append_password_file(\"passwd\", &append0).expect(\"cannot append to file\");\n    let recs2 = read_password_file(\"passwd\").expect(\"cannot read file\");\n    println!(\"\");\n    println!(\"Appended file:\");\n    for r in recs2 {\n        println!(\"{}\",r.to_line());\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn echo(n: &i32) {\n    println!(\"{}\", n);\n}\n\nfn main() {\n    let a: [i32; 5];\n    a = [1, 2, 3, 4, 5];\n    let _: Vec<_> = a.into_iter().map(echo).collect();\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate num;\nuse num::bigint::BigUint;\nuse num::FromPrimitive;\nuse num::pow::pow;\n\nfn main() {\n    let big = BigUint::from_u8(5).unwrap();\n    let answer_as_string = format!(\"{}\", pow(big,pow(4,pow(3,2))));\n\n      // The rest is output formatting.\n    let first_twenty: String = answer_as_string.chars().take(20).collect();\n    let last_twenty_reversed: Vec<char> = answer_as_string.chars().rev().take(20).collect();\n    let last_twenty: String = last_twenty_reversed.into_iter().rev().collect();\n    println!(\"Number of digits: {}\", answer_as_string.len());\n    println!(\"First and last digits: {:?}..{:?}\", first_twenty, last_twenty);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![feature(rustc_private)]\n\nextern crate arena;\n\nuse arena::TypedArena;\n\nfn main() {\n    // Memory is allocated using the default allocator (currently jemalloc).  The memory is\n    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that\n    // references to an arena don't become invalid when the original chunk runs out of space.  The\n    // chunk size is configurable as an argument to TypedArena::with_capacity if necessary.\n    let arena = TypedArena::new();\n\n    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is\n    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and\n    // can allocate only objects of one type.  The type is determined by type inference--if you try\n    // to allocate an integer, then Rust's compiler knows it is an integer arena.\n    let v1 = arena.alloc(1i32);\n\n    // TypedArena returns a mutable reference\n    let v2 = arena.alloc(3);\n    *v2 += 38;\n    println!(\"{}\", *v1 + *v2);\n\n    // The arena's destructor is called as it goes out of scope, at which point it deallocates\n    // everything stored within it at once.\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate num;\nuse num::complex::Complex;\n\nfn main() {\n    // two valid forms of definition\n    let a = Complex {re:-4.0, im: 5.0};\n    let b = Complex::new(1.0, 1.0);\n\n    println!(\"   a    = {}\", a);\n    println!(\"   b    = {}\", b);\n    println!(\" a + b  = {}\", a + b);\n    println!(\" a * b  = {}\", a * b);\n    println!(\" 1 / a  = {}\", a.inv());\n    println!(\"  -a    = {}\", -a);\n    println!(\"conj(a) = {}\", a.conj());\n}\n"
  },
  {
    "language": "Rust",
    "code": "//! Simple calculator parser and evaluator\n\n\n/// Binary operator\n#[derive(Debug)]\npub enum Operator {\n    Add,\n    Substract,\n    Multiply,\n    Divide\n}\n\n/// A node in the tree\n#[derive(Debug)]\npub enum Node {\n    Value(f64),\n    SubNode(Box<Node>),\n    Binary(Operator, Box<Node>,Box<Node>),\n}\n\n/// parse a string into a node\npub fn parse(txt :&str) -> Option<Node> {\n    let chars = txt.chars().filter(|c| *c != ' ').collect();\n    parse_expression(&chars, 0).map(|(_,n)| n)\n}\n\n/// parse an expression into a node, keeping track of the position in the character vector\nfn parse_expression(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)> {\n    match parse_start(chars, pos) {\n        Some((new_pos, first)) => {\n            match parse_operator(chars, new_pos) {\n                Some((new_pos2,op)) => {\n                    if let Some((new_pos3, second)) = parse_expression(chars, new_pos2) {\n                        Some((new_pos3, combine(op, first, second)))\n                    } else {\n                        None\n                    }\n                },\n                None => Some((new_pos,first)),\n            }\n        },\n        None => None,\n    }\n}\n\n/// combine nodes to respect associativity rules\nfn combine(op: Operator, first: Node, second: Node) -> Node {\n    match second {\n        Node::Binary(op2,v21,v22) => if precedence(&op)>=precedence(&op2) {\n            Node::Binary(op2,Box::new(combine(op,first,*v21)),v22)\n        } else {\n            Node::Binary(op,Box::new(first),Box::new(Node::Binary(op2,v21,v22)))\n        },\n        _ => Node::Binary(op,Box::new(first),Box::new(second)),\n    }\n}\n\n/// a precedence rank for operators\nfn precedence(op: &Operator) -> usize {\n    match op{\n        Operator::Multiply | Operator::Divide => 2,\n        _ => 1\n    }\n}\n\n/// try to parse from the start of an expression (either a parenthesis or a value)\nfn parse_start(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)> {\n    match start_parenthesis(chars, pos){\n        Some (new_pos) => {\n            let r = parse_expression(chars, new_pos);\n            end_parenthesis(chars, r)\n        },\n        None => parse_value(chars, pos),\n    }\n}\n\n/// match a starting parentheseis\nfn start_parenthesis(chars: &Vec<char>, pos: usize) -> Option<usize>{\n    if pos<chars.len() && chars[pos] == '(' {\n        Some(pos+1)\n    } else {\n        None\n    }\n}\n\n/// match an end parenthesis, if successful will create a sub node contained the wrapped expression\nfn end_parenthesis(chars: &Vec<char>, wrapped :Option<(usize,Node)>) -> Option<(usize,Node)>{\n    match wrapped {\n        Some((pos, node)) => if pos<chars.len() && chars[pos] == ')' {\n                Some((pos+1,Node::SubNode(Box::new(node))))\n            } else {\n                None\n            },\n        None => None,\n    }\n}\n\n/// parse a value: an decimal with an optional minus sign\nfn parse_value(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)>{\n    let mut new_pos = pos;\n    if new_pos<chars.len() && chars[new_pos] == '-' {\n        new_pos = new_pos+1;\n    }\n    while new_pos<chars.len() && (chars[new_pos]=='.' || (chars[new_pos] >= '0' && chars[new_pos] <= '9')) {\n        new_pos = new_pos+1;\n    }\n    if new_pos>pos {\n        if let Ok(v) = dbg!(chars[pos..new_pos].iter().collect::<String>()).parse() {\n            Some((new_pos,Node::Value(v)))\n        } else {\n            None\n        }\n    } else {\n        None\n    }\n\n}\n\n/// parse an operator\nfn parse_operator(chars: &Vec<char>, pos: usize) -> Option<(usize,Operator)> {\n    if pos<chars.len() {\n        let ops_with_char = vec!(('+',Operator::Add),('-',Operator::Substract),('*',Operator::Multiply),('/',Operator::Divide));\n        for (ch,op) in ops_with_char {\n            if chars[pos] == ch {\n                return Some((pos+1, op));\n            }\n        }\n    }\n    None\n}\n\n/// eval a string\npub fn eval(txt :&str) -> f64 {\n    match parse(txt) {\n        Some(t) => eval_term(&t),\n        None => panic!(\"Cannot parse {}\",txt),\n    }\n\n}\n\n/// eval a term, recursively\nfn eval_term(t: &Node) -> f64 {\n    match t {\n        Node::Value(v) => *v,\n        Node::SubNode(t) => eval_term(t),\n        Node::Binary(Operator::Add,t1,t2) => eval_term(t1) + eval_term(t2),\n        Node::Binary(Operator::Substract,t1,t2) => eval_term(t1) - eval_term(t2),\n        Node::Binary(Operator::Multiply,t1,t2) => eval_term(t1) * eval_term(t2),\n        Node::Binary(Operator::Divide,t1,t2) => eval_term(t1) / eval_term(t2),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eval(){\n        assert_eq!(2.0,eval(\"2\"));\n        assert_eq!(4.0,eval(\"2+2\"));\n        assert_eq!(11.0/4.0, eval(\"2+3/4\"));\n        assert_eq!(2.0, eval(\"2*3-4\"));\n        assert_eq!(3.0, eval(\"1+2*3-4\"));\n        assert_eq!(89.0/6.0, eval(\"2*(3+4)+5/6\"));\n        assert_eq!(14.0, eval(\"2 * (3 -1) + 2 * 5\"));\n        assert_eq!(7000.0, eval(\"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\"));\n        assert_eq!(-9.0/4.0, eval(\"2*-3--4+-.25\"));\n        assert_eq!(1.5, eval(\"1 - 5 * 2 / 20 + 1\"));\n        assert_eq!(3.5, eval(\"2 * (3 + ((5) / (7 - 11)))\"));\n\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "/// calculate pi with algebraic/geometric mean\npub fn pi(n: usize) -> f64 {\n    let mut a : f64 = 1.0;\n    let two : f64= 2.0;\n    let mut g = 1.0 / two.sqrt();\n    let mut s = 0.0;\n    let mut k = 1;\n    while k<=n  {\n\n        let a1 = (a+g)/two;\n        let g1 = (a*g).sqrt();\n        a = a1;\n        g = g1;\n        s += (a.powi(2)-g.powi(2)) * two.powi((k+1) as i32);\n        k += 1;\n\n\n    }\n\n    4.0 * a.powi(2) / (1.0-s)\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    println!(\"pi(7): {}\", pi(7));\n}\n"
  },
  {
    "language": "Rust",
    "code": "// Accepts two command line arguments\n// cargo run --name agm arg1 arg2\n\nfn main () {\n    let mut args = std::env::args();\n\n    let x = args.nth(1).expect(\"First argument not specified.\").parse::<f32>().unwrap();\n    let y = args.next().expect(\"Second argument not specified.\").parse::<f32>().unwrap();\n\n    let result = agm(x,y);\n    println!(\"The arithmetic-geometric mean is {}\", result);\n}\n\nfn agm (x: f32, y: f32) -> f32 {\n    let e: f32 = 0.000001;\n    let mut a = x;\n    let mut g = y;\n    let mut a1: f32;\n    let mut g1: f32;\n\n    if a * g < 0f32 { panic!(\"The arithmetric-geometric mean is undefined for numbers less than zero!\"); }\n    else {\n        loop {\n            a1 = (a + g) / 2.;\n            g1 = (a * g).sqrt();\n            a = a1;\n            g = g1;\n            if (a - g).abs() < e {  return a; }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::env;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    let a = args[1].parse::<i32>().unwrap();\n    let b = args[2].parse::<i32>().unwrap();\n\n    println!(\"sum:              {}\", a + b);\n    println!(\"difference:       {}\", a - b);\n    println!(\"product:          {}\", a * b);\n    println!(\"integer quotient: {}\", a / b); // truncates towards zero\n    println!(\"remainder:        {}\", a % b); // same sign as first operand\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::Ordering;\nuse std::ops::{Add, AddAssign, Sub, SubAssign, Mul, MulAssign, Div, DivAssign, Neg};\n\nfn gcd(a: i64, b: i64) -> i64 {\n    match b {\n        0 => a,\n        _ => gcd(b, a % b),\n    }\n}\n\nfn lcm(a: i64, b: i64) -> i64 {\n    a / gcd(a, b) * b\n}\n\n#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord)]\npub struct Rational {\n    numerator: i64,\n    denominator: i64,\n}\n\nimpl Rational {\n    fn new(numerator: i64, denominator: i64) -> Self {\n        let divisor = gcd(numerator, denominator);\n        Rational {\n            numerator: numerator / divisor,\n            denominator: denominator / divisor,\n        }\n    }\n}\n\nimpl Add for Rational {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        let multiplier = lcm(self.denominator, other.denominator);\n        Rational::new(self.numerator * multiplier / self.denominator +\n                      other.numerator * multiplier / other.denominator,\n                      multiplier)\n    }\n}\n\nimpl AddAssign for Rational {\n    fn add_assign(&mut self, other: Self) {\n        *self = *self + other;\n    }\n}\n\nimpl Sub for Rational {\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n        self + -other\n    }\n}\n\nimpl SubAssign for Rational {\n    fn sub_assign(&mut self, other: Self) {\n        *self = *self - other;\n    }\n}\n\nimpl Mul for Rational {\n    type Output = Self;\n\n    fn mul(self, other: Self) -> Self {\n        Rational::new(self.numerator * other.numerator,\n                      self.denominator * other.denominator)\n    }\n}\n\nimpl MulAssign for Rational {\n    fn mul_assign(&mut self, other: Self) {\n        *self = *self * other;\n    }\n}\n\nimpl Div for Rational {\n    type Output = Self;\n\n    fn div(self, other: Self) -> Self {\n        self *\n        Rational {\n            numerator: other.denominator,\n            denominator: other.numerator,\n        }\n    }\n}\n\nimpl DivAssign for Rational {\n    fn div_assign(&mut self, other: Self) {\n        *self = *self / other;\n    }\n}\n\nimpl Neg for Rational {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Rational {\n            numerator: -self.numerator,\n            denominator: self.denominator,\n        }\n    }\n}\n\nimpl PartialOrd for Rational {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        (self.numerator * other.denominator).partial_cmp(&(self.denominator * other.numerator))\n    }\n}\n\nimpl<T: Into<i64>> From<T> for Rational {\n    fn from(value: T) -> Self {\n        Rational::new(value.into(), 1)\n    }\n}\n\nfn main() {\n    let max = 1 << 19;\n    for candidate in 2..max {\n        let mut sum = Rational::new(1, candidate);\n        for factor in 2..(candidate as f64).sqrt().ceil() as i64 {\n            if candidate % factor == 0 {\n                sum += Rational::new(1, factor);\n                sum += Rational::new(1, candidate / factor);\n            }\n        }\n\n        if sum == 1.into() {\n            println!(\"{} is perfect\", candidate);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let a_vec = vec![1, 2, 3, 4, 5];\n    let b_vec = vec![6; 5];\n\n    let c_vec = concatenate_arrays(&a_vec, &b_vec);\n\n    println!(\"{:?} ~ {:?} => {:?}\", a_vec, b_vec, c_vec);\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    let mut concat = x.to_vec();\n    concat.extend_from_slice(y);\n\n    concat\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    x.iter().chain(y).cloned().collect()\n}\n"
  },
  {
    "language": "Rust",
    "code": "let a = [1, 2, 3]; // immutable array\nlet mut m = [1, 2, 3]; // mutable array\nlet zeroes = [0; 200]; // creates an array of 200 zeroes\n"
  },
  {
    "language": "Rust",
    "code": "let a = [1, 2, 3];\na.len();\nfor e in a.iter() {\n    e;\n}\n"
  },
  {
    "language": "Rust",
    "code": "let names = [\"Graydon\", \"Brian\", \"Niko\"];\nnames[1]; // second element\n"
  },
  {
    "language": "Rust",
    "code": "let v = vec![1, 2, 3];\n"
  },
  {
    "language": "Rust",
    "code": "let mut v = vec![1, 2, 3];\nv.push(4);\nv.len(); // 4\n"
  },
  {
    "language": "Rust",
    "code": "let x = 42;\nassert!(x == 42);\nassert_eq!(x, 42);\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    for (country, medals) in olympic_medals {\n        println!(\"{} has had {} gold medals, {} silver medals, and {} bronze medals\",\n               country, medals.0, medals.1, medals.2);\n\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate rand;\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::cmp;\nuse std::time::Duration;\n\nuse rand::Rng;\nuse rand::distributions::{IndependentSample, Range};\n\ntrait Buckets {\n    fn equalize<R:Rng>(&mut self, rng: &mut R);\n    fn randomize<R:Rng>(&mut self, rng: &mut R);\n    fn print_state(&self);\n}\n\nimpl Buckets for [i32] {\n    fn equalize<R:Rng>(&mut self, rng: &mut R) {\n        let range = Range::new(0,self.len()-1);\n        let src = range.ind_sample(rng);\n        let dst = range.ind_sample(rng);\n        if dst != src {\n            let amount = cmp::min(((dst + src) / 2) as i32, self[src]);\n            let multiplier = if amount >= 0 { -1 } else { 1 };\n            self[src] += amount * multiplier;\n            self[dst] -= amount * multiplier;\n        }\n    }\n    fn randomize<R:Rng>(&mut self, rng: &mut R) {\n        let ind_range = Range::new(0,self.len()-1);\n        let src = ind_range.ind_sample(rng);\n        let dst = ind_range.ind_sample(rng);\n        if dst != src {\n            let amount = cmp::min(Range::new(0,20).ind_sample(rng), self[src]);\n            self[src] -= amount;\n            self[dst] += amount;\n\n        }\n    }\n    fn print_state(&self) {\n        println!(\"{:?} = {}\", self, self.iter().sum::<i32>());\n    }\n}\n\nfn main() {\n    let e_buckets = Arc::new(Mutex::new([10; 10]));\n    let r_buckets = e_buckets.clone();\n    let p_buckets = e_buckets.clone();\n\n    thread::spawn(move || {\n        let mut rng = rand::thread_rng();\n        loop {\n            let mut buckets = e_buckets.lock().unwrap();\n            buckets.equalize(&mut rng);\n        }\n    });\n    thread::spawn(move || {\n        let mut rng = rand::thread_rng();\n        loop {\n            let mut buckets = r_buckets.lock().unwrap();\n            buckets.randomize(&mut rng);\n        }\n    });\n\n    let sleep_time = Duration::new(1,0);\n    loop {\n        {\n            let buckets = p_buckets.lock().unwrap();\n            buckets.print_state();\n        }\n        thread::sleep(sleep_time);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate rand;\n\nuse rand::{ThreadRng, thread_rng};\nuse rand::distributions::{IndependentSample, Range};\nuse std::collections::HashSet;\nuse std::env;\nuse std::process;\n\nfn help() {\n    println!(\"usage: average_loop_length <max_N> <trials>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut max_n: u32 = 20;\n    let mut trials: u32 = 1000;\n\n    match args.len() {\n        1 => {}\n        3 => {\n            max_n = args[1].parse::<u32>().unwrap();\n            trials = args[2].parse::<u32>().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let mut rng = thread_rng();\n\n    println!(\" N    average    analytical    (error)\");\n    println!(\"===  =========  ============  =========\");\n    for n in 1..(max_n + 1) {\n        let the_analytical = analytical(n);\n        let the_empirical = empirical(n, trials, &mut rng);\n        println!(\" {:>2}     {:3.4}        {:3.4}  ( {:>+1.2}%)\",\n                 n,\n                 the_empirical,\n                 the_analytical,\n                 100f64 * (the_empirical / the_analytical - 1f64));\n    }\n}\n\nfn factorial(n: u32) -> f64 {\n    (1..n + 1).fold(1f64, |p, n| p * n as f64)\n}\n\nfn analytical(n: u32) -> f64 {\n    let sum: f64 = (1..(n + 1))\n                       .map(|i| factorial(n) / (n as f64).powi(i as i32) / factorial(n - i))\n                       .fold(0f64, |a, v| a + v);\n    sum\n}\n\nfn empirical(n: u32, trials: u32, rng: &mut ThreadRng) -> f64 {\n    let sum: f64 = (0..trials)\n                       .map(|_t| {\n                           let mut item = 1u32;\n                           let mut seen = HashSet::new();\n                           let range = Range::new(1u32, n + 1);\n\n                           for step in 0..n {\n                               if seen.contains(&item) {\n                                   return step as f64;\n                               }\n                               seen.insert(item);\n                               item = range.ind_sample(rng);\n                           }\n                           n as f64\n                       })\n                       .fold(0f64, |a, v| a + v);\n    sum / trials as f64\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn sum(arr: &[f64]) -> f64 {\n    arr.iter().fold(0.0, |p,&q| p + q)\n}\n\nfn mean(arr: &[f64]) -> f64 {\n    sum(arr) / arr.len() as f64\n}\n\nfn main() {\n    let v = &[2.0, 3.0, 5.0, 7.0, 13.0, 21.0, 33.0, 54.0];\n    println!(\"mean of {:?}: {:?}\", v, mean(v));\n\n    let w = &[];\n    println!(\"mean of {:?}: {:?}\", w, mean(w));\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::f64;\n// the macro is from\n// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-\n// point-numbers-and-delta\nfn mean_angle(angles: &[f64]) -> f64 {\n    let length: f64 = angles.len() as f64;\n    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;\n    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;\n    (sin_mean).atan2(cos_mean).to_degrees()\n}\n\nfn main() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles1,\n             mean_angle(&angles1));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles2,\n             mean_angle(&angles2));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles3,\n             mean_angle(&angles3));\n}\n\nmacro_rules! assert_diff{\n    ($x: expr,$y : expr, $diff :expr)=>{\n        if ( $x - $y ).abs() > $diff {\n            panic!(\"floating point difference is to big {}\", $x - $y );\n        }\n    }\n}\n\n#[test]\nfn calculate() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    assert_diff!(0.0, mean_angle(&angles1), 0.001);\n    assert_diff!(-90.0, mean_angle(&angles2), 0.001);\n    assert_diff!(20.0, mean_angle(&angles3), 0.001);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn median(mut xs: Vec<f64>) -> f64 {\n    // sort in ascending order, panic on f64::NaN\n    xs.sort_by(|x,y| x.partial_cmp(y).unwrap() );\n    let n = xs.len();\n    if n % 2 == 0 {\n        (xs[n/2] + xs[n/2 - 1]) / 2.0\n    } else {\n        xs[n/2]\n    }\n}\n\nfn main() {\n    let nums = vec![2.,3.,5.,0.,9.,82.,353.,32.,12.];\n    println!(\"{:?}\", median(nums))\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashMap;\n\nfn main() {\n    let mode_vec1 = mode(vec![ 1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);\n    let mode_vec2 = mode(vec![ 1, 1, 2, 4, 4]);\n\n    println!(\"Mode of vec1 is: {:?}\", mode_vec1);\n    println!(\"Mode of vec2 is: {:?}\", mode_vec2);\n\n    assert!( mode_vec1 == [6], \"Error in mode calculation\");\n    assert!( (mode_vec2 == [1, 4]) || (mode_vec2 == [4,1]), \"Error in mode calculation\" );\n}\n\nfn mode(vs: Vec<i32>) -> Vec<i32> {\n    let mut vec_mode = Vec::new();\n    let mut seen_map = HashMap::new();\n    let mut max_val = 0;\n    for i in vs{\n        let ctr = seen_map.entry(i).or_insert(0);\n        *ctr += 1;\n        if *ctr > max_val{\n            max_val = *ctr;\n        }\n    }\n    for (key, val) in seen_map {\n        if val == max_val{\n            vec_mode.push(key);\n        }\n    }\n    vec_mode\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let mut sum = 0.0;\n    let mut prod = 1;\n    let mut recsum = 0.0;\n    for i in 1..11{\n        sum += i as f32;\n        prod *= i;\n        recsum += 1.0/(i as f32);\n    }\n    let avg = sum/10.0;\n    let gmean = (prod as f32).powf(0.1);\n    let hmean = 10.0/recsum;\n    println!(\"Average: {}, Geometric mean: {}, Harmonic mean: {}\", avg, gmean, hmean);\n    assert!( ( (avg >= gmean) && (gmean >= hmean) ), \"Incorrect calculation\");\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn root_mean_square(vec: Vec<i32>) -> f32 {\n    let sum_squares = vec.iter().fold(0, |acc, &x| acc + x.pow(2));\n    return ((sum_squares as f32)/(vec.len() as f32)).sqrt();\n}\n\nfn main() {\n    let vec = (1..11).collect();\n    println!(\"The root mean square is: {}\", root_mean_square(vec));\n}\n"
  },
  {
    "language": "Rust",
    "code": "struct SimpleMovingAverage {\n    period: usize,\n    numbers: Vec<usize>\n}\n\nimpl SimpleMovingAverage {\n    fn new(p: usize) -> SimpleMovingAverage {\n        SimpleMovingAverage {\n            period: p,\n            numbers: Vec::new()\n        }\n    }\n\n    fn add_number(&mut self, number: usize) -> f64 {\n        self.numbers.push(number);\n\n        if self.numbers.len() > self.period {\n            self.numbers.remove(0);\n        }\n\n        if self.numbers.is_empty() {\n            return 0f64;\n        }else {\n            let sum = self.numbers.iter().fold(0, |acc, x| acc+x);\n            return sum as f64 / self.numbers.len() as f64;\n        }\n    }\n}\n\nfn main() {\n    for period in [3, 5].iter() {\n        println!(\"Moving average with period {}\", period);\n\n        let mut sma = SimpleMovingAverage::new(*period);\n        for i in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1].iter() {\n            println!(\"Number: {} | Average: {}\", i, sma.add_number(*i));\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nstruct SimpleMovingAverage {\n    period: usize,\n    numbers: VecDeque<usize>\n}\n\nimpl SimpleMovingAverage {\n    fn new(p: usize) -> SimpleMovingAverage {\n        SimpleMovingAverage {\n            period: p,\n            numbers: VecDeque::new()\n        }\n    }\n\n    fn add_number(&mut self, number: usize) -> f64 {\n        self.numbers.push_back(number);\n\n        if self.numbers.len() > self.period {\n            self.numbers.pop_front();\n        }\n\n        if self.numbers.is_empty() {\n            return 0f64;\n        }else {\n            let sum = self.numbers.iter().fold(0, |acc, x| acc+x);\n            return sum as f64 / self.numbers.len() as f64;\n        }\n    }\n}\n\nfn main() {\n    for period in [3, 5].iter() {\n        println!(\"Moving average with period {}\", period);\n\n        let mut sma = SimpleMovingAverage::new(*period);\n        for i in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1].iter() {\n            println!(\"Number: {} | Average: {}\", i, sma.add_number(*i));\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate rand;\n\ntrait Balanced {\n    /// Returns true if the brackets are balanced\n    fn is_balanced(&self) -> bool;\n}\n\nimpl<'a> Balanced for str {\n    fn is_balanced(&self) -> bool {\n        let mut count = 0;\n\n        for bracket in self.chars() {\n            let change = match bracket {\n                '[' => 1,\n                ']' => -1,\n                _ => panic!(\"Strings should only contain brackets\")\n            };\n\n            count += change;\n            if count < 0 { return false; }\n        }\n\n        count == 0\n    }\n}\n\n/// Generates random brackets\nfn generate_brackets(num: usize) -> String {\n    use rand::random;\n\n    (0..num).map(|_| if random() { '[' } else { ']' }).collect()\n}\n\nfn main() {\n    for i in (0..10) {\n        let brackets = generate_brackets(i);\n\n        println!(\"{}    {}\", brackets, brackets.is_balanced())\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate num_traits;\nextern crate num;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num_traits::{Zero, One};\nuse std::collections::HashMap;\n\n// Return a vector of all fibonacci results from fib(1) to fib(n)\nfn fib(n: usize) -> Vec<BigInt> {\n    let mut result = Vec::with_capacity(n);\n    let mut a = BigInt::zero();\n    let mut b = BigInt::one();\n\n    result.push(b.clone());\n\n    for i in 1..n {\n        let t = b.clone();\n        b = a+b;\n        a = t;\n        result.push(b.clone());\n    }\n\n    result\n}\n\n// Return the first digit of a `BigInt`\nfn first_digit(x: &BigInt) -> u8 {\n    let zero = BigInt::zero();\n    assert!(x > &zero);\n\n    let s = x.to_str_radix(10);\n\n    // parse the first digit of the stringified integer\n    *&s[..1].parse::<u8>().unwrap()\n}\n\nfn main() {\n    const N: usize = 1000;\n    let mut counter: HashMap<u8, u32> = HashMap::new();\n    for x in fib(N) {\n        let d = first_digit(&x);\n        *counter.entry(d).or_insert(0) += 1;\n    }\n\n    println!(\"{:>13}    {:>10}\", \"real\", \"predicted\");\n    for y in 1..10 {\n        println!(\"{}: {:10.3} v. {:10.3}\", y, *counter.get(&y).unwrap_or(&0) as f32 / N as f32,\n        (1.0 + 1.0 / (y as f32)).log10());\n    }\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "// 2.5 implementations presented here:  naive, optimized, and an iterator using\n// the optimized function. The speeds vary significantly: relative\n// speeds of optimized:iterator:naive implementations is 625:25:1.\n\n#![feature(test)]\n\nextern crate num;\nextern crate test;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num::rational::{BigRational};\nuse std::cmp::max;\nuse std::env;\nuse std::ops::{Mul, Sub};\nuse std::process;\n\nstruct Bn {\n    value: BigRational,\n    index: i32\n}\n\nstruct Context {\n    bigone_const: BigInt,\n    a: Vec<BigRational>,\n    index: i32              // Counter for iterator implementation\n}\n\nimpl Context {\n    pub fn new() -> Context {\n        let bigone = 1.to_bigint().unwrap();\n        let a_vec: Vec<BigRational> = vec![];\n        Context {\n            bigone_const: bigone,\n            a: a_vec,\n            index: -1\n        }\n    }\n}\n\nimpl Iterator for Context {\n    type Item = Bn;\n\n    fn next(&mut self) -> Option<Bn> {\n        self.index += 1;\n        Some(Bn { value: bernoulli(self.index as usize, self), index: self.index })\n    }\n}\n\nfn help() {\n    println!(\"Usage: bernoulli_numbers <up_to>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut up_to: usize = 60;\n\n    match args.len() {\n        1 => {},\n        2 => {\n            up_to = args[1].parse::<usize>().unwrap();\n        },\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let context = Context::new();\n    // Collect the solutions by using the Context iterator\n    // (this is not as fast as calling the optimized function directly).\n    let res = context.take(up_to + 1).collect::<Vec<_>>();\n    let width = res.iter().fold(0, |a, r| max(a, r.value.numer().to_string().len()));\n\n    for r in res.iter().filter(|r| *r.value.numer() != ToBigInt::to_bigint(&0).unwrap()) {\n        println!(\"B({:>2}) = {:>2$} / {denom}\", r.index, r.value.numer(), width,\n            denom = r.value.denom());\n    }\n}\n\n// Implementation with no reused calculations.\nfn _bernoulli_naive(n: usize, c: &mut Context) -> BigRational {\n    for m in 0..n + 1 {\n        c.a.push(BigRational::new(c.bigone_const.clone(), (m + 1).to_bigint().unwrap()));\n        for j in (1..m + 1).rev() {\n            c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(\n                BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())\n            );\n        }\n    }\n    c.a[0].reduced()\n}\n\n// Implementation with reused calculations (does not require sequential calls).\nfn bernoulli(n: usize, c: &mut Context) -> BigRational {\n    for i in 0..n + 1 {\n        if i >= c.a.len() {\n            c.a.push(BigRational::new(c.bigone_const.clone(), (i + 1).to_bigint().unwrap()));\n            for j in (1..i + 1).rev() {\n                c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(\n                    BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())\n                );\n            }\n        }\n    }\n    c.a[0].reduced()\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::{Bn, Context, bernoulli, _bernoulli_naive};\n    use num::rational::{BigRational};\n    use std::str::FromStr;\n    use test::Bencher;\n\n    // [tests elided]\n\n    #[bench]\n    fn bench_bernoulli_naive(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = _bernoulli_naive(n, &mut context);\n                res.push(Bn { value:b.clone(), index: n as i32});\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = bernoulli(n, &mut context);\n                res.push(Bn { value:b.clone(), index: n as i32});\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli_iter(b: &mut Bencher) {\n        b.iter(|| {\n            let context = Context::new();\n            let _res = context.take(30 + 1).collect::<Vec<_>>();\n        });\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    for i in 0..8 {\n        println!(\"{:b}\", i)\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "let arr = [\"a\", \"bc\", \"def\", \"ghij\"];\narr.binary_search(&\"a\"); // Search lexicographically\narr.binary_search_by(|e| e.len().cmp(&1)); // Search by length\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::Ordering::*;\n\n//\n// This implementation fails the following test\n//\n#[test]\nfn binary_search_returns_none() {\n    let data = vec![1, 2, 3];\n    let target = 10;\n    assert_eq!(binary_search(&data, &target), None);\n}\n\n// Broken, didn't manage to debug sorry.\nfn binary_search<T: Ord>(arr: &[T], elem: &T) -> Option<usize>\n{\n    let mut size = arr.len();\n    let mut base = 0;\n\n    while size > 0 {\n        size /= 2;\n        let mid = base + size;\n        base = match arr[mid].cmp(elem) {\n            Less    => mid,\n            Greater => base,\n            Equal   => return Some(mid)\n        };\n    }\n\n    None\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::Ordering::*;\n\npub fn binary_search<T: Ord>(data: &[T], target: &T) -> Option<usize> {\n    let mut high = data.len();\n    let mut low = 0;\n    let mut mid = high / 2;\n\n    while low < high {\n        match target.cmp(&data[mid]) {\n            Less => high = mid - 1,\n            Greater => low = mid + 1,\n            Equal => return Some(mid),\n        };\n        mid = (high + low) / 2;\n    }\n    None\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str;\n\nfn main() {\n    // Create new string\n    let string = String::from(\"Hello world!\");\n    println!(\"{}\", string);\n    assert_eq!(string, \"Hello world!\", \"Incorrect string text\");\n\n    // Create and assign value to string\n    let mut assigned_str = String::new();\n    assert_eq!(assigned_str, \"\", \"Incorrect string creation\");\n    assigned_str += \"Text has been assigned!\";\n    println!(\"{}\", assigned_str);\n    assert_eq!(assigned_str, \"Text has been assigned!\",\"Incorrect string text\");\n\n    // String comparison, compared lexicographically byte-wise same as the asserts above\n    if string == \"Hello world!\" && assigned_str == \"Text has been assigned!\" {\n        println!(\"Strings are equal\");\n    }\n\n    // Cloning -> string can still be used after cloning\n    let clone_str = string.clone();\n    println!(\"String is:{}  and  Clone string is: {}\", string, clone_str);\n    assert_eq!(clone_str, string, \"Incorrect string creation\");\n\n    // Copying, string won't be usable anymore, accessing it will cause compiler failure\n    let copy_str = string;\n    println!(\"String copied now: {}\", copy_str);\n\n    // Check if string is empty\n    let empty_str = String::new();\n    assert!(empty_str.is_empty(), \"Error, string should be empty\");\n\n    // Append byte, Rust strings are a stream of UTF-8 bytes\n    let byte_vec = [65]; // contains A\n    let byte_str = str::from_utf8(&byte_vec).unwrap();\n    assert_eq!(byte_str, \"A\", \"Incorrect byte append\");\n\n    // Substrings can be accessed through slices\n    let test_str = \"Blah String\";\n    let mut sub_str = &test_str[0..11];\n    assert_eq!(sub_str, \"Blah String\", \"Error in slicing\");\n    sub_str = &test_str[1..5];\n    assert_eq!(sub_str, \"lah \", \"Error in slicing\");\n    sub_str = &test_str[3..];\n    assert_eq!(sub_str, \"h String\", \"Error in slicing\");\n    sub_str = &test_str[..2];\n    assert_eq!(sub_str, \"Bl\", \"Error in slicing\");\n\n    // String replace, note string is immutable\n    let org_str = \"Hello\";\n    assert_eq!(org_str.replace(\"l\", \"a\"), \"Heaao\", \"Error in replacement\");\n    assert_eq!(org_str.replace(\"ll\", \"r\"), \"Hero\", \"Error in replacement\");\n\n    // Joining strings requires a `String` and an &str or a two `String`s one of which needs an & for coercion\n    let str1 = \"Hi\";\n    let str2 = \" There\";\n    let fin_str = str1.to_string() + str2;\n    assert_eq!(fin_str, \"Hi There\", \"Error in concatenation\");\n\n    // Joining strings requires a `String` and an &str or two `Strings`s, one of which needs an & for coercion\n    let str1 = \"Hi\";\n    let str2 = \" There\";\n    let fin_str = str1.to_string() + str2;\n    assert_eq!(fin_str, \"Hi There\", \"Error in concatenation\");\n\n    // Splits -- note Rust supports passing patterns to splits\n    let f_str = \"Pooja and Sundar are up in Tumkur\";\n    let split_str: Vec<_> = f_str.split(' ').collect();\n    assert_eq!(split_str, [\"Pooja\", \"and\", \"Sundar\", \"are\", \"up\", \"in\", \"Tumkur\"], \"Error in string split\");\n}\n"
  },
  {
    "language": "Swift",
    "code": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* do the 100 passes */\nfor i in 1...100 {\n    /* map on a strideTo instance to only visit the needed doors on each iteration */\n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* set i^2 doors to opened */\nvar i = 1\ndo {\n    doorsStateList[(i*i)-1] = DoorState.Opened\n    ++i\n} while (i*i) <= doorsStateList.count\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits : \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n// check value of expression provided by the operator\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n\n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n\n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n\n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n\n\n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n\n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n\n        for oper in opr {\n          expression += oper\n        }\n\n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n// n=4, total=64, npow=16\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n\n  var solution = \"\"\n\n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n\n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits : \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n// check value of expression provided by the operator\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet input = FileHandle.standardInput\n\nlet data = input.availableData\nlet str = String(data: data, encoding: .utf8)!\nlet nums = str.split(separator: \" \")\n    .map { String($0.unicodeScalars\n        .filter { CharacterSet.decimalDigits.contains($0) }) }\n\nlet a = Int(nums[0])!\nlet b = Int(nums[1])!\n\nprint(\" \\(a + b)\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Swift\n\nfunc canMake(word: String) -> Bool {\n\tvar blocks = [\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t]\n\t\n\tfor letter in word.uppercased().characters {\n\t\tguard let index = blocks.index(where: { $0.characters.contains(letter) }) else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tblocks.remove(at: index)\n\t}\n\t\n\treturn true\n}\n\nlet words = [\"a\", \"bARK\", \"boOK\", \"TreAt\", \"CoMmon\", \"SquAd\", \"CONFUse\"]\n\nwords.forEach { print($0, canMake(word: $0)) }\n"
  },
  {
    "language": "Swift",
    "code": "var deficients = 0 // sumPd < n\nvar perfects = 0 // sumPd = n\nvar abundants = 0 // sumPd > n\n\n// 1 is deficient (no proper divisor)\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 // 1 is a proper divisor of all integer above 1\n\n    var maxPdToTest = i/2 // the max divisor to test\n\n    for var j = 2; j < maxPdToTest; j++ {\n\n        if (i%j) == 0 {\n            // j is a proper divisor\n            sumPd += j\n\n            // New maximum for divisibility check\n            maxPdToTest = i / j\n\n            // To add to sum of proper divisors unless already done\n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n\n    // Select type according to sum of Proper divisors\n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n"
  },
  {
    "language": "Swift",
    "code": "func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n"
  },
  {
    "language": "Swift",
    "code": "func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "// For NSObject, NSTimeInterval and NSThread\nimport Foundation\n// For PI and sin\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n\n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n\n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n\n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n\n    func Output() -> Double {\n        return S\n    }\n\n}\n\n// main\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n\n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet fooKey = UnsafeMutablePointer<UInt8>.alloc(1)\n\nclass MyClass { }\nlet e = MyClass()\n\n// set\nobjc_setAssociatedObject(e, fooKey, 1, .OBJC_ASSOCIATION_RETAIN)\n\n// get\nif let associatedObject = objc_getAssociatedObject(e, fooKey) {\n  print(\"associated object: \\(associatedObject)\")\n} else {\n  print(\"no associated object\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "class MyClass { }\n\nfunc printAddress<T>(of pointer: UnsafePointer<T>) {\n    print(pointer)\n}\n\nfunc test() {\n    var x = 42\n    var y = 3.14\n    var z = \"foo\"\n    var obj = MyClass()\n\n    // Use a pointer to a variable on the stack and print its address.\n    withUnsafePointer(to: &x)   { print($0) }\n    withUnsafePointer(to: &y)   { print($0) }\n    withUnsafePointer(to: &z)   { print($0) }\n    withUnsafePointer(to: &obj) { print($0) }\n\n    // Alternately:\n    printAddress(of: &x)\n    printAddress(of: &y)\n    printAddress(of: &z)\n    printAddress(of: &obj)\n\n    // Printing the address of an object that an object reference points to.\n    print(Unmanaged.passUnretained(obj).toOpaque())\n}\n\ntest()\n"
  },
  {
    "language": "Swift",
    "code": "func polynomialCoeffs(n: Int) -> [Int] {\n    var result = [Int](count : n+1, repeatedValue : 0)\n\n    result[0]=1\n    for i in 1 ..< n/2+1 { //Progress up, until reaching the middle value\n        result[i] = result[i-1] * (n-i+1)/i;\n    }\n    for i in n/2+1 ..< n+1 { //Copy the inverse of the first part\n        result[i] = result[n-i];\n    }\n    // Take into account the sign\n    for i in stride(from: 1, through: n, by: 2) {\n        result[i] = -result[i]\n    }\n\n    return result\n}\n\nfunc isPrime(n: Int) -> Bool {\n\n    var coeffs = polynomialCoeffs(n)\n\n    coeffs[0]--\n    coeffs[n]++\n\n    for i in 1 ... n {\n        if coeffs[i]%n != 0 {\n            return false\n        }\n    }\n\n    return true\n}\n\nfor i in 0...10 {\n\n    let coeffs = polynomialCoeffs(i)\n\n    print(\"(x-1)^\\(i) = \")\n    if i == 0 {\n        print(\"1\")\n    } else {\n        if i == 1 {\n            print(\"x\")\n        } else {\n            print(\"x^\\(i)\")\n            if i == 2 {\n                print(\"\\(coeffs[i-1])x\")\n            } else {\n                for j in 1...(i - 2) {\n                    if j%2 == 0 {\n                        print(\"+\\(coeffs[j])x^\\(i-j)\")\n                    } else {\n                        print(\"\\(coeffs[j])x^\\(i-j)\")\n                    }\n                }\n                if (i-1)%2 == 0 {\n                    print(\"+\\(coeffs[i-1])x\")\n                } else {\n                    print(\"\\(coeffs[i-1])x\")\n                }\n            }\n        }\n        if i%2 == 0 {\n            print(\"+\\(coeffs[i])\")\n        } else {\n            print(\"\\(coeffs[i])\")\n        }\n    }\n    println()\n}\n\nprintln()\nprint(\"Primes under 50 : \")\n\nfor i in 1...50 {\n    if isPrime(i) {\n        print(\"\\(i) \")\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n\n    if n == 1 { return [] }\n\n    var result = [Int]()\n\n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n\n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n\n    return sorted(result)\n\n}\n\n\nfunc sumDivs(n:Int) -> Int {\n\n    struct Cache { static var sum = [Int:Int]() }\n\n    if let sum = Cache.sum[n] { return sum }\n\n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n\n    Cache.sum[n] = sum\n\n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n\n    if n == m { return false }\n\n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n\n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc sigma(n: Int) -> Int {\n\n    if n == 1 { return 0 }          // definition of aliquot sum\n\n    var result = 1\n    let root = sqrt(n)\n\n    for var div = 2; div <= root; ++div {\n        if n % div == 0 {\n            result += div + n/div\n        }\n\n    }\n    if root*root == n { result -= root }\n\n    return (result)\n}\n\nfunc amicables (upTo: Int) -> () {\n\n    var aliquot = Array(count: upTo+1, repeatedValue: 0)\n\n    for i in 1 ... upTo {           // fill lookup array\n        aliquot[i] = sigma(i)\n    }\n\n for i in 1 ... upTo {\n        let a = aliquot[i]\n        if a > upTo {continue}      //second part of pair out-of-bounds\n\n        if a == i {continue}        //skip perfect numbers\n\n        if i == aliquot[a] {\n            print(\"\\(i, a)\")\n            aliquot[a] = upTo+1     //prevent second display of pair\n        }\n    }\n}\n\namicables(20_000)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet wordsURL = NSURL(string: \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")!\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords//[0..<100] // used to limit the size while testing\n\nextension String {\n    var charactersAscending : String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n\n    var knownwords = charsToWords[chars] ?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let fib: Int -> Int = {\n  func f(n: Int) -> Int {\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprint(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "let fib: Int -> Int = {\n  var f: (Int -> Int)!\n  f = { n in\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprintln(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nfunc fib(n: Int) -> Int {\n  assert(n >= 0, \"fib: no negative numbers\")\n  return y {f in {n in n < 2 ? 1 : f(n-1) + f(n-2)}} (n)\n}\n\nprintln(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "func square(n: Int) -> Int {\n    return n * n\n}\n\nlet numbers = [1, 3, 5, 7]\n\nlet squares1a = numbers.map(square)         // map method on array\n\nlet squares1b = numbers.map {x in x*x}      // map method on array with anonymous function\n\nlet squares1b = numbers.map { $0 * $0 }      // map method on array with anonymous function and unnamed parameters\n\nlet isquares1 = numbers.lazy.map(square)   // lazy sequence\n"
  },
  {
    "language": "Swift",
    "code": "public struct Complex {\n\n    public let real : Double\n    public let imaginary : Double\n\n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n\n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n\n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n\n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n\n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n\n}\npublic func + (left: Complex, right: Complex) -> Complex {\n\n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n\n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n// Checking equality is almost necessary for a struct of this type  to be useful\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n"
  },
  {
    "language": "Swift",
    "code": "extension Complex : CustomStringConvertible {\n\n    public var description : String {\n\n        guard real != 0 || imaginary != 0 else { return \"0\" }\n\n        let rs : String = real != 0 ? \"\\(real)\" : \"\"\n        let iS : String\n        let sign : String\n        let iSpace = real != 0 ? \" \" : \"\"\n        switch imaginary {\n        case let i where i < 0:\n            sign = \"-\"\n            iS = i == -1 ? \"i\" : \"\\(-i)i\"\n        case let i where i > 0:\n            sign = real != 0 ? \"+\" : \"\"\n            iS = i == 1 ? \"i\" : \"\\(i)i\"\n        default:\n            sign = \"\"\n            iS = \"\"\n        }\n        return \"\\(rs)\\(iSpace)\\(sign)\\(iSpace)\\(iS)\"\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "public func - (left:Complex, right:Complex) -> Complex {\n    return left + -right\n}\n\npublic func / (divident:Complex, divisor:Complex) -> Complex {\n    let rc = divisor.conjugate\n    let num = divident * rc\n    let den = divisor * rc\n    return Complex(real: num.real/den.real, imaginary: num.imaginary/den.real)\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let a = 6\nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func gcd(with other: Self) -> Self {\n    var gcd = self\n    var b = other\n\n    while b != 0 {\n      (gcd, b) = (b, gcd % b)\n    }\n\n    return gcd\n  }\n\n  @inlinable\n  public func lcm(with other: Self) -> Self {\n    let g = gcd(with: other)\n\n    return self / g * other\n  }\n}\n\npublic struct Frac<NumType: BinaryInteger & SignedNumeric>: Equatable {\n  @usableFromInline\n  var _num: NumType\n\n  @usableFromInline\n  var _dom: NumType\n\n  @usableFromInline\n  init(_num: NumType, _dom: NumType) {\n    self._num = _num\n    self._dom = _dom\n  }\n\n  @inlinable\n  public init(numerator: NumType, denominator: NumType) {\n    let divisor = numerator.gcd(with: denominator)\n\n    self._num = numerator / divisor\n    self._dom = denominator / divisor\n  }\n\n  @inlinable\n  public static func + (lhs: Frac, rhs: Frac) -> Frac {\n    let multiplier = lhs._dom.lcm(with: rhs.denominator)\n\n    return Frac(\n      numerator: lhs._num * multiplier / lhs._dom + rhs._num * multiplier / rhs._dom,\n      denominator: multiplier\n    )\n  }\n\n  @inlinable\n  public static func += (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + rhs\n  }\n\n  @inlinable\n  public static func - (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs + -rhs\n  }\n\n  @inlinable\n  public static func -= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + -rhs\n  }\n\n  @inlinable\n  public static func * (lhs: Frac, rhs: Frac) -> Frac {\n    return Frac(numerator: lhs._num * rhs._num, denominator: lhs._dom * rhs._dom)\n  }\n\n  @inlinable\n  public static func *= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs * rhs\n  }\n\n  @inlinable\n  public static func / (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs * Frac(_num: rhs._dom, _dom: rhs._num)\n  }\n\n  @inlinable\n  public static func /= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs / rhs\n  }\n\n  @inlinable\n  prefix static func - (rhs: Frac) -> Frac {\n    return Frac(_num: -rhs._num, _dom: rhs._dom)\n  }\n}\n\nextension Frac {\n  @inlinable\n  public var numerator: NumType {\n    get { _num }\n    set {\n      let divisor = newValue.gcd(with: denominator)\n\n      _num = newValue / divisor\n      _dom = denominator / divisor\n    }\n  }\n\n  @inlinable\n  public var denominator: NumType {\n    get { _dom }\n    set {\n      let divisor = newValue.gcd(with: numerator)\n\n      _num = numerator / divisor\n      _dom = newValue / divisor\n    }\n  }\n}\n\nextension Frac: CustomStringConvertible {\n  public var description: String {\n    let neg = numerator < 0 || denominator < 0\n\n    return \"Frac(\\(neg ? \"-\" : \"\")\\(abs(numerator)) / \\(abs(denominator)))\"\n  }\n}\n\nextension Frac: Comparable {\n  @inlinable\n  public static func <(lhs: Frac, rhs: Frac) -> Bool {\n    return lhs._num * rhs._dom < lhs._dom * rhs._num\n  }\n}\n\nextension Frac: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) {\n    self._num = NumType(value)\n    self._dom = 1\n  }\n}\n\n\nfor candidate in 2..<1<<19 {\n  var sum = Frac(numerator: 1, denominator: candidate)\n\n  let m = Int(ceil(Double(candidate).squareRoot()))\n\n  for factor in 2..<m where candidate % factor == 0 {\n    sum += Frac(numerator: 1, denominator: factor)\n    sum += Frac(numerator: 1, denominator: candidate / factor)\n  }\n\n  if sum == 1 {\n    print(\"\\(candidate) is perfect\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n"
  },
  {
    "language": "Swift",
    "code": "// Arrays are typed in Swift, however, using the Any object we can add any type. Swift does not support fixed length arrays\nvar anyArray = [Any]()\nanyArray.append(\"foo\") // Adding to an Array\nanyArray.append(1) // [\"foo\", 1]\nanyArray.removeAtIndex(1) // Remove object\nanyArray[0] = \"bar\" // [\"bar\"]\n"
  },
  {
    "language": "Swift",
    "code": "var a = 5\n//...input or change a here\nassert(a == 42) // aborts program when a is not 42\nassert(a == 42, \"Error message\") // aborts program\n       // when a is not 42 with \"Error message\" for the message\n       // the error message must be a static string\n"
  },
  {
    "language": "Swift",
    "code": "// make an empty map\nvar a = [String: Int]()\n// or\nvar b: [String: Int] = [:]\n\n// make an empty map with an initial capacity\nvar c = [String: Int](minimumCapacity: 42)\n\n// set a value\nc[\"foo\"] = 3\n\n// make a map with a literal\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n"
  },
  {
    "language": "Swift",
    "code": "let myMap = [\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 ]\n\n// iterating over key-value pairs:\nfor (key, value) in myMap {\n    println(\"key = \\(key), value = \\(value)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfinal class AtomicBuckets: CustomStringConvertible {\n  var count: Int {\n    return buckets.count\n  }\n\n  var description: String {\n    return withBucketsLocked { \"\\(buckets)\" }\n  }\n\n  var total: Int {\n    return withBucketsLocked { buckets.reduce(0, +) }\n  }\n\n  private let lock = DispatchSemaphore(value: 1)\n\n  private var buckets: [Int]\n\n  subscript(n: Int) -> Int {\n    return withBucketsLocked { buckets[n] }\n  }\n\n  init(with buckets: [Int]) {\n    self.buckets = buckets\n  }\n\n  func transfer(amount: Int, from: Int, to: Int) {\n    withBucketsLocked {\n      let transferAmount = buckets[from] >= amount ? amount : buckets[from]\n\n      buckets[from] -= transferAmount\n      buckets[to] += transferAmount\n    }\n  }\n\n  private func withBucketsLocked<T>(do: () -> T) -> T {\n    let ret: T\n\n    lock.wait()\n    ret = `do`()\n    lock.signal()\n\n    return ret\n  }\n}\n\nlet bucks = AtomicBuckets(with: [21, 39, 40, 20])\nlet order = DispatchSource.makeTimerSource()\nlet chaos = DispatchSource.makeTimerSource()\nlet printer = DispatchSource.makeTimerSource()\n\nprinter.setEventHandler {\n  print(\"\\(bucks) = \\(bucks.total)\")\n}\n\nprinter.schedule(deadline: .now(), repeating: .seconds(1))\nprinter.activate()\n\norder.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n  let (v1, v2) = (bucks[b1], bucks[b2])\n\n  guard v1 != v2 else {\n    return\n  }\n\n  if v1 > v2 {\n    bucks.transfer(amount: (v1 - v2) / 2, from: b1, to: b2)\n  } else {\n    bucks.transfer(amount: (v2 - v1) / 2, from: b2, to: b1)\n  }\n}\n\norder.schedule(deadline: .now(), repeating: .milliseconds(5))\norder.activate()\n\nchaos.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n\n  bucks.transfer(amount: Int.random(in: 0..<(bucks[b1] + 1)), from: b1, to: b2)\n}\n\nchaos.schedule(deadline: .now(), repeating: .milliseconds(5))\nchaos.activate()\n\ndispatchMain()\n"
  },
  {
    "language": "Swift",
    "code": "func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n"
  },
  {
    "language": "Swift",
    "code": "// Extend the Collection protocol. Any type that conforms to extension where its Element type conforms to Hashable will automatically gain this method.\nextension Collection where Element: Hashable {\n\n    /// Return a Mode of the function, or nil if none exist.\n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        // Standard for loop. Can also use the forEach(_:) or reduce(into:) methods on self.\n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        // The max(by:) method used here to find one of the elements with the highest associated count.\n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() // returns \"a\"\n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() // returns 3\n\nlet emptyArray: [Int] = []\nemptyArray.mode() // returns nil\n"
  },
  {
    "language": "Swift",
    "code": "extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n"
  },
  {
    "language": "Swift",
    "code": "struct SimpleMovingAverage {\n  var period: Int\n  var numbers = [Double]()\n\n  mutating func addNumber(_ n: Double) -> Double {\n    numbers.append(n)\n\n    if numbers.count > period {\n      numbers.removeFirst()\n    }\n\n    guard !numbers.isEmpty else {\n      return 0\n    }\n\n    return numbers.reduce(0, +) / Double(numbers.count)\n  }\n}\n\nfor period in [3, 5] {\n  print(\"Moving average with period \\(period)\")\n\n  var averager = SimpleMovingAverage(period: period)\n\n  for n in [1.0, 2, 3, 4, 5, 5, 4, 3, 2, 1] {\n    print(\"n: \\(n); average \\(averager.addNumber(n))\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc isBal(str: String) -> Bool {\n\n  var count = 0\n\n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n\n}\n"
  },
  {
    "language": "Swift",
    "code": "isBal(\"[[[]]]\") // true\n\nisBal(\"[]][[]\") // false\n"
  },
  {
    "language": "Swift",
    "code": "func randBrack(n: Int) -> String {\n\n  var bracks: [Character] = Array(Repeat(count: n, repeatedValue: \"[\"))\n\n  for i in UInt32(n+1)...UInt32(n + n) {\n\n    bracks.insert(\"]\", atIndex: Int(arc4random_uniform(i)))\n\n  }\n\n  return String(bracks)\n\n}\n"
  },
  {
    "language": "Swift",
    "code": "randBrack(2) // \"]][[\"\n"
  },
  {
    "language": "Swift",
    "code": "func randIsBal(n: Int) {\n\n  let (bal, un) = (\"\", \"un\")\n\n  for str in (1...n).map(randBrack) {\n\n    print(\"\\(str) is \\(isBal(str) ? bal : un)balanced\\n\")\n\n  }\n}\n\nrandIsBal(4)\n"
  },
  {
    "language": "Swift",
    "code": "//    ][ is unbalanced\n//\n//    ]][[ is unbalanced\n//\n//    []][[] is unbalanced\n//\n//    [][][[]] is balanced\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n/* Reads from a file and returns the content as a String */\nfunc readFromFile(fileName file:String) -> String{\n\n    var ret:String = \"\"\n\n    let path = Foundation.URL(string: \"file://\"+file)\n\n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n\n    return ret\n}\n\n/* Calculates the probability following Benford's law */\nfunc benford(digit z:Int) -> Double {\n\n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n\n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n// get CLI input\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n// Read from given file and parse into lines\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n// check digits line by line\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n\n}\n\n// print result\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n"
  },
  {
    "language": "Swift",
    "code": "import BigInt\n\npublic func bernoulli<T: BinaryInteger & SignedNumeric>(n: Int) -> Frac<T> {\n  guard n != 0 else {\n    return 1\n  }\n\n  var arr = [Frac<T>]()\n\n  for m in 0...n {\n    arr.append(Frac(numerator: 1, denominator: T(m) + 1))\n\n    for j in stride(from: m, through: 1, by: -1) {\n      arr[j-1] = (arr[j-1] - arr[j]) * Frac(numerator: T(j), denominator: 1)\n    }\n  }\n\n  return arr[0]\n}\n\nfor n in 0...60 {\n  let b = bernoulli(n: n) as Frac<BigInt>\n\n  guard b != 0 else {\n    continue\n  }\n\n  print(\"B(\\(n)) = \\(b)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n"
  },
  {
    "language": "Swift",
    "code": "func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var recurse: ((Int, Int) -> Int?)!\n  recurse = {(low, high) in switch (low + high) / 2 {\n    case _ where high < low: return nil\n    case let mid where xs[mid] > x: return recurse(low, mid - 1)\n    case let mid where xs[mid] < x: return recurse(mid + 1, high)\n    case let mid: return mid\n  }}\n  return recurse(0, xs.count - 1)\n}\n"
  },
  {
    "language": "Swift",
    "code": "func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var (low, high) = (0, xs.count - 1)\n  while low <= high {\n    switch (low + high) / 2 {\n      case let mid where xs[mid] > x: high = mid - 1\n      case let mid where xs[mid] < x: low = mid + 1\n      case let mid: return mid\n    }\n  }\n  return nil\n}\n"
  },
  {
    "language": "Swift",
    "code": "func testBinarySearch(n: Int) {\n  let odds = Array(stride(from: 1, through: n, by: 2))\n  let result = flatMap(0...n) {binarySearch(odds, $0)}\n  assert(result == Array(0..<odds.count))\n  println(\"\\(odds) are odd natural numbers\")\n  for it in result {\n    println(\"\\(it) is ordinal of \\(odds[it])\")\n  }\n}\n\ntestBinarySearch(12)\n\nfunc flatMap<T, U>(source: [T], transform: (T) -> U?) -> [U] {\n  return source.reduce([]) {(var xs, x) in if let x = transform(x) {xs.append(x)}; return xs}\n}\n"
  },
  {
    "language": "Swift",
    "code": "func bitwise(a: Int, b: Int) {\n  // All bitwise operations (including shifts)\n  // require both operands to be the same type\n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") // left shift\n  // for right shifts, if the operands are unsigned, Swift performs\n  // a logical shift; if signed, an arithmetic shift.\n  println(\"a >> b: \\(a >> b)\") // arithmetic right shift\n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") // logical right shift\n}\n\nbitwise(-15,3)\n"
  },
  {
    "language": "Swift",
    "code": "struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc generateRandomNumArray(numDigits: Int = 4) -> [Int] {\n  guard numDigits > 0 else {\n    return []\n  }\n\n  let needed =  min(9, numDigits)\n  var nums = Set<Int>()\n\n  repeat {\n    nums.insert(.random(in: 1...9))\n  } while nums.count != needed\n\n  return Array(nums)\n}\n\nfunc parseGuess(_ guess: String) -> [Int]? {\n  guard guess.count == 4 else {\n    return nil\n  }\n\n  let guessArray = guess.map(String.init).map(Int.init).compactMap({ $0 })\n\n  guard Set(guessArray).count == 4 else {\n    return nil\n  }\n\n  return guessArray\n}\n\nwhile true {\n  let num = generateRandomNumArray()\n  var bulls = 0\n  var cows = 0\n\n  print(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  guard let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr) else {\n    print(\"Invalid input\")\n    continue\n  }\n\n  for (guess, actual) in zip(guess, num) {\n    if guess == actual {\n      bulls += 1\n    } else if num.contains(guess) {\n      cows += 1\n    }\n  }\n\n  print(\"Actual number: \\(num.map(String.init).joined())\")\n  print(\"Your score: \\(bulls) bulls and \\(cows) cows\\n\")\n  print(\"Would you like to play again? (y): \")\n\n  guard readLine(strippingNewline: true)!.lowercased() == \"y\" else {\n    exit(0)\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) // '-' = 45\n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  // if '-', set it to 'a'-1\n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } // if larget than 'z', reduce by 27\n  if 96 == cv { cv = 45 }  // restore '-'\n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet hello = \"Hello, World!\"\nlet fromC = strdup(hello)\nlet backToSwiftString = String.fromCString(fromC)\n"
  },
  {
    "language": "Swift",
    "code": "// call a function with no args\nnoArgs()\n\n// call a function with one arg with no external name\noneArgUnnamed(1)\n\n// call a function with one arg with external name\noneArgNamed(arg: 1)\n\n// call a function with two args with no external names\ntwoArgsUnnamed(1, 2)\n\n// call a function with two args and external names\ntwoArgsNamed(arg1: 1, arg2: 2)\n\n// call a function with an optional arg\n// with arg\noptionalArguments(arg: 1)\n// without\noptionalArguments() // defaults to 0\n\n// function that takes another function as arg\nfuncArg(noArgs)\n\n// variadic function\nvariadic(opts: \"foo\", \"bar\")\n\n// getting a return value\nlet foo = returnString()\n\n// getting a bunch of return values\nlet (foo, bar, baz) = returnSomeValues()\n\n// getting a bunch of return values, discarding second returned value\nlet (foo, _, baz) = returnSomeValues()\n"
  },
  {
    "language": "Swift",
    "code": "// Class\nMyClass.method(someParameter)\n// or equivalently:\nlet foo = MyClass.self\nfoo.method(someParameter)\n\n// Instance\nmyInstance.method(someParameter)\n\n// Method with multiple arguments\nmyInstance.method(red:arg1, green:arg2, blue:arg3)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func carmichael<T: BinaryInteger & SignedNumeric>(p1: T) -> [(T, T, T)] {\n  func mod(_ n: T, _ m: T) -> T { (n % m + m) % m }\n\n  var res = [(T, T, T)]()\n\n  guard p1.isPrime else {\n    return res\n  }\n\n  for h3 in stride(from: 2, to: p1, by: 1) {\n    for d in stride(from: 1, to: h3 + p1, by: 1) {\n      if (h3 + p1) * (p1 - 1) % d != 0 || mod(-p1 * p1, h3) != d % h3 {\n        continue\n      }\n\n      let p2 = 1 + (p1 - 1) * (h3 + p1) / d\n\n      guard p2.isPrime else {\n        continue\n      }\n\n      let p3 = 1 + p1 * p2 / h3\n\n      guard p3.isPrime && (p2 * p3) % (p1 - 1) == 1 else {\n        continue\n      }\n\n      res.append((p1, p2, p3))\n    }\n  }\n\n  return res\n}\n\n\nlet res =\n  (1..<62)\n    .lazy\n    .filter({ $0.isPrime })\n    .map(carmichael)\n    .filter({ !$0.isEmpty })\n    .flatMap({ $0 })\n\nfor c in res {\n  print(c)\n}\n"
  },
  {
    "language": "Swift",
    "code": "let dog = \"Benjamin\"\nlet Dog = \"Samba\"\nlet DOG = \"Bernie\"\nprintln(\"The three dogs are named \\(dog), \\(Dog), and \\(DOG).\")\n"
  },
  {
    "language": "Swift",
    "code": "func catalan(_ n: Int) -> Int {\n  switch n {\n  case 0:\n    return 1\n  case _:\n    return catalan(n - 1) * 2 * (2 * n - 1) / (n + 1)\n  }\n}\n\nfor i in 1..<16 {\n  print(\"catalan(\\(i)) => \\(catalan(i))\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n"
  },
  {
    "language": "Swift",
    "code": "let c1: UnicodeScalar = \"a\"\nprintln(c1.value) // prints \"97\"\nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) // prints \"960\"\n"
  },
  {
    "language": "Swift",
    "code": "let s1 = \"a\"\nfor c in s1.unicodeScalars {\n  println(c.value) // prints \"97\"\n}\nlet s2 = \"\u03c0\"\nfor c in s2.unicodeScalars {\n  println(c.value) // prints \"960\"\n}\n"
  },
  {
    "language": "Swift",
    "code": "let i1: UInt32 = 97\nprintln(UnicodeScalar(i1)) // prints \"a\"\nlet i2: UInt32 = 960\nprintln(UnicodeScalar(i2)) // prints \"\u03c0\"\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\n\n/*\n * Function: euclid\n * Usage: (r,s) = euclid(m,n)\n * --------------------------\n * The extended Euclidean algorithm subsequently performs\n * Euclidean divisions till the remainder is zero and then\n * returns the B\u00e9zout coefficients r and s.\n */\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n/*\n * Function: gcd\n * Usage: x = gcd(m,n)\n * -------------------\n * The greatest common divisor of two numbers a and b\n * is expressed by ax + by = gcd(a,b) where x and y are\n * the B\u00e9zout coefficients as determined by the extended\n * euclidean algorithm.\n */\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n/*\n * Function: coprime\n * Usage: truth = coprime(m,n)\n * ---------------------------\n * If two values are coprime, their greatest common\n * divisor is 1.\n */\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n//coprime(2,4)\n\n/*\n * Function: crt\n * Usage: x = crt(a,n)\n * -------------------\n * The Chinese Remainder Theorem supposes that given the\n * integers n_1...n_k that are pairwise co-prime, then for\n * any sequence of integers a_1...a_k there exists an integer\n * x that solves the system of linear congruences:\n *\n *   x === a_1 (mod n_1)\n *   ...\n *   x === a_k (mod n_k)\n */\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    // There is no identity operator for elements of [Int].\n    // The offset of the elements of an enumerated sequence\n    // can be used instead, to determine if two elements of the same\n    // array are the same.\n    let divs = n_i.enumerated()\n\n    // Check if elements of n_i are pairwise coprime divs.filter{ $0.0 < n.0 }\n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n\n    // Calculate factor N\n    let N = n_i.map{$0}.reduce(1, *)\n\n    // Euclidean algorithm determines s_i (and r_i)\n    var s:[Int] = []\n\n    // Using euclidean algorithm to calculate r_i, s_i\n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n\n    // Solve for x\n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    // Return minimal solution\n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n"
  },
  {
    "language": "Swift",
    "code": "func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "class MyClass{\n\n  // stored property\n  var variable : Int\n\n  /**\n  * The constructor\n  */\n  init() {\n    self.variable = 42\n  }\n\n  /**\n  * A method\n  */\n  func someMethod() {\n    self.variable = 1\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "MyClass()\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n\n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n\n    return Self.closestPair(xP, xY)?.1\n  }\n\n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n\n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n\n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n\n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n\n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n\n    var (closest, pairClosest) = (dMin, pairMin)\n\n    for i in 0..<ys.count {\n      let p1 = ys[i]\n\n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n\n        guard abs(p2.y - p1.y) < dMin else { break }\n\n        let distance = abs(p1.distance(to: p2))\n\n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n\n    return (closest, pairClosest)\n  }\n\n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n\n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n\n    guard count != 2 else { return (minDistance, closestPoints) }\n\n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n\n        let distance = abs(p1.distance(to: p2))\n\n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n\n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#! /bin/bash\n\ndeclare -a doors\nfor((i=1; i <= 100; i++)); do\n    doors[$i]=0\ndone\n\nfor((i=1; i <= 100; i++)); do\n    for((j=i; j <= 100; j += i)); do\n\techo $i $j\n\tdoors[$j]=$(( doors[j] ^ 1 ))\n    done\ndone\n\nfor((i=1; i <= 100; i++)); do\n    if [[ ${doors[$i]} -eq 0 ]]; then\n\top=\"closed\"\n    else\n\top=\"open\"\n    fi\n    echo $i $op\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nfor i in {1..100}; do\n  door[$i*$i]=1\n  [ -z ${door[$i]} ] && echo \"$i closed\" || echo \"$i open\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "gen_digits() {\n    awk 'BEGIN { srand()\n                 for(i = 1; i <= 4; i++) print 1 + int(9 * rand())\n         }' | sort\n}\n\nsame_digits() {\n    [ \"$(tr -dc 0-9 | sed 's/./&\\n/g' | grep . | sort)\" = \"$*\" ]\n}\n\nguessed() {\n    [ \"$(echo \"$1\" | tr -dc '\\n0-9()*/+-' | bc 2>/dev/null)\" = 24 ]\n}\n\n\nwhile :\ndo\n    digits=$(gen_digits)\n    echo\n    echo Digits: $digits\n    read -r expr\n\n    echo \" $expr\" | same_digits \"$digits\" || \\\n        { echo digits should be: $digits; continue; }\n\n    guessed \"$expr\" && message=correct \\\n                    || message=wrong\n\n    echo $message\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a b || exit\necho `expr \"$a\" + \"$b\"`\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\nread a b || exit\necho $(( a + b ))\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "echo 2 3 | ksh a+b.sh\n5\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "set line=$<\nset input=($line)\n@ sum = $input[1] + $input[2]\necho $sum\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "can_build_word() {\n    if [[ $1 ]]; then\n        can_build_word_rec \"$1\" BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\n    else\n        return 1\n    fi\n}\n\ncan_build_word_rec() {\n    [[ -z $1 ]] && return 0\n\n    local -u word=$1       # uppercase the first parameter\n    shift\n    local blocks=(\"$@\")\n\n    # see if we have a block for the first letter\n    local letter=${word:0:1} indices=() i\n    for (( i=0; i<${#blocks[@]}; i++ )); do\n        if [[ ${blocks[i]} == *$letter* ]]; then\n            indices+=($i)\n        fi\n    done\n    (( ${#indices[@]} == 0 )) && return 1\n\n    local tmp\n    for i in ${indices[@]}; do\n        tmp=( \"${blocks[@]}\" )\n        unset \"tmp[$i]\"\n        can_build_word_rec \"${word:1}\" \"${tmp[@]}\" && return 0\n    done\n\n    return 1\n}\n\nwords=( \"\" A BARK Book treat COMMON Squad confuse )\nfor word in \"${words[@]}\"; do\n    can_build_word \"$word\" \"${blocks[@]}\" && ans=yes || ans=no\n    printf \"%s\\t%s\\n\" \"$word\" $ans\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\naccumulator() {\n\t# Define a global function named $1\n\t# with a global variable named ${1}_sum.\n\teval \"${1}_sum=\\$2\"\n\teval \"$1() {\n\t\t${1}_sum=\\$(echo \\\"(\\$${1}_sum) + (\\$2)\\\" | bc)\n\t\teval \\\"\\$1=\\\\\\$${1}_sum\\\"  # Provide the current sum.\n\t}\"\n}\n\naccumulator x 1\nx r 5\naccumulator y 3\nx r 2.3\necho $r\ny r -3000\necho $r\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "fn accumulator n {\n\tresult @ i {\n\t\tn = `{echo $n + $i | bc}\n\t\tresult $n\n\t}\n}\n\nfn-x = <={accumulator 1}\nx 5\nfn-y = <={accumulator 3}\necho <={x 2.3}\necho <={y -3000}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "ack() {\n  local m=$1\n  local n=$2\n  if [ $m -eq 0 ]; then\n    echo -n $((n+1))\n  elif [ $n -eq 0 ]; then\n    ack $((m-1)) 1\n  else\n    ack $((m-1)) $(ack $m $((n-1)))\n  fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "for ((m=0;m<=3;m++)); do\n  for ((n=0;n<=6;n++)); do\n    ack $m $n\n    echo -n \" \"\n  done\n  echo\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\n\nLDAP_HOST=\"localhost\"\nLDAP_PORT=11389\nLDAP_DN_STR=\"uid=admin,ou=system\"\nLDAP_CREDS=\"********\"\nLDAP_BASE_DN=\"ou=users,o=mojo\"\nLDAP_SCOPE=\"sub\"\nLDAP_FILTER=\"(&(objectClass=person)(&(uid=*mil*)))\"\nLDAP_ATTRIBUTES=\"dn cn sn uid\"\n\nldapsearch \\\n  -s base \\\n  -h $LDAP_HOST \\\n  -p $LDAP_PORT \\\n  -LLL \\\n  -x \\\n  -v \\\n  -s $LDAP_SCOPE \\\n  -D $LDAP_DN_STR \\\n  -w $LDAP_CREDS \\\n  -b $LDAP_BASE_DN \\\n  $LDAP_FILTER \\\n  $LDAP_ATTRIBUTES\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "cat <<EOF_OUTER > just-nocenter.sh\n#!/bin/sh\n\ntd() {\ncat <<'EOF'\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEOF\n}\n\nrows=$( td | wc -l )\n\n# get the number of fields\nfields=$(td | rs -c'$' -g1 -h | awk '{print $2}')\n\n# get the max of the value widths\ncwidth=$(td | rs -c'$' -g1 -w1 2>/dev/null | awk 'BEGIN{w=0}{if(length>w){w=length}}END{print w}')\n\n# compute the minimum line width for the columns\nlwidth=$(( (1 + cwidth) * fields ))\n\n# left adjusted columns\ntd | rs -c'$' -g1 -zn -w$lwidth\n\necho \"\"\n\n# right adjusted columns\ntd | rs -c'$' -g1 -znj -w$lwidth\n\necho \"\"\n\nexit\nEOF_OUTER\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "$ ./just-nocenter.sh\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "function get_words {\n    typeset host=www.puzzlers.org\n    typeset page=/pub/wordlists/unixdict.txt\n    exec 7<>/dev/tcp/$host/80\n    print -e -u7 \"GET $page HTTP/1.1\\r\\nhost: $host\\r\\nConnection: close\\r\\n\\r\\n\"\n    # remove the http header and save the word list\n    sed 's/\\r$//; 1,/^$/d' <&7 >\"$1\"\n    exec 7<&-\n}\n\nfunction is_deranged {\n    typeset -i i\n    for ((i=0; i<${#1}; i++)); do\n        [[ ${1:i:1} == ${2:i:1} ]] && return 1\n    done\n    return 0\n}\n\nfunction word2key {\n    typeset -a chars=( $(\n        for ((i=0; i<${#word}; i++)); do\n            echo \"${word:i:1}\"\n        done | sort\n    ) )\n    typeset IFS=\"\"\n    echo \"${chars[*]}\"\n}\n\n[[ -f word.list ]] || get_words word.list\n\ntypeset -A words\ntypeset -i max=0\n\nwhile IFS= read -r word; do\n    key=$(word2key $word)\n    if [[ -z \"${words[\"$key\"]}\" ]]; then\n        words[\"$key\"]=$word\n    else\n        if (( ${#word} > max )); then\n            if is_deranged \"${words[\"$key\"]}\" \"$word\"; then\n                max_deranged=(\"${words[\"$key\"]}\" \"$word\")\n                max=${#word}\n            fi\n        fi\n    fi\ndone <word.list\necho $max - ${max_deranged[@]}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "http_get_body() {\n    local host=$1\n    local uri=$2\n    exec 5<> /dev/tcp/$host/80\n    printf >&5 \"%s\\r\\n\" \"GET $uri HTTP/1.1\" \"Host: $host\" \"Connection: close\" \"\"\n    mapfile -t -u5\n    local lines=( \"${MAPFILE[@]//$'\\r'}\" )\n    local i=0 found=0\n    for (( ; found == 0; i++ )); do\n        [[ -z ${lines[i]} ]] && (( found++ ))\n    done\n    printf \"%s\\n\" \"${lines[@]:i}\"\n    exec 5>&-\n}\n\ndeclare -A wordlist\n\nwhile read -r word; do\n    uniq_letters=( $(for ((i=0; i<${#word}; i++)); do echo \"${word:i:1}\"; done | sort) )\n    wordlist[\"${uniq_letters[*]}\"]+=\"$word \"\ndone < <( http_get_body wiki.puzzlers.org  /pub/wordlists/unixdict.txt )\n\nmaxlen=0\nmaxwords=()\n\nfor key in \"${!wordlist[@]}\"; do\n    words=( ${wordlist[$key]} )\n    if (( ${#words[@]} > maxlen )); then\n        maxlen=${#words[@]}\n        maxwords=( \"${wordlist[\"$key\"]}\" )\n    elif (( ${#words[@]} == maxlen )); then\n        maxwords+=( \"${wordlist[$key]}\" )\n    fi\ndone\n\nprintf \"%s\\n\" \"${maxwords[@]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "fib() {\n  if test 0 -gt \"$1\"; then\n    echo \"fib: fib of negative\" 1>&2\n    return 1\n  else\n    (\n      fib2() {\n        if test 2 -gt \"$1\"; then\n          echo \"$1\"\n        else\n          echo $(( $(fib2 $(($1 - 1)) ) + $(fib2 $(($1 - 2)) ) ))\n        fi\n      }\n      fib2 \"$1\"\n    )\n  fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "$ for i in -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12; do\n>   fib $i\n> done\nfib: fib of negative\nfib: fib of negative\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "rec1=(\n    jsmith\n    x\n    1001\n    1000\n    \"Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org\"\n    /home/jsmith\n    /bin/bash\n)\n\nrec2=(\n    jdoe\n    x\n    1002\n    1000\n    \"Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org\"\n    /home/jdoe\n    /bin/bash\n)\n\nrec3=(\n    xyz\n    x\n    1003\n    1000\n    \"X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org\"\n    /home/xyz\n    /bin/bash\n)\n\nfilename=./passwd-ish\n\n# use parentheses to run the commands in a subshell, so the\n# current shell's IFS variable is not changed\n(\n    IFS=:\n    echo \"${rec1[*]}\"\n    echo \"${rec2[*]}\"\n) > \"$filename\"\n\necho before appending:\ncat \"$filename\"\n\n# appending, use the \">>\" redirection symbol\nIFS=:\necho \"${rec3[*]}\" >> \"$filename\"\n\necho after appending:\ncat \"$filename\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map() {\n\tmap_command=$1\n\tshift\n\tfor i do \"$map_command\" \"$i\"; done\n}\nlist=1:2:3\n(IFS=:; map echo $list)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map() {\n\ttypeset command=$1\n\tshift\n\tfor i do \"$command\" \"$i\"; done\n}\nset -A ary 1 2 3\nmap print \"${ary[@]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map(){for i ($*[2,-1]) $1 $i}\na=(1 2 3)\nmap print $a\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T Complex_t=(\n    float real=0\n    float imag=0\n\n    function to_s {\n        print -- \"${_.real} + ${_.imag} i\"\n    }\n\n    function dup {\n        nameref other=$1\n        _=( real=${other.real} imag=${other.imag} )\n    }\n\n    function add {\n        typeset varname\n        for varname; do\n            nameref other=$varname\n            (( _.real += other.real ))\n            (( _.imag += other.imag ))\n        done\n    }\n\n    function negate {\n        (( _.real *= -1 ))\n        (( _.imag *= -1 ))\n    }\n\n    function conjugate {\n        (( _.imag *= -1 ))\n    }\n\n    function multiply {\n        typeset varname\n        for varname; do\n            nameref other=$varname\n            float a=${_.real} b=${_.imag} c=${other.real} d=${other.imag}\n            (( _.real = a*c - b*d ))\n            (( _.imag = b*c + a*d ))\n        done\n    }\n\n    function inverse {\n        if (( _.real == 0 && _.imag == 0 )); then\n            print -u2 \"division by zero\"\n            return 1\n        fi\n        float denom=$(( _.real*_.real + _.imag*_.imag ))\n        (( _.real = _.real / denom ))\n        (( _.imag = -1 * _.imag / denom ))\n    }\n)\n\nComplex_t a=(real=1 imag=1)\na.to_s        # 1 + 1 i\n\nComplex_t b=(real=3.14159 imag=1.2)\nb.to_s        # 3.14159 + 1.2 i\n\nComplex_t c\nc.add a b\nc.to_s        # 4.14159 + 2.2 i\n\nc.negate\nc.to_s        # -4.14159 + -2.2 i\n\nc.conjugate\nc.to_s        # -4.14159 + 2.2 i\n\nc.dup a\nc.multiply b\nc.to_s        # 1.94159 + 4.34159 i\n\nComplex_t d=(real=2 imag=1)\nd.inverse\nd.to_s        # 0.4 + -0.2 i\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "function agm {\n    float a=$1 g=$2 eps=${3:-1e-11} tmp\n    while (( abs(a-g) > eps )); do\n        print \"debug: a=$a\\tg=$g\"\n        tmp=$(( (a+g)/2.0 ))\n        g=$(( sqrt(a*g) ))\n        a=$tmp\n    done\n    echo $a\n}\n\nagm $((1/sqrt(2))) 1\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "while (( abs(a-g) > eps ))\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "while [[ $a != $g ]]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a; read b;\necho \"a+b     = \"  `expr $a  +  $b`\necho \"a-b     = \"  `expr $a  -  $b`\necho \"a*b     = \"  `expr $a \\*  $b`\necho \"a/b     = \"  `expr $a  /  $b` # truncates towards 0\necho \"a mod b = \"  `expr $a  %  $b` # same sign as first operand\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a; read b;\necho \"a+b     = $((a+b))\"\necho \"a-b     = $((a-b))\"\necho \"a*b     = $((a*b))\"\necho \"a/b     = $((a/b))\" # truncates towards 0\necho \"a mod b = $((a%b))\" # same sign as first operand\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "array1=( 1 2 3 4 5 )\narray2=( 6 7 8 9 10 )\nbotharrays=( ${array1[@]} ${array2[@]} )\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "array1='1 2 3 4 5'\narray2='6 7 8 9 10'\n\n# Concatenated to a Bash array ...\nbotharrays_a=( $array1 $array2 )\n\n# Concatenated to a string ...\nbotharrays_s=\"$array1 $array2\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "alist=( item1 item2 item3 )  # creates a 3 item array called \"alist\"\ndeclare -a list2        # declare an empty list called \"list2\"\ndeclare -a list3[0]     # empty list called \"list3\"; the subscript is ignored\n\n# create a 4 item list, with a specific order\nlist5=([3]=apple [2]=cherry [1]=banana [0]=strawberry)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "count=${#alist[*]}\necho \"The number of items in alist is ${#alist[*]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "x=0\nwhile [[ $x < ${#alist[*]} ]]; do\n  echo \"Item $x = ${alist[$x]}\"\n  : $((x++))\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "x=${#alist[*]}       # start with the number of items in the array\nwhile [[ $x > 0 ]]; do     # while there are items left\n  : $((x--))               # decrement first, because indexing is zero-based\n  echo \"Item $x = ${alist[$x]}\"   # show the current item\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "alist[${#alist[*]}]=new_item\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# shell function to append values to an array\n# push LIST VALUES ...\npush() {\n  local var=${1:?'Missing variable name!'}\n  shift\n  eval \"\\$$var=( \\\"\\${$var[@]}\\\" \\\"$@\\\" )\"\n}\n\npush alist \"one thing to add\"\npush alist many words to add\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist[0]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# pop ARRAY -- pop the last item on ARRAY and output it\n\npop() {\n  local var=${1:?'Missing array name'}\n  local x ;   eval \"x=\\${#$var[*]}\"\n  if [[ $x > 0 ]]; then\n    local val ; eval \"val=\\\"\\${$var[$((--x))]}\\\"\"\n    unset $var[$x]\n  else\n    echo 1>&2 \"No items in $var\" ; exit 1\n  fi\n  echo \"$val\"\n}\n\nalist=(a b c)\npop alist\na\npop alist\nb\npop alist\nc\npop alist\nNo items in alist\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist[*]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "assert() {\n    if test ! $1; then\n        [[ $2 ]] && echo \"$2\" >&2\n        exit 1\n    fi\n}\nx=42\nassert \"$x -eq 42\" \"that's not the answer\"\n((x--))\nassert \"$x -eq 42\" \"that's not the answer\"\necho \"won't get here\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A hash\nhash=( [key1]=val1 [key2]=val2 )\nhash[key3]=val3\necho \"${hash[key3]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "declare -A hash\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A a=([key1]=value1 [key2]=value2)\n\n# just keys\nprintf '%s\\n' \"${!a[@]}\"\n\n# just values\nprintf '%s\\n' \"${a[@]}\"\n\n# keys and values\nfor key in \"${!a[@]}\"; do\n\tprintf '%s => %s\\n' \"$key\" \"${a[$key]}\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A a\na=(key1 value1 key2 value2)\n\n# just keys\nprint -l -- ${(k)a}\n\n# just values\nprint -l -- ${(v)a}\n\n# keys and values\nprintf '%s => %s\\n' ${(kv)a}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "mean() {\n\tif expr $# >/dev/null; then\n\t\t(count=0\n\t\t sum=0\n\t\t while expr $# \\> 0 >/dev/null; do\n\t\t\tsum=`expr $sum + \"$1\"`\n\t\t\tresult=$?\n\t\t\texpr $result \\> 1 >/dev/null && exit $result\n\n\t\t\tcount=`expr $count + 1`\n\t\t\tshift\n\t\t done\n\t\t expr $sum / $count)\n\telse\n\t\techo 0\n\tfi\n}\n\nprintf \"test 1: \"; mean\t\t\t\t# 0\nprintf \"test 2: \"; mean 300\t\t\t# 300\nprintf \"test 3: \"; mean 300 100 400\t\t# 266\nprintf \"test 4: \"; mean -400 400 -1300 200\t# -275\nprintf \"test 5: \"; mean -\t\t\t# expr: syntax error\nprintf \"test 6: \"; mean 1 2 A 3\t\t\t# expr: non-numeric argument\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nfunction mode {\n    declare -A map\n    max=0\n    for x in \"$@\"; do\n\ttmp=$((${map[$x]} + 1))\n\tmap[$x]=$tmp\n\t((tmp > max)) && max=$tmp\n    done\n    for x in \"${!map[@]}\"; do\n\t[[ ${map[$x]} == $max ]] && echo -n \"$x \"\n    done\n    echo\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "mode 1 2 1 2 a b a b a 2\na 2\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "generate() {\n    local b=()\n    local i j tmp\n    for ((i=1; i<=$1; i++)); do\n        b+=( '[' ']')\n    done\n    for ((i=${#b[@]}-1; i>0; i--)); do\n        j=$(rand $i)\n        tmp=${b[j]}\n        b[j]=${b[i]}\n        b[i]=$tmp\n    done\n    local IFS=\n    echo \"${b[*]}\"\n}\n\n# a random number in the range [0,n)\nrand() {\n    echo $(( $RANDOM % $1 ))\n}\n\nbalanced() {\n    local -i lvl=0\n    local i\n    for ((i=0; i<${#1}; i++)); do\n        case ${1:i:1} in\n            '[') ((lvl++));;\n            ']') (( --lvl < 0 )) && return 1;;\n        esac\n    done\n    (( lvl == 0 )); return $?\n}\n\nfor ((i=0; i<=10; i++)); do\n    test=$(generate $i)\n    balanced \"$test\" && result=OK || result=\"NOT OK\"\n    printf \"%s\\t%s\\n\" \"$test\" \"$result\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# Define a function to output binary digits\ntobinary() {\n  # We use the bench calculator for our conversion\n  echo \"obase=2;$1\"|bc\n}\n\n# Call the function with each of our values\ntobinary 5\ntobinary 50\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/ksh\n# This should work on any clone of Bourne Shell, ksh is the fastest.\n\nvalue=$1; [ -z \"$value\" ] && exit\narray=()\nsize=0\n\nwhile IFS= read -r line; do\n\tsize=$(($size + 1))\n\tarray[${#array[*]}]=$line\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "left=0\nright=$(($size - 1))\nwhile\t[ $left -le $right ] ; do\n\tmid=$((($left + $right) >> 1))\n#\techo \"$left\t$mid(${array[$mid]})\t$right\"\n\tif\t[ $value -eq ${array[$mid]} ] ; then\n\t\techo $mid\n\t\texit\n\telif\t[ $value -lt ${array[$mid]} ]; then\n\t\tright=$(($mid - 1))\n\telse\n\t\tleft=$((mid + 1))\n\tfi\ndone\necho 'ERROR 404 : NOT FOUND'\n"
  },
  {
    "language": "UNIX-Shell",
    "code": " No code yet\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "base58=({1..9} {A..H} {J..N} {P..Z} {a..k} {m..z})\nbitcoinregex=\"^[$(printf \"%s\" \"${base58[@]}\")]{34}$\"\n\ndecodeBase58() {\n    local s=$1\n    for i in {0..57}\n    do s=\"${s//${base58[i]}/ $i}\"\n    done\n    dc <<< \"16o0d${s// /+58*}+f\"\n}\n\nchecksum() {\n    xxd -p -r <<<\"$1\" |\n    openssl dgst -sha256 -binary |\n    openssl dgst -sha256 -binary |\n    xxd -p -c 80 |\n    head -c 8\n}\n\ncheckBitcoinAddress() {\n    if [[ \"$1\" =~ $bitcoinregex ]]\n    then\n        h=$(decodeBase58 \"$1\")\n        checksum \"00${h::${#h}-8}\" |\n        grep -qi \"^${h: -8}$\"\n    else return 2\n    fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "    function setrgb {\n        _.r=$1\n        _.g=$2\n        _.b=$3\n    }\n    function grayscale {\n        integer x=$(( round( 0.2126*_.r + 0.7152*_.g + 0.0722*_.b ) ))\n        _.r=$x\n        _.g=$x\n        _.b=$x\n    }\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "    function grayscale {\n        RGBColor_t c\n        for ((y=0; y<_.height; y++)); do\n            for ((x=0; x<_.width; x++)); do\n                c.setrgb ${_.data[y][x]}\n                c.grayscale\n                _.data[y][x]=$(c.to_s)\n            done\n        done\n    }\n\n    function read {\n        exec 4<\"$1\"\n        typeset filetype\n        read -u4 filetype\n        if [[ $filetype != \"P3\" ]]; then\n            print -u2 \"error: I can only read P3 type PPM files\"\n        else\n            read -u4 _.width _.height\n            integer maxval\n            read -u4 maxval\n            integer x y r g b\n            typeset -a bytes\n            for ((y=0; y<_.height; y++)); do\n                read -u4 -A bytes\n                for ((x=0; x<_.width; x++)); do\n                    r=${bytes[3*x+0]}\n                    g=${bytes[3*x+1]}\n                    b=${bytes[3*x+2]}\n                    if (( r > maxval || g > maxval || b > maxval )); then\n                        print -u2 \"error: invalid color ($r $g $b), max=$maxval\"\n                        return 1\n                    fi\n                    _.data[y][x]=\"$r $g $b\"\n                done\n            done\n        fi\n        exec 4<&-\n    }\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "Bitmap_t c\nc.read \"$HOME/tmp/bitmap.ppm\"\nc.to_s\n\nif [[ $(c.to_s) == $(cat \"$HOME/tmp/bitmap.ppm\") ]]; then\n    echo looks OK\nelse\n    echo something is wrong\nfi\n\nc.grayscale\nc.to_s\nc.write \"$HOME/tmp/bitmap_g.ppm\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "    function write {\n        _.to_s > \"$1\"\n    }\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "Bitmap_t b\n# do stuff to b, and save it:\nb.write '$HOME/tmp/bitmap.ppm'\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T RGBColor_t=(\n    integer r g b\n    function to_s {\n        printf \"%d %d %d\" ${_.r} ${_.g} ${_.b}\n    }\n    function white   { print \"255 255 255\"; }\n    function black   { print \"0 0 0\"; }\n    function red     { print \"255 0 0\"; }\n    function green   { print \"0 255 0\"; }\n    function blue    { print \"0 0 255\"; }\n    function yellow  { print \"255 255 0\"; }\n    function magenta { print \"255 0 255\"; }\n    function cyan    { print \"0 255 255\"; }\n)\n\ntypeset -T Bitmap_t=(\n    integer height\n    integer width\n    typeset -a data\n\n    function fill {\n        typeset color=$1\n        if [[ -z ${color:+set} ]]; then\n            print -u2 \"error: no fill color specified\"\n            return 1\n        fi\n        integer x y\n        for ((y=0; y<_.height; y++)); do\n            for ((x=0; x<_.width; x++)); do\n                _.data[y][x]=\"$color\"\n            done\n        done\n    }\n\n    function setpixel {\n        integer x=$1 y=$2\n        typeset color=$3\n        _.data[y][x]=$color\n    }\n\n    function getpixel {\n        integer x=$1 y=$2\n        print \"${_.data[y][x]}\"\n    }\n\n    function to_s {\n        typeset ppm=\"\"\n        ppm+=\"P3\"$'\\n'\n        ppm+=\"${_.width} ${_.height}\"$'\\n'\n        ppm+=\"255\"$'\\n'\n        typeset sep\n        for ((y=0; y<_.height; y++)); do\n            sep=\"\"\n            for ((x=0; x<_.width; x++)); do\n                ppm+=\"$sep${_.data[y][x]}\"\n                sep=\" \"\n            done\n            ppm+=$'\\n'\n        done\n        print -- \"$ppm\"\n    }\n)\n\nRGBColor_t color\nBitmap_t b=( width=3  height=2 )\nb.fill \"$(color.white)\"\nb.setpixel 0 0 \"$(color.red)\"\nb.setpixel 1 0 \"$(color.green)\"\nb.setpixel 2 0 \"$(color.blue)\"\nb.setpixel 0 1 \"$(color.yellow)\"\nb.setpixel 1 1 \"$(color.white)\"\nb.setpixel 2 1 \"$(color.black)\"\necho \"$(b.getpixel 0 0)\"\nb.to_s\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "if\n  echo 'Looking for file'  # This is the evaluation block\n  test -e foobar.fil       # The exit code from this statement determines whether the branch runs\nthen\n  echo 'The file exists'   # This is the optional branch\n  echo 'I am going to delete it'\n  rm foobar.fil\nfi\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "true && echo \"true\" || echo \"false\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# List of abbreviated compass point labels\ncompass_points=( N NbE N-NE NEbN NE NEbE E-NE EbN\n                 E EbS E-SE SEbE SE SEbS S-SE SbE\n                 S SbW S-SW SWbS SW SWbW W-SW WbS\n                 W WbN W-NW NWbW NW NWbN N-NW NbW )\n\n# List of angles to test\ntest_angles=(  0.00  16.87  16.88  33.75  50.62  50.63  67.50\n              84.37  84.38 101.25 118.12 118.13 135.00 151.87\n             151.88 168.75 185.62 185.63 202.50 219.37 219.38\n             236.25 253.12 253.13 270.00 286.87 286.88 303.75\n             320.62 320.63 337.50 354.37 354.38 )\n\ncapitalize() {\n  printf '%s%s\\n' \"$(tr a-z A-Z <<<\"${1:0:1}\")\" \"${1:1}\"\n}\n\n# convert compass point abbreviation to full text of label\nfunction expand_point {\n  local label=$1\n  set -- N north E east S south W west b \" by \"\n  while (( $# )); do\n    label=${label//$1/$2}\n    shift 2\n  done\n  capitalize \"$label\"\n}\n\n# modulus function that returns 1..N instead of 0..N-1\nfunction amod {\n  echo $(( ($1 - 1) % $2 + 1 ))\n}\n\n# convert a compass angle from degrees into a box index (1..32)\nfunction compass_point {\n  # use bc or dc depending on what's on the system\n  #amod $(dc <<<\"$1 5.625 + 11.25 / 1 + p\") 32\n  amod $(bc <<<\"($1 + 5.625) / 11.25 + 1\") 32\n}\n\n#  Now output the table of test data\nheader_format=\"%-7s | %-18s | %s\\n\"\nrow_format=\"%7.2f | %-18s | %2d\\n\"\nprintf \"$header_format\" \"Degrees\" \"Closest Point\" \"Index\"\nfor angle in ${test_angles[@]}; do\n  let index=$(compass_point $angle)\n  abbr=${compass_points[index-1]}\n  label=\"$(expand_point $abbr)\"\n  printf \"$row_format\" $angle \"$label\" $index\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nrand() {\n  local min=${1:-0}\n  local max=${2:-32767}\n\n  [ ${min} -gt ${max} ] &&\n  min=$(( min ^ max )) &&\n  max=$(( min ^ max )) &&\n  min=$(( min ^ max ))\n\n  echo -n $(( ( $RANDOM % $max ) + $min ))\n}\n\nin_arr() {\n  local quandry=\"${1}\"\n  shift\n  local arr=( $@ )\n  local i=''\n\n  for i in ${arr[*]}\n  do\n    [ \"${quandry}\" == \"${i}\" ] && return 0 && break\n  done\n\n  return 1\n}\n\ndelete_at() {\n  local idx=\"$(( $1 + 1 ))\"\n  shift\n  local arr=( \"sentinel\" $@ )\n\n  echo -n \"${arr[@]:1:$(( idx - 1 ))} ${arr[@]:$((idx + 1)):$(( ${#arr[@]} - idx - 1))}\"\n}\n\ndelete_first() {\n  local meanie=\"${1}\"\n  shift\n  local arr=( $@ )\n  local i=0\n\n  for (( i = 0; i < ${#arr[@]} ; i++ ))\n  do\n    [ \"${arr[${i}]}\" == \"${meanie}\" ] && arr=( $( delete_at ${i} ${arr[*]} ) )\n  done\n\n  echo -n \"${arr[*]}\"\n}\n\nto_arr() {\n  local string=\"${1}\"\n  local arr=()\n\n  while [ \"${#string}\" -gt 0 ]\n  do\n    arr=( ${arr[*]} ${string:0:1} )\n    string=\"${string:1}\"\n  done\n\n  echo -n \"${arr[*]}\"\n}\n\nchoose_idx() {\n  local arr=( $@ )\n\n  echo -n \"$( rand 0 $(( ${#arr[@]} - 1 )) )\"\n}\n\nlocate_bulls() {\n  local secret=( $( to_arr \"${1}\" ) )\n  local guess=( $( to_arr \"${2}\" ) )\n  local hits=()\n  local i=0\n\n  for (( i=0; i<4; i++ ))\n  do\n    [ \"${secret[${i}]}\" -eq \"${guess[${i}]}\" ] && hits=( ${hits[*]} ${i} )\n  done\n\n  echo -n \"${hits[*]}\"\n}\n\nbulls() {\n  local secret=\"${1}\"\n  local guess=\"${2}\"\n  local bulls=( $( locate_bulls \"${secret}\" \"${guess}\" ) )\n\n  echo -n \"${#bulls[@]}\"\n}\n\ncows() {\n  local secret=( $( to_arr \"${1}\" ) )\n  local guess=( $( to_arr \"${2}\" ) )\n  local bulls=( $( locate_bulls \"${1}\" \"${2}\" ) )\n  local hits=0\n  local i=''\n\n  # Avoid double-counting bulls\n  for i in ${bulls[*]}\n  do\n    secret=( $( delete_at ${i} ${secret[*]} ) )\n  done\n\n  # Process the guess against what's left of the secret\n  for i in ${guess[*]}\n  do\n    in_arr \"${i}\" ${secret[*]} &&\n    secret=( $( delete_first \"${i}\" ${secret[*]} ) ) &&\n    (( hits++ ))\n  done\n\n  echo -n ${hits}\n}\n\nmalformed() {\n  local guess=( $( to_arr \"${1}\" ) )\n  local i=''\n\n  [ ${#guess[@]} -ne 4 ] &&\n  return 0\n\n  for i in ${guess[*]}\n  do\n    if ! in_arr ${i} 1 2 3 4 5 6 7 8 9\n    then\n      return 0\n      break\n    fi\n  done\n\n  return 1\n}\n\ncandidates=( 1 2 3 4 5 6 7 8 9 )\nsecret=''\n\nwhile [ \"${#secret}\" -lt 4 ]\ndo\n  cidx=$( choose_idx ${candidates[*]} )\n  secret=\"${secret}${candidates[${cidx}]}\"\n  candidates=( $(delete_at ${cidx} ${candidates[*]} ) )\ndone\n\nwhile read -p \"Enter a four-digit guess:  \" guess\ndo\n  malformed \"${guess}\" && echo \"Malformed guess\" && continue\n  [ \"${guess}\" == \"${secret}\" ] && echo \"You win!\" && exit\n  echo \"Score: $( bulls \"${secret}\" \"${guess}\" ) Bulls, $( cows \"${secret}\" \"${guess}\" ) Cows\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "caesar() {\n    local OPTIND\n    local encrypt n=0\n    while getopts :edn: option; do\n        case $option in\n            e) encrypt=true ;;\n            d) encrypt=false ;;\n            n) n=$OPTARG ;;\n            :) echo \"error: missing argument for -$OPTARG\" >&2\n               return 1 ;;\n            ?) echo \"error: unknown option -$OPTARG\" >&2\n               return 1 ;;\n        esac\n    done\n    shift $((OPTIND-1))\n    if [[ -z $encrypt ]]; then\n        echo \"error: specify one of -e or -d\" >&2\n        return 1\n    fi\n\n    local upper=ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    local lower=abcdefghijklmnopqrstuvwxyz\n    if $encrypt; then\n        tr \"$upper$lower\" \"${upper:n}${upper:0:n}${lower:n}${lower:0:n}\" <<< \"$1\"\n    else\n        tr \"${upper:n}${upper:0:n}${lower:n}${lower:0:n}\" \"$upper$lower\" <<< \"$1\"\n    fi\n}\n\ntr() {\n    local -A charmap\n    local i trans line char\n    for ((i=0; i<${#1}; i++)); do\n        charmap[${1:i:1}]=${2:i:1}\n    done\n    while IFS= read -r line; do\n        trans=\"\"\n        for ((i=0; i<${#line}; i++)); do\n            char=${line:i:1}\n            if [[ -n ${charmap[$char]} ]]; then\n                trans+=${charmap[$char]}\n            else\n                trans+=$char\n            fi\n        done\n        echo \"$trans\"\n    done\n}\n\ntxt=\"The five boxing wizards jump quickly.\"\nenc=$(caesar -e -n 5 \"$txt\")\ndec=$(caesar -d -n 5 \"$enc\")\n\necho \"original:  $txt\"\necho \"encrypted: $enc\"\necho \"decrypted: $dec\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "CAL=CAL\nTR=TR\nA=A\nZ=Z\nLANG=C ${CAL,,} 1969 | ${TR,,} ${A,}-${Z,} A-Z\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\necho \"Snoopy goes here\"\ncal 1969\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "sayhello    # Call a function in statement context with no arguments\nmultiply 3 4    # Call a function in statement context with two arguments\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "dog=\"Benjamin\"\nDog=\"Samba\"\nDOG=\"Bernie\"\necho \"The three dogs are named $dog, $Dog and $DOG.\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "test -f input.txt\ntest -f /input.txt\ntest -d docs\ntest -d /docs\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "for f in input.txt /input.txt; do\n\ttest -f \"$f\" && r=true || r=false\n\techo \"$f is a regular file? $r\"\ndone\nfor d in docs /docs; do\n\ttest -d \"$d\" && r=true || r=false\n\techo \"$d is a directory? $r\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T Summation_t=(\n    integer sum\n\n    # the constructor\n    function create {\n        _.sum=0\n    }\n\n    # a method\n    function add {\n        (( _.sum += $1 ))\n    }\n)\n\nSummation_t s\nfor i in 1 2 3 4 5; do\n    s.add $i\ndone\nprint ${s.sum}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "a_index=(one two three)           # create an array with a few elements\na_index+=(four five)              # append some elements\na_index[9]=ten                   # add a specific index\nfor elem in \"${a_index[@]}\"; do   # interate over the elements\n    echo \"$elem\"\ndone\nfor idx in \"${!a_index[@]}\"; do   # interate over the array indices\n    printf \"%d\\t%s\\n\" $idx \"${a_index[idx]}\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "declare -A a_assoc=([one]=1 [two]=2 [three]=3)    # create an array with a few elements\na_assoc+=([four]=4 [five]=5)                      # add some elements\na_assoc[ten]=10\nfor value in \"${a_assoc[@]}\"; do                  # interate over the values\n    echo \"$value\"\ndone\nfor key in \"${!a_assoc[@]}\"; do                   # interate over the array indices\n    printf \"%s\\t%s\\n\" \"$key\" \"${a_assoc[$key]}\"\ndone\n"
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. HelloWorld. PROCEDURE DIVISION. DISPLAY \"Hello, world!\"."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. AddNumbers. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num1 PIC 9(3) VALUE 123. 01 Num2 PIC 9(3) VALUE 456. 01 Result PIC 9(4). PROCEDURE DIVISION. COMPUTE Result = Num1 + Num2. DISPLAY \"Sum is: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. Factorial. DATA DIVISION. WORKING-STORAGE SECTION. 01 Number PIC 9(2) VALUE 5. 01 Result PIC 9(4). PROCEDURE DIVISION. COMPUTE Result = 1. PERFORM VARYING Number FROM 1 BY 1 UNTIL Number > 5 MULTIPLY Result BY Number. END-PERFORM. DISPLAY \"Factorial of 5 is: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. Fibonacci. DATA DIVISION. WORKING-STORAGE SECTION. 01 n PIC 9(2) VALUE 10. 01 a PIC 9(5) VALUE 0. 01 b PIC 9(5) VALUE 1. 01 c PIC 9(5). PROCEDURE DIVISION. DISPLAY a DISPLAY b PERFORM VARYING n FROM 1 BY 1 UNTIL n > 10   COMPUTE c = a + b   DISPLAY c   COMPUTE a = b   COMPUTE b = c END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ReverseString. DATA DIVISION. WORKING-STORAGE SECTION. 01 Input-String PIC X(20) VALUE 'COBOL'. 01 Output-String PIC X(20). PROCEDURE DIVISION. MOVE Function REVERSE OF Input-String TO Output-String. DISPLAY \"Reversed string: \" Output-String."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MultiplicationTable. DATA DIVISION. WORKING-STORAGE SECTION. 01 i PIC 9(2) VALUE 1. 01 j PIC 9(2) VALUE 1. PROCEDURE DIVISION. PERFORM VARYING i FROM 1 BY 1 UNTIL i > 10   PERFORM VARYING j FROM 1 BY 1 UNTIL j > 10     COMPUTE Result = i * j     DISPLAY i \" * \" j \" = \" Result   END-PERFORM END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. SimpleMath. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num1 PIC 9(2) VALUE 10. 01 Num2 PIC 9(2) VALUE 5. 01 Result PIC 9(3). PROCEDURE DIVISION. ADD Num1 TO Num2 GIVING Result. DISPLAY \"Addition: \" Result. SUBTRACT Num1 FROM Num2 GIVING Result. DISPLAY \"Subtraction: \" Result. MULTIPLY Num1 BY Num2 GIVING Result. DISPLAY \"Multiplication: \" Result. DIVIDE Num1 INTO Num2 GIVING Result. DISPLAY \"Division: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ArrayOperations. DATA DIVISION. WORKING-STORAGE SECTION. 01 Numbers OCCURS 5 TIMES PIC 9(2) VALUE ZEROES. 01 Index PIC 9 VALUE 1. PROCEDURE DIVISION. PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 5   COMPUTE Numbers(Index) = Index * 10   DISPLAY \"Index \" Index \": \" Numbers(Index) END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. BubbleSort. DATA DIVISION. WORKING-STORAGE SECTION. 01 Numbers OCCURS 10 TIMES PIC 9(2) VALUE ZEROES. 01 Index1 PIC 9 VALUE 1. 01 Index2 PIC 9 VALUE 1. 01 Temp PIC 9. PROCEDURE DIVISION. PERFORM VARYING Index1 FROM 1 BY 1 UNTIL Index1 > 10   PERFORM VARYING Index2 FROM 1 BY 1 UNTIL Index2 > 10 - Index1     IF Numbers(Index2) > Numbers(Index2 + 1)       MOVE Numbers(Index2) TO Temp       MOVE Numbers(Index2 + 1) TO Numbers(Index2)       MOVE Temp TO Numbers(Index2 + 1)     END-IF   END-PERFORM END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ConcatenateStrings. DATA DIVISION. WORKING-STORAGE SECTION. 01 String1 PIC X(10) VALUE 'Hello'. 01 String2 PIC X(10) VALUE 'COBOL'. 01 ResultString PIC X(20). PROCEDURE DIVISION. STRING String1 DELIMITED BY SIZE   String2 DELIMITED BY SIZE INTO ResultString. DISPLAY \"Concatenated string: \" ResultString."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. PalindromeCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 InputString PIC X(20) VALUE 'LEVEL'. 01 ReverseString PIC X(20). PROCEDURE DIVISION. MOVE Function REVERSE OF InputString TO ReverseString. IF InputString = ReverseString     DISPLAY \"Palindrome!\" ELSE     DISPLAY \"Not a Palindrome!\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. EvenOddCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Number PIC 9(2) VALUE 11. PROCEDURE DIVISION. IF Number MOD 2 = 0     DISPLAY Number \" is Even.\" ELSE     DISPLAY Number \" is Odd.\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MaxOfThree. DATA DIVISION. WORKING-STORAGE SECTION. 01 A PIC 9(2) VALUE 25. 01 B PIC 9(2) VALUE 37. 01 C PIC 9(2) VALUE 19. 01 MaxNumber PIC 9(2). PROCEDURE DIVISION. IF A > B AND A > C     MOVE A TO MaxNumber ELSE IF B > A AND B > C     MOVE B TO MaxNumber ELSE     MOVE C TO MaxNumber END-IF. DISPLAY \"Maximum Number is: \" MaxNumber."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MergeArrays. DATA DIVISION. WORKING-STORAGE SECTION. 01 Array1 OCCURS 5 TIMES PIC 9(2) VALUE 10, 20, 30, 40, 50. 01 Array2 OCCURS 5 TIMES PIC 9(2) VALUE 60, 70, 80, 90, 100. 01 MergedArray OCCURS 10 TIMES PIC 9(2). PROCEDURE DIVISION. PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 5   MOVE Array1(Index) TO MergedArray(Index)   MOVE Array2(Index) TO MergedArray(Index + 5) END-PERFORM. DISPLAY \"Merged Array: \". PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 10   DISPLAY MergedArray(Index) END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. PrimeNumberCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num PIC 9(2) VALUE 17. 01 PrimeFlag PIC X VALUE 'Y'. 01 Divisor PIC 9(2). PROCEDURE DIVISION. PERFORM VARYING Divisor FROM 2 BY 1 UNTIL Divisor > Num / 2   IF Num MOD Divisor = 0       MOVE 'N' TO PrimeFlag       EXIT PERFORM   END-IF END-PERFORM. IF PrimeFlag = 'Y'   DISPLAY Num \" is a Prime Number.\" ELSE   DISPLAY Num \" is not a Prime Number.\" END-IF"
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. AreaOfCircle. DATA DIVISION. WORKING-STORAGE SECTION. 01 Radius PIC 9(3) VALUE 10. 01 Pi PIC 9V9(6) VALUE 3.14159. 01 Area PIC 9(5)V99. PROCEDURE DIVISION. COMPUTE Area = Pi * Radius * Radius. DISPLAY \"Area of Circle: \" Area."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. FibonacciSeries. DATA DIVISION. WORKING-STORAGE SECTION. 01 FirstNum PIC 9(2) VALUE 0. 01 SecondNum PIC 9(2) VALUE 1. 01 NextNum PIC 9(2). PROCEDURE DIVISION. DISPLAY FirstNum DISPLAY SecondNum PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 8   COMPUTE NextNum = FirstNum + SecondNum   DISPLAY NextNum   COMPUTE FirstNum = SecondNum   COMPUTE SecondNum = NextNum END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. CountWords. DATA DIVISION. WORKING-STORAGE SECTION. 01 Sentence PIC X(50) VALUE 'COBOL programming is fun and structured.'. 01 WordCount PIC 9(3). PROCEDURE DIVISION. STRING LENGTH OF Sentence DELIMITED BY SPACES INTO WordCount. DISPLAY \"Number of Words: \" WordCount."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. StringConcatenation. DATA DIVISION. WORKING-STORAGE SECTION. 01 String1 PIC X(20) VALUE 'Hello'. 01 String2 PIC X(20) VALUE 'COBOL'. 01 ResultString PIC X(40). PROCEDURE DIVISION. MOVE Function CONCATENATE OF String1 AND String2 TO ResultString. DISPLAY \"Concatenated string: \" ResultString."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. LeapYearCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Year PIC 9(4) VALUE 2024. PROCEDURE DIVISION. IF (Year MOD 4 = 0 AND Year MOD 100 <> 0) OR (Year MOD 400 = 0)     DISPLAY Year \" is a Leap Year.\" ELSE     DISPLAY Year \" is not a Leap Year.\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. FILE-HANDLING.\n\nDATA DIVISION.\nFILE SECTION.\n    FD INPUT-FILE.\n    01 INPUT-RECORD.\n        05 NAME    PIC X(20).\n        05 AGE     PIC 99.\n\nWORKING-STORAGE SECTION.\n    01 OUTPUT-RECORD.\n        05 RESULT  PIC X(30).\n\nPROCEDURE DIVISION.\n    OPEN INPUT INPUT-FILE.\n    READ INPUT-FILE INTO INPUT-RECORD\n        AT END DISPLAY 'End of file reached'\n    END-READ.\n\n    PERFORM UNTIL EOF\n        MOVE NAME TO RESULT\n        DISPLAY 'Name: ' RESULT\n        MOVE AGE TO RESULT\n        DISPLAY 'Age: ' RESULT\n        READ INPUT-FILE INTO INPUT-RECORD\n            AT END SET EOF TO TRUE\n        END-READ\n    END-PERFORM.\n\n    CLOSE INPUT-FILE.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MAIN-PROGRAM.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 5.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    PERFORM MULTIPLY-BY-TWO.\n    DISPLAY 'Result: ' RESULT.\n    STOP RUN.\n\nMULTIPLY-BY-TWO.\n    MULTIPLY NUMBER BY 2 GIVING RESULT."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. CONDITIONAL.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUM PIC 99 VALUE 10.\n\nPROCEDURE DIVISION.\n    IF NUM > 5\n        DISPLAY 'Number is greater than 5'\n    ELSE\n        DISPLAY 'Number is less than or equal to 5'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. ADD-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 10.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    ADD 20 TO NUMBER.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after adding 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SUBTRACT-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 50.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    SUBTRACT 20 FROM NUMBER.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after subtracting 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MULTIPLY-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 3.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    MULTIPLY NUMBER BY 20.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after multiplying by 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. DIVIDE-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 999 VALUE 100.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    DIVIDE NUMBER BY 20 GIVING RESULT.\n    DISPLAY 'Result after dividing by 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. DISPLAY-MESSAGE.\n\nPROCEDURE DIVISION.\n    DISPLAY 'This is a sample COBOL program'.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. READ-WRITE-FILE.\n\nDATA DIVISION.\nFILE SECTION.\n    FD MY-FILE.\n    01 RECORD.\n        05 NAME PIC X(30).\n        05 AGE PIC 99.\n\nPROCEDURE DIVISION.\n    OPEN OUTPUT MY-FILE.\n    MOVE 'John' TO NAME.\n    MOVE 25 TO AGE.\n    WRITE RECORD.\n    CLOSE MY-FILE.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SIMPLE-ADD.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 A PIC 99 VALUE 5.\n    01 B PIC 99 VALUE 10.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    ADD A, B GIVING RESULT.\n    DISPLAY 'Result of addition: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "Dart",
    "code": "void main() { print('Hello, World!'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { int number = 42; String message = 'Hello'; double piValue = 3.14; bool isTrue = true; }"
  },
  {
    "language": "Dart",
    "code": "void main() { bool isTrue = true; if (isTrue) { print('It is true!'); } else { print('It is false!'); } }"
  },
  {
    "language": "Dart",
    "code": "void main() { for (var i = 0; i < 5; i++) { print('Count: $i'); } }"
  },
  {
    "language": "Dart",
    "code": "void main() { int count = 0; while (count < 5) { print('Count: $count'); count++; } }"
  },
  {
    "language": "Dart",
    "code": "void greet(String name) { print('Hello, $name!'); } void main() { greet('Alice'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { List<String> fruits = ['Apple', 'Orange', 'Banana']; print(fruits); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Map<String, int> ages = {'Alice': 25, 'Bob': 30, 'Charlie': 28}; print(ages); }"
  },
  {
    "language": "Dart",
    "code": "class Person { String name; int age; Person(this.name, this.age); } void main() { var person = Person('Alice', 25); print('Name: ${person.name}, Age: ${person.age}'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Future<void> fetchData() async { await Future.delayed(Duration(seconds: 2)); print('Data fetched!'); } fetchData(); print('Fetching data...'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Set<int> numbers = {1, 2, 3, 4, 5}; print(numbers); }"
  },
  {
    "language": "Dart",
    "code": "enum Status { pending, approved, rejected } void main() { var applicationStatus = Status.approved; print('Application Status: $applicationStatus'); }"
  },
  {
    "language": "Dart",
    "code": "import 'dart:math'; void main() { var random = Random(); print('Random number: ${random.nextInt(100)}'); }"
  },
  {
    "language": "Dart",
    "code": "import 'dart:io'; void main() { stdout.write('Enter your name: '); var name = stdin.readLineSync(); print('Hello, $name!'); }"
  },
  {
    "language": "Dart",
    "code": "void greet({String name = 'Anonymous'}) { print('Hello, $name!'); } void main() { greet(name: 'Alice'); greet(); }"
  },
  {
    "language": "Dart",
    "code": "class Bird { void fly() { print('Flying!'); } } class Sparrow extends Bird {} void main() { var sparrow = Sparrow(); sparrow.fly(); }"
  },
  {
    "language": "Dart",
    "code": "extension StringExtension on String { void shout() { print('${this.toUpperCase()}!!!'); } } void main() { var message = 'hello'; message.shout(); }"
  },
  {
    "language": "Dart",
    "code": "Future<void> delayedPrint() { return Future.delayed(Duration(seconds: 2), () { print('Delayed print after 2 seconds'); }); } void main() { delayedPrint(); print('Printed immediately'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { RegExp regex = RegExp(r'\\d+'); String text = 'There are 123 apples'; Iterable<Match> matches = regex.allMatches(text); matches.forEach((match) => print(match.group(0))); }"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  print('Hello, World!');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int result = add(3, 5);\n  print('Result: result');\n}\n\nint add(int a, int b) {\n  return a + b;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  for (int i = 0; i < 5; i++) {\n    print('Value: i');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<String> names = ['Alice', 'Bob', 'Charlie'];\n  for (String name in names) {\n    print('Hello, name!');\n  }}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String message = 'Hello';\n  String name = 'Alice';\n  String result = concatenate(message, name);\n  print(result);\n}\n\nString concatenate(String a, String b) {\n  return ''a', 'b!'';\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  double radius = 7.0;\n  double area = calculateArea(radius);\n  print('Area of the circle: area');\n}\n\ndouble calculateArea(double r) {\n  return 3.14 * r * r;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int num = 10;\n  if (num > 5) {\n    print('Number is greater than 5');\n  } else {\n    print('Number is less than or equal to 5');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int x = 0;\n  while (x < 5) {\n    print('Value: ,'x';\n    x++;\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<int> numbers = [1, 2, 3, 4, 5];\n  numbers.forEach((number) => print('Number: number'));\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String text = 'This is a Dart program';\n  print(text);\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String name = 'Alice';\n  print('Hello, name!');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int number = 7;\n  if (number % 2 == 0) {\n    print('Even');\n  } else {\n    print('Odd');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int n = 5;\n  for (int i = 1; i <= n; i++) {\n    print('*' * i);\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<int> numbers = [1, 2, 3, 4, 5];\n  int sum = numbers.reduce((value, element) => value + element);\n  print('Sum: sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String message = 'Hello';\n  String name = 'Bob';\n  String result = 'message, name!';\n  print(result);\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int x = 10;\n  do {\n    print('Value: x');\n    x -= 2;\n  } while (x > 0);\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String str = 'Dart Programming Language';\n  List<String> parts = str.split(' ');\n  parts.forEach((part) => print(part));\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int a = 10, b = 20;\n  int max = (a > b) ? a : b;\n  print('Maximum: max');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  double tempCelsius = 30.0;\n  double tempFahrenheit = (tempCelsius * 9/5) + 32;\n  print('tempCelsius\u00b0C = tempFahrenheit\u00b0F');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int num = 54321;\n  int reversed = int.parse(num.toString().split('').reversed.join());\n  print('Reversed number: reversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String message = 'Welcome';\n  for (int i = 0; i < message.length; i++) {\n    print(message[i]);\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int num = 5;\n  print('Square of num is: {num * num}');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<int> list = [1, 2, 3, 4, 5];\n  List<int> squares = list.map((number) => number * number).toList();\n  print('Squared values: squares');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String str = 'Dart';\n  String reversed = str.split('').reversed.join();\n  print('Reversed string: eversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  double radius = 7.0;\n  double area = calculateArea(radius);\n  print('Area of the circle: area');\n}\n\ndouble calculateArea(double r) {\n  return 3.14 * r * r;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<String> fruits = ['Apple', 'Banana', 'Orange'];\n  for (String fruit in fruits) {\n    print('I like fruit');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int a = 10, b = 20;\n  int sum = a + b;\n  print('Sum: sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int x = 5;\n  while (x > 0) {\n    print('Value: x');\n    x--;\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int number = 12345;\n  String reversed = number.toString().split('').reversed.join();\n  print('Reversed number: reversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String sentence = 'This is a Dart code snippet';\n  List<String> words = sentence.split(' ');\n  words.forEach((word) => print('Word: word'));\n}"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM HelloWorld PRINT *, 'Hello, World!' END PROGRAM HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Variables INTEGER :: number REAL :: piValue CHARACTER(LEN=5) :: message LOGICAL :: isTrue number = 42 piValue = 3.14 message = 'Hello' isTrue = .TRUE. END PROGRAM Variables"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ConditionalStatements LOGICAL :: isTrue isTrue = .TRUE. IF (isTrue) THEN PRINT *, 'It is true!' ELSE PRINT *, 'It is false!' END IF END PROGRAM ConditionalStatements"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Loops INTEGER :: i DO i = 0, 4 PRINT *, 'Count: ', i END DO END PROGRAM Loops"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM WhileLoop INTEGER :: count count = 0 DO WHILE (count < 5) PRINT *, 'Count: ', count count = count + 1 END DO END PROGRAM WhileLoop"
  },
  {
    "language": "Fortran",
    "code": "SUBROUTINE Greet(name) CHARACTER(LEN=10) :: name PRINT *, 'Hello, ', name, '!' END SUBROUTINE Greet PROGRAM Main CALL Greet('Alice') END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Arrays INTEGER, DIMENSION(3) :: numbers numbers = [1, 2, 3] PRINT *, numbers END PROGRAM Arrays"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Arrays2D INTEGER, DIMENSION(2, 3) :: matrix matrix = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3]) PRINT *, matrix END PROGRAM Arrays2D"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Functions SUBROUTINE AddNumbers(a, b) INTEGER :: a, b PRINT *, 'Sum:', a + b END SUBROUTINE AddNumbers PROGRAM Main CALL AddNumbers(5, 7) END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Modules MODULE MathFunctions CONTAINS FUNCTION Cube(x) REAL :: x Cube = x**3 END FUNCTION Cube END MODULE MathFunctions PROGRAM Main USE MathFunctions REAL :: result result = Cube(3.0) PRINT *, 'Cube:', result END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM IfElseStatements INTEGER :: age age = 18 IF (age < 18) THEN PRINT *, 'You are a minor.' ELSEIF (age >= 18 .AND. age < 65) THEN PRINT *, 'You are an adult.' ELSE PRINT *, 'You are a senior citizen.' END IF END PROGRAM IfElseStatements"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM RandomNumbers INTEGER :: randomNum CALL RANDOM_NUMBER(randomNum) randomNum = randomNum * 100 PRINT *, 'Random number:', randomNum END PROGRAM RandomNumbers"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM UserInput CHARACTER(LEN=20) :: name PRINT *, 'Enter your name: ' READ *, name PRINT *, 'Hello, ', TRIM(name), '!' END PROGRAM UserInput"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM OptionalArguments SUBROUTINE Greet(name) CHARACTER(LEN=10), OPTIONAL :: name IF (PRESENT(name)) THEN PRINT *, 'Hello, ', name, '!' ELSE PRINT *, 'Hello, World!' END IF END SUBROUTINE Greet PROGRAM Main CALL Greet('Alice') CALL Greet() END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM DerivedTypes TYPE Person CHARACTER(LEN=20) :: name INTEGER :: age END TYPE Person TYPE(Person) :: individual individual%name = 'Alice' individual%age = 25 PRINT *, 'Name:', individual%name PRINT *, 'Age:', individual%age END PROGRAM DerivedTypes"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FileIO INTEGER :: num, i OPEN(UNIT=10, FILE='numbers.txt', STATUS='OLD') DO i = 1, 3 READ(10, *) num PRINT *, 'Number:', num END DO CLOSE(10) END PROGRAM FileIO"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM AllocateArray INTEGER, ALLOCATABLE :: arr(:) ALLOCATE(arr(5)) arr = [1, 2, 3, 4, 5] PRINT *, arr DEALLOCATE(arr) END PROGRAM AllocateArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM RegexExample CHARACTER(LEN=50) :: text CHARACTER(LEN=20) :: pattern INTEGER :: i, nmatches INTEGER, ALLOCATABLE :: matches(:) text = 'There are 123 apples' pattern = '(\\d+)' CALL GET_MATCHES(text, pattern, matches, nmatches) DO i = 1, nmatches PRINT *, 'Match: ', TRIM(matches(i)) END DO END PROGRAM RegexExample"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM HelloWorld\n    PRINT *, 'Hello, World!'\nEND PROGRAM HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SimpleCalculation\n    INTEGER :: num1 = 123, num2 = 456, result\n    result = num1 + num2\n    PRINT *, 'Result: ', result\nEND PROGRAM SimpleCalculation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Looping\n    INTEGER :: i\n    DO i = 1, 10\n        PRINT *, 'Value of i: ', i\n    END DO\nEND PROGRAM Looping"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Conditional\n    INTEGER :: num\n    num = 10\n    IF (num > 5) THEN\n        PRINT *, 'Number is greater than 5'\n    ELSE\n        PRINT *, 'Number is less than or equal to 5'\n    END IF\nEND PROGRAM Conditional"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Subroutine\n    INTEGER :: number = 5, result\n    CALL MultiplyByTwo(number, result)\n    PRINT *, 'Result: ', result\nEND PROGRAM Subroutine\n\nSUBROUTINE MultiplyByTwo(num, res)\n    INTEGER, INTENT(IN) :: num\n    INTEGER, INTENT(OUT) :: res\n    res = num * 2\nEND SUBROUTINE MultiplyByTwo"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FileHandling\n    INTEGER :: unit\n    CHARACTER(LEN=100) :: line\n    OPEN (UNIT=unit, FILE='sample.txt', STATUS='OLD')\n    DO WHILE (.NOT. EOF(unit))\n        READ (unit, '(A)') line\n        PRINT *, line\n    END DO\n    CLOSE(unit)\nEND PROGRAM FileHandling"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Factorial\n    INTEGER :: n = 5, factorial = 1, i\n    DO i = 1, n\n        factorial = factorial * i\n    END DO\n    PRINT *, 'Factorial of ', n, ' is ', factorial\nEND PROGRAM Factorial"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ArrayExample\n    REAL :: numbers(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n    INTEGER :: i\n    DO i = 1, SIZE(numbers)\n        PRINT *, 'Number ', i, ': ', numbers(i)\n    END DO\nEND PROGRAM ArrayExample"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM QuadraticEquation\n    REAL :: a = 1.0, b = -3.0, c = 2.0, discriminant, root1, root2\n    discriminant = b**2 - 4 * a * c\n    root1 = (-b + SQRT(discriminant)) / (2 * a)\n    root2 = (-b - SQRT(discriminant)) / (2 * a)\n    PRINT *, 'Root 1: ', root1\n    PRINT *, 'Root 2: ', root2\nEND PROGRAM QuadraticEquation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FibonacciSeries\n    INTEGER :: n = 10, a = 0, b = 1, i, next\n    PRINT *, 'Fibonacci Series:'\n    DO i = 1, n\n        PRINT *, a\n        next = a + b\n        a = b\n        b = next\n    END DO\nEND PROGRAM FibonacciSeries"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM AverageCalculator\n    INTEGER :: n = 5, i\n    REAL :: numbers(n), total = 0.0, average\n    PRINT *, 'Enter ', n, ' numbers:'\n    DO i = 1, n\n        READ *, numbers(i)\n        total = total + numbers(i)\n    END DO\n    average = total / REAL(n)\n    PRINT *, 'Average: ', average\nEND PROGRAM AverageCalculator"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM StringConcatenation\n    CHARACTER(LEN=20) :: str1 = 'Hello', str2 = 'World', result\n    result = str1 // ' ' // str2\n    PRINT *, 'Concatenated String: ', result\nEND PROGRAM StringConcatenation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM PrimeNumberCheck\n    INTEGER :: num = 11, i, flag = 0\n    DO i = 2, num - 1\n        IF (MOD(num, i) == 0) THEN\n            flag = 1\n            EXIT\n        END IF\n    END DO\n    IF (flag == 0) THEN\n        PRINT *, num, ' is a prime number'\n    ELSE\n        PRINT *, num, ' is not a prime number'\n    END IF\nEND PROGRAM PrimeNumberCheck"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ExponentCalculation\n    REAL :: base = 2.0, exponent = 3.0, result\n    result = base ** exponent\n    PRINT *, 'Result: ', result\nEND PROGRAM ExponentCalculation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM LinearSearch\n    INTEGER :: numbers(5) = [4, 7, 2, 9, 5], key = 2, i, position = -1\n    DO i = 1, SIZE(numbers)\n        IF (numbers(i) == key) THEN\n            position = i\n            EXIT\n        END IF\n    END DO\n    IF (position /= -1) THEN\n        PRINT *, 'Element found at position: ', position\n    ELSE\n        PRINT *, 'Element not found'\n    END IF\nEND PROGRAM LinearSearch"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ArraySum\n    INTEGER, DIMENSION(3, 3) :: matrix = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    INTEGER :: i, j, total = 0\n    DO i = 1, 3\n        DO j = 1, 3\n            total = total + matrix(i, j)\n        END DO\n    END DO\n    PRINT *, 'Sum of matrix elements: ', total\nEND PROGRAM ArraySum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM OddEvenCounter\n    INTEGER :: numbers(5) = [1, 2, 3, 4, 5]\n    INTEGER :: i, oddCount = 0, evenCount = 0\n    DO i = 1, SIZE(numbers)\n        IF (MOD(numbers(i), 2) == 0) THEN\n            evenCount = evenCount + 1\n        ELSE\n            oddCount = oddCount + 1\n        END IF\n    END DO\n    PRINT *, 'Number of even numbers: ', evenCount\n    PRINT *, 'Number of odd numbers: ', oddCount\nEND PROGRAM OddEvenCounter"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM TriangleArea\n    REAL :: base = 5.0, height = 8.0, area\n    area = 0.5 * base * height\n    PRINT *, 'Area of the triangle: ', area\nEND PROGRAM TriangleArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM CircleArea\n    REAL :: radius = 7.0, area\n    area = 3.14 * radius * radius\n    PRINT *, 'Area of the circle: ', area\nEND PROGRAM CircleArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ArrayManipulation\n    INTEGER :: numbers(5) = [5, 10, 15, 20, 25], i\n    PRINT *, 'Original Array:'\n    DO i = 1, SIZE(numbers)\n        PRINT *, numbers(i)\n    END DO\n    PRINT *, 'Array after modification:'\n    DO i = 1, SIZE(numbers)\n        numbers(i) = numbers(i) * 2\n        PRINT *, numbers(i)\n    END DO\nEND PROGRAM ArrayManipulation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixMultiplication\n    INTEGER :: A(3,3), B(3,3), C(3,3)\n    INTEGER :: i, j, k, sum\n    A = RESHAPE([2, 3, 4, 5, 6, 7, 8, 9, 1], [3, 3])\n    B = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    DO i = 1, 3\n        DO j = 1, 3\n            sum = 0\n            DO k = 1, 3\n                sum = sum + A(i, k) * B(k, j)\n            END DO\n            C(i, j) = sum\n        END DO\n    END DO\n    PRINT *, 'Resultant Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, C(i, j)\n        END DO\n    END DO\nEND PROGRAM MatrixMultiplication"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SortingArray\n    INTEGER :: numbers(5) = [3, 7, 1, 5, 4]\n    INTEGER :: i, j, temp\n    DO i = 1, SIZE(numbers) - 1\n        DO j = 1, SIZE(numbers) - i\n            IF (numbers(j) > numbers(j+1)) THEN\n                temp = numbers(j)\n                numbers(j) = numbers(j+1)\n                numbers(j+1) = temp\n            END IF\n        END DO\n    END DO\n    PRINT *, 'Sorted Array:'\n    DO i = 1, SIZE(numbers)\n        PRINT *, numbers(i)\n    END DO\nEND PROGRAM SortingArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMaximum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, max\n    max = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) > max) THEN\n            max = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Maximum value: ', max\nEND PROGRAM FindingMaximum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMinimum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, min\n    min = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) < min) THEN\n            min = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Minimum value: ', min\nEND PROGRAM FindingMinimum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FibonacciRecursion\n    INTEGER :: n = 10\n    PRINT *, 'Fibonacci Series:'\n    DO i = 1, n\n        PRINT *, fibonacci(i)\n    END DO\nCONTAINS\n    INTEGER FUNCTION fibonacci(num)\n        INTEGER, INTENT(IN) :: num\n        IF (num <= 1) THEN\n            fibonacci = num\n        ELSE\n            fibonacci = fibonacci(num-1) + fibonacci(num-2)\n        END IF\n    END FUNCTION fibonacci\nEND PROGRAM FibonacciRecursion"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM TriangularArea\n    REAL :: base = 5.0, height = 8.0, area\n    area = 0.5 * base * height\n    PRINT *, 'Area of the triangle: ', area\nEND PROGRAM TriangularArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM CircleCircumference\n    REAL :: radius = 7.0, circumference\n    circumference = 2.0 * 3.14 * radius\n    PRINT *, 'Circumference of the circle: ', circumference\nEND PROGRAM CircleCircumference"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixTranspose\n    INTEGER :: A(3,3), i, j\n    A = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    PRINT *, 'Original Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(i, j)\n        END DO\n    END DO\n    PRINT *, 'Transposed Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(j, i)\n        END DO\n    END DO\nEND PROGRAM MatrixTranspose"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM PalindromeCheck\n    CHARACTER(LEN=50) :: str = 'racecar', reversed\n    INTEGER :: len, i, flag = 0\n    len = LEN_TRIM(str)\n    reversed = ''\n    DO i = len, 1, -1\n        reversed = TRIM(reversed) // str(i:i)\n    END DO\n    IF (TRIM(str) == reversed) THEN\n        PRINT *, 'It is a palindrome'\n    ELSE\n        PRINT *, 'It is not a palindrome'\n    END IF\nEND PROGRAM PalindromeCheck"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM VectorAddition\n    INTEGER :: A(3), B(3), C(3), i\n    A = [1, 2, 3]\n    B = [4, 5, 6]\n    DO i = 1, SIZE(A)\n        C(i) = A(i) + B(i)\n    END DO\n    PRINT *, 'Resultant Vector:'\n    DO i = 1, SIZE(C)\n        PRINT *, C(i)\n    END DO\nEND PROGRAM VectorAddition"
  },
  {
    "language": "Groovy",
    "code": "def greet() { println 'Hello, World!' } greet()"
  },
  {
    "language": "Groovy",
    "code": "def variables() { def number = 42 def piValue = 3.14 def message = 'Hello' def isTrue = true } variables()"
  },
  {
    "language": "Groovy",
    "code": "def conditionalStatements() { def isTrue = true if (isTrue) { println 'It is true!' } else { println 'It is false!' } } conditionalStatements()"
  },
  {
    "language": "Groovy",
    "code": "def loops() { for (int i = 0; i < 5; i++) { println \"Count: $i\" } } loops()"
  },
  {
    "language": "Groovy",
    "code": "def whileLoop() { def count = 0 while (count < 5) { println \"Count: $count\" count++ } } whileLoop()"
  },
  {
    "language": "Groovy",
    "code": "def greet(name) { println \"Hello, $name!\" } greet('Alice')"
  },
  {
    "language": "Groovy",
    "code": "def list() { def fruits = ['Apple', 'Orange', 'Banana'] println fruits } list()"
  },
  {
    "language": "Groovy",
    "code": "def map() { def ages = [Alice: 25, Bob: 30, Charlie: 28] println ages } map()"
  },
  {
    "language": "Groovy",
    "code": "class Person { String name int age } def person = new Person(name: 'Alice', age: 25) println \"Name: ${person.name}, Age: ${person.age}\""
  },
  {
    "language": "Groovy",
    "code": "def fetchData() { def result = new groovy.concurrent.Promise() result.future.onComplete { println 'Data fetched!' } result.resolve() } fetchData() println 'Fetching data...'"
  },
  {
    "language": "Groovy",
    "code": "def set() { def numbers = [1, 2, 3, 4, 5] as Set println numbers } set()"
  },
  {
    "language": "Groovy",
    "code": "enum Status { PENDING, APPROVED, REJECTED } def applicationStatus = Status.APPROVED println \"Application Status: $applicationStatus\""
  },
  {
    "language": "Groovy",
    "code": "import java.util.Random def random = new Random() println \"Random number: ${random.nextInt(100)}\""
  },
  {
    "language": "Groovy",
    "code": "def userInput() { print 'Enter your name: ' def name = System.console().readLine() println \"Hello, $name!\" } userInput()"
  },
  {
    "language": "Groovy",
    "code": "def optionalArguments(name = 'Anonymous') { println \"Hello, $name!\" } optionalArguments('Alice') optionalArguments()"
  },
  {
    "language": "Groovy",
    "code": "class Bird { def fly() { println 'Flying!' } } class Sparrow extends Bird {} def sparrow = new Sparrow() sparrow.fly()"
  },
  {
    "language": "Groovy",
    "code": "String.metaClass.shout = { println \"${delegate.toUpperCase()}!!!\" } def message = 'hello' message.shout()"
  },
  {
    "language": "Groovy",
    "code": "def delayedPrint() { groovy.concurrent.Promise.delay { println 'Delayed print after 2 seconds' } } delayedPrint() println 'Printed immediately'"
  },
  {
    "language": "Groovy",
    "code": "def regexExample() { def text = 'There are 123 apples' def pattern = /\\d+/ def matches = (text =~ pattern) matches.each { println \"Match: ${it}\" } } regexExample()"
  },
  {
    "language": "Groovy",
    "code": "def name = 'Alice'\nprintln 'Hello, $name!'"
  },
  {
    "language": "Groovy",
    "code": "int number = 7\nif (number % 2 == 0) {\n    println 'Even'\n} else {\n    println 'Odd'\n}"
  },
  {
    "language": "Groovy",
    "code": "int n = 5\nfor (int i = 1; i <= n; i++) {\n    println '*' * i\n}"
  },
  {
    "language": "Groovy",
    "code": "List<int> numbers = [1, 2, 3, 4, 5]\nList<int> squares = numbers.collect { it * it }\nprintln 'Squared values: $squares'"
  },
  {
    "language": "Groovy",
    "code": "String str = 'Groovy'\nString reversed = str.reverse()\nprintln 'Reversed string: $reversed'"
  },
  {
    "language": "Groovy",
    "code": "def radius = 7.0\ndef area = 3.14 * radius * radius\nprintln 'Area of the circle: $area'"
  },
  {
    "language": "Groovy",
    "code": "int num = 5\nwhile (num > 0) {\n    println 'Value: $num'\n    num--\n}"
  },
  {
    "language": "Groovy",
    "code": "String text = 'Groovy is awesome'\nList<String> parts = text.tokenize()\nparts.each { part ->\n    println 'Part: $part'\n}"
  },
  {
    "language": "Groovy",
    "code": "int a = 10, b = 20\nint max = (a > b) ? a : b\nprintln 'Maximum: $max'"
  },
  {
    "language": "Groovy",
    "code": "double tempCelsius = 30.0\ndouble tempFahrenheit = (tempCelsius * 9/5) + 32\nprintln '$tempCelsius\u00b0C = $tempFahrenheit\u00b0F'"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixMultiplication\n    INTEGER :: A(3,3), B(3,3), C(3,3)\n    INTEGER :: i, j, k, sum\n    A = RESHAPE([2, 3, 4, 5, 6, 7, 8, 9, 1], [3, 3])\n    B = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    DO i = 1, 3\n        DO j = 1, 3\n            sum = 0\n            DO k = 1, 3\n                sum = sum + A(i, k) * B(k, j)\n            END DO\n            C(i, j) = sum\n        END DO\n    END DO\n    PRINT *, 'Resultant Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, C(i, j)\n        END DO\n    END DO\nEND PROGRAM MatrixMultiplication"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SortingArray\n    INTEGER :: numbers(5) = [3, 7, 1, 5, 4]\n    INTEGER :: i, j, temp\n    DO i = 1, SIZE(numbers) - 1\n        DO j = 1, SIZE(numbers) - i\n            IF (numbers(j) > numbers(j+1)) THEN\n                temp = numbers(j)\n                numbers(j) = numbers(j+1)\n                numbers(j+1) = temp\n            END IF\n        END DO\n    END DO\n    PRINT *, 'Sorted Array:'\n    DO i = 1, SIZE(numbers)\n        PRINT *, numbers(i)\n    END DO\nEND PROGRAM SortingArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMaximum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, max\n    max = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) > max) THEN\n            max = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Maximum value: ', max\nEND PROGRAM FindingMaximum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMinimum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, min\n    min = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) < min) THEN\n            min = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Minimum value: ', min\nEND PROGRAM FindingMinimum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FibonacciRecursion\n    INTEGER :: n = 10\n    PRINT *, 'Fibonacci Series:'\n    DO i = 1, n\n        PRINT *, fibonacci(i)\n    END DO\nCONTAINS\n    INTEGER FUNCTION fibonacci(num)\n        INTEGER, INTENT(IN) :: num\n        IF (num <= 1) THEN\n            fibonacci = num\n        ELSE\n            fibonacci = fibonacci(num-1) + fibonacci(num-2)\n        END IF\n    END FUNCTION fibonacci\nEND PROGRAM FibonacciRecursion"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM TriangularArea\n    REAL :: base = 5.0, height = 8.0, area\n    area = 0.5 * base * height\n    PRINT *, 'Area of the triangle: ', area\nEND PROGRAM TriangularArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM CircleCircumference\n    REAL :: radius = 7.0, circumference\n    circumference = 2.0 * 3.14 * radius\n    PRINT *, 'Circumference of the circle: ', circumference\nEND PROGRAM CircleCircumference"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixTranspose\n    INTEGER :: A(3,3), i, j\n    A = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    PRINT *, 'Original Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(i, j)\n        END DO\n    END DO\n    PRINT *, 'Transposed Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(j, i)\n        END DO\n    END DO\nEND PROGRAM MatrixTranspose"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM PalindromeCheck\n    CHARACTER(LEN=50) :: str = 'racecar', reversed\n    INTEGER :: len, i, flag = 0\n    len = LEN_TRIM(str)\n    reversed = ''\n    DO i = len, 1, -1\n        reversed = TRIM(reversed) // str(i:i)\n    END DO\n    IF (TRIM(str) == reversed) THEN\n        PRINT *, 'It is a palindrome'\n    ELSE\n        PRINT *, 'It is not a palindrome'\n    END IF\nEND PROGRAM PalindromeCheck"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM VectorAddition\n    INTEGER :: A(3), B(3), C(3), i\n    A = [1, 2, 3]\n    B = [4, 5, 6]\n    DO i = 1, SIZE(A)\n        C(i) = A(i) + B(i)\n    END DO\n    PRINT *, 'Resultant Vector:'\n    DO i = 1, SIZE(C)\n        PRINT *, C(i)\n    END DO\nEND PROGRAM VectorAddition"
  },
  {
    "language": "Haskell",
    "code": "main :: IO () main = putStrLn \"Hello, World!\""
  },
  {
    "language": "Haskell",
    "code": "variables :: IO () variables = do let number = 42 piValue = 3.14 message = \"Hello\" isTrue = True putStrLn \"Variables defined\""
  },
  {
    "language": "Haskell",
    "code": "conditionalStatements :: Bool -> IO () conditionalStatements isTrue = if isTrue then putStrLn \"It is true!\" else putStrLn \"It is false!\""
  },
  {
    "language": "Haskell",
    "code": "loops :: IO () loops = mapM_ (\\i -> putStrLn $ \"Count: \" ++ show i) [0..4]"
  },
  {
    "language": "Haskell",
    "code": "whileLoop :: Int -> IO () whileLoop count = if count < 5 then do putStrLn $ \"Count: \" ++ show count whileLoop (count + 1) else return ()"
  },
  {
    "language": "Haskell",
    "code": "greet :: String -> IO () greet name = putStrLn $ \"Hello, \" ++ name ++ \"!\" greet \"Alice\""
  },
  {
    "language": "Haskell",
    "code": "list :: IO () list = let fruits = [\"Apple\", \"Orange\", \"Banana\"] in print fruits"
  },
  {
    "language": "Haskell",
    "code": "map :: IO () map = let ages = [(\"Alice\", 25), (\"Bob\", 30), (\"Charlie\", 28)] in print ages"
  },
  {
    "language": "Haskell",
    "code": "data Person = Person { name :: String, age :: Int } main :: IO () main = let person = Person { name = \"Alice\", age = 25 } in do putStrLn $ \"Name: \" ++ name person putStrLn $ \"Age: \" ++ show (age person)"
  },
  {
    "language": "Haskell",
    "code": "fetchData :: IO () fetchData = do putStrLn \"Fetching data...\" putStrLn \"Data fetched!\""
  },
  {
    "language": "Haskell",
    "code": "set :: IO () set = let numbers = [1, 2, 3, 4, 5] in print (Data.List.nub numbers)"
  },
  {
    "language": "Haskell",
    "code": "```data Status = Pending"
  },
  {
    "language": "Haskell",
    "code": "import System.Random main :: IO () main = do gen <- newStdGen let (randomNum, _) = randomR (1, 100) gen putStrLn $ \"Random number: \" ++ show randomNum"
  },
  {
    "language": "Haskell",
    "code": "userInput :: IO () userInput = do putStrLn \"Enter your name: \" name <- getLine putStrLn $ \"Hello, \" ++ name ++ \"!\""
  },
  {
    "language": "Haskell",
    "code": "optionalArguments :: Maybe String -> IO () optionalArguments name = case name of Just n -> putStrLn $ \"Hello, \" ++ n Nothing -> putStrLn \"Hello, World!\" optionalArguments (Just \"Alice\") optionalArguments Nothing"
  },
  {
    "language": "Haskell",
    "code": "data Bird = Bird fly :: Bird -> IO () fly _ = putStrLn \"Flying!\" main :: IO () main = fly Bird"
  },
  {
    "language": "Haskell",
    "code": "import Data.Char (toUpper) shout :: String -> IO () shout msg = putStrLn $ map toUpper msg ++ \"!!!\" main :: IO () main = shout \"hello\""
  },
  {
    "language": "Haskell",
    "code": "delayedPrint :: IO () delayedPrint = do putStrLn \"Printed immediately\" threadDelay 2000000 putStrLn \"Delayed print after 2 seconds\""
  },
  {
    "language": "Haskell",
    "code": "import Text.Regex.PCRE regexExample :: IO () regexExample = do let text = \"There are 123 apples\" let matches = getAllTextMatches $ text =~ \"\\\\d+\" :: [String] mapM_ putStrLn matches"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = putStrLn \"Hello, World!\""
  },
  {
    "language": "Haskell",
    "code": "add :: Int -> Int -> Int\nadd a b = a + b\nmain :: IO ()\nmain = print (add 3 5)"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (putStrLn . show) [0..4]"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (\\name -> putStrLn $ \"Hello, \" ++ name ++ \"!\") [\"Alice\", \"Bob\", \"Charlie\"]"
  },
  {
    "language": "Haskell",
    "code": "concatenate :: String -> String -> String\nconcatenate a b = a ++ \", \" ++ b ++ \"!\"\nmain :: IO ()\nmain = putStrLn $ concatenate \"Hello\" \"Alice\""
  },
  {
    "language": "Haskell",
    "code": "calculateArea :: Double -> Double\ncalculateArea radius = 3.14 * radius * radius\nmain :: IO ()\nmain = print $ calculateArea 7.0"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = if 10 > 5 then putStrLn \"Number is greater than 5\" else putStrLn \"Number is less than or equal to 5\""
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (\\x -> putStrLn $ \"Value: \" ++ show x) [0..4]"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (\\num -> putStrLn $ \"Number: \" ++ show num) [1, 2, 3, 4, 5]"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = putStrLn \"This is a Haskell program\""
  },
  {
    "language": "Haskell",
    "code": "greet :: String -> String\ngreet name = \"Hello, \" ++ name ++ \"!\"\nmain :: IO ()\nmain = putStrLn (greet \"Alice\")"
  },
  {
    "language": "Haskell",
    "code": "isEven :: Int -> Bool\nisEven n = n `mod` 2 == 0\nmain :: IO ()\nmain = print (isEven 7)"
  },
  {
    "language": "Haskell",
    "code": "printStars :: Int -> IO ()\nprintStars n = mapM_ putStrLn (replicate n \"*\")\nmain :: IO ()\nmain = printStars 5"
  },
  {
    "language": "Haskell",
    "code": "squares :: [Int]\nsquares = map (^2) [1..5]\nmain :: IO ()\nmain = print squares"
  },
  {
    "language": "Haskell",
    "code": "reverseString :: String -> String\nreverseString str = reverse str\nmain :: IO ()\nmain = putStrLn (reverseString \"Haskell\")"
  },
  {
    "language": "Haskell",
    "code": "calculateArea :: Double -> Double\ncalculateArea radius = 3.14 * radius * radius\nmain :: IO ()\nmain = print (calculateArea 5.0)"
  },
  {
    "language": "Haskell",
    "code": "checkNumber :: Int -> IO ()\ncheckNumber num = if num > 5 then putStrLn \"Number is greater than 5\" else putStrLn \"Number is less than or equal to 5\"\nmain :: IO ()\nmain = checkNumber 10"
  },
  {
    "language": "Haskell",
    "code": "printValues :: IO ()\nprintValues = mapM_ (\\x -> putStrLn $ \"Value: \" ++ show x) [1..5]\nmain :: IO ()\nmain = printValues"
  },
  {
    "language": "Haskell",
    "code": "printNumbers :: IO ()\nprintNumbers = mapM_ (\\n -> putStrLn $ \"Number: \" ++ show n) [6, 7, 8, 9, 10]\nmain :: IO ()\nmain = printNumbers"
  },
  {
    "language": "Haskell",
    "code": "printText :: IO ()\nprintText = putStrLn \"This is another Haskell program\"\nmain :: IO ()\nmain = printText"
  },
  {
    "language": "Lisp",
    "code": "(defun hello-world () (format t \"Hello, World!\")) (hello-world)"
  },
  {
    "language": "Lisp",
    "code": "(defun variables () (let ((number 42) (piValue 3.14) (message \"Hello\") (isTrue t)) (format t \"Variables defined\"))) (variables)"
  },
  {
    "language": "Lisp",
    "code": "(defun conditional-statements (isTrue) (if isTrue (format t \"It is true!\") (format t \"It is false!\"))) (conditional-statements t)"
  },
  {
    "language": "Lisp",
    "code": "(defun loops () (dotimes (i 5) (format t \"Count: ~A~%\" i))) (loops)"
  },
  {
    "language": "Lisp",
    "code": "(defun while-loop (count) (if (< count 5) (progn (format t \"Count: ~A~%\" count) (while-loop (+ count 1))))) (while-loop 0)"
  },
  {
    "language": "Lisp",
    "code": "(defun greet (name) (format t \"Hello, ~A!~%\" name)) (greet \"Alice\")"
  },
  {
    "language": "Lisp",
    "code": "(defun list-example () (let ((fruits '(\"Apple\" \"Orange\" \"Banana\"))) (print fruits))) (list-example)"
  },
  {
    "language": "Lisp",
    "code": "(defun map-example () (let ((ages '((Alice . 25) (Bob . 30) (Charlie . 28)))) (print ages))) (map-example)"
  },
  {
    "language": "Lisp",
    "code": "(defstruct person name age) (let ((person (make-person :name \"Alice\" :age 25))) (format t \"Name: ~A~%\" (person-name person)) (format t \"Age: ~A~%\" (person-age person)))"
  },
  {
    "language": "Lisp",
    "code": "(defun fetch-data () (format t \"Fetching data...~%\") (format t \"Data fetched!\")) (fetch-data)"
  },
  {
    "language": "Lisp",
    "code": "(defun set-example () (let ((numbers (list 1 2 3 4 5))) (print (remove-duplicates numbers)))) (set-example)"
  },
  {
    "language": "Lisp",
    "code": "(defparameter *status* '(pending approved rejected)) (let ((application-status (nth 1 *status*))) (format t \"Application Status: ~A~%\" application-status))"
  },
  {
    "language": "Lisp",
    "code": "(ql:quickload :cl-random) (let ((random-number (random:random 100))) (format t \"Random number: ~A~%\" random-number))"
  },
  {
    "language": "Lisp",
    "code": "(defun user-input () (format t \"Enter your name: \") (let ((name (read-line))) (format t \"Hello, ~A!~%\" name))) (user-input)"
  },
  {
    "language": "Lisp",
    "code": "(defun optional-arguments (&optional (name \"Anonymous\")) (format t \"Hello, ~A!~%\" name)) (optional-arguments \"Alice\") (optional-arguments)"
  },
  {
    "language": "Lisp",
    "code": "(defclass bird () ()) (defmethod fly ((bird bird)) (format t \"Flying!\")) (let ((sparrow (make-instance 'bird))) (fly sparrow))"
  },
  {
    "language": "Lisp",
    "code": "(defun shout (msg) (format t \"~A!!!~%\" (string-upcase msg))) (shout \"hello\")"
  },
  {
    "language": "Lisp",
    "code": "(defun delayed-print () (format t \"Printed immediately~%\") (sleep 2) (format t \"Delayed print after 2 seconds~%\")) (delayed-print)"
  },
  {
    "language": "Lisp",
    "code": "(ql:quickload :cl-ppcre) (let ((text \"There are 123 apples\") (matches (ppcre:all-matches-as-strings \"\\\\d+\" \"There are 123 apples\"))) (mapc #'(lambda (match) (format t \"Match: ~A~%\" match)) matches))"
  },
  {
    "language": "Lisp",
    "code": "(defun hello-world ()\n  (format t \"Hello, World!\"))\n(hello-world)"
  },
  {
    "language": "Lisp",
    "code": "(defun add (a b)\n  (+ a b))\n(print (add 3 5))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (i 5)\n  (format t \"Value: ~A~%\" i))"
  },
  {
    "language": "Lisp",
    "code": "(defparameter *names* '(\"Alice\" \"Bob\" \"Charlie\"))\n(mapc #'(lambda (name)\n          (format t \"Hello, ~A!~%\" name))\n      *names*)"
  },
  {
    "language": "Lisp",
    "code": "(defun concatenate (a b)\n  (format nil \"~A, ~A!\" a b))\n(println (concatenate \"Hello\" \"Alice\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun calculate-area (radius)\n  (* 3.14 (* radius radius)))\n(print (calculate-area 7.0))"
  },
  {
    "language": "Lisp",
    "code": "(if (> 10 5)\n    (format t \"Number is greater than 5~%\")\n    (format t \"Number is less than or equal to 5~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (x 5)\n  (format t \"Value: ~A~%\" x))"
  },
  {
    "language": "Lisp",
    "code": "(mapcar #'(lambda (num)\n            (format t \"Number: ~A~%\" num))\n        '(1 2 3 4 5))"
  },
  {
    "language": "Lisp",
    "code": "(format t \"This is a Lisp program~%\")"
  },
  {
    "language": "Lisp",
    "code": "(defun greet (name)\n  (format t \"Hello, ~A!\" name))\n(greet \"Alice\")"
  },
  {
    "language": "Lisp",
    "code": "(defun is-even (n)\n  (= (mod n 2) 0))\n(print (is-even 7))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (i 5)\n  (dotimes (j (1+ i))\n    (format t \"*\")\n  )\n  (format t \"~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun squares ()\n  (mapcar #'(lambda (x) (* x x)) '(1 2 3 4 5)))\n(print (squares))"
  },
  {
    "language": "Lisp",
    "code": "(defun reverse-string (str)\n  (reverse str))\n(println (reverse-string \"Lisp\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun calculate-area (radius)\n  (* 3.14 (* radius radius)))\n(print (calculate-area 5.0))"
  },
  {
    "language": "Lisp",
    "code": "(if (> 10 5)\n    (format t \"Number is greater than 5~%\")\n    (format t \"Number is less than or equal to 5~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (num 5)\n  (format t \"Value: ~A~%\" num))"
  },
  {
    "language": "Lisp",
    "code": "(mapcar #'(lambda (n)\n            (format t \"Number: ~A~%\" n))\n        '(6 7 8 9 10))"
  },
  {
    "language": "Lisp",
    "code": "(format t \"This is another Lisp program~%\")"
  },
  {
    "language": "Lisp",
    "code": "(defun factorial (n)\n  (if (= n 0) 1\n    (* n (factorial (- n 1)))))\n(println (factorial 5))"
  },
  {
    "language": "Lisp",
    "code": "(defun fibonacci (n)\n  (cond\n    ((= n 0) 0)\n    ((= n 1) 1)\n    (t (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))\n(println (fibonacci 8))"
  },
  {
    "language": "Lisp",
    "code": "(defun is-prime (n)\n  (if (<= n 1) nil\n    (loop for i from 2 to (isqrt n) when (zerop (mod n i)) return nil)\n    t))\n(println (is-prime 17))"
  },
  {
    "language": "Lisp",
    "code": "(defun reverse-list (lst)\n  (if (null lst) '()\n    (append (reverse-list (cdr lst)) (list (car lst)))))\n(println (reverse-list '(1 2 3 4 5)))"
  },
  {
    "language": "Lisp",
    "code": "(defun count-occurrences (item lst)\n  (count item lst))\n(println (count-occurrences 'a '(a b a c a d)))"
  },
  {
    "language": "Lisp",
    "code": "(defun remove-duplicates (lst)\n  (remove-duplicates lst :test #'equal))\n(println (remove-duplicates '(1 2 2 3 4 4 4)))"
  },
  {
    "language": "Lisp",
    "code": "(defun first-n-elements (n lst)\n  (if (<= n 0) '()\n    (cons (car lst) (first-n-elements (- n 1) (cdr lst)))))\n(println (first-n-elements 3 '(1 2 3 4 5 6)))"
  },
  {
    "language": "Lisp",
    "code": "(defun last-element (lst)\n  (if (null (cdr lst)) (car lst)\n    (last-element (cdr lst))))\n(println (last-element '(1 2 3 4 5)))"
  },
  {
    "language": "Lisp",
    "code": "(defun list-range (start end)\n  (loop for i from start to end collect i))\n(println (list-range 1 10))"
  },
  {
    "language": "Lisp",
    "code": "(defun flatten (lst)\n  (cond\n    ((null lst) '())\n    ((atom lst) (list lst))\n    (t (append (flatten (car lst)) (flatten (cdr lst))))))\n(println (flatten '(1 (2 (3 4) 5) 6)))"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Hello, World!</title> </head> <body> <h1>Hello, World!</h1> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>My Page</title> </head> <body> <h2>Welcome!</h2> <p>This is my first webpage.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Lists</title> </head> <body> <h2>Shopping List</h2> <ul> <li>Apples</li> <li>Oranges</li> <li>Bananas</li> </ul> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Links</title> </head> <body> <h2>Useful Links</h2> <a href=\"https://www.example.com\">Example</a> <a href=\"https://www.google.com\">Google</a> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Forms</title> </head> <body> <h2>Login Form</h2> <form> <label for=\"username\">Username:</label> <input type=\"text\" id=\"username\" name=\"username\"><br><br> <label for=\"password\">Password:</label> <input type=\"password\" id=\"password\" name=\"password\"><br><br> <input type=\"submit\" value=\"Submit\"> </form> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Images</title> </head> <body> <h2>Cute Animals</h2> <img src=\"cat.jpg\" alt=\"Cat\"> <img src=\"dog.jpg\" alt=\"Dog\"> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Tables</title> </head> <body> <h2>Employee Details</h2> <table border=\"1\"> <tr> <th>Name</th> <th>Age</th> </tr> <tr> <td>Alice</td> <td>25</td> </tr> <tr> <td>Bob</td> <td>30</td> </tr> </table> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Audio</title> </head> <body> <h2>Listen to Music</h2> <audio controls> <source src=\"song.mp3\" type=\"audio/mpeg\"> Your browser does not support the audio element. </audio> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Video</title> </head> <body> <h2>Watch a Video</h2> <video width=\"320\" height=\"240\" controls> <source src=\"video.mp4\" type=\"video/mp4\"> Your browser does not support the video tag. </video> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Styling</title> <style> h1 { color: blue; } p { font-size: 16px; } </style> </head> <body> <h1>Welcome!</h1> <p>This is a styled paragraph.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>JavaScript</title> <script> function showMessage() { alert('Hello, World!'); } </script> </head> <body> <h2>Click the button</h2> <button onclick=\"showMessage()\">Show Message</button> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Canvas</title> <script> function draw() { var canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d'); ctx.fillStyle = 'green'; ctx.fillRect(10, 10, 150, 100); } </script> </head> <body> <h2>Draw a Rectangle</h2> <canvas id=\"myCanvas\" width=\"200\" height=\"200\" style=\"border:1px solid black;\"></canvas> <br> <button onclick=\"draw()\">Draw</button> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Comments</title> </head> <body> <!-- This is a comment --> <h1>Welcome!</h1> <p>This is an example of using comments in HTML.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Dropdown Menu</title> <style> .dropdown { position: relative; display: inline-block; } .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 120px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); } .dropdown:hover .dropdown-content { display: block; } </style> </head> <body> <h2>Hoverable Dropdown</h2> <div class=\"dropdown\"> <span>Hover me</span> <div class=\"dropdown-content\"> <p>Dropdown item 1</p> <p>Dropdown item 2</p> <p>Dropdown item 3</p> </div> </div> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Form Validation</title> <style> .error { color: red; } </style> </head> <body> <h2>Registration Form</h2> <form onsubmit=\"return validateForm()\"> <label for=\"username\">Username:</label> <input type=\"text\" id=\"username\" name=\"username\"><br> <span id=\"username-error\" class=\"error\"></span><br> <label for=\"password\">Password:</label> <input type=\"password\" id=\"password\" name=\"password\"><br> <span id=\"password-error\" class=\"error\"></span><br> <input type=\"submit\" value=\"Submit\"> </form> <script> function validateForm() { var username = document.getElementById('username').value; var password = document.getElementById('password').value; if (username === "
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Meta Tags</title> <meta charset=\"UTF-8\"> <meta name=\"description\" content=\"Example meta tags for a webpage\"> <meta name=\"keywords\" content=\"HTML, Meta Tags, Webpage\"> <meta name=\"author\" content=\"Your Name\"> </head> <body> <h1>Webpage with Meta Tags</h1> <p>This webpage uses meta tags for SEO.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Audio Playlist</title> </head> <body> <h2>My Music Playlist</h2> <audio controls> <source src=\"song1.mp3\" type=\"audio/mpeg\"> <source src=\"song2.ogg\" type=\"audio/ogg\"> Your browser does not support the audio element. </audio> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Video Playlist</title> </head> <body> <h2>My Video Playlist</h2> <video width=\"320\" height=\"240\" controls> <source src=\"video1.mp4\" type=\"video/mp4\"> <source src=\"video2.webm\" type=\"video/webm\"> Your browser does not support the video tag. </video> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>SVG</title> </head> <body> <h2>Circle</h2> <svg height=\"100\" width=\"100\"> <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" /> </svg> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Canvas Animation</title> <style> canvas { border: 1px solid black; } </style> </head> <body> <h2>Canvas Animation</h2> <canvas id=\"myCanvas\" width=\"200\" height=\"100\"></canvas> <script> var canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d'); var x = 0; function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'blue'; ctx.fillRect(x, 0, 50, 50); x += 1; if (x >= canvas.width) { x = 0; } requestAnimationFrame(draw); } draw(); </script> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Geolocation</title> </head> <body> <h2>Location Finder</h2> <p id=\"demo\"></p> <script> function getLocation() { if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition); } else { document.getElementById('demo').innerHTML = 'Geolocation is not supported by this browser.'; } } function showPosition(position) { document.getElementById('demo').innerHTML = 'Latitude: ' + position.coords.latitude + '<br>Longitude: ' + position.coords.longitude; } </script> <button onclick=\"getLocation()\">Get Location</button> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Drag and Drop</title> <style> #div1, #div2 { width: 100px; height: 50px; padding: 10px; border: 1px solid black; margin: 10px 0; } </style> <script> function allowDrop(event) { event.preventDefault(); } function drag(event) { event.dataTransfer.setData('text', event.target.id); } function drop(event) { event.preventDefault(); var data = event.dataTransfer.getData('text'); event.target.appendChild(document.getElementById(data)); } </script> </head> <body> <h2>Drag and Drop</h2> <div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div> <div id=\"div2\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div> <img id=\"drag1\" src=\"img.jpg\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"88\" height=\"31\"> <img id=\"drag2\" src=\"img.jpg\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"88\" height=\"31\"> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Local Storage</title> <script> function saveData() { var data = document.getElementById('data').value; localStorage.setItem('userInput', data); } function loadData() { var data = localStorage.getItem('userInput'); document.getElementById('display').innerHTML = 'Data from Local Storage: ' + data; } </script> </head> <body> <h2>Local Storage Example</h2> <input type=\"text\" id="
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello, World!</title>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Simple Form</title>\n</head>\n<body>\n    <form>\n        <label for=\"name\">Name:</label>\n        <input type=\"text\" id=\"name\" name=\"name\">\n        <br>\n        <input type=\"submit\" value=\"Submit\">\n    </form>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>List Example</title>\n</head>\n<body>\n    <ul>\n        <li>Apple</li>\n        <li>Orange</li>\n        <li>Banana</li>\n    </ul>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Table Example</title>\n</head>\n<body>\n    <table border=\"1\">\n        <tr>\n            <th>Name</th>\n            <th>Age</th>\n        </tr>\n        <tr>\n            <td>Alice</td>\n            <td>25</td>\n        </tr>\n        <tr>\n            <td>Bob</td>\n            <td>30</td>\n        </tr>\n    </table>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Image Example</title>\n</head>\n<body>\n    <img src=\"https://via.placeholder.com/150\" alt=\"Placeholder Image\">\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Link Example</title>\n</head>\n<body>\n    <a href=\"https://www.example.com\">Visit Example Website</a>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Button Example</title>\n</head>\n<body>\n    <button onclick=\"alert('Hello!')\">Click me</button>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Heading Example</title>\n</head>\n<body>\n    <h2>Welcome to my Website</h2>\n    <p>This is a paragraph describing the website.</p>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Audio Example</title>\n</head>\n<body>\n    <audio controls>\n        <source src=\"horse.ogg\" type=\"audio/ogg\">\n        <source src=\"horse.mp3\" type=\"audio/mpeg\">\n        Your browser does not support the audio element.\n    </audio>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Video Example</title>\n</head>\n<body>\n    <video width=\"320\" height=\"240\" controls>\n        <source src=\"movie.mp4\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n    </video>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Form Example</title>\n</head>\n<body>\n    <form action=\"/submit\" method=\"post\">\n        <label for=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" name=\"username\">\n        <br>\n        <label for=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" name=\"password\">\n        <br>\n        <input type=\"submit\" value=\"Login\">\n    </form>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Dropdown Example</title>\n</head>\n<body>\n    <select>\n        <option value=\"volvo\">Volvo</option>\n        <option value=\"saab\">Saab</option>\n        <option value=\"mercedes\">Mercedes</option>\n        <option value=\"audi\">Audi</option>\n    </select>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Canvas Example</title>\n</head>\n<body>\n    <canvas id=\"myCanvas\" width=\"200\" height=\"100\" style=\"border:1px solid #000000;\">\n        Your browser does not support the HTML canvas element.\n    </canvas>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Checkbox Example</title>\n</head>\n<body>\n    <input type=\"checkbox\" id=\"vehicle1\" name=\"vehicle1\" value=\"Bike\">\n    <label for=\"vehicle1\">I have a bike</label><br>\n    <input type=\"checkbox\" id=\"vehicle2\" name=\"vehicle2\" value=\"Car\">\n    <label for=\"vehicle2\">I have a car</label><br>\n    <input type=\"checkbox\" id=\"vehicle3\" name=\"vehicle3\" value=\"Boat\">\n    <label for=\"vehicle3\">I have a boat</label><br>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Radio Button Example</title>\n</head>\n<body>\n    <input type=\"radio\" id=\"male\" name=\"gender\" value=\"male\">\n    <label for=\"male\">Male</label><br>\n    <input type=\"radio\" id=\"female\" name=\"gender\" value=\"female\">\n    <label for=\"female\">Female</label><br>\n    <input type=\"radio\" id=\"other\" name=\"gender\" value=\"other\">\n    <label for=\"other\">Other</label><br>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Textarea Example</title>\n</head>\n<body>\n    <textarea id=\"message\" name=\"message\" rows=\"4\" cols=\"50\">\n        Write your message here...\n    </textarea>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Ordered List Example</title>\n</head>\n<body>\n    <ol>\n        <li>Coffee</li>\n        <li>Tea</li>\n        <li>Milk</li>\n    </ol>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Embedded Iframe Example</title>\n</head>\n<body>\n    <iframe src=\"https://www.example.com\"></iframe>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Meta Tags Example</title>\n    <meta charset=\"UTF-8\">\n    <meta name=\"description\" content=\"Example Description\">\n    <meta name=\"keywords\" content=\"HTML, Example, Tags\">\n</head>\n<body>\n    <!-- Content Here -->\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Progress Bar Example</title>\n</head>\n<body>\n    <progress value=\"70\" max=\"100\"></progress>\n</body>\n</html>"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func variables() { number := 42 piValue := 3.14 message := \"Hello\" isTrue := true fmt.Println(number, piValue, message, isTrue) } func main() { variables() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func conditionalStatements(isTrue bool) { if isTrue { fmt.Println(\"It is true!\") } else { fmt.Println(\"It is false!\") } } func main() { conditionalStatements(true) }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func loops() { for i := 0; i < 5; i++ { fmt.Println(\"Count:\", i) } } func main() { loops() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func whileLoop() { count := 0 for count < 5 { fmt.Println(\"Count:\", count) count++ } } func main() { whileLoop() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func greet(name string) { fmt.Println(\"Hello,\", name+\"!\") } func main() { greet(\"Alice\") }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func list() { fruits := []string{\"Apple\", \"Orange\", \"Banana\"} fmt.Println(fruits) } func main() { list() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func mapExample() { ages := map[string]int{\"Alice\": 25, \"Bob\": 30, \"Charlie\": 28} fmt.Println(ages) } func main() { mapExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" type Person struct { name string age int } func main() { person := Person{name: \"Alice\", age: 25} fmt.Println(\"Name:\", person.name, \"Age:\", person.age) }"
  },
  {
    "language": "Go",
    "code": "package main import ( \"fmt\" \"time\" ) func fetchData() { fmt.Println(\"Fetching data...\") time.Sleep(2 * time.Second) fmt.Println(\"Data fetched!\") } func main() { fetchData() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func set() { numbers := map[int]bool{1: true, 2: true, 3: true, 4: true, 5: true} fmt.Println(numbers) } func main() { set() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" type Status int const ( PENDING Status = iota APPROVED REJECTED ) func main() { applicationStatus := APPROVED fmt.Println(\"Application Status:\", applicationStatus) }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"math/rand\" func randomNumbers() { fmt.Println(\"Random number:\", rand.Intn(100)) } func main() { randomNumbers() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func userInput() { var name string fmt.Print(\"Enter your name: \") fmt.Scanln(&name) fmt.Println(\"Hello,\", name+\"!\") } func main() { userInput() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func optionalArguments(names ...string) { for _, name := range names { fmt.Println(\"Hello,\", name+\"!\") } } func main() { optionalArguments(\"Alice\", \"Bob\") optionalArguments() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func structs() { type Rectangle struct { width, height int } var rect Rectangle rect.width = 10 rect.height = 20 fmt.Println(\"Rectangle:\", rect) } func main() { structs() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"os\" func fileIO() { file, err := os.Create(\"test.txt\") if err != nil { fmt.Println(\"Error creating file:\", err) return } defer file.Close() file.WriteString(\"Hello, Go!\") fmt.Println(\"File created and written to.\") } func main() { fileIO() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func deferExample() { defer fmt.Println(\"World!\") fmt.Println(\"Hello,\") } func main() { deferExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func panicRecover() { defer func() { if r := recover(); r != nil { fmt.Println(\"Recovered from panic:\", r) } }() panic(\"Panic occurred!\") } func main() { panicRecover() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func channels() { ch := make(chan int) go func() { ch <- 42 }() fmt.Println(\"Channel value:\", <-ch) } func main() { channels() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func selectExample() { ch1 := make(chan string) ch2 := make(chan string) go func() { ch1 <- \"Hello\" }() go func() { ch2 <- \"World\" }() select { case msg1 := <-ch1: fmt.Println(\"Received:\", msg1) case msg2 := <-ch2: fmt.Println(\"Received:\", msg2) } } func main() { selectExample() }"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, Go!\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(\"Square root of 16 is:\", math.Sqrt(16))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := add(3, 7)\n\tfmt.Println(\"Sum:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(i)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x int\n\tfmt.Println(\"Enter a number:\")\n\tfmt.Scan(&x)\n\tfmt.Println(\"You entered:\", x)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a, b int = 5, 10\n\tfmt.Printf(\"Before swap: a = %d, b = %d\\n\", a, b)\n\t// Swap logic\n\ta, b = b, a\n\tfmt.Printf(\"After swap: a = %d, b = %d\\n\", a, b)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar message = make(chan string)\n\tgo func() {\n\t\tmessage <- \"Hello, Go Concurrency!\"\n\t}()\n\treceivedMessage := <-message\n\tfmt.Println(receivedMessage)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfruits := []string{\"apple\", \"banana\", \"orange\"}\n\tfor index, fruit := range fruits {\n\t\tfmt.Printf(\"Index: %d, Fruit: %s\\n\", index, fruit)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tconst pi = 3.14159\n\tfmt.Printf(\"Value of pi: %f\\n\", pi)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"Deferred statement 1\")\n\tdefer fmt.Println(\"Deferred statement 2\")\n\tfmt.Println(\"Main function\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar age int\n\tswitch {\n\tcase age < 18:\n\t\tfmt.Println(\"You are a minor.\")\n\tcase age >= 18 && age < 60:\n\t\tfmt.Println(\"You are an adult.\")\n\tdefault:\n\t\tfmt.Println(\"You are a senior citizen.\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcurrentHour := time.Now().Hour()\n\tif currentHour < 12 {\n\t\tfmt.Println(\"Good morning!\")\n\t} else if currentHour < 17 {\n\t\tfmt.Println(\"Good afternoon!\")\n\t} else {\n\t\tfmt.Println(\"Good evening!\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x interface{}\n\tx = 42\n\tswitch x.(type) {\n\tcase int:\n\t\tfmt.Println(\"x is an integer\")\n\tcase string:\n\t\tfmt.Println(\"x is a string\")\n\tdefault:\n\t\tfmt.Println(\"x is of unknown type\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4, 5}\n\t// Doubling each element in the slice\n\tfor i := range numbers {\n\t\tnumbers[i] *= 2\n\t}\n\tfmt.Println(\"Doubled numbers:\", numbers)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Your code here\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateSum(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := calculateSum(10, 20)\n\tfmt.Println(\"Sum is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}\n\nfunc main() {\n\tresult := fibonacci(10)\n\tfmt.Println(\"Fibonacci of 10 is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc printTime() {\n\tfmt.Println(\"Current time:\", time.Now())\n}\n\nfunc main() {\n\t// Your code here\n\tprintTime()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc findMax(nums ...int) int {\n\tmax := nums[0]\n\tfor _, num := range nums {\n\t"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc reverseString(input string) string {\n\tchars := strings.Split(input, \"\")\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn strings.Join(chars, \"\")\n}\n\nfunc main() {\n\toriginal := \"Hello, Go!\"\n\treversed := reverseString(original)\n\tfmt.Printf(\"Original: %s, Reversed: %s\\n\", original, reversed)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateRandomNumber() int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(100)\n}\n\nfunc main() {\n\trandomNumber := generateRandomNumber()\n\tfmt.Println(\"Random Number:\", randomNumber)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc readFile(filename string) (string, error) {\n\tdata, err := os.ReadFile(filename)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}\n\nfunc main() {\n\tcontent, err := readFile(\"example.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"File content:\", content)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc convertStringToInt(input string) (int, error) {\n\tresult, err := strconv.Atoi(input)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn result, nil\n}\n\nfunc main() {\n\tstrNumber := \"42\"\n\tintNumber, err := convertStringToInt(strNumber)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting string to int:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Converted Int:\", intNumber)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateFactorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * calculateFactorial(n-1)\n}\n\nfunc main() {\n\tresult := calculateFactorial(5)\n\tfmt.Println(\"Factorial of 5 is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc calculateCircleArea(radius float64) float64 {\n\treturn math.Pi * math.Pow(radius, 2)\n}\n\nfunc main() {\n\tradius := 3.0\n\tarea := calculateCircleArea(radius)\n\tfmt.Printf(\"Circle area with radius %.2f: %.2f\\n\", radius, area)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n)\n\ntype Person struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tCity  string `json:\"city\"`\n}\n\nfunc main() {\n\tperson := Person{\"John Doe\", 30, \"New York\"}\n\tjsonData, err := json.Marshal(person)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"JSON Data:\", string(jsonData))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc sleepAndPrint(message string, duration time.Duration) {\n\ttime.Sleep(duration)\n\tfmt.Println(message)\n}\n\nfunc main() {\n\tsleepAndPrint(\"Message 1\", 2*time.Second)\n\tsleepAndPrint(\"Message 2\", 1*time.Second)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc sortIntSlice(nums []int) {\n\tsort.Ints(nums)\n\tfmt.Println(\"Sorted Slice:\", nums)\n}\n\nfunc main() {\n\tnumbers := []int{5, 2, 8, 1, 9}\n\tsortIntSlice(numbers)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc formatNumberAsString(number int) string {\n\treturn strconv.FormatInt(int64(number), 2)\n}\n\nfunc main() {\n\tnumber := 42\n\tbinaryString := formatNumberAsString(number)\n\tfmt.Printf(\"Binary representation of %d: %s\\n\", number, binaryString)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleRequest)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc printTimePeriodically() {\n\tfor {\n\t\tfmt.Println(\"Current time:\", time.Now())\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}\n\nfunc main() {\n\tgo printTimePeriodically()\n\t// Your code here\n\ttime.Sleep(30 * time.Second)\n}"
  },
  {
    "language": "Erlang",
    "code": "module(hello). -export([world/0]). world() -> io:format(\"Hello, World!~n\")."
  },
  {
    "language": "Erlang",
    "code": "module(variables). -export([example/0]). example() -> Number = 42, PiValue = 3.14, Message = \"Hello\", IsTrue = true, io:format(\"~w ~w ~s I160, [Number, PiValue, Message, IsTrue])."
  },
  {
    "language": "Erlang",
    "code": "module(conditional). -export([statements/1]). statements(true) -> io:format(\"It is true!~n\"); statements(false) -> io:format(\"It is false!~n\")"
  },
  {
    "language": "Erlang",
    "code": "-module(loops). -export([example/0]). example() -> loops(0). loops(5) -> ok; loops(Count) -> io:format(\"Count: ~w~n\", [Count]), loops(Count + 1).'"
  },
  {
    "language": "Erlang",
    "code": "-module(while). -export([example/0]). example() -> while(0). while(5) -> ok; while(Count) -> io:format(\"Count: ~w~n\", [Count]), while(Count + 1).'"
  },
  {
    "language": "Erlang",
    "code": "-module(greet). -export([hello/1]). hello(Name) -> io:format(\"Hello, ~s!~n\", [Name]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(lists). -export([example/0]). example() -> List = [1, 2, 3, 4, 5], io:format(\"~w~n\", [List]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(maps). -export([example/0]). example() -> Map = #{alice => 25, bob => 30, charlie => 28}, io:format(\"~p~n\", [Map]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(person). -export([details/0]). details() -> Person = #{name => \"Alice\", age => 25}, io:format(\"Name: ~s, Age: ~w~n\", [maps:get(name, Person), maps:get(age, Person)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(delay). -export([wait/0]). wait() -> timer:sleep(2000), io:format(\"Waited for 2 seconds!~n\").'"
  },
  {
    "language": "Erlang",
    "code": "-module(set). -export([example/0]). example() -> Set = #{1 => true, 2 => true, 3 => true, 4 => true, 5 => true}, io:format(\"~p~n\", [Set]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(status). -export([example/0]). example() -> ApplicationStatus = approved, io:format(\"Application Status: ~p~n\", [ApplicationStatus]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(random). -export([example/0]). example() -> random:seed(erlang:system_time()), io:format(\"Random Number: ~w~n\", [random:uniform(100)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(user_input). -export([example/0]). example() -> io:format(\"Enter your name: \"), Name = io:get_line(\"\"), io:format(\"Hello, ~s!~n\", [string:strip(Name)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(optional_args). -export([example/0]). example() -> optional_arguments(\"Alice\", \"Bob\"), optional_arguments(). optional_arguments() -> ok; optional_arguments(Names...) -> lists:foreach(fun(Name) -> io:format(\"Hello, ~s!~n\", [Name]) end, Names).'"
  },
  {
    "language": "Erlang",
    "code": "-module(rectangle). -export([example/0]). example() -> Rectangle = #{width => 10, height => 20}, io:format(\"Rectangle: ~p~n\", [Rectangle]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(file_io). -export([example/0]). example() -> {ok, File} = file:open(\"test.txt\", [write]), file:write(File, \"Hello, Erlang!\"), file:close(File), io:format(\"File created and written to.~n\").'"
  },
  {
    "language": "Erlang",
    "code": "-module(defer). -export([example/0]). example() -> spawn(fun() -> defer(\"World!\") end), io:format(\"Hello, \"). defer(Message) -> io:format(\"~s\", [Message]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(panic_recover). -export([example/0]). example() -> try throw(panic) catch throw:panic -> io:format(\"Recovered from panic.~n\") end.'"
  },
  {
    "language": "Erlang",
    "code": "-module(channels). -export([example/0]). example() -> {Channel, _} = erlang:spawn_monitor(fun() -> Channel = erlang:monitor(process, spawn(fun() -> io:format(\"Hello, World!~n\") end)) end), receive {'DOWN', Channel, process, _, _} -> io:format(\"Channel terminated.~n\") after 3000 -> erlang:exit(Channel, kill), io:format(\"Channel killed.~n\") end.'"
  },
  {
    "language": "Lua",
    "code": "function iterateArray(arr) local i = 0 return function() i = i + 1 return arr[i] end end arr = {10, 20, 30, 40} iterator = iterateArray(arr) while true do local val = iterator() if val == nil then break end print(\"Value:\", val) end"
  },
  {
    "language": "Lua",
    "code": "Vector = {x = 0, y = 0} Vector.__add = function(v1, v2) return {x = v1.x + v2.x, y = v1.y + v2.y} end setmetatable(Vector, Vector) v1 = {x = 10, y = 20} v2 = {x = 30, y = 40} result = v1 + v2 print(\"Resultant Vector:\", result.x, result.y)"
  },
  {
    "language": "Lua",
    "code": "function outerFunction() local outerVar = 10 local function innerFunction() outerVar = outerVar + 5 return outerVar end return innerFunction end closure = outerFunction() print(\"Closure Value 1:\", closure()) print(\"Closure Value 2:\", closure())"
  },
  {
    "language": "Lua",
    "code": "function simpleCoroutine() for i = 1, 3 do coroutine.yield(i) end end co = coroutine.create(simpleCoroutine) while coroutine.status(co) ~= \"dead\" do status, value = coroutine.resume(co) print(\"Yielded value:\", value) end"
  },
  {
    "language": "Lua",
    "code": "function divide(a, b) assert(b ~= 0, \"Division by zero!\") return a / b end success, result = pcall(divide, 10, 0) if not success then print(\"Error:\", result) else print(\"Result:\", result) end"
  },
  {
    "language": "Lua",
    "code": "Dog = {sound = \"Woof!\"} function Dog:makeSound() print(self.sound) end myDog = {} setmetatable(myDog, Dog) myDog:makeSound()"
  },
  {
    "language": "Lua",
    "code": "function readFromFile(filename) local file = io.open(filename, \"r\") if not file then error(\"File not found or cannot be opened.\") end local content = file:read(\"*a\") file:close() return content end success, content = pcall(readFromFile, \"example.txt\") if success then print(\"File Content:\") print(content) else print(\"Error:\", content) end"
  },
  {
    "language": "Lua",
    "code": "module = {} function module.greet(name) print(\"Hello,\", name) end return module"
  },
  {
    "language": "Lua",
    "code": "text = \"Lua programming is awesome!\" words = {} for word in text:gmatch(\"%S+\") do table.insert(words, word) end for i, word in ipairs(words) do print(\"Word \" .. i .. \":\", word) end"
  },
  {
    "language": "Lua",
    "code": "function add(a, b) return a + b end function executeFunction(func, a, b) print(\"Result:\", func(a, b)) end executeFunction(add, 10, 20)"
  },
  {
    "language": "Lua",
    "code": "function generatorFunction() local i = 0 return function() i = i + 1 return i end end gen = generatorFunction() print(gen(), gen(), gen())"
  },
  {
    "language": "Lua",
    "code": "local function factorial(n) if n <= 1 then return 1 else return n * factorial(n - 1) end end print(\"Factorial of 5:\", factorial(5))"
  },
  {
    "language": "Lua",
    "code": "local function closureExample() local outerVar = 10 return function() outerVar = outerVar + 5 return outerVar end end closure = closureExample() print(\"Closure Value 1:\", closure()) print(\"Closure Value 2:\", closure())"
  },
  {
    "language": "Lua",
    "code": "local function reverseArray(arr) local reversed = {} for i = #arr, 1, -1 do table.insert(reversed, arr[i]) end return reversed end arr = {10, 20, 30, 40} reversedArr = reverseArray(arr) for i, val in ipairs(reversedArr) do print(\"Reversed[\" .. i .. \"]:\", val) end"
  },
  {
    "language": "Lua",
    "code": "local function isValidEmail(email) return email:match(\"^[%w%p]+@[%w%p]+%.%w%w%w?$\") ~= nil end emails = {\"example@email.com\", \"invalid-email\", \"another.example@email.co\"} for i, email in ipairs(emails) do print(\"Email \" .. i .. \":\", email, \"Valid:\", isValidEmail(email)) end"
  },
  {
    "language": "Lua",
    "code": "local function countOccurrences(text, pattern) local count = 0 for _ in text:gmatch(pattern) do count = count + 1 end return count end text = \"Lua is a scripting language, Lua is versatile\" pattern = \"Lua\" print(\"Occurrences of 'Lua':\", countOccurrences(text, pattern))"
  },
  {
    "language": "Lua",
    "code": "local function capitalizeWords(sentence) return sentence:gsub(\"(%w)(%w*)\", function(first, rest) return first:upper() .. rest:lower() end) end sentence = \"lua programming is fun\" print(\"Capitalized:\", capitalizeWords(sentence))"
  },
  {
    "language": "Lua",
    "code": "local function binarySearch(arr, target) local left, right = 1, #arr while left <= right do local mid = math.floor((left + right) / 2) if arr[mid] == target then return mid elseif arr[mid] < target then left = mid + 1 else right = mid - 1 end end return -1 end numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90} target = 60 print(\"Index of\", target, \":\", binarySearch(numbers, target))"
  },
  {
    "language": "Lua",
    "code": "local function memoize(func) local cache = {} return function(n) if not cache[n] then cache[n] = func(n) end return cache[n] end end function fibonacci(n) if n <= 2 then return 1 else return fibonacci(n - 1) + fibonacci(n - 2) end end fibonacci = memoize(fibonacci) print(\"Fibonacci(10):\", fibonacci(10))"
  },
  {
    "language": "Lua",
    "code": "local function parseJSON(jsonString) return load(\"return \" .. jsonString)() end jsonString = '{\"name\": \"Lua\", \"type\": \"Scripting Language\"}' parsedData = parseJSON(jsonString) for key, value in pairs(parsedData) do print(key .. \":\", value) end"
  },
  {
    "language": "Prolog",
    "code": "animal(cat). animal(dog). animal(elephant). size(elephant, big). size(cat, small). sound(cat, meow). sound(dog, bark)"
  },
  {
    "language": "Prolog",
    "code": "factorial(0, 1). factorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult."
  },
  {
    "language": "Prolog",
    "code": "edge(a, b). edge(b, c). edge(c, d). connected(X, Y) :- edge(X, Y). connected(X, Y) :- edge(X, Z), connected(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "parent(john, paul). parent(paul, mary). grandparent(X, Y) :- parent(X, Z), parent(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "triangle(A, B, C) :- A + B > C, A + C > B, B + C > A."
  },
  {
    "language": "Prolog",
    "code": "```even_length([]). even_length([_, _"
  },
  {
    "language": "Prolog",
    "code": "member(X, [X"
  },
  {
    "language": "Prolog",
    "code": "max(X, Y, Max) :- (X >= Y -> Max = X ; Max = Y)."
  },
  {
    "language": "Prolog",
    "code": "fib(0, 0). fib(1, 1). fib(N, Result) :- N > 1, Prev1 is N - 1, Prev2 is N - 2, fib(Prev1, Prev1Result), fib(Prev2, Prev2Result), Result is Prev1Result + Prev2Result."
  },
  {
    "language": "Prolog",
    "code": "append([], L, L). append([H"
  },
  {
    "language": "Prolog",
    "code": "map(_, [], []). map(P, [H"
  },
  {
    "language": "Prolog",
    "code": "merge([], L, L). merge(L, [], L). merge([X"
  },
  {
    "language": "Prolog",
    "code": "divisor(X, Y) :- Y > 1, Y1 is Y - 1, X mod Y =:= 0. divisors(X, Y, [Y"
  },
  {
    "language": "Prolog",
    "code": "prime(2). prime(X) :- X > 2, \\+ has_factor(X, 2). has_factor(N, M) :- N mod M =:= 0. has_factor(N, M) :- M * M < N, M2 is M + 1, has_factor(N, M2)."
  },
  {
    "language": "Prolog",
    "code": "partition(_, [], [], []). partition(Pivot, [H"
  },
  {
    "language": "Prolog",
    "code": "animal(cat), animal(dog), animal(elephant), size(elephant, big), size(cat, small), sound(cat, meow), sound(dog, bark), factorial(0, 1), factorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult, edge(a, b), edge(b, c), edge(c, d), connected(X, Y) :- edge(X, Y), connected(X, Y) :- edge(X, Z), connected(Z, Y), parent(john, paul), parent(paul, mary), grandparent(X, Y) :- parent(X, Z), parent(Z, Y), triangle(A, B, C) :- A + B > C, A + C > B, B + C > A, even_length([]), even_length([_, _ | Tail]) :- even_length(Tail), member(X, [X | _]), member(X, [_ | Tail]) :- member(X, Tail), max(X, Y, Max) :- (X >= Y -> Max = X ; Max = Y), fib(0, 0), fib(1, 1), fib(N, Result) :- N > 1, Prev1 is N - 1, Prev2 is N - 2, fib(Prev1, Prev1Result), fib(Prev2, Prev2Result), Result is Prev1Result + Prev2Result."
  },
  {
    "language": "Scheme",
    "code": "(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (sum-of-squares a b) (+ (* a a) (* b b)))"
  },
  {
    "language": "Scheme",
    "code": "(define my-list '(1 2 3 4)) (car my-list) (cdr my-list)"
  },
  {
    "language": "Scheme",
    "code": "(define (fibonacci n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (power-of-two n) (expt 2 n))"
  },
  {
    "language": "Scheme",
    "code": "(define (sum-list lst) (if (null? lst) 0 (+ (car lst) (sum-list (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (square x) (* x x))"
  },
  {
    "language": "Scheme",
    "code": "(define (map f lst) (if (null? lst) '() (cons (f (car lst)) (map f (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (filter pred lst) (cond ((null? lst) '()) ((pred (car lst)) (cons (car lst) (filter pred (cdr lst)))) (else (filter pred (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (merge lst1 lst2) (cond ((null? lst1) lst2) ((null? lst2) lst1) ((< (car lst1) (car lst2)) (cons (car lst1) (merge (cdr lst1) lst2))) (else (cons (car lst2) (merge lst1 (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (gcd a b) (if (= b 0) a (gcd b (remainder a b))))"
  },
  {
    "language": "Scheme",
    "code": "(define (quicksort lst) (if (null? lst) '() (let ((pivot (car lst))) (append (quicksort (filter (lambda (x) (< x pivot)) (cdr lst))) (cons pivot (quicksort (filter (lambda (x) (>= x pivot)) (cdr lst))))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (reverse lst) (define (reverse-iter lst result) (if (null? lst) result (reverse-iter (cdr lst) (cons (car lst) result)))) (reverse-iter lst '()))"
  },
  {
    "language": "Scheme",
    "code": "(define (make-counter) (let ((count 0)) (lambda () (set! count (+ count 1)) count)))"
  },
  {
    "language": "Scheme",
    "code": "(define (factorial n) (let loop ((n n) (acc 1)) (if (= n 0) acc (loop (- n 1) (* acc n)))))"
  },
  {
    "language": "Scheme",
    "code": "(define greeting \"Hello, \") (define name \"Alice\") (display (string-append greeting name))"
  },
  {
    "language": "Scheme",
    "code": "(define myList '(1 2 3 4)) (define myListReversed (reverse myList)) (define myListLength (length myList))"
  },
  {
    "language": "Scheme",
    "code": "(define (apply-twice func arg) (func (func arg))) (define (add-one x) (+ x 1)) (define result (apply-twice add-one 5))"
  },
  {
    "language": "Scheme",
    "code": "(+ 10 20) (- 50 30) (* 5 6) (/ 100 4)"
  },
  {
    "language": "Scheme",
    "code": "(define (is-even? n) (= (remainder n 2) 0)) (if (is-even? 10) (display \"Number is even\") (display \"Number is odd\"))"
  },
  {
    "language": "TCL",
    "code": "set greeting \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "puts \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "for {set i 0} {$i < 5} {incr i} { puts \"Iteration: $i\" }"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} foreach item $myList { puts $item }"
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] llength $numbers"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 3; expr {$x + $y}"
  },
  {
    "language": "TCL",
    "code": "set fruits {apple banana cherry} lsearch -exact $fruits banana"
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] lsort -integer $numbers"
  },
  {
    "language": "TCL",
    "code": "set sentence \"This is a sentence.\" set words [split $sentence] lindex $words 2"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 10; if {$x > $y} { puts \"x is greater than y\" } else { puts \"x is less than or equal to y\" }"
  },
  {
    "language": "TCL",
    "code": "proc add {a b} { return [expr {$a + $b}] } add 5 3"
  },
  {
    "language": "TCL",
    "code": "set colors {red green blue} lrange $colors 0 1"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} lsearch $myList banana"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} linsert $myList end \"orange\""
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] lreverse $numbers"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 10; expr {$x * $y}"
  },
  {
    "language": "TCL",
    "code": "set sentence \"This is a sentence.\" set words [split $sentence] llength $words"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} lrange $myList 0 1"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 3; expr {$x % $y}"
  },
  {
    "language": "SmallTalk",
    "code": "Object subclass: Person [ | name age | initialize [ name := ''. age := 0. ] setName: aName [ name := aName. ] setAge: anAge [ age := anAge. ] getName [ ^name ] getAge [ ^age ] ]; person := (Person new setName: 'Alice'; setAge: 30; yourself); Transcript show: 'Name: ', (person getName), '. Age: ', (person getAge asString), '.'."
  },
  {
    "language": "SmallTalk",
    "code": "Object subclass: BankAccount [ | balance | initialize [ balance := 0. ] deposit: amount [ balance := balance + amount. ^'Deposit successful.' ] withdraw: amount [ | message | message := (balance >= amount) ifTrue: [ balance := balance - amount. 'Withdrawal successful: ', amount asString ] ifFalse: ['Insufficient funds.'] ^message ] checkBalance [ ^balance ] ]; account := BankAccount new. account deposit: 100. Transcript show: 'Balance after deposit: ', (account checkBalance) asString; cr. withdrawalMessage := account withdraw: 50. Transcript show: withdrawalMessage; cr. withdrawalMessage := account withdraw: 80. Transcript show: withdrawalMessage; cr. Transcript show: 'Final balance: ', (account checkBalance) asString; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript\n    show: 'Hello, world!';\n    cr."
  },
  {
    "language": "SmallTalk",
    "code": "| numbers |\nnumbers := #(1 2 3 4 5).\nnumbers do: [:each | Transcript show: each asString; cr]."
  },
  {
    "language": "SmallTalk",
    "code": "(1 to: 5) collect: [:each | each squared]."
  },
  {
    "language": "SmallTalk",
    "code": "| person |\nperson := Dictionary new.\nperson at: 'name' put: 'Alice'.\nperson at: 'age' put: 30."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript show: (Date today) asString; cr."
  },
  {
    "language": "SmallTalk",
    "code": "| circle |\ncircle := EllipseMorph new.\ncircle openInWorld.\ncircle color: Color blue."
  },
  {
    "language": "SmallTalk",
    "code": "| worker |\nworker := Worker new.\nworker work."
  },
  {
    "language": "SmallTalk",
    "code": "| car |\ncar := Car new.\ncar drive: 100."
  },
  {
    "language": "SmallTalk",
    "code": "| rectangle |\nrectangle := Rectangle origin: 0@0 corner: 100@100."
  },
  {
    "language": "SmallTalk",
    "code": "(1 to: 10) do: [:i |\n    Transcript show: i asString; cr.\n]."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript show: 'I love Smalltalk!'; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Cursor wait showWhile: [Sensor anyButtonPressed]."
  },
  {
    "language": "SmallTalk",
    "code": "| s |\ns := 'Hello, world!'.\ns at: 2 put: $a.\nTranscript show: s; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Display restoreAfter: [\n    Transcript show: 'Smalltalk is fun!'; cr.\n]."
  },
  {
    "language": "SmallTalk",
    "code": "| animal |\nanimal := 'Dog'.\nanimal, ' is a friendly pet.'."
  },
  {
    "language": "SmallTalk",
    "code": "Sensor waitButton."
  },
  {
    "language": "SmallTalk",
    "code": "('Smalltalk' copyFrom: 3 to: 6) reverse."
  },
  {
    "language": "R",
    "code": "# Create a data frame\ndata <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(data)\n\n# Subset based on conditions\nselected_data <- subset(data, Age > 25)\n\n# Print the subset\nprint(selected_data)"
  },
  {
    "language": "R",
    "code": "# Create a function that calculates factorial\nfactorial <- function(n) {\n    if (n == 0) {\n        return(1)\n    } else {\n        return(n * factorial(n - 1))\n    }\n}\n\n# Call the function\nresult <- factorial(5)\nprint(result)\n\n# Utilize ggplot2 package for plotting\nrequire(ggplot2)\n\n# Create sample data\ndata <- data.frame(\n    x = 1:10,\n    y = rnorm(10)\n)\n\n# Plot using ggplot2\nggplot(data, aes(x=x, y=y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Function to print elements of a list\nprint_list <- function(my_list) {\n    for (element in my_list) {\n        print(element)\n    }\n}\n\n# Create a list\nmy_list <- list(name = \"John\", age = 30, city = \"New York\")\n\n# Print elements of the list\nprint_list(my_list)\n\n# Function accepting and printing unspecified arguments\nprint_arguments <- function(...) {\n    for (arg in list(...)) {\n        print(arg)\n    }\n}\n\n# Call the function with different arguments\nprint_arguments(\"Hello\", 10, TRUE)"
  },
  {
    "language": "R",
    "code": "# Create a data frame\nstudents <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(students)\n\n# Extract specific columns\nages <- students$Age\ngrades <- students$Grade\n\n# Print extracted columns\nprint(ages)\nprint(grades)"
  },
  {
    "language": "R",
    "code": "# Function to check if a number is even\nis_even <- function(num) {\n    if (num %% 2 == 0) {\n        return(TRUE)\n    } else {\n        return(FALSE)\n    }\n}\n\n# Check numbers for evenness\nprint(is_even(5))\nprint(is_even(10))"
  },
  {
    "language": "R",
    "code": "# Loop to create a list of squares\nsquares <- c()\nfor (i in 1:10) {\n    squares[i] <- i^2\n}\n\n# Print the list of squares\nprint(squares)\n\n# Function to calculate sum of a list\ncalculate_sum <- function(nums) {\n    sum <- 0\n    for (num in nums) {\n        sum <- sum + num\n    }\n    return(sum)\n}\n\n# Calculate sum of a list of numbers\nresult <- calculate_sum(1:10)\nprint(result)"
  },
  {
    "language": "R",
    "code": "# Generating random data\nset.seed(123)\ndata <- data.frame(\n    x = 1:100,\n    y = rnorm(100)\n)\n\n# Scatter plot using base R graphics\nplot(data$x, data$y, main = \"Random Data Scatter Plot\", xlab = \"X-axis\", ylab = \"Y-axis\")"
  },
  {
    "language": "R",
    "code": "# Create a data frame\nstudents <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(students)\n\n# Subset based on conditions\nselected_students <- subset(students, Age > 25)\n\n# Print the subset\nprint(selected_students)"
  },
  {
    "language": "R",
    "code": "# Create a function that prints 'Hello' n times\nprint_hello <- function(n){\n    for (i in 1:n){\n        print(\"Hello\")\n    }\n}\n\n# Call the function\nprint_hello(3)\n\n# Utilize ggplot2 package for plotting\nrequire(ggplot2)\n\n# Create sample data\ndata <- data.frame(\n    x = 1:10,\n    y = rnorm(10)\n)\n\n# Plot using ggplot2\nggplot(data, aes(x=x, y=y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Function to accept and print unspecified arguments\nprint_arguments <- function(...){\n    for (arg in list(...)){\n        print(arg)\n    }\n}\n\n# Call the function with different arguments\nprint_arguments(\"Hello\", 10, TRUE)"
  },
  {
    "language": "R",
    "code": "# Function to calculate factorial with error handling\nfactorial <- function(n) {\n    if (n < 0) {\n        stop(\"Factorial not defined for negative numbers.\")\n    }\n    if (n == 0) {\n        return(1)\n    } else {\n        return(n * factorial(n - 1))\n    }\n}\n\n# Get user input for factorial calculation\nuser_input <- as.integer(readline(\"Enter a number to calculate its factorial: \"))\nresult <- factorial(user_input)\nprint(paste(\"Factorial of\", user_input, \"is\", result))"
  },
  {
    "language": "R",
    "code": "# Apply function to calculate square of elements in a vector\nvector <- c(1, 2, 3, 4, 5)\nsquared_vector <- sapply(vector, function(x) x^2)\nprint(squared_vector)\n\n# Apply function to a data frame\ndata <- data.frame(\n    A = c(1, 2, 3),\n    B = c(4, 5, 6),\n    C = c(7, 8, 9)\n)\nmean_values <- apply(data, 2, mean)\nprint(mean_values)"
  },
  {
    "language": "R",
    "code": "# String concatenation and substring\nstring1 <- \"Hello\"\nstring2 <- \"World!\"\nconcatenated <- paste(string1, string2)\nsubstring <- substr(concatenated, start = 3, stop = 8)\nprint(concatenated)\nprint(substring)\n\n# Checking string containment\ntext <- \"This is a sample text.\"\nif (\"sample\" %in% strsplit(text, \" \")[[1]]) {\n    print(\"String 'sample' found in text.\")\n} else {\n    print(\"String 'sample' not found in text.\")\n}"
  },
  {
    "language": "R",
    "code": "# Create matrices\nmatrix1 <- matrix(1:9, nrow = 3)\nmatrix2 <- matrix(9:1, nrow = 3)\n\n# Matrix multiplication\nresult_matrix <- matrix1 %*% matrix2\nprint(result_matrix)\n\n# Matrix transpose\ntransposed_matrix <- t(matrix1)\nprint(transposed_matrix)"
  },
  {
    "language": "R",
    "code": "# Write data to a CSV file\ndata <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28)\n)\nwrite.csv(data, \"output.csv\")\n\n# Read data from a CSV file\nread_data <- read.csv(\"output.csv\")\nprint(read_data)"
  },
  {
    "language": "R",
    "code": "# Generating random data\nset.seed(123)\ndata1 <- data.frame(\n    x = 1:50,\n    y = rnorm(50, mean = 0, sd = 1)\n)\ndata2 <- data.frame(\n    x = 1:50,\n    y = rnorm(50, mean = 2, sd = 1)\n)\n\n# Plotting multiple graphs\npar(mfrow = c(1, 2))  # Arrange plots in a 1x2 grid\nplot(data1$x, data1$y, main = \"Random Data 1\")\nplot(data2$x, data2$y, main = \"Random Data 2\")"
  },
  {
    "language": "R",
    "code": "# Using lapply to apply a function to elements of a list\nmy_list <- list(1:5, 6:10, 11:15)\n\nsquared_lists <- lapply(my_list, function(x) x^2)\nprint(squared_lists)"
  },
  {
    "language": "R",
    "code": "# Creating matrices\nmatrix1 <- matrix(1:9, nrow = 3)\nmatrix2 <- matrix(9:1, nrow = 3)\n\n# Element-wise matrix operations\nelementwise_sum <- matrix1 + matrix2\nelementwise_product <- matrix1 * matrix2\n\nprint(elementwise_sum)\nprint(elementwise_product)"
  },
  {
    "language": "R",
    "code": "# Create a factor vector\ngrades <- factor(c(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\"))\n\n# Display unique levels of the factor\nprint(levels(grades))\n\n# Convert factor to numeric\nnumeric_grades <- as.numeric(grades)\nprint(numeric_grades)"
  },
  {
    "language": "R",
    "code": "# Getting current date and time\ncurrent_date <- Sys.Date()\ncurrent_time <- Sys.time()\n\nprint(current_date)\nprint(current_time)"
  },
  {
    "language": "D",
    "code": "immutable int x = 5;\nimmutable string message = \"Hello, D!\";"
  },
  {
    "language": "D",
    "code": "pure int square(int x) {\n    return x * x;\n}"
  },
  {
    "language": "D",
    "code": "nothrow void doSomething() {\n    // Code that doesn't throw exceptions\n}"
  },
  {
    "language": "D",
    "code": "@safe {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n}'"
  },
  {
    "language": "D",
    "code": "@trusted void unsafeOperation() {\n    // Unsafe operations here\n}'"
  },
  {
    "language": "D",
    "code": "@system {\n    // Low-level system operations here\n}'"
  },
  {
    "language": "D",
    "code": "final class FinalClass {\n    // Class members and methods\n}"
  },
  {
    "language": "D",
    "code": "void modify(ref int x) {\n    x *= 2;\n}"
  },
  {
    "language": "D",
    "code": "void foo() {\n    scope int x = 10;\n    // x is valid only within this scope\n}"
  },
  {
    "language": "D",
    "code": "void modify(inout int x) {\n    x += 5;\n}"
  },
  {
    "language": "D",
    "code": "lazy int result = complexCalculation();"
  },
  {
    "language": "D",
    "code": "pure nothrow @safe int calculate(int x, int y) {\n    return x + y;\n}"
  },
  {
    "language": "D",
    "code": "nothrow pure int multiply(int a, int b) {\n    return a * b;\n}"
  },
  {
    "language": "D",
    "code": "@trusted void unsafeOperation() {\n    // Perform unsafe operations here\n}'"
  },
  {
    "language": "D",
    "code": "@safe immutable int[] createImmutableArray() {\n    return [1, 2, 3, 4, 5];\n}'"
  },
  {
    "language": "D",
    "code": "@system void systemOperation() {\n    // Perform system-level operations here\n}'"
  },
  {
    "language": "D",
    "code": "void increment(ref int x) {\n    x++;\n}"
  },
  {
    "language": "D",
    "code": "void process(inout int x) {\n    x *= 2;\n}"
  },
  {
    "language": "D",
    "code": "@safe immutable string greeting = \"Hello, World!\";'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Hello, Bash!\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor i in {1..5}; do\n\techo $i\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction greet() {\n\techo \"Welcome, $1!\"\n}\n\ngreet \"John\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nread -p \"Enter your name: \" name\n\necho \"Hello, $name!\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nif [ -f \"file.txt\" ]; then\n\techo \"File exists.\"\nelse\n\techo \"File does not exist.\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nnumbers=(1 2 3 4 5)\nfor num in \"${numbers[@]}\"; do\n\techo $num\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction swap() {\n\tlocal temp=$1\n\tlocal x=$2\n\tlocal y=$3\n\teval $1=$y $2=$x\n}\n\na=5\nb=10\nswap temp a b\necho \"After swapping: a=$a, b=$b\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nwhile true; do\n\techo \"Infinite loop...\"\n\tsleep 1\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction calculate_sum() {\n\tlocal result=$(( $1 + $2 ))\n\techo \"Sum is: $result\"\n}\n\ncalculate_sum 10 20"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfile=\"example.txt\"\nif [ -e $file ]; then\n\techo \"File exists: $file\"\nelse\n\techo \"File does not exist: $file\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor (( i=0; i<5; i++ )); do\n\techo $i\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nif [ $# -eq 0 ]; then\n\techo \"No arguments provided.\"\nelse\n\techo \"Arguments: $@\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nhour=$(date +%H)\nif [ $hour -lt 12 ]; then\n\techo \"Good morning!\"\nelif [ $hour -lt 17 ]; then\n\techo \"Good afternoon!\"\nelse\n\techo \"Good evening!\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor file in *.txt; do\n\techo \"Processing file: $file\"\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Number of arguments: $#\"\necho \"Argument 1: $1\"\necho \"Argument 2: $2\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction factorial() {\n\tif [ $1 -eq 0 ]; then\n\t\techo 1\n\telse\n\t\techo $(( $1 * $(factorial $(( $1 - 1 ))) ))\n\tfi\n}\n\nresult=$(factorial 5)\necho \"Factorial of 5 is: $result\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Current date: $(date)\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Running command: ls -l\"\nls -l"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\narray=(\"apple\" \"banana\" \"orange\")\nfor fruit in \"${array[@]}\"; do\n\techo $fruit\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction greet_user() {\n\tlocal name=$1\n\techo \"Hello, $name!\"\n}\n\ngreet_user \"Alice\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Simple function and usage\nfunction greet() {\n\techo \"Hello, $1!\"\n}\n\ngreet \"World\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Reading user input and conditional statements\nread -p \"Enter a number: \" num\nif [ $num -gt 0 ]; then\n\techo \"Number is positive\"\nelse\n\techo \"Number is non-positive\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Arrays and loops\nfruits=(\"apple\" \"banana\" \"orange\")\nfor fruit in \"${fruits[@]}\"; do\n\techo \"Fruit: $fruit\"\ndone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Functions with return values\nfunction add() {\n\tlocal result=$(( $1 + $2 ))\n\techo $result\n}\n\nsum=$(add 10 20)\necho \"Sum is: $sum\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Command substitution and file manipulation\nfiles=$(ls *.txt)\necho \"Text files: $files\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using sed for text manipulation\necho \"Hello, World!\" | sed 's/World/Universe/'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Arithmetic operations\nresult=$((5 * 3 + 2))\necho \"Result: $result\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Process management and background tasks\nfunction long_running_task() {\n\techo \"Task started\"\n\tsleep 5\n\techo \"Task completed\"\n}\n\nlong_running_task &\n\necho \"Main script continues\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Reading and parsing a CSV file\nwhile IFS=',' read -r name age city; do\n\techo \"Name: $name, Age: $age, City: $city\"\ndone < data.csv"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Associative arrays\ndeclare -A colors\n\ncolors[red]=\"#FF0000\"\ncolors[green]=\"#00FF00\"\ncolors[blue]=\"#0000FF\"\n\necho \"Red: ${colors[red]}\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Advanced string manipulation\nstring=\"Hello, World!\"\nsubstring=${string:7:5}\necho \"Substring: $substring\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Pattern matching and regular expressions\nstring=\"apple\"\nif [[ $string =~ ^[aeiou] ]]; then\n\techo \"$string starts with a vowel\"\nelse\n\techo \"$string does not start with a vowel\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using awk for text processing\necho \"John,Doe,30\" | awk -F\",\" '{print \"Name: \" $1 \" \" $2, \"Age: \" $3}'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Generating a random password\nlength=8\npassword=$(openssl rand -base64 12 | tr -dc 'a-zA-Z0-9' | head -c $length)\necho \"Random Password: $password\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Advanced if-else condition\nnum=15\nif ((num < 10)); then\n\techo \"Number is less than 10\"\nelif ((num >= 10 && num < 20)); then\n\techo \"Number is between 10 and 19\"\nelse\n\techo \"Number is 20 or greater\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Function with default parameter\nfunction greet() {\n\tlocal name=${1:-\"Guest\"}\n\techo \"Hello, $name!\"\n}\n\ngreet\n"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Sending HTTP request using curl\nresponse=$(curl -s https://api.example.com/data)\necho \"Response: $response\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using jq to process JSON data\njson='{\"name\": \"John\", \"age\": 25}'\nname=$(echo $json | jq -r '.name')\necho \"Name: $name\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Trapping signals in a script\nfunction cleanup() {\n\techo \"Cleaning up...\"\n}\n\ntrap cleanup EXIT\n\necho \"Script is running...\""
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees;"
  },
  {
    "language": "SQL",
    "code": "SELECT first_name, last_name FROM users WHERE age > 30;"
  },
  {
    "language": "SQL",
    "code": "SELECT product_name, price FROM products ORDER BY price DESC LIMIT 5;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_orders FROM orders;"
  },
  {
    "language": "SQL",
    "code": "SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department;"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO customers (first_name, last_name, email) VALUES ('John', 'Doe', 'john@example.com');"
  },
  {
    "language": "SQL",
    "code": "UPDATE products SET price = price * 1.1 WHERE category = 'Electronics';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM users WHERE last_login < '2023-01-01';"
  },
  {
    "language": "SQL",
    "code": "CREATE TABLE IF NOT EXISTS employees (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100),\n    age INT,\n    department VARCHAR(100)\n);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE products ADD COLUMN stock INT DEFAULT 0;"
  },
  {
    "language": "SQL",
    "code": "SELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_customers FROM customers WHERE country = 'USA';"
  },
  {
    "language": "SQL",
    "code": "SELECT order_date, SUM(total_amount) AS revenue FROM orders GROUP BY order_date;"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(age) AS avg_age FROM users WHERE gender = 'Female';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (101, 205, 3);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET department = 'HR' WHERE department = 'Admin';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM products WHERE stock = 0;"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_lastname ON users(last_name);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN city VARCHAR(50);"
  },
  {
    "language": "SQL",
    "code": "SELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_customers FROM customers WHERE country = 'USA';"
  },
  {
    "language": "SQL",
    "code": "SELECT order_date, SUM(total_amount) AS revenue FROM orders GROUP BY order_date;"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(age) AS avg_age FROM users WHERE gender = 'Female';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (101, 205, 3);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET department = 'HR' WHERE department = 'Admin';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM products WHERE stock = 0;"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_lastname ON users(last_name);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN city VARCHAR(50);"
  },
  {
    "language": "SQL",
    "code": "SELECT first_name, last_name, email FROM users WHERE department IN ('Sales', 'Marketing');"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(salary) AS avg_salary FROM employees WHERE department = 'HR';"
  },
  {
    "language": "SQL",
    "code": "SELECT customer_id, COUNT(order_id) AS total_orders FROM orders GROUP BY customer_id HAVING total_orders > 5;"
  },
  {
    "language": "SQL",
    "code": "SELECT product_name, price FROM products WHERE LOWER(product_name) LIKE '%phone%';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (105, 210, 2), (106, 215, 1);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET salary = salary * 1.1 WHERE age > 40;"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM users WHERE last_login < DATE_SUB(NOW(), INTERVAL 6 MONTH);"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_category ON products(category);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN state VARCHAR(50) AFTER city;"
  },
  {
    "language": "SQL",
    "code": "DROP INDEX IF EXISTS idx_lastname ON users;"
  },
  {
    "language": "C",
    "code": "** <li> sqlite3_value_text()\n** <li> sqlite3_value_text16()\n** <li> sqlite3_value_text16le()\n** <li> sqlite3_value_text16be()\n** <li> sqlite3_value_bytes()\n"
  },
  {
    "language": "C",
    "code": "**\n** Note the last bullet in particular.  The destructor X in\n** sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the\n** sqlite3_set_auxdata() interface even returns.  Hence sqlite3_set_auxdata()\n** should be called near the end of the function implementation and the\n"
  },
  {
    "language": "C",
    "code": "  const char *zName,\n  int eTextRep,\n  void *pArg,\n  int(*xCompare)(void*,int,const void*,int,const void*),\n  void(*xDestroy)(void*)\n"
  },
  {
    "language": "C",
    "code": "  void *pArg,\n  int(*xCompare)(void*,int,const void*,int,const void*)\n);\n\n/*\n"
  },
  {
    "language": "C",
    "code": ");\n\n#ifdef SQLITE_ENABLE_CEROD\n/*\n** Specify the activation key for a CEROD database.  Unless\n"
  },
  {
    "language": "C",
    "code": "** The sqlite3_sleep() function causes the current thread to suspend execution\n** for at least a number of milliseconds specified in its parameter.\n**\n** If the operating system does not support sleep requests with\n** millisecond time resolution, then the time will be rounded up to\n"
  },
  {
    "language": "C",
    "code": "** the name of a folder (a.k.a. directory), then all temporary files\n** created by SQLite when using a built-in [sqlite3_vfs | VFS]\n** will be placed in that directory.)^  ^If this variable\n** is a NULL pointer, then SQLite performs a search for an appropriate\n** temporary file directory.\n"
  },
  {
    "language": "C",
    "code": "** SQLite when using a built-in windows [sqlite3_vfs | VFS] will be assumed\n** to be relative to that directory.)^ ^If this variable is a NULL\n** pointer, then SQLite assumes that all database files specified\n** with a relative pathname are relative to the current directory\n** for the process.  Only the windows VFS makes use of this global\n"
  },
  {
    "language": "C",
    "code": "** METHOD: sqlite3\n**\n** ^The sqlite3_db_filename(D,N) interface returns a pointer to the filename\n** associated with database N of connection D.\n** ^If there is no attached database N on the database\n"
  },
  {
    "language": "C",
    "code": "SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);\n\n/*\n** CAPI3REF: Data Change Notification Callbacks\n** METHOD: sqlite3\n"
  },
  {
    "language": "C",
    "code": "** is not invoked when conflicting rows are deleted because of an\n** [ON CONFLICT | ON CONFLICT REPLACE] clause.  ^Nor is the update hook\n** invoked when rows are deleted using the [truncate optimization].\n** The exceptions defined in this paragraph might change in a future\n** release of SQLite.\n"
  },
  {
    "language": "C",
    "code": "** ^The soft heap limit may not be greater than the hard heap limit.\n** ^If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N)\n** is invoked with a value of N that is greater than the hard heap limit,\n** the the soft heap limit is set to the value of the hard heap limit.\n** ^The soft heap limit is automatically enabled whenever the hard heap\n"
  },
  {
    "language": "C",
    "code": "** ^The column is identified by the second, third and fourth parameters to\n** this function. ^(The second parameter is either the name of the database\n** (i.e. \"main\", \"temp\", or an attached database) containing the specified\n** table or NULL.)^ ^If it is NULL, then all attached databases are searched\n** for the table using the same algorithm used by the database engine to\n"
  },
  {
    "language": "C",
    "code": "** ^(Use [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],..)\n** to enable or disable only the C-API.)^\n**\n** <b>Security warning:</b> It is recommended that extension loading\n** be enabled using the [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method\n"
  },
  {
    "language": "C",
    "code": "** and [sqlite3_cancel_auto_extension()]\n*/\nSQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void));\n\n/*\n"
  },
  {
    "language": "C",
    "code": "** any database connection.\n*/\nstruct sqlite3_module {\n  int iVersion;\n  int (*xCreate)(sqlite3*, void *pAux,\n"
  },
  {
    "language": "C",
    "code": "  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);\n  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);\n  int (*xBegin)(sqlite3_vtab *pVTab);\n  int (*xSync)(sqlite3_vtab *pVTab);\n  int (*xCommit)(sqlite3_vtab *pVTab);\n"
  },
  {
    "language": "C",
    "code": "SQLITE_API int sqlite3_create_module_v2(\n  sqlite3 *db,               /* SQLite connection to register module with */\n  const char *zName,         /* Name of the module */\n  const sqlite3_module *p,   /* Methods for the module */\n  void *pClientData,         /* Client data for xCreate/xConnect */\n"
  },
  {
    "language": "C",
    "code": "** of this object to describe a particular instance\n** of the [virtual table].  Each subclass will\n** be tailored to the specific needs of the module implementation.\n** The purpose of this superclass is to define certain fields that are\n** common to all module implementations.\n"
  },
  {
    "language": "C",
    "code": "** code is SQLITE_MISUSE, *ppBlob is set to NULL.)^ ^This means that, provided\n** the API is not misused, it is always safe to call [sqlite3_blob_close()]\n** on *ppBlob after this function it returns.\n**\n** This function fails with SQLITE_ERROR if any of the following are true:\n"
  },
  {
    "language": "C",
    "code": "** </ul>\n**\n** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)\n** cause sqlite3_mutex_alloc() to create\n** a new mutex.  ^The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n"
  },
  {
    "language": "C",
    "code": "** a pointer to a static preexisting mutex.  ^Nine static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n"
  },
  {
    "language": "C",
    "code": "** previously entered by the same thread.   The behavior\n** is undefined if the mutex is not currently entered by the\n** calling thread or is not currently allocated.\n**\n** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or\n"
  },
  {
    "language": "C",
    "code": "** sqlite3_mutex_leave() is a NULL pointer, then all three routines\n** behave as no-ops.\n**\n** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].\n*/\n"
  },
  {
    "language": "C",
    "code": "/*\n** CAPI3REF: SQL Keyword Checking\n**\n** These routines provide access to the set of SQL language keywords\n** recognized by SQLite.  Applications can uses these routines to determine\n"
  },
  {
    "language": "C",
    "code": "SQLITE_API void sqlite3_str_append(sqlite3_str*, const char *zIn, int N);\nSQLITE_API void sqlite3_str_appendall(sqlite3_str*, const char *zIn);\nSQLITE_API void sqlite3_str_appendchar(sqlite3_str*, int N, char C);\nSQLITE_API void sqlite3_str_reset(sqlite3_str*);\n\n"
  },
  {
    "language": "C",
    "code": "** by [sqlite3_str_value(X)] as long as they do not write into any bytes\n** outside the range of 0 to [sqlite3_str_length(X)] and do not read or\n** write any byte after any subsequent sqlite3_str method call.\n*/\nSQLITE_API int sqlite3_str_errcode(sqlite3_str*);\n"
  },
  {
    "language": "C",
    "code": "** and internal memory usage by the SQLite library.  Auxiliary page-cache\n** memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included in\n** this parameter.  The amount returned is the sum of the allocation\n** sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>)^\n**\n"
  },
  {
    "language": "C",
    "code": "**\n** [[SQLITE_STATUS_SCRATCH_OVERFLOW]] ^(<dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>\n** <dd>No longer used.</dd>\n**\n** [[SQLITE_STATUS_SCRATCH_SIZE]] <dt>SQLITE_STATUS_SCRATCH_SIZE</dt>\n"
  },
  {
    "language": "C",
    "code": "** and the highest instantaneous value is written into *pHiwtr.  ^If\n** the resetFlg is true, then the highest instantaneous value is\n** reset back down to the current value.\n**\n** ^The sqlite3_db_status() routine returns SQLITE_OK on success and a\n"
  },
  {
    "language": "C",
    "code": "** connections.)^  In other words, if none of the pager caches associated\n** with the database connection are shared, this request returns the same\n** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are\n** shared, the value returned by this call will be smaller than that returned\n** by DBSTATUS_CACHE_USED. ^The highwater mark associated with\n"
  },
  {
    "language": "C",
    "code": "** </dl>\n*/\n#define SQLITE_DBSTATUS_LOOKASIDE_USED       0\n#define SQLITE_DBSTATUS_CACHE_USED           1\n#define SQLITE_DBSTATUS_SCHEMA_USED          2\n"
  },
  {
    "language": "C",
    "code": "**\n** ^(This interface is used to retrieve and reset counter values from\n** a [prepared statement].  The first argument is the prepared statement\n** object to be interrogated.  The second argument\n** is an integer code for a specific [SQLITE_STMTSTATUS counter]\n"
  },
  {
    "language": "C",
    "code": "**\n** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>\n** <dd>^This is the approximate number of bytes of heap memory\n** used to store the prepared statement.  ^This value is not actually\n** a counter, and so the resetFlg parameter to sqlite3_stmt_status()\n"
  },
  {
    "language": "C",
    "code": "typedef struct sqlite3_pcache_page sqlite3_pcache_page;\nstruct sqlite3_pcache_page {\n  void *pBuf;        /* The content of the page */\n  void *pExtra;      /* Extra information associated with the page */\n};\n"
  },
  {
    "language": "C",
    "code": "** [[the xCachesize() page cache method]]\n** ^(The xCachesize() method may be called at any time by SQLite to set the\n** suggested maximum cache-size (number of pages stored by) the cache\n** instance passed as the first argument. This is the value configured using\n** the SQLite \"[PRAGMA cache_size]\" command.)^  As with the bPurgeable\n"
  },
  {
    "language": "C",
    "code": "**\n** <table border=1 width=85% align=center>\n** <tr><th> createFlag <th> Behavior when page is not already in cache\n** <tr><td> 0 <td> Do not allocate a new page.  Return NULL.\n** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.\n"
  },
  {
    "language": "C",
    "code": "** sqlite3_backup_finish() returns the corresponding [error code].\n**\n** ^A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step()\n** is not a permanent error and does not affect the return value of\n** sqlite3_backup_finish().\n"
  },
  {
    "language": "C",
    "code": "** [database connection] is not passed to any other API (by any thread) after\n** sqlite3_backup_init() is called and before the corresponding call to\n** sqlite3_backup_finish().  SQLite does not currently check to see\n** if the application incorrectly accesses the destination [database connection]\n** and so no error code is reported, but the operations may malfunction\n"
  },
  {
    "language": "C",
    "code": "** is not accessed while the backup is running. In practice this means\n** that the application must guarantee that the disk file being\n** backed up to is not accessed by any connection within the process,\n** not just the specific connection that was passed to sqlite3_backup_init().\n**\n"
  },
  {
    "language": "C",
    "code": "** blocked connection already has a registered unlock-notify callback,\n** then the new callback replaces the old.)^ ^If sqlite3_unlock_notify() is\n** called with a NULL pointer as its second argument, then any existing\n** unlock-notify callback is canceled. ^The blocked connections\n** unlock-notify callback may also be canceled by closing the blocked\n"
  },
  {
    "language": "C",
    "code": "/*\n** CAPI3REF: String Comparison\n**\n** ^The [sqlite3_stricmp()] and [sqlite3_strnicmp()] APIs allow applications\n** and extensions to compare the contents of two buffers containing UTF-8\n"
  },
  {
    "language": "C",
    "code": "** string X matches the [GLOB] pattern P.\n** ^The definition of [GLOB] pattern matching used in\n** [sqlite3_strglob(P,X)] is the same as for the \"X GLOB P\" operator in the\n** SQL dialect understood by SQLite.  ^The [sqlite3_strglob(P,X)] function\n** is case sensitive.\n"
  },
  {
    "language": "C",
    "code": "** be reset.  See the [checkpointing] documentation for addition\n** information.\n**\n** This interface used to be the only way to cause a checkpoint to\n** occur.  But then the newer and more powerful [sqlite3_wal_checkpoint_v2()]\n"
  },
  {
    "language": "C",
    "code": "/* #define SQLITE_ABORT 4  // Also an error code */\n#define SQLITE_REPLACE  5\n\n/*\n** CAPI3REF: Prepared Statement Scan Status Opcodes\n"
  },
  {
    "language": "C",
    "code": "**\n** ^Statistics might not be available for all loops in all statements. ^In cases\n** where there exist loops with no available statistics, this function behaves\n** as if the loop did not exist - it returns non-zero and leave the variable\n** that pOut points to unchanged.\n"
  },
  {
    "language": "C",
    "code": "** file (page 1 is always \"in use\").  ^The [sqlite3_db_cacheflush(D)]\n** interface flushes caches for all schemas - \"main\", \"temp\", and\n** any [attached] databases.\n**\n** ^If this function needs to obtain extra database locks before dirty pages\n"
  },
  {
    "language": "C",
    "code": "** can be flushed to disk, it does so. ^If those locks cannot be obtained\n** immediately and there is a busy-handler callback configured, it is invoked\n** in the usual manner. ^If the required lock still cannot be obtained, then\n** the database is skipped and an attempt made to flush any dirty pages\n** belonging to the next (if any) database. ^If any databases are skipped\n"
  },
  {
    "language": "C",
    "code": "**\n** ^The [sqlite3_preupdate_old(D,N,P)] interface writes into P a pointer to\n** a [protected sqlite3_value] that contains the value of the Nth column of\n** the table row before it is updated.  The N parameter must be between 0\n** and one less than the number of columns or the behavior will be\n"
  },
  {
    "language": "C",
    "code": "** is currently using for that database, or NULL if the no such contiguous\n** memory representation of the database exists.  A contiguous memory\n** representation of the database will usually only exist if there has\n** been a prior call to [sqlite3_deserialize(D,S,...)] with the same\n** values of D and S.\n"
  },
  {
    "language": "C",
    "code": ");\n\n\n/*\n** A pointer to a structure of the following type is passed as the first\n"
  },
  {
    "language": "C",
    "code": "** Session objects created using this function should be deleted using the\n** [sqlite3session_delete()] function before the database handle that they\n** are attached to is itself closed. If the database handle is closed before\n** the session object is deleted, then the results of calling any session\n** module function, including [sqlite3session_delete()] on the session object\n"
  },
  {
    "language": "C",
    "code": "** database zDb, where zDb is either \"main\", or \"temp\", or the name of an\n** attached database. It is not an error if database zDb is not attached\n** to the database when the session object is created.\n*/\nSQLITE_API int sqlite3session_create(\n"
  },
  {
    "language": "C",
    "code": "** METHOD: sqlite3_session\n**\n** Obtain a changeset containing changes to the tables attached to the\n** session object passed as the first argument. If successful,\n** set *ppChangeset to point to a buffer containing the changeset\n"
  },
  {
    "language": "C",
    "code": "  char **pzErrMsg\n);\n\n\n/*\n"
  },
  {
    "language": "C",
    "code": "** <ul>\n**   <li> DELETE records consist of the primary key fields only. The\n**        original values of other fields are omitted.\n**   <li> The original values of any modified fields are omitted from\n**        UPDATE records.\n"
  },
  {
    "language": "C",
    "code": "** a single table are grouped together, tables appear in the order in which\n** they were attached to the session object).\n*/\nSQLITE_API int sqlite3session_patchset(\n  sqlite3_session *pSession,      /* Session object */\n"
  },
  {
    "language": "C",
    "code": "** The behavior of sqlite3changeset_start_v2() and its streaming equivalent\n** may be modified by passing a combination of\n** [SQLITE_CHANGESETSTART_INVERT | supported flags] as the 4th parameter.\n**\n** Note that the sqlite3changeset_start_v2() API is still <b>experimental</b>\n"
  },
  {
    "language": "C",
    "code": "** METHOD: sqlite3_changeset_iter\n**\n** For each modified table, a changeset includes the following:\n**\n** <ul>\n"
  },
  {
    "language": "C",
    "code": "  sqlite3_changeset_iter *pIter,  /* Iterator object */\n  unsigned char **pabPK,          /* OUT: Array of boolean - true for PK cols */\n  int *pnCol                      /* OUT: Number of entries in output array */\n);\n\n"
  },
  {
    "language": "C",
    "code": "/*\n** CAPI3REF: Obtain old.* Values From A Changeset Iterator\n** METHOD: sqlite3_changeset_iter\n**\n** The pIter argument passed to this function may either be an iterator\n"
  },
  {
    "language": "C",
    "code": "/*\n** CAPI3REF: Obtain A Composite Changeset From A Changegroup\n** METHOD: sqlite3_changegroup\n**\n** Obtain a buffer containing a changeset (or patchset) representing the\n"
  },
  {
    "language": "C",
    "code": "** current contents of the changegroup. If the inputs to the changegroup\n** were themselves changesets, the output is a changeset. Or, if the\n** inputs were patchsets, the output is also a patchset.\n**\n** As with the output of the sqlite3session_changeset() and\n"
  },
  {
    "language": "C",
    "code": "**   If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT\n**   (which can only happen if a foreign key constraint is violated), the\n**   conflict-handler function is invoked with [SQLITE_CHANGESET_CONSTRAINT]\n**   passed as the second argument. This includes the case where the DELETE\n**   operation is attempted because an earlier call to the conflict handler\n"
  },
  {
    "language": "C",
    "code": "** <dt>UPDATE Changes<dd>\n**   For each UPDATE change, the function checks if the target database\n**   contains a row with the same primary key value (or values) as the\n**   original row values stored in the changeset. If it does, and the values\n**   stored in all modified non-primary key columns also match the values\n"
  },
  {
    "language": "C",
    "code": "    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */\n    sqlite3_changeset_iter *p     /* Handle describing change and conflict */\n  ),\n  void *pCtx,                     /* First argument passed to xConflict */\n  void **ppRebase, int *pnRebase, /* OUT: Rebase data */\n"
  },
  {
    "language": "C",
    "code": "** CAPI3REF: Configure a changeset rebaser object.\n** EXPERIMENTAL\n**\n** Configure the changeset rebaser object to rebase changesets according\n** to the conflict resolutions described by buffer pRebase (size nRebase\n"
  },
  {
    "language": "C",
    "code": "\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n"
  },
  {
    "language": "C",
    "code": "**   if an error occurs, an SQLite error code is returned and the final values\n**   of (*pz) and (*pn) are undefined.\n**\n** xPhraseCount:\n**   Returns the number of phrases in the current query expression.\n"
  },
  {
    "language": "C",
    "code": "      void *pCtx,\n      int flags,            /* Mask of FTS5_TOKENIZE_* flags */\n      const char *pText, int nText,\n      int (*xToken)(\n        void *pCtx,         /* Copy of 2nd argument to xTokenize() */\n"
  },
  {
    "language": "C",
    "code": "  int (*xFindTokenizer)(\n    fts5_api *pApi,\n    const char *zName,\n    void **ppContext,\n    fts5_tokenizer *pTokenizer\n"
  },
  {
    "language": "C",
    "code": "\n/*\n** The sqlite3_user_delete() interface can be used (by an admin user only)\n** to delete a user.  The currently logged-in user cannot be deleted,\n** which guarantees that there is always an admin user and hence that\n"
  },
  {
    "language": "C",
    "code": "\nint\n_sqlite3_step_blocking(sqlite3_stmt *stmt)\n{\n  int rv;\n"
  },
  {
    "language": "C",
    "code": "  int (*vtab_config)(sqlite3*,int op,...);\n  int (*vtab_on_conflict)(sqlite3*);\n  /* Version 3.7.16 and later */\n  int (*close_v2)(sqlite3*);\n  const char *(*db_filename)(sqlite3*,const char*);\n"
  },
  {
    "language": "C",
    "code": "/* Version 3.14.0 and later */\n#define sqlite3_trace_v2               sqlite3_api->trace_v2\n#define sqlite3_expanded_sql           sqlite3_api->expanded_sql\n/* Version 3.18.0 and later */\n#define sqlite3_set_last_insert_rowid  sqlite3_api->set_last_insert_rowid\n"
  },
  {
    "language": "C",
    "code": "/* A lexical scanner generated by flex */\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION 2\n#define YY_FLEX_MINOR_VERSION 5\n"
  },
  {
    "language": "C",
    "code": "/* First, we deal with  platform-specific or compiler-specific issues. */\n\n/* begin standard C headers. */\n#include <stdio.h>\n#include <string.h>\n"
  },
  {
    "language": "C",
    "code": "#define yyextra yyg->yyextra_r\n#define yyleng yyg->yyleng_r\n#define yytext yyg->yytext_r\n#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)\n#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)\n"
  },
  {
    "language": "C",
    "code": "\t\t*yy_cp = yyg->yy_hold_char; \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\tyyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n"
  },
  {
    "language": "C",
    "code": "\tint yy_buffer_status;\n\n#define YY_BUFFER_NEW 0\n#define YY_BUFFER_NORMAL 1\n\t/* When an EOF's been seen but there's still some text to process\n"
  },
  {
    "language": "C",
    "code": "\t * When we actually see the EOF, we change the status to \"new\"\n\t * (via linguist_yyrestart()), so that the user can continue scanning by\n\t * just pointing yyin at a new input file.\n\t */\n#define YY_BUFFER_EOF_PENDING 2\n"
  },
  {
    "language": "C",
    "code": "#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \\\n                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \\\n                          : NULL)\n\n/* Same as previous macro, but useful when we know that the buffer stack is not\n"
  },
  {
    "language": "C",
    "code": "    else\n      ++off;\n    feed_token(strdup(off), SHEBANG_TOKEN);\n    eat_until_eol();\n    return 1;\n"
  },
  {
    "language": "C",
    "code": "case 23:\nYY_RULE_SETUP\n#line 98 \"tokenizer.l\"\n{ feed_token(strdup(yytext), REGULAR_TOKEN); *(strchr(yyextra->token, '=') + 1) = 0; return 1; }\n\tYY_BREAK\n"
  },
  {
    "language": "C",
    "code": "\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n"
  },
  {
    "language": "C",
    "code": "\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n"
  },
  {
    "language": "C",
    "code": "\t\t\t++yyg->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n"
  },
  {
    "language": "C",
    "code": "\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in linguist_yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n"
  },
  {
    "language": "C",
    "code": "\t\tlinguist_yyfree((void *) b->yy_ch_buf ,yyscanner );\n\n\tlinguist_yyfree((void *) b ,yyscanner );\n}\n\n"
  },
  {
    "language": "C",
    "code": "FILE *linguist_yyget_in  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyin;\n}\n"
  },
  {
    "language": "C",
    "code": "    return yy_flex_debug;\n}\n\nvoid linguist_yyset_debug (int  bdebug , yyscan_t yyscanner)\n{\n"
  },
  {
    "language": "C",
    "code": " * That's why we explicitly handle the declaration, instead of using our macros.\n */\n\nint linguist_yylex_init(yyscan_t* ptr_yy_globals)\n\n"
  },
  {
    "language": "C",
    "code": "{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n"
  },
  {
    "language": "C",
    "code": "{\n\tfree( (char *) ptr );\t/* see linguist_yyrealloc() for (char *) cast */\n}\n\n#define YYTABLES_NAME \"yytables\"\n"
  },
  {
    "language": "C",
    "code": "#define YY_TYPEDEF_YY_SCANNER_T\ntypedef void* yyscan_t;\n#endif\n\n/* For convenience, these vars (plus the bison vars far below)\n"
  },
  {
    "language": "C",
    "code": "/* Default declaration of generated scanner - a define so the user can\n * easily add parameters.\n */\n#ifndef YY_DECL\n#define YY_DECL_IS_OURS 1\n"
  },
  {
    "language": "C",
    "code": "#endif\n\n    OnigUChar *str_start = (OnigUChar *) str;\n    OnigUChar *str_end = (OnigUChar *) (str_start + str_length);\n    OnigUChar *search_start = (OnigUChar *)(str_start + offset);\n"
  },
  {
    "language": "C",
    "code": "    groupInfo.bufferOffset = 0;\n    groupInfo.bufferSize = bufferSize;\n    groupInfo.numbers = groupNumbers;\n    groupInfo.numIndex = 0;\n    onig_foreach_name(reg, name_callback, (void* )&groupInfo);\n"
  },
  {
    "language": "C",
    "code": "#define _Included_com_baeldung_jni_ExampleObjectsJNI\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n"
  },
  {
    "language": "C",
    "code": "#include \"bash.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\nint realpath_builtin(list)\n"
  },
  {
    "language": "C++",
    "code": " * Example: -\n * 4\n * 1 2\n * 1 3\n * 2 4\n"
  },
  {
    "language": "C++",
    "code": "// weight cycle\nvoid BellmanFord(Graph graph, int src) {\n    int V = graph.vertexNum;\n    int E = graph.edgeNum;\n    int dist[V];\n"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <iostream>\nusing namespace std;\n\n#define MAX 10\n"
  },
  {
    "language": "C++",
    "code": "\n            if (cost < min)\n                min = cost;  // store the minimum cost\n        }\n        dp[i][j] = min;\n"
  },
  {
    "language": "C++",
    "code": "     * @return std::size_t Number of values in the BST.\n     */\n    std::size_t size() { return size_; }\n\n    /**\n"
  },
  {
    "language": "C++",
    "code": "    }\n}\n\n/**\n * @brief Test function to save resulting points to a CSV file.\n"
  },
  {
    "language": "C++",
    "code": "    // glutIdleFunc(glutPostRedisplay);\n    glutTimerFunc(spirograph::animation_speed, spirograph::timer_cb, 0);\n    glutKeyboardFunc(spirograph::keyboard_cb);\n    glutDisplayFunc(spirograph::test2);\n    glutMainLoop();\n"
  },
  {
    "language": "C++",
    "code": " */\ndouble binomial_expected(double n, double p) { return n * p; }\n\n/** finds the variance of the binomial distribution\n * \\param [in] n\n"
  },
  {
    "language": "C++",
    "code": " */\ndouble nCr(double n, double r) {\n    double numerator = n;\n    double denominator = r;\n\n"
  },
  {
    "language": "C++",
    "code": " * \\parama [in] B probability of event B\n * \\returns probability of A and B\n */\ndouble addition_rule_independent(double A, double B) {\n    return (A + B) - (A * B);\n"
  },
  {
    "language": "C++",
    "code": " */\nstruct SegmentIntersection {\n    inline bool intersect(Point first_point, Point second_point,\n                          Point third_point, Point forth_point) {\n        int direction1 = direction(third_point, forth_point, first_point);\n"
  },
  {
    "language": "C++",
    "code": " * Program to generate the encryption-decryption key and perform encryption and\n * decryption of ASCII text using the famous block cipher algorithm. This is a\n * powerful encryption algorithm that is relatively easy to implement with a\n * given key. The strength of the algorithm depends on the size of the block\n * encryption matrix key; the bigger the matrix, the stronger the encryption and\n"
  },
  {
    "language": "C++",
    "code": " * algorithm.\n *\n * @author [Krishna Vedala](https://github.com/kvedala)\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#endif\n        for (i = 0; i < L2 - key_len + 1; i += key_len) {\n            std::valarray<uint8_t> batch_int(key_len);\n            for (size_t j = 0; j < key_len; j++) {\n                batch_int[j] = get_char_idx(text[i + j]);\n"
  },
  {
    "language": "C++",
    "code": "     * @param limit2 upper limit of range of random elements (default=10)\n     * @return Encryption martix\n     */\n    static matrix<int> generate_encryption_key(size_t size, int limit1 = 0,\n                                               int limit2 = 10) {\n"
  },
  {
    "language": "C++",
    "code": "\n        return encrypt_key;\n    }\n\n    /**\n"
  },
  {
    "language": "C++",
    "code": "     * @param size size of matrix key (typically \\f$\\text{size}\\le10\\f$)\n     * @param limit1 lower limit of range of random elements (default=0)\n     * @param limit2 upper limit of range of random elements (default=10)\n     * @return std::pair<matrix<int>, matrix<int>> encryption and decryption\n     * keys as a pair\n"
  },
  {
    "language": "C++",
    "code": "    }\n\n    /**\n     * @brief Encrypt a given text using a given key\n     *\n"
  },
  {
    "language": "C++",
    "code": " * \\note This program implements caesar cipher for only uppercase English alphabet characters (i.e. A-Z). \n * \n * @author [Deep Raval](https://github.com/imdeep2905)\n */\n#include <iostream>\n"
  },
  {
    "language": "C++",
    "code": "            for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {\n                int place_value_text = get_value(text[i]); // Getting value of character in text\n                int place_value_key = get_value(key[j]); // Getting value of character in key\n                place_value_text = (place_value_text - place_value_key + 26) % 26; // Applying decryption\n                char decrypted_char = get_char(place_value_text); // Getting new character from decrypted value\n"
  },
  {
    "language": "C++",
    "code": "            return \"..---\";\n        case '3':\n            return \"...--\";\n        case '4':\n            return \"....-\";\n"
  },
  {
    "language": "C++",
    "code": " *\n * @warning This program is only for educational purposes. It has serious flaws\n * in implementation with regards to memory management resulting in large\n * amounts of memory leaks.\n * @todo fix the program for memory leaks and better structure in C++ and not C\n"
  },
  {
    "language": "C++",
    "code": "/**\n * a one-way linked list\n */\ntypedef struct list {\n    int key;            //!< key value for node\n"
  },
  {
    "language": "C++",
    "code": "    }\n}\n\n/**\n * ternary_search is a template function\n"
  },
  {
    "language": "C++",
    "code": " * * Worst Time Complexity O(log n)\n * * Best Time Complexity \u2126(1)\n * * Space Complexity O(1)\n * * Auxiliary Space Complexity O(1)\n * \\returns pointer to value in the array\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \\file\n * \\brief [Interpolation\n * search](https://en.wikipedia.org/wiki/Interpolation_search) algorithm\n */\n"
  },
  {
    "language": "C++",
    "code": "    std::cin >> n;\n\n    int *array = new int[n];\n\n    std::cout << \"array in ascending (increasing) order : \" << std::endl;\n"
  },
  {
    "language": "C++",
    "code": "    assert(not_found == answer1);\n    // Test 2\n    answer1 = search::saddleback::saddleback(matrix, 0);\n    assert(not_found == answer1);\n    // Test 3\n"
  },
  {
    "language": "C++",
    "code": "    env->SetObjectField(newUserData, nameField, name);\n    env->SetDoubleField(newUserData, balanceField, balance);\n    \n    // Return the created object\n    return newUserData;\n"
  },
  {
    "language": "Java",
    "code": "      case \"f\":\n        fragment = value;\n        break;\n      default:\n        throw new IllegalArgumentException(\"unexpected attribute: \" + value);\n"
  },
  {
    "language": "Java",
    "code": "/*\n * Copyright (C) 2014 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n"
  },
  {
    "language": "Java",
    "code": "  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();\n  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();\n\n  @RegisterExtension public PlatformRule platform = new PlatformRule();\n  @RegisterExtension public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();\n"
  },
  {
    "language": "Java",
    "code": "    this.server = server;\n  }\n\n  @AfterEach public void tearDown() throws Exception {\n    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);\n"
  },
  {
    "language": "Java",
    "code": "  }\n\n  @Test public void nullInterceptor() {\n    OkHttpClient.Builder builder = new OkHttpClient.Builder();\n    try {\n"
  },
  {
    "language": "Java",
    "code": "      builder.build();\n      fail();\n    } catch (IllegalStateException expected) {\n      assertThat(expected.getMessage()).isEqualTo(\"Null network interceptor: [null]\");\n    }\n"
  },
  {
    "language": "Java",
    "code": "  }\n\n  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {\n    try {\n      new OkHttpClient.Builder()\n"
  },
  {
    "language": "Java",
    "code": "  @Test public void noSslSocketFactoryConfigured() throws Exception {\n    OkHttpClient client = new OkHttpClient.Builder()\n        .connectionSpecs(asList(ConnectionSpec.CLEARTEXT))\n        .build();\n    try {\n"
  },
  {
    "language": "Java",
    "code": "      }\n    };\n\n    OkHttpClient client = new OkHttpClient.Builder()\n        .protocols(nullHostileProtocols)\n"
  },
  {
    "language": "Java",
    "code": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n"
  },
  {
    "language": "Java",
    "code": "    assertThat(body.contentLength()).isEqualTo(expected.length());\n\n    Buffer out = new Buffer();\n    body.writeTo(out);\n    assertThat(out.readUtf8()).isEqualTo(expected);\n"
  },
  {
    "language": "Java",
    "code": "    // Browsers convert '\\u0000' to '%EF%BF%BD'.\n    assertThat(formEncode(0)).isEqualTo(\"%00\");\n    assertThat(formEncode(1)).isEqualTo(\"%01\");\n    assertThat(formEncode(2)).isEqualTo(\"%02\");\n    assertThat(formEncode(3)).isEqualTo(\"%03\");\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Representation of one story, a set of request headers to encode or decode. This class is used\n * reflectively with Moshi to parse stories from files.\n */\npublic class Story implements Cloneable {\n"
  },
  {
    "language": "Java",
    "code": "    int i = 0;\n    while (true) { // break after last test.\n      String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);\n      InputStream storyInputStream = HpackJsonUtil.class.getResourceAsStream(storyResourceName);\n      if (storyInputStream == null) {\n"
  },
  {
    "language": "Java",
    "code": "    }\n\n    return result;\n  }\n\n"
  },
  {
    "language": "Java",
    "code": "  private final MockWebServer server = new MockWebServer();\n\n  @BeforeEach public void setUp() throws IOException {\n    platform.assumeNotBouncyCastle();\n    server.start();\n"
  },
  {
    "language": "Java",
    "code": "\n  @Test public void mockResponseSetHeaders() {\n    MockResponse response = new MockResponse()\n        .clearHeaders()\n        .addHeader(\"Cookie: s=square\")\n"
  },
  {
    "language": "Java",
    "code": "        .setBody(\"ABC\")\n        .clearHeaders()\n        .addHeader(\"Content-Length: 4\"));\n    server.enqueue(new MockResponse().setBody(\"DEF\"));\n\n"
  },
  {
    "language": "Java",
    "code": "  }\n\n  @Test public void hostnameImplicitlyStarts() {\n    assertThat(server.getHostName()).isNotNull();\n  }\n"
  },
  {
    "language": "Java",
    "code": "    server.enqueue(new MockResponse().setBody(\"hello world\"));\n\n    URL url = server.url(\"/a/deep/path?key=foo%20bar\").url();\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    InputStream in = connection.getInputStream();\n"
  },
  {
    "language": "Java",
    "code": "\n    HttpUrl url = server.url(\"/\");\n    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();\n    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());\n    connection.setHostnameVerifier(new RecordingHostnameVerifier());\n"
  },
  {
    "language": "Java",
    "code": "        .build();\n\n    HttpUrl url = server.url(\"/\");\n    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();\n    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());\n"
  },
  {
    "language": "Java",
    "code": "\n    boolean androidMorEarlier = Build.VERSION.SDK_INT <= 23;\n    try {\n      sendRequest(client, \"https://valid-isrgrootx1.letsencrypt.org/robots.txt\");\n      if (androidMorEarlier) {\n"
  },
  {
    "language": "Java",
    "code": "              \"MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw\\n\" +\n              \"TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\\n\" +\n              \"cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4\\n\" +\n              \"WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu\\n\" +\n              \"ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY\\n\" +\n"
  },
  {
    "language": "Java",
    "code": "\n      builder.sslSocketFactory(certificates.sslSocketFactory(), certificates.trustManager());\n    }\n\n    OkHttpClient client = builder.build();\n"
  },
  {
    "language": "Java",
    "code": "        .build();\n\n    server.enqueue(new MockResponse()\n        .setHeadersDelay(500, TimeUnit.MILLISECONDS)\n        .setHeader(\"content-type\", \"text/event-stream\")\n"
  },
  {
    "language": "Java",
    "code": "        .url(server.url(\"/\"));\n\n    if (accept != null) {\n      builder.header(\"Accept\", accept);\n    }\n"
  },
  {
    "language": "Java",
    "code": "        + \"data\\n\"\n        + \"\\n\"\n        + \"data\\n\"\n        + \"data\\n\"\n        + \"\\n\"\n"
  },
  {
    "language": "Java",
    "code": "    Platform.get().log(\"[ES] onFailure\", Platform.INFO, t);\n    events.add(new Failure(t, response));\n  }\n\n  private Object nextEvent() {\n"
  },
  {
    "language": "Java",
    "code": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n"
  },
  {
    "language": "Java",
    "code": "      Buffer buffer = new Buffer();\n      body.writeTo(buffer);\n      return buffer.readString(body.contentType().charset());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n"
  },
  {
    "language": "Java",
    "code": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n"
  },
  {
    "language": "Java",
    "code": "        .bootstrapDnsHosts(getByIp(\"1.1.1.1\"), getByIp(\"1.0.0.1\"))\n        .includeIPv6(false)\n        .build();\n  }\n\n"
  },
  {
    "language": "Java",
    "code": "        .sslSocketFactory(\n            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())\n        .hostnameVerifier(hostnameVerifier)\n        .build();\n\n"
  },
  {
    "language": "Java",
    "code": "        .setHeader(\"Content-Type\", PLAIN));\n    Response response = client.newCall(request().build()).execute();\n    response.body().close();\n\n    applicationLogs\n"
  },
  {
    "language": "Java",
    "code": "        .assertLogMatch(\"<-- 200 OK \" + url + \" \\\\(\\\\d+ms\\\\)\")\n        .assertLogEqual(\"Content-Length: 0\")\n        .assertLogEqual(\"<-- END HTTP\")\n        .assertNoMoreLogs();\n  }\n"
  },
  {
    "language": "Java",
    "code": "\n  @Test public void headersResponseBody() throws IOException {\n    setLevel(Level.HEADERS);\n\n    server.enqueue(new MockResponse()\n"
  },
  {
    "language": "Java",
    "code": "        .assertLogEqual(\"\")\n        .assertLogEqual(\"Hello!\")\n        .assertLogEqual(\"<-- END HTTP (6-byte body)\")\n        .assertNoMoreLogs();\n\n"
  },
  {
    "language": "Java",
    "code": "        .assertLogEqual(\"Content-Type: text/plain; charset=utf-8\")\n        .assertLogEqual(\"\")\n        .assertLogEqual(\"Hello!\")\n        .assertLogEqual(\"<-- END HTTP (6-byte body)\")\n        .assertNoMoreLogs();\n"
  },
  {
    "language": "Java",
    "code": "          .assertLogEqual(\"Content-Type: text/plain; charset=utf-8\")\n          .assertLogMatch(\"Content-Length: \\\\d+\")\n          .assertLogEqual(\"<-- END HTTP (encoded body omitted)\")\n          .assertNoMoreLogs();\n    }\n"
  },
  {
    "language": "Java",
    "code": "    platform.assumeNotBouncyCastle();\n\n    server.useHttps(handshakeCertificates.sslSocketFactory(), false); // HTTP/2\n    url = server.url(\"/\");\n\n"
  },
  {
    "language": "Java",
    "code": "/*\n * Copyright (C) 2018 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n"
  },
  {
    "language": "Java",
    "code": "        .assertLogMatch(\"proxySelectStart: \" + url)\n        .assertLogMatch(\"proxySelectEnd: \\\\[DIRECT\\\\]\")\n        .assertLogMatch(\"dnsStart: \" + url.host())\n        .assertLogMatch(\"callFailed: java.net.UnknownHostException: reason\")\n        .assertNoMoreLogs();\n"
  },
  {
    "language": "Java",
    "code": "\n    logRecorder\n        .assertLogMatch(\"cacheConditionalHit: Response\\\\{protocol=h2, code=200, message=, url=\" + url + \"\\\\}\")\n        .assertLogMatch(\"cacheHit: Response\\\\{protocol=h2, code=200, message=, url=\" + url + \"\\\\}\")\n        .assertLogMatch(\"cacheMiss\")\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.List;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n"
  },
  {
    "language": "Java",
    "code": "        SocketException exception = new SocketException();\n        exception.initCause(e);\n        throw exception;\n      }\n    }\n"
  },
  {
    "language": "Java",
    "code": " * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n"
  },
  {
    "language": "Java",
    "code": "        .setResponseCode(302)\n        .addHeader(\"Location\", \"https://twitter.com/CuteEmergency/status/789457462864863232\");\n  }\n\n  public interface Listener {\n"
  },
  {
    "language": "Java",
    "code": "\n    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team, session -> {\n      initOauthSession(session);\n      System.out.printf(\"session granted: %s\\n\", session);\n    });\n"
  },
  {
    "language": "Java",
    "code": "  }\n\n  /** Starts a real time messaging session. */\n  public void startRtm() throws IOException {\n    String accessToken;\n"
  },
  {
    "language": "Java",
    "code": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.WebSocketListener;\nimport okio.ByteString;\n"
  },
  {
    "language": "Java",
    "code": "\n    return builder.build();\n  }\n\n  /** See https://api.slack.com/methods/oauth.access. */\n"
  },
  {
    "language": "Java",
    "code": "        .addQueryParameter(\"redirect_uri\", redirectUrl.toString())\n        .build();\n    Request request = new Request.Builder()\n        .url(url)\n        .build();\n"
  },
  {
    "language": "Java",
    "code": "    Call call = httpClient.newCall(request);\n    try (Response response = call.execute()) {\n      JsonAdapter<OAuthSession> jsonAdapter = moshi.adapter(OAuthSession.class);\n      return jsonAdapter.fromJson(response.body().source());\n    }\n"
  },
  {
    "language": "Java",
    "code": "  String run(String url) throws IOException {\n    Request request = new Request.Builder()\n        .url(url)\n        .build();\n\n"
  },
  {
    "language": "Java",
    "code": "import okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\n\npublic class PostExample {\n"
  },
  {
    "language": "Java",
    "code": "      if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n      System.out.println(response.handshake().cipherSuite());\n      System.out.println(response.body().string());\n    }\n"
  },
  {
    "language": "Java",
    "code": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic final class PreemptiveAuth {\n"
  },
  {
    "language": "Java",
    "code": "      printEvent(\"proxySelectStart\");\n    }\n\n    @Override public void proxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {\n      printEvent(\"proxySelectEnd\");\n"
  },
  {
    "language": "Java",
    "code": "    @Override public void requestHeadersEnd(Call call, Request request) {\n      printEvent(\"requestHeadersEnd\");\n    }\n\n    @Override public void requestBodyStart(Call call) {\n"
  },
  {
    "language": "Java",
    "code": "    private final Pipe pipe = new Pipe(8192);\n    private final BufferedSink sink = Okio.buffer(pipe.sink());\n\n    public BufferedSink sink() {\n      return sink;\n"
  },
  {
    "language": "Java",
    "code": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic final class LoggingInterceptors {\n"
  },
  {
    "language": "Java",
    "code": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n"
  },
  {
    "language": "Java",
    "code": "\n    @Override public void responseHeadersStart(Call call) {\n      printEvent(\"responseHeadersStart\");\n    }\n\n"
  },
  {
    "language": "Java",
    "code": "import okio.ForwardingSource;\nimport okio.Okio;\nimport okio.Source;\n\npublic final class Progress {\n"
  },
  {
    "language": "Java",
    "code": "              .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n              .build();\n        })\n        .build();\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic final class AsynchronousGet {\n  private final OkHttpClient client = new OkHttpClient();\n\n  public void run() throws Exception {\n"
  },
  {
    "language": "Java",
    "code": "      }\n    });\n  }\n\n  public static void main(String... args) throws Exception {\n"
  },
  {
    "language": "Java",
    "code": "\n      System.out.println(response.body().string());\n    }\n  }\n\n"
  },
  {
    "language": "Java",
    "code": "        .addFormDataPart(\"title\", \"Square Logo\")\n        .addFormDataPart(\"image\", \"logo-square.png\",\n            RequestBody.create(\n                new File(\"docs/images/logo-square.png\"),\n                MEDIA_TYPE_PNG))\n"
  },
  {
    "language": "Java",
    "code": "package okhttp3.recipes;\n\nimport java.io.IOException;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\n"
  },
  {
    "language": "Java",
    "code": "        for (int i = 2; i <= 997; i++) {\n          sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i)));\n        }\n      }\n\n"
  },
  {
    "language": "Java",
    "code": "/*\n * Copyright (C) 2014 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n"
  },
  {
    "language": "Java",
    "code": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n"
  },
  {
    "language": "Java",
    "code": " * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n"
  },
  {
    "language": "Java",
    "code": "        .addHeader(\"Accept\", \"application/vnd.github.v3+json\")\n        .build();\n\n    try (Response response = client.newCall(request).execute()) {\n      if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n"
  },
  {
    "language": "Java",
    "code": "      + \"AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP\\n\"\n      + \"9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/\\n\"\n      + \"eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m\\n\"\n      + \"0vdXcDazv/wor3ElhVsT/h5/WrQ8\\n\"\n      + \"-----END CERTIFICATE-----\\n\");\n"
  },
  {
    "language": "Java",
    "code": "            .sslSocketFactory(certificates.sslSocketFactory(), certificates.trustManager())\n            .build();\n  }\n\n  public void run() throws Exception {\n"
  },
  {
    "language": "Java",
    "code": "import okhttp3.mockwebserver.MockWebServer;\nimport okhttp3.mockwebserver.RecordedRequest;\nimport okio.Buffer;\nimport okio.Okio;\n\n"
  },
  {
    "language": "Java",
    "code": "    try {\n      if (!path.startsWith(\"/\") || path.contains(\"..\")) throw new FileNotFoundException();\n\n      File file = new File(root + path);\n      return file.isDirectory()\n"
  },
  {
    "language": "Java",
    "code": "    if (path.endsWith(\".gif\")) return \"image/gif\";\n    if (path.endsWith(\".html\")) return \"text/html; charset=utf-8\";\n    if (path.endsWith(\".txt\")) return \"text/plain; charset=utf-8\";\n    return \"application/octet-stream\";\n  }\n"
  },
  {
    "language": "Java",
    "code": "  @Test public void testLocalhostIpv6() throws UnknownHostException {\n    Socket socket = new FakeSocket(InetAddress.getByAddress(\"localhost\",\n        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);\n\n    RecordedRequest request = new RecordedRequest(\"GET / HTTP/1.1\", headers,\n"
  },
  {
    "language": "Java",
    "code": "import org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\n"
  },
  {
    "language": "Java",
    "code": "      }\n    }\n    // Halfway +/- 0.5%\n    assertThat((float) i).isCloseTo(512f, offset(5f));\n  }\n"
  },
  {
    "language": "Java",
    "code": "  @Test public void shutdownWithoutEnqueue() throws IOException {\n    MockWebServer server = new MockWebServer();\n    server.start();\n    server.shutdown();\n  }\n"
  },
  {
    "language": "Java",
    "code": "\n    assertThat(server.protocols().size()).isEqualTo(1);\n    assertThat(server.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);\n  }\n\n"
  },
  {
    "language": "Java",
    "code": "\n    server2.start();\n    server2.start();\n    server2.shutdown();\n  }\n"
  },
  {
    "language": "Java",
    "code": "import org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n"
  },
  {
    "language": "Java",
    "code": "      }\n    };\n    mockWebServer.setDispatcher(dispatcher);\n    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);\n    startsFirst.start();\n"
  },
  {
    "language": "Java",
    "code": " * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n"
  },
  {
    "language": "Java",
    "code": "        + \"-----BEGIN CERTIFICATE-----\\n\"\n        + \"MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDDAhjYXNo\\n\"\n        + \"LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMM\\n\"\n        + \"CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\\n\"\n        + \"+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\\n\"\n"
  },
  {
    "language": "Java",
    "code": "        + \"lu/GJQZoU9lDrCPeUcQ28tzOW6AKBggqhkjOPQMBBw==\\n\"\n        + \"-----END PRIVATE KEY-----\\n\";\n\n    HeldCertificate heldCertificate = HeldCertificate.decode(certificatePem + pkcs8Pem);\n    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);\n"
  },
  {
    "language": "Java",
    "code": "      assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);\n    }\n\n    X509Certificate certificate = heldCertificate.certificate();\n    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);\n"
  },
  {
    "language": "Java",
    "code": "\n    assertThat(certificate.getSubjectX500Principal().getName())\n        .isEqualTo(\"CN=cash.app,OU=engineering\");\n  }\n\n"
  },
  {
    "language": "Java",
    "code": "  @Test public void decodeRsa512() {\n    // The certificate + private key below was generated with OpenSSL. Never generate certificates\n    // with MD5 or 512-bit RSA; that's insecure!\n    //\n    // openssl req \\\n"
  },
  {
    "language": "Java",
    "code": "    //   -keyout privateKey.key \\\n    //   -out certificate.crt\n\n    String certificatePem = \"\"\n        + \"-----BEGIN CERTIFICATE-----\\n\"\n"
  },
  {
    "language": "Java",
    "code": "    String pkcs8Pem = \"\"\n        + \"-----BEGIN PRIVATE KEY-----\\n\"\n        + \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCaU+vrUPL0APGI\\n\"\n        + \"SXIuRX4xRrigXmGKx+GRPnWDWvGJwOm23Vpq/eZxQx6PbSUB1+QZzAwge20RpNAp\\n\"\n        + \"2lt5/qFtgUpEon2j06rd/0+ODqqVJX+6d3SpmF1fPfKUB6AOZbxEkaJpBSTavoTg\\n\"\n"
  },
  {
    "language": "Java",
    "code": "        + \"KM82/1X/jBx8jufm3SokIoIsMKbqC+ZPj+ep9dx7sxyTCE+nVSnjdL2Uyx+DDg3o\\n\"\n        + \"na237HTScWIi+tMv5QGEwqLHS2q+NZYfjgnSxNY8BRw4XZCcIZRko9niuB5gUjj/\\n\"\n        + \"y01HwvOCWuOMaSKZak1OdOaz3427/TkhYIqf6ft0ELF+ASRk3BLQA06pRt88H3u2\\n\"\n        + \"3vsHJsWr2rkCN0h9uDp2o50ZQ5fvlxqG0QIZmvkIkQKBgQDOHeZKvXO5IxQ+S8ed\\n\"\n        + \"09bC5SKiclCdW+Ry7N2x1MBfrxc4TTTTNaUN9Qdc6RXANG9bX2CJv0Dkh/0yH3z9\\n\"\n"
  },
  {
    "language": "Java",
    "code": "    }\n  }\n\n  @Test public void decodeMalformed() {\n    try {\n"
  },
  {
    "language": "Java",
    "code": "          + \"-----END CERTIFICATE-----\\n\"\n          + \"-----BEGIN PRIVATE KEY-----\\n\"\n          + \"MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\\n\"\n          + \"-----END PRIVATE KEY-----\\n\");\n      fail();\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                            if (instance) {\n                                instanceContract = instance.contract;\n                                if (type(instanceContract) == TYPES.f) {\n                                    contractResult = instanceContract(window);\n"
  },
  {
    "language": "JavaScript",
    "code": "                                    if (type(instanceAdded) == TYPES.f)\n                                        instanceAdded(extensionOptions);\n\n                                    return _base.ext(extName);\n                                }\n"
  },
  {
    "language": "JavaScript",
    "code": "                            }\n                        }\n                        else\n                            return _base.ext(extName);\n                    }\n"
  },
  {
    "language": "JavaScript",
    "code": "                 */\n                function construct(targetElement, options, extensions) {\n                    _defaultOptions = globals.defaultOptions;\n                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;\n                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                        return _base;\n                    }\n\n                    if (_isBody) {\n"
  },
  {
    "language": "JavaScript",
    "code": "                             */\n                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);\n                        }\n                    }\n\n"
  },
  {
    "language": "JavaScript",
    "code": "                    setTimeout(function () {\n                        if (_supportTransition && !_destroyed)\n                            addClass(_hostElement, _classNameHostTransition);\n                    }, 333);\n\n"
  },
  {
    "language": "JavaScript",
    "code": " * Date: 02.08.2020\n */\n\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd)\n"
  },
  {
    "language": "JavaScript",
    "code": "            oH: 'offsetHeight',\n            cH: 'clientHeight',\n            sH: 'scrollHeight',\n            oW: 'offsetWidth',\n            cW: 'clientWidth',\n"
  },
  {
    "language": "JavaScript",
    "code": "            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\n            var jsCache = {};\n            var cssCache = {};\n            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];\n            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                    var dummyStyle = document.createElement('div')[LEXICON.s];\n                    var possbleValues = values.split(' ');\n                    var preparedSuffix = suffix || '';\n                    var i = 0;\n"
  },
  {
    "language": "JavaScript",
    "code": "                /**\n                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.\n                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.\n                 */\n                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                /**\n                 * Gets the vendor-prefixed CSS property by the given name.\n                 * For example the given name is \"transform\" and you're using a old Firefox browser then the returned value would be \"-moz-transform\".\n                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.\n"
  },
  {
    "language": "JavaScript",
    "code": "             * Redistribution and use in source and binary forms, with or without modification, \n             * are permitted provided that the following conditions are met:\n             * \n             * Redistributions of source code must retain the above copyright notice, this list of \n             * conditions and the following disclaimer.\n"
  },
  {
    "language": "JavaScript",
    "code": "             * or promote products derived from this software without specific prior written permission.\n             * \n             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \n             * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n             * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
  },
  {
    "language": "JavaScript",
    "code": "                            } else if (copy !== undefined) {\n                                target[name] = copy;\n                            }\n                        }\n                    }\n"
  },
  {
    "language": "JavaScript",
    "code": "                                            prop: key,\n                                            start: fromVal,\n                                            now: easedVal,\n                                            end: toVal,\n                                            pos: percent,\n"
  },
  {
    "language": "JavaScript",
    "code": "                            parent.insertBefore(el.firstChild, el);\n                        parent.removeChild(el);\n                    }\n\n                    return this;\n"
  },
  {
    "language": "JavaScript",
    "code": "                    var classList;\n\n                    while ((elem = this[i++])) {\n                        classList = elem.classList;\n                        if (classList && classList.contains(className))\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                parent: function (selector) {\n                    var parents = [];\n                    var parent;\n                    this.each(function () {\n"
  },
  {
    "language": "JavaScript",
    "code": "\n\n                //ANIMATION:\n\n                animate: function (props, duration, easing, complete) {\n"
  },
  {
    "language": "JavaScript",
    "code": "                        var inArray = FRAMEWORK.inArray;\n                        var isEmptyObj = FRAMEWORK.isEmptyObject;\n                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {\n                            for (var prop in template) {\n                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {\n"
  },
  {
    "language": "JavaScript",
    "code": "                                    else if (!templateIsComplex) {\n                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {\n                                            currType = templateTypes[i];\n                                            templateValueType = type(currType);\n                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix\n"
  },
  {
    "language": "JavaScript",
    "code": "                var _overlayScrollbarDummySize;\n                var _rtlScrollBehavior;\n                var _autoUpdateRecommended;\n                var _msieVersion;\n                var _nativeScrollbarStyling;\n"
  },
  {
    "language": "JavaScript",
    "code": "                                        //execution order is important for IE!!!\n                                        _sizeObserverElement.children().eq(0).css(css);\n                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);\n                                        _cssDirectionDetectedCache = dir;\n                                        result = true;\n"
  },
  {
    "language": "JavaScript",
    "code": "                function freezeResizeObserver(targetElement, freeze) {\n                    if (targetElement !== undefined) {\n                        if(freeze) {\n                            if (_supportResizeObserver) {\n                                var element = targetElement.contents()[0];\n"
  },
  {
    "language": "JavaScript",
    "code": "                 * If there are any size changes, the update method gets called.\n                 */\n                function hostOnResized() {\n                    if (!_sleeping) {\n                        var changed;\n"
  },
  {
    "language": "JavaScript",
    "code": "                    if (_sleeping || _mutationObserversConnected)\n                        return;\n\n                    var elem;\n                    var curr;\n"
  },
  {
    "language": "JavaScript",
    "code": "                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);\n                    }\n                    if (checkX && !sizeIsAffected) {\n                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);\n                        if (!sizeIsAffected && !_isBorderBox)\n"
  },
  {
    "language": "JavaScript",
    "code": "                        origHeight = _targetElementNative[LEXICON.oH];\n                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);\n\n                        //append correct size values\n                        css[_strWidth] = width;\n"
  },
  {
    "language": "JavaScript",
    "code": "                    _scrollbarsVisibilityCache = scrollbarsVisibility;\n                    _scrollbarsAutoHideCache = scrollbarsAutoHide;\n                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;\n                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;\n                    _classNameCache = className;\n"
  },
  {
    "language": "JavaScript",
    "code": "                    }\n                    else {\n                        contentGlueElementCSS[_strWidth] = _strEmpty;\n                    }\n                    if (heightAuto) {\n"
  },
  {
    "language": "JavaScript",
    "code": "                            var viewportElementResetCSS = {};\n                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;\n                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;\n                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);\n                            _viewportElement.css(viewportElementResetCSS);\n"
  },
  {
    "language": "JavaScript",
    "code": "                                var xy = scrollbarVars._x_y;\n                                var XY = scrollbarVars._X_Y;\n                                var strDirection = horizontal ? _strBottom : isRTLLeft;\n\n                                var reset = function () {\n"
  },
  {
    "language": "JavaScript",
    "code": "                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {\n                            if (_isRTL && widthAuto) {\n                                var floatTmp = _contentElement.css(_strFloat);\n                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);\n                                _contentElement.css(_strFloat, floatTmp);\n"
  },
  {
    "language": "JavaScript",
    "code": "                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                    if (!destroy) {\n                        if (_isTextarea) {\n                            if (!_currentPreparedOptions.sizeAutoCapable) {\n                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);\n"
  },
  {
    "language": "JavaScript",
    "code": "                        37, 38, 39, 40,                                           //left, up, right, down arrows\n                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock\n                    ];\n                    var textareaKeyDownKeyCodesList = [];\n                    var textareaUpdateIntervalID;\n"
  },
  {
    "language": "JavaScript",
    "code": "                    function textareaOnScroll(event) {\n                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);\n                        _targetElement[_strScrollTop](0);\n                        COMPATIBILITY.prvD(event);\n                        COMPATIBILITY.stpP(event);\n"
  },
  {
    "language": "JavaScript",
    "code": "                                updateTextarea();\n                        }, 50);\n                    }\n                    function textareaOnFocus() {\n                        _textareaHasFocus = true;\n"
  },
  {
    "language": "JavaScript",
    "code": "                    function textareaOnKeyUp(event) {\n                        var keyCode = event.keyCode;\n                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);\n\n                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\n"
  },
  {
    "language": "JavaScript",
    "code": "                            if (index > -1)\n                                textareaKeyDownKeyCodesList.splice(index, 1);\n                            if (!textareaKeyDownKeyCodesList[LEXICON.l])\n                                updateTextarea(true);\n                        }\n"
  },
  {
    "language": "JavaScript",
    "code": "                            }, scrollStopDelay);\n                        }\n                    }\n\n\n"
  },
  {
    "language": "JavaScript",
    "code": "\n                //==== Scrollbars ====//\n\n                /**\n                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)\n"
  },
  {
    "language": "JavaScript",
    "code": "                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl\n                    var trackTimeout;\n                    var mouseDownScroll;\n                    var mouseDownOffset;\n                    var mouseDownInvertedScale;\n"
  },
  {
    "language": "JavaScript",
    "code": "                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);\n\n                            scrollAction();\n                            COMPATIBILITY.prvD(event);\n                            COMPATIBILITY.stpP(event);\n"
  },
  {
    "language": "JavaScript",
    "code": "                 * Refreshes the handle offset of the given scrollbar.\n                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\n                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)\n                 */\n                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {\n"
  },
  {
    "language": "JavaScript",
    "code": "                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {\n                    suffix = suffix || _strEmpty;\n                    prefix = prefix || _strEmpty;\n                    return {\n                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),\n"
  },
  {
    "language": "JavaScript",
    "code": "                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.\n                 */\n                function isHTMLElement(o) {\n                    var strOwnerDocument = 'ownerDocument';\n                    var strHTMLElement = 'HTMLElement';\n"
  },
  {
    "language": "JavaScript",
    "code": "                    }\n\n                    return {\n                        _cursorRow: cursorRow, //cursorRow\n                        _cursorColumn: cursorCol, //cursorCol\n"
  },
  {
    "language": "JavaScript",
    "code": "                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.\n                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)\n                 * If its a boolean it decides whether only the children of the host element shall be selected.\n                 * @returns {*} The generated or selected element.\n                 */\n"
  },
  {
    "language": "JavaScript",
    "code": "\n\n                //==== Utils Cache ====//\n\n                /**\n"
  },
  {
    "language": "JavaScript",
    "code": "                 * @returns {*} The first element which is a child of the given element and matches the givens selector.\n                 */\n                function findFirst(el, selector) {\n                    return _frameworkProto.find.call(el, selector).eq(0);\n                }\n"
  },
  {
    "language": "JavaScript",
    "code": "                    var contentSizeC;\n                    var isString = type(force) == TYPES.s;\n                    var doUpdateAuto;\n                    var mutHost;\n                    var mutContent;\n"
  },
  {
    "language": "JavaScript",
    "code": "                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());\n                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());\n                            }\n                            else {\n                                mutHost = _base.update(_strAuto);\n"
  },
  {
    "language": "JavaScript",
    "code": "                        changedOps = setOptions(newOptions);\n                    }\n\n                    if (!FRAMEWORK.isEmptyObject(changedOps)) {\n                        update({ _changedOptions: changedOps });\n"
  },
  {
    "language": "JavaScript",
    "code": "                    setupScrollbarsDOM(true);\n                    setupScrollbarCornerDOM(true);\n                    setupStructureDOM(true);\n\n                    //remove all generated image load events\n"
  },
  {
    "language": "JavaScript",
    "code": "                };\n\n                /**\n                 * Scrolls to a given position or element.\n                 * @param coordinates\n"
  },
  {
    "language": "JavaScript",
    "code": "                 */\n                _base.scroll = function (coordinates, duration, easing, complete) {\n                    if (arguments.length === 0 || coordinates === undefined) {\n                        var infoX = _scrollHorizontalInfo;\n                        var infoY = _scrollVerticalInfo;\n"
  },
  {
    "language": "JavaScript",
    "code": "                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.\n                            var viewportOffset = _paddingElement.offset();\n\n                            //get coordinates\n                            var elementOffset = finalElement.offset();\n"
  },
  {
    "language": "JavaScript",
    "code": "            /**\n             * Returns a object which contains global information about the plugin and each instance of it.\n             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.\n             */\n            _plugin.globals = function () {\n"
  },
  {
    "language": "JavaScript",
    "code": "             * Registers, Unregisters or returns a extension.\n             * Register: Pass the name and the extension. (defaultOptions is optional)\n             * Unregister: Pass the name and anything except a function as extension parameter.\n             * Get extension: Pass the name of the extension which shall be got.\n             * Get all extensions: Pass no arguments.\n"
  },
  {
    "language": "JavaScript",
    "code": "                else\n                    return PLUGIN(_elements, options);\n            };\n        }\n        return PLUGIN;\n"
  },
  {
    "language": "JavaScript",
    "code": " *\n * Copyright KingSora | Rene Haas.\n * https://github.com/KingSora\n *\n * Released under the MIT license.\n"
  },
  {
    "language": "JavaScript",
    "code": "  var SELECTOR_DATA_REFRESH = '[data-card-widget=\"card-refresh\"]';\n  var Default = {\n    source: '',\n    sourceSelector: '',\n    params: {},\n"
  },
  {
    "language": "JavaScript",
    "code": "  };\n\n  var CardRefresh = /*#__PURE__*/function () {\n    function CardRefresh(element, settings) {\n      this._element = element;\n"
  },
  {
    "language": "JavaScript",
    "code": "\n  $__default['default'].fn[NAME] = CardRefresh._jQueryInterface;\n  $__default['default'].fn[NAME].Constructor = CardRefresh;\n\n  $__default['default'].fn[NAME].noConflict = function () {\n"
  },
  {
    "language": "JavaScript",
    "code": "      });\n\n      this._element.trigger($__default['default'].Event(EVENT_MINIMIZED), this._parent);\n    };\n\n"
  },
  {
    "language": "JavaScript",
    "code": "\n  $__default['default'](document).on('click', SELECTOR_DATA_COLLAPSE, function (event) {\n    if (event) {\n      event.preventDefault();\n    }\n"
  },
  {
    "language": "JavaScript",
    "code": "\n    CardWidget._jQueryInterface.call($__default['default'](this), 'toggle');\n  });\n  $__default['default'](document).on('click', SELECTOR_DATA_REMOVE, function (event) {\n    if (event) {\n"
  },
  {
    "language": "JavaScript",
    "code": "  var CLASS_NAME_NAVBAR_XL_FIXED = 'layout-xl-navbar-fixed';\n  var CLASS_NAME_FOOTER_FIXED = 'layout-footer-fixed';\n  var CLASS_NAME_FOOTER_SM_FIXED = 'layout-sm-footer-fixed';\n  var CLASS_NAME_FOOTER_MD_FIXED = 'layout-md-footer-fixed';\n  var CLASS_NAME_FOOTER_LG_FIXED = 'layout-lg-footer-fixed';\n"
  },
  {
    "language": "JavaScript",
    "code": "\n      var $controlSidebar = $__default['default'](SELECTOR_CONTROL_SIDEBAR + \" \" + SELECTOR_CONTROL_SIDEBAR_CONTENT);\n      $controlSidebar.css('height', sidebarHeight);\n\n      if (typeof $__default['default'].fn.overlayScrollbars !== 'undefined') {\n"
  },
  {
    "language": "JavaScript",
    "code": "          right: 'inherit'\n        });\n      }\n\n      var offset = $element.offset();\n"
  },
  {
    "language": "JavaScript",
    "code": "\n        if (!data) {\n          data = new ExpandableTable($__default['default'](this));\n          $__default['default'](this).data(DATA_KEY$5, data);\n        }\n"
  },
  {
    "language": "JavaScript",
    "code": "  var SELECTOR_TAB_NAV = SELECTOR_DATA_TOGGLE$3 + \".iframe-mode .nav\";\n  var SELECTOR_TAB_NAVBAR_NAV = SELECTOR_DATA_TOGGLE$3 + \".iframe-mode .navbar-nav\";\n  var SELECTOR_TAB_NAVBAR_NAV_ITEM = SELECTOR_TAB_NAVBAR_NAV + \" .nav-item\";\n  var SELECTOR_TAB_CONTENT = SELECTOR_DATA_TOGGLE$3 + \".iframe-mode .tab-content\";\n  var SELECTOR_TAB_EMPTY = SELECTOR_TAB_CONTENT + \" .tab-empty\";\n"
  },
  {
    "language": "JavaScript",
    "code": "\n      this.onTabCreated($__default['default'](\"#\" + navId));\n    };\n\n    _proto.openTabSidebar = function openTabSidebar(item, autoOpen) {\n"
  },
  {
    "language": "JavaScript",
    "code": "        this._setupListeners();\n\n        this._fixHeight(true);\n      }\n    };\n"
  },
  {
    "language": "JavaScript",
    "code": "\n          _this2.openTabSidebar(e.target);\n        });\n      }\n\n"
  },
  {
    "language": "JavaScript",
    "code": "        _this2.switchTab(e.target);\n      });\n      $__default['default'](document).on('click', SELECTOR_DATA_TOGGLE_CLOSE, function (e) {\n        e.preventDefault();\n\n"
  },
  {
    "language": "JavaScript",
    "code": "          mousedown = false;\n          clearInterval(mousedownInterval);\n          mousedownInterval = null;\n        }\n      });\n"
  },
  {
    "language": "JavaScript",
    "code": "    _proto._fixHeight = function _fixHeight(tabEmpty) {\n      if (tabEmpty === void 0) {\n        tabEmpty = false;\n      }\n\n"
  },
  {
    "language": "JavaScript",
    "code": "   * ====================================================\n   */\n\n\n  $__default['default'](window).on('load', function () {\n"
  },
  {
    "language": "JavaScript",
    "code": "\n      this._init();\n    } // Public\n\n\n"
  },
  {
    "language": "JavaScript",
    "code": "      }\n\n      var $body = $__default['default']('body');\n      var controlSidebar = 0;\n\n"
  },
  {
    "language": "JavaScript",
    "code": "      $__default['default'](window).resize(function () {\n        _this.fixLayoutHeight();\n      });\n      $__default['default'](document).ready(function () {\n        _this.fixLayoutHeight();\n"
  },
  {
    "language": "JavaScript",
    "code": "  /**\n   * --------------------------------------------\n   * AdminLTE PushMenu.js\n   * License MIT\n   * --------------------------------------------\n"
  },
  {
    "language": "JavaScript",
    "code": "\n      var $body = $__default['default']('body');\n      var toggleState = localStorage.getItem(\"remember\" + EVENT_KEY$5);\n\n      if (toggleState === CLASS_NAME_COLLAPSED$1) {\n"
  },
  {
    "language": "JavaScript",
    "code": "      var _this3 = this;\n\n      if (path === void 0) {\n        path = [];\n      }\n"
  },
  {
    "language": "JavaScript",
    "code": "\n        if (this._config.position == POSITION_TOP_RIGHT) {\n          container.addClass(CLASS_NAME_TOP_RIGHT);\n        } else if (this._config.position == POSITION_TOP_LEFT) {\n          container.addClass(CLASS_NAME_TOP_LEFT);\n"
  },
  {
    "language": "JavaScript",
    "code": "\n    _proto.toggle = function toggle(event) {\n      var $relativeTarget = $__default['default'](event.currentTarget);\n      var $parent = $relativeTarget.parent();\n      var treeviewMenu = $parent.find(\"> \" + SELECTOR_TREEVIEW_MENU);\n"
  },
  {
    "language": "JavaScript",
    "code": "      if (isOpen) {\n        this.collapse($__default['default'](treeviewMenu), parentLi);\n      } else {\n        this.expand($__default['default'](treeviewMenu), parentLi);\n      }\n"
  },
  {
    "language": "JavaScript",
    "code": "        pointRadius: false,\n        pointColor: '#3b8bba',\n        pointStrokeColor: 'rgba(60,141,188,1)',\n        pointHighlightFill: '#fff',\n        pointHighlightStroke: 'rgba(60,141,188,1)',\n"
  },
  {
    "language": "JavaScript",
    "code": "          display: false\n        }\n      }],\n      yAxes: [{\n        gridLines: {\n"
  },
  {
    "language": "JavaScript",
    "code": "      'Mail-Order Sales'\n    ],\n    datasets: [\n      {\n        data: [30, 12, 20],\n"
  },
  {
    "language": "JavaScript",
    "code": "    labels: ['2011 Q1', '2011 Q2', '2011 Q3', '2011 Q4', '2012 Q1', '2012 Q2', '2012 Q3', '2012 Q4', '2013 Q1', '2013 Q2'],\n    datasets: [\n      {\n        label: 'Digital Goods',\n        fill: false,\n"
  },
  {
    "language": "JavaScript",
    "code": "  // You can switch between pie and douhnut using the method below.\n  // eslint-disable-next-line no-unused-vars\n  var pieChart = new Chart(pieChartCanvas, {\n    type: 'doughnut',\n    data: pieData,\n"
  },
  {
    "language": "JavaScript",
    "code": "      $('.nav-sidebar').addClass('nav-collapse-hide-child')\n    } else {\n      $('.nav-sidebar').removeClass('nav-collapse-hide-child')\n    }\n  })\n"
  },
  {
    "language": "JavaScript",
    "code": "      $sidebar.removeClass(skin)\n    })\n\n    $sidebar.addClass(sidebar_class)\n  }))\n"
  },
  {
    "language": "JavaScript",
    "code": "  })\n  $container.append($logo_variants)\n  var $clear_btn = $('<a />', {\n    href: '#'\n  }).text('clear').on('click', function (e) {\n"
  },
  {
    "language": "JavaScript",
    "code": "  function createSkinBlock(colors, callback) {\n    var $block = $('<div />', {\n      class: 'd-flex flex-wrap mb-3'\n    })\n\n"
  },
  {
    "language": "Bash",
    "code": "# This is roughly equivalent to going back in time and setting\n# COMP_WORDBREAKS to exclude those characters.  The intent is to\n# make option types like --date=<type> and <rev>:<path> easy to\n# recognize by treating each shell word as a single token.\n#\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\t# unless the previous token is the command name.\n\t\t\tif [ $j -ge 2 ] && [ -n \"$first\" ]; then\n\t\t\t\t((j--))\n\t\t\tfi\n\t\t\tfirst=\n"
  },
  {
    "language": "Bash",
    "code": "{\n\tlocal IFS=$'\\n'\n\t__gitcompappend \"$1\" \"${2-}\" \"${3-$cur}\" \"${4- }\"\n}\n\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\t# both quoted and unquoted.\n\t\t\tif (p in paths)\n\t\t\t\t# We have seen the same directory unquoted,\n\t\t\t\t# skip it.\n\t\t\t\tcontinue\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\t\t# C-style one-character escape sequence.\n\t\t\t\tout = out substr(\"\\a\\b\\t\\v\\f\\r\\\"\\\\\",\n\t\t\t\t\t\t esc_idx, 1)\n\t\t\t} else if (esc == \"n\") {\n\t\t\t\t# Uh-oh, a newline character.\n"
  },
  {
    "language": "Bash",
    "code": "\t\tcase \"$COMP_WORDBREAKS\" in\n\t\t*:*) : great ;;\n\t\t*)   pfx=\"$ref:$pfx\" ;;\n\t\tesac\n\n"
  },
  {
    "language": "Bash",
    "code": "\t+*)\n\t\tpfx=\"+\"\n\t\tcur_=\"${cur_#+}\"\n\t\t;;\n\tesac\n"
  },
  {
    "language": "Bash",
    "code": "\t\tfi\n\t\t;;\n\tesac\n}\n\n"
  },
  {
    "language": "Bash",
    "code": "__git_find_last_on_cmdline ()\n{\n\tlocal word c=$cword show_idx\n\n\twhile test $# -gt 1; do\n"
  },
  {
    "language": "Bash",
    "code": "\t\tcase \"$1\" in\n\t\t--show-idx)\tshow_idx=y ;;\n\t\t*)\t\treturn 1 ;;\n\t\tesac\n\t\tshift\n"
  },
  {
    "language": "Bash",
    "code": "\tdone\n}\n\n# Echo the value of an option set on the command line or config\n#\n"
  },
  {
    "language": "Bash",
    "code": "\tlocal result= values config_key word\n\n\tshort_opt=\"$1\"\n\tlong_opt=\"$2\"\n\tvalues=\"$3\"\n"
  },
  {
    "language": "Bash",
    "code": "\tdone\n\treturn 1\n}\n\n# Try to count non option arguments passed on the command line for the\n"
  },
  {
    "language": "Bash",
    "code": "\t\t__gitcomp \"+x -x\" \"\" \"${cur##--chmod=}\"\n\t\treturn\n\t\t;;\n\t--*)\n\t\t__gitcomp_builtin add\n"
  },
  {
    "language": "Bash",
    "code": "_git_fsck ()\n{\n\tcase \"$cur\" in\n\t--*)\n\t\t__gitcomp_builtin fsck\n"
  },
  {
    "language": "Bash",
    "code": "# Lists matching symbol names from a tag (as in ctags) file.\n# 1: List symbol names matching this word.\n# 2: The tag file to list symbol names from.\n# 3: A prefix to be added to each listed symbol name (optional).\n# 4: A suffix to be appended to each listed symbol name (optional).\n"
  },
  {
    "language": "Bash",
    "code": "# Options that go well for log and shortlog (not gitk)\n__git_log_shortlog_options=\"\n\t--author= --committer= --grep=\n\t--all-match --invert-grep\n\"\n"
  },
  {
    "language": "Bash",
    "code": "\tesac\n\tcase \"$cur\" in\n\t--pretty=*|--format=*)\n\t\t__gitcomp \"$__git_log_pretty_formats $(__git_pretty_aliases)\n\t\t\t\" \"\" \"${cur#*=}\"\n"
  },
  {
    "language": "Bash",
    "code": "\t--repo)\n\t\t__gitcomp_nl \"$(__git_remotes)\"\n\t\treturn\n\t\t;;\n\t--recurse-submodules)\n"
  },
  {
    "language": "Bash",
    "code": "\t\treturn\n\t\t;;\n\t--*)\n\t\t__gitcomp_builtin push\n\t\treturn\n"
  },
  {
    "language": "Bash",
    "code": "\t\t__gitcomp \"$__git_rebase_inprogress_options\"\n\t\treturn\n\tfi\n\t__git_complete_strategy && return\n\tcase \"$cur\" in\n"
  },
  {
    "language": "Bash",
    "code": "\t\t;;\n\tlog.date)\n\t\t__gitcomp \"$__git_log_date_formats\" \"\" \"$cur_\"\n\t\treturn\n\t\t;;\n"
  },
  {
    "language": "Bash",
    "code": "},\n\n# Completes configuration sections, subsections, variable names.\n#\n# Usage: __git_complete_config_variable_name [<option>]...\n"
  },
  {
    "language": "Bash",
    "code": "\t\tcase \"$1\" in\n\t\t--cur=*)\tcur_=\"${1##--cur=}\" ;;\n\t\t--sfx=*)\tsfx=\"${1##--sfx=}\" ;;\n\t\t*)\t\treturn 1 ;;\n\t\tesac\n"
  },
  {
    "language": "Bash",
    "code": "\t\treturn\n\t\t;;\n\tguitool.*.*)\n\t\tlocal pfx=\"${cur_%.*}.\"\n\t\tcur_=\"${cur_##*.}\"\n"
  },
  {
    "language": "Bash",
    "code": "\t\t*)\n\t\t\t__gitcomp \"$subcommands\"\n\t\t\t;;\n\t\tesac\n\t\treturn\n"
  },
  {
    "language": "Bash",
    "code": "\t\t;;\n\tesac\n\n\t__git_complete_index_file \"--cached\"\n}\n"
  },
  {
    "language": "Bash",
    "code": "\t\treturn\n\t\t;;\n\tesac\n\t__git_complete_revlist_file\n}\n"
  },
  {
    "language": "Bash",
    "code": "\t\tapply,--*|pop,--*)\n\t\t\t__gitcomp \"--index --quiet\"\n\t\t\t;;\n\t\tdrop,--*)\n\t\t\t__gitcomp \"--quiet\"\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\t;;\n\t\tbranch,--*)\n\t\t\t__gitcomp \"--dry-run --message --tag\"\n\t\t\t;;\n\t\ttag,--*)\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\t\t\t# the ref to be checked out.\n\t\t\t\t\t__git_complete_refs\n\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\tfi\n"
  },
  {
    "language": "Bash",
    "code": "\n__git_have_func () {\n\tdeclare -f -- \"$1\" >/dev/null 2>&1\n}\n\n"
  },
  {
    "language": "Bash",
    "code": "\techo \"package windows\"\n\techo \"type KNOWNFOLDERID GUID\"\n\techo \"var (\"\n\twhile read -r line; do\n\t\t[[ $line =~ DEFINE_KNOWN_FOLDER\\((FOLDERID_[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+)\\) ]] || continue\n"
  },
  {
    "language": "Bash",
    "code": "#!/usr/bin/env bash\nset -ex\n\n# This script builds archiver for most common platforms.\n\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\tcontinue\n\t\tfi\n\t\t[[ -n $key && -n $value ]] || continue\n\t\t[[ -z ${errors[\"$key\"]} ]] || continue\n\t\terrors[\"$key\"]=\"$value\"\n"
  },
  {
    "language": "Bash",
    "code": "alias ng.test='/usr/local/sbin/nginx -t -c /usr/local/etc/nginx/nginx.conf'\nalias ng.dump='/usr/local/sbin/nginx -T -c /usr/local/etc/nginx/nginx.conf'\n\nalias CD_NGX_ROOT=\"cd /usr/local/etc/nginx && ls -lh\"\nalias CD_NGX_LOGS=\"cd /var/log/nginx && ls -lh\"\n"
  },
  {
    "language": "Bash",
    "code": "[[ -n $knownfolders ]] || { echo \"Unable to find KnownFolders.h\" >&2; exit 1; }\n\n{\n\techo \"// Code generated by 'mkknownfolderids.bash'; DO NOT EDIT.\"\n\techo\n"
  },
  {
    "language": "Bash",
    "code": "\techo \"package windows\"\n\techo \"type KNOWNFOLDERID GUID\"\n\techo \"var (\"\n\twhile read -r line; do\n\t\t[[ $line =~ DEFINE_KNOWN_FOLDER\\((FOLDERID_[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+)\\) ]] || continue\n"
  },
  {
    "language": "Bash",
    "code": "\n    # Output the command we ran\n    echo \"Executing: \" $@\n\n    # \"$output\" gets rid of newlines. This will bring them back.\n"
  },
  {
    "language": "Bash",
    "code": "export CGO_ENABLED=0\n\ncd cmd/arc\nGOOS=linux   GOARCH=386   go build -o ../../builds/arc_linux_386\nGOOS=linux   GOARCH=amd64 go build -o ../../builds/arc_linux_amd64\n"
  },
  {
    "language": "Bash",
    "code": "  shift\n\n  local errtrace=0\n  if grep -q \"errtrace\" <<< \"$SHELLOPTS\"\n  then\n"
  },
  {
    "language": "Bash",
    "code": "},\n\nfunction echoyellow {\n  tput setaf 3\n  tput bold\n"
  },
  {
    "language": "Bash",
    "code": "  fi\n  echo \"Status=$status\"\n  echo \"Output=$output\"\n  echo \"---\"\n  echo \"Got version=$VERSION\"\n"
  },
  {
    "language": "Bash",
    "code": "  mkdir -p \"${OUTDIR}\"\n  docker_wget \"$DC\" \"http://${HOSTPORT}/config_dump\" -q -O - > \"${OUTDIR}/config_dump.json\"\n  docker_wget \"$DC\" \"http://${HOSTPORT}/clusters?format=json\" -q -O - > \"${OUTDIR}/clusters.json\"\n  docker_wget \"$DC\" \"http://${HOSTPORT}/stats\" -q -O - > \"${OUTDIR}/stats.txt\"\n  docker_wget \"$DC\" \"http://${HOSTPORT}/stats/prometheus\" -q -O - > \"${OUTDIR}/stats_prometheus.txt\"\n"
  },
  {
    "language": "Bash",
    "code": "\n  echo \"$PID\"\n}\n\nfunction kill_envoy {\n"
  },
  {
    "language": "Bash",
    "code": "},\n\nfunction delete_config_entry {\n  local KIND=$1\n  local NAME=$2\n"
  },
  {
    "language": "Bash",
    "code": "\n  case \"$CHECK_STATE\" in\n    pass)\n      ;;\n    warn)\n"
  },
  {
    "language": "Bash",
    "code": "      ;;\n    fail)\n      ;;\n    *)\n      echo \"invalid ttl check state '${CHECK_STATE}'\" >&2\n"
  },
  {
    "language": "Bash",
    "code": "},\n\n# ShellCheck doesn't know about $status from Bats\n# shellcheck disable=SC2154\n# shellcheck disable=SC2120\n"
  },
  {
    "language": "Bash",
    "code": "\n# ShellCheck doesn't know about $output from Bats\n# shellcheck disable=SC2154\nassert_output_not_exists() {\n  [[ -z \"$output\" ]] || flunk \"expected no output, found some\"\n"
  },
  {
    "language": "Bash",
    "code": "# ShellCheck doesn't know about $lines from Bats\n# shellcheck disable=SC2154\nassert_line_count() {\n  declare EXPECTED=\"$1\"\n  local num_lines=\"${#lines[@]}\"\n"
  },
  {
    "language": "Bash",
    "code": "  dokku --force apps:destroy \"$TEST_APP\"\n  return \"$RC\"\n}\n\ndestroy_key() {\n"
  },
  {
    "language": "Bash",
    "code": "  echo \"output: $output\"\n  echo \"status: $status\"\n  assert_output \"${to}\"\n}\n\n"
  },
  {
    "language": "Bash",
    "code": "{{ \\$port_map_list := \\$port_map | split \":\" }}\n{{ \\$scheme := index \\$port_map_list 0 }}\n{{ \\$listen_port := index \\$port_map_list 1 }}\n{{ \\$upstream_port := index \\$port_map_list 2 }}\n{{ if eq \\$scheme \"http\" }}\n"
  },
  {
    "language": "Bash",
    "code": "  local NETWORK_NAME=\"$1:=$TEST_NETWORK\"\n\n  NETWORK=$(docker network ls -q -f name=\"$NETWORK_NAME\")\n  [[ -z \"$NETWORK\" ]] && docker network create \"$NETWORK_NAME\"\n}\n"
  },
  {
    "language": "Bash",
    "code": "export GO111MODULE=on\nif [[ ! -d \"../../node_modules/\" ]]; then\n    (cd ../..; npm ci)\nfi\n(cd ../../; go build -tags sqlite -o test/e2e/hydra . )\n"
  },
  {
    "language": "Bash",
    "code": "            DSN=$TEST_DATABASE_MYSQL \\\n                ./hydra serve all --dangerous-force-http --sqa-opt-out > ./hydra.e2e.log 2>&1 &\n            export CYPRESS_jwt_enabled=false\n            ;;\n\n"
  },
  {
    "language": "Bash",
    "code": "\t\tprintf \"%s = &KNOWNFOLDERID{0x%08x, 0x%04x, 0x%04x, [8]byte{0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x}}\\n\" \\\n\t\t\t\"${BASH_REMATCH[1]}\" $(( \"${BASH_REMATCH[2]}\" )) $(( \"${BASH_REMATCH[3]}\" )) $(( \"${BASH_REMATCH[4]}\" )) \\\n\t\t\t$(( \"${BASH_REMATCH[5]}\" )) $(( \"${BASH_REMATCH[6]}\" )) $(( \"${BASH_REMATCH[7]}\" )) $(( \"${BASH_REMATCH[8]}\" )) \\\n\t\t\t$(( \"${BASH_REMATCH[9]}\" )) $(( \"${BASH_REMATCH[10]}\" )) $(( \"${BASH_REMATCH[11]}\" )) $(( \"${BASH_REMATCH[12]}\" ))\n\tdone < \"$knownfolders\"\n"
  },
  {
    "language": "Bash",
    "code": "\n\twhile read -r line; do\n\t\tunset vtype\n\t\tif [[ $line =~ ^#define\\ +([A-Z0-9_]+k?)\\ +([A-Z0-9_]+\\()?([A-Z][A-Z0-9_]+k?)\\)? ]]; then\n\t\t\tkey=\"${BASH_REMATCH[1]}\"\n"
  },
  {
    "language": "Bash",
    "code": "\n\twhile read -r line; do\n\t\tunset vtype\n\t\tif [[ $line =~ ^#define\\ +([A-Z0-9_]+k?)\\ +([A-Z0-9_]+\\()?([A-Z][A-Z0-9_]+k?)\\)? ]]; then\n\t\t\tkey=\"${BASH_REMATCH[1]}\"\n"
  },
  {
    "language": "Bash",
    "code": "    IFS=$'\\n;' read -rd '' -a prompt_command_array <<< \"$PROMPT_COMMAND\"\n\n    local trimmed_arg\n    trimmed_arg=$(__bp_trim_whitespace \"${1:-}\")\n\n"
  },
  {
    "language": "Bash",
    "code": "fi\n\n\n# set error file location\nif [[ \"$(uname)\" == \"Darwin\" ]]; then\n"
  },
  {
    "language": "Bash",
    "code": "    fi\n}\n\n\n# open autojump results in file browser\n"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Copyright 2019 The Go Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n"
  },
  {
    "language": "Bash",
    "code": "\techo \"package windows\"\n\techo \"type KNOWNFOLDERID GUID\"\n\techo \"var (\"\n\twhile read -r line; do\n\t\t[[ $line =~ DEFINE_KNOWN_FOLDER\\((FOLDERID_[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+),[\\t\\ ]*(0x[^,]+)\\) ]] || continue\n"
  },
  {
    "language": "Bash",
    "code": "\t\t\tvtype=\"\"\n\t\t\tif [[ $last_vtype == Handle && $value == NO_ERROR ]]; then\n\t\t\t\tvalue=\"S_OK\"\n\t\t\telif [[ $last_vtype == syscall.Errno && $value == NO_ERROR ]]; then\n\t\t\t\tvalue=\"ERROR_SUCCESS\"\n"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Copyright 2019 The Go Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n"
  },
  {
    "language": "Bash",
    "code": "\nset -e\nshopt -s nullglob\n\nwinerror=\"$(printf '%s\\n' \"/mnt/c/Program Files (x86)/Windows Kits/\"/*/Include/*/shared/winerror.h | sort -Vr | head -n 1)\"\n"
  },
  {
    "language": "Bash",
    "code": "      -sil-partial-specialization \\\n      -sil-partial-specialization-with-generic-substitutions \\\n      -sil-print-all \\\n      -sil-print-debuginfo \\\n      -sil-print-functions \\\n"
  },
  {
    "language": "Bash",
    "code": "      -verify-linetable \\\n      -verify-skip-convert-escape-to-noescape-attributes \\\n      -view-cfg-long-line-behavior \\\n      -view-cfg-max-columns \\\n      -view-cfg-only-for-function \\\n"
  },
  {
    "language": "Bash",
    "code": "# This source file is part of the FoundationDB open source project\n#\n# Copyright 2013-2018 Apple Inc. and the FoundationDB project authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
  },
  {
    "language": "Bash",
    "code": "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n"
  },
  {
    "language": "Bash",
    "code": "#! /bin/bash\n\n# start.bash\n#\n# This source file is part of the FoundationDB open source project\n"
  },
  {
    "language": "Bash",
    "code": "  unset N_NODE_MIRROR\n  unset N_NODE_DOWNLOAD_MIRROR\n  unset N_MAX_REMOTE_MATCHES\n  unset N_PRESERVE_NPM\n  unset HTTP_USER\n"
  },
  {
    "language": "Rust",
    "code": "    }\n\n    Ok(())\n  }\n\n"
  },
  {
    "language": "Rust",
    "code": "    // immutable borrow, but if `.resolve_specifier` is mut, then everything\n    // that calls it is is mut\n    let mut s = specifier;\n    while let Some(redirect) = self.redirects.get(s) {\n      s = redirect;\n"
  },
  {
    "language": "Rust",
    "code": "        // root modules can be redirects, so before we pass it to tsc we need\n        // to resolve the redirect\n        specifier.clone(),\n        self.get_media_type(specifier).unwrap(),\n      ));\n"
  },
  {
    "language": "Rust",
    "code": "    } else {\n      return Err(GraphError::MissingSpecifier(module.clone()).into());\n    };\n\n    let mut seen = HashSet::new();\n"
  },
  {
    "language": "Rust",
    "code": "        ModuleSlot::Err(err) => Err(anyhow!(err.to_string())),\n        ModuleSlot::Module(module) => {\n          for (_, dep) in module.dependencies.iter() {\n            // a dynamic import should be skipped, because while it might not\n            // be available to statically analyze, it might be available at\n"
  },
  {
    "language": "Rust",
    "code": "  pending: FuturesUnordered<FetchFuture>,\n}\n\nimpl GraphBuilder {\n  pub fn new(\n"
  },
  {
    "language": "Rust",
    "code": "\n    loop {\n      match self.pending.next().await {\n        Some(Err((specifier, err))) => {\n          self\n"
  },
  {
    "language": "Rust",
    "code": "          let is_root = &cached_module.specifier == specifier;\n          self.visit(cached_module, is_root)?;\n        }\n        _ => {}\n      }\n"
  },
  {
    "language": "Rust",
    "code": "    self\n      .graph\n      .modules\n      .insert(specifier, ModuleSlot::Module(Box::new(module)));\n\n"
  },
  {
    "language": "Rust",
    "code": "    }\n    fn get_tsbuildinfo(\n      &self,\n      _specifier: &ModuleSpecifier,\n    ) -> Result<Option<String>, AnyError> {\n"
  },
  {
    "language": "Rust",
    "code": "        .tsbuildinfo_calls\n        .push((specifier.clone(), tsbuildinfo));\n      Ok(())\n    }\n    fn set_deps(\n"
  },
  {
    "language": "Rust",
    "code": "      .expect(\"module not inserted\");\n\n    (builder.get_graph(), handler)\n  }\n\n"
  },
  {
    "language": "Rust",
    "code": "    let version_f = get_version(&doc_b, \"1.2.4\", b\"\");\n    assert_eq!(version_e, version_f);\n  }\n\n  #[test]\n"
  },
  {
    "language": "Rust",
    "code": "    assert!(module.maybe_version.is_none());\n    module.set_version(b\"\");\n    assert_eq!(module.maybe_version, expected);\n  }\n\n"
  },
  {
    "language": "Rust",
    "code": "      (\"file:///tests/fixture13.ts\", \"fixture13.out\"),\n      (\"file:///tests/fixture14.ts\", \"fixture14.out\"),\n      (\"file:///tests/fixture15.ts\", \"fixture15.out\"),\n    ];\n    let c = PathBuf::from(env::var_os(\"CARGO_MANIFEST_DIR\").unwrap());\n"
  },
  {
    "language": "Rust",
    "code": "        debug: false,\n        emit: false,\n        lib: TypeLib::DenoWindow,\n        maybe_config_path: None,\n        reload: false,\n"
  },
  {
    "language": "Rust",
    "code": "    };\n\n    // let's do it all over again to ensure that the versions are determinstic\n    let (graph, handler) = setup(specifier).await;\n    let result_info = graph\n"
  },
  {
    "language": "Rust",
    "code": "    assert!(emitted_files.contains_key(\"file:///a.ts.js.map\"));\n    let out_b = emitted_files.get(\"file:///b.ts.js\");\n    assert!(out_b.is_some());\n    let out_b = out_b.unwrap();\n    assert!(out_b.starts_with(\"export const b = \\\"b\\\";\"));\n"
  },
  {
    "language": "Rust",
    "code": "        export const b = \"b\";\n      \"#\n      ),\n    )\n    .await;\n"
  },
  {
    "language": "Rust",
    "code": "        export const b = \"b\";\n      \"#\n      ),\n    )\n    .await;\n"
  },
  {
    "language": "Rust",
    "code": "      .expect(\"could not resolve module\");\n    let (graph, _) = setup(specifier).await;\n    let info = graph.info().expect(\"could not get info\");\n    assert!(info.compiled.is_none());\n    assert_eq!(info.dep_count, 6);\n"
  },
  {
    "language": "Rust",
    "code": "    }));\n    let mut builder = GraphBuilder::new(handler.clone(), None, None);\n    builder\n      .add(&specifier, false)\n      .await\n"
  },
  {
    "language": "Rust",
    "code": "    let cwd = current_dir().unwrap();\n    assert_eq!(resolve_from_cwd(Path::new(\"a/..\")).unwrap(), cwd);\n  }\n\n  #[test]\n"
  },
  {
    "language": "Rust",
    "code": "    assert!(is_supported_ext_fmt(Path::new(\"readme.MD\")));\n    assert!(is_supported_ext_fmt(Path::new(\"lib/typescript.d.ts\")));\n    assert!(is_supported_ext_fmt(Path::new(\"cli/tests/001_hello.js\")));\n    assert!(is_supported_ext_fmt(Path::new(\"cli/tests/002_hello.ts\")));\n    assert!(is_supported_ext_fmt(Path::new(\"foo.jsx\")));\n"
  },
  {
    "language": "Rust",
    "code": "\n    let result = collect_files(&[root_dir_path], &[ignore_dir_path], |path| {\n      // exclude dotfiles\n      path\n        .file_name()\n"
  },
  {
    "language": "Rust",
    "code": "    let (options_value, ignored) =\n      parse_config(config_text, &config_path).expect(\"error parsing\");\n    assert!(options_value.is_object());\n    let options = options_value.as_object().unwrap();\n    assert!(options.contains_key(\"strict\"));\n"
  },
  {
    "language": "Rust",
    "code": "      }\n    }\n    _ => None,\n  };\n\n"
  },
  {
    "language": "Rust",
    "code": "  column_number: i64,\n  source_line: Option<String>,\n  mappings_map: &mut CachedMaps,\n  getter: Arc<G>,\n) -> (String, i64, i64, Option<String>) {\n"
  },
  {
    "language": "Rust",
    "code": "\n            let source_line = if let Some(source_line) = maybe_source_line {\n              Some(source_line.to_string())\n            } else if let Some(source_line) =\n              getter.get_source_line(&file_name, token.get_src_line() as usize)\n"
  },
  {
    "language": "Rust",
    "code": "use deno_core::serde_json::json;\nuse deno_core::JsRuntime;\nuse deno_core::RuntimeOptions;\nuse regex::Regex;\nuse serde::Deserialize;\n"
  },
  {
    "language": "Rust",
    "code": "  println!(\"Snapshot size: {}\", snapshot_slice.len());\n  std::fs::write(&snapshot_path, snapshot_slice).unwrap();\n  println!(\"Snapshot written to: {} \", snapshot_path.display());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "    \"es2020.sharedmemory\",\n    \"es2020.string\",\n    \"es2020.symbol.wellknown\",\n    \"esnext\",\n    \"esnext.intl\",\n"
  },
  {
    "language": "Rust",
    "code": "      manifest_dir.join(file.path())\n    })\n    .filter(|path| path.extension().unwrap_or_default() == \"js\")\n    .collect::<Vec<PathBuf>>();\n  js_files.sort();\n"
  },
  {
    "language": "Rust",
    "code": "      .arg(\"run\")\n      .arg(\"-\")\n      .stdout(std::process::Stdio::piped())\n      .stdin(std::process::Stdio::piped())\n      .spawn()\n"
  },
  {
    "language": "Rust",
    "code": "      .current_dir(util::root_path())\n      .arg(\"run\")\n      .arg(\"http://127.0.0.1:4551/cli/tests/001_hello.js\")\n      .env(\"DENO_AUTH_TOKENS\", \"abcdef123456789@127.0.0.1:4551\")\n      .stdout(std::process::Stdio::piped())\n"
  },
  {
    "language": "Rust",
    "code": "    if let Ok(mut master) = fork.is_parent() {\n      let mut obytes: [u8; 100] = [0; 100];\n      let mut nread = master.read(&mut obytes).unwrap();\n      assert_eq!(String::from_utf8_lossy(&obytes[0..nread]), \"S\");\n      master.write_all(b\"a\").unwrap();\n"
  },
  {
    "language": "Rust",
    "code": "  }\n\n  #[cfg(unix)]\n  #[test]\n  pub fn test_raw_tty_cbreak() {\n"
  },
  {
    "language": "Rust",
    "code": "    } else {\n      // Keep echo enabled such that 'C^' would be printed in non-raw mode.\n      std::env::set_current_dir(root_path).unwrap();\n      let err = exec::Command::new(deno_exe)\n        .arg(\"run\")\n"
  },
  {
    "language": "Rust",
    "code": "\n  #[test]\n  fn cache_invalidation_test() {\n    let deno_dir = TempDir::new().expect(\"tempdir fail\");\n    let fixture_path = deno_dir.path().join(\"fixture.ts\");\n"
  },
  {
    "language": "Rust",
    "code": "      .arg(\"--check\")\n      .arg(badly_formatted_js_str)\n      .arg(badly_formatted_md_str)\n      .arg(badly_formatted_json_str)\n      .spawn()\n"
  },
  {
    "language": "Rust",
    "code": "      .expect(\"Failed to spawn script\")\n      .wait()\n      .expect(\"Failed to wait for child process\");\n    // No target files found\n    assert!(!status.success());\n"
  },
  {
    "language": "Rust",
    "code": "    fn bundle_js_watch() {\n      use std::path::PathBuf;\n      // Test strategy extends this of test bundle_js by adding watcher\n      let t = TempDir::new().expect(\"tempdir fail\");\n      let file_to_watch = t.path().join(\"file_to_watch.js\");\n"
  },
  {
    "language": "Rust",
    "code": "      wait_for_process_finished(\"Process\", &mut stderr_lines);\n\n      // Then restore the file\n      std::fs::write(\n        &file_to_watch,\n"
  },
  {
    "language": "Rust",
    "code": "      assert!(stderr_lines.next().unwrap().contains(\"Restarting\"));\n      assert!(stdout_lines.next().unwrap().contains(\"modified!\"));\n      wait_for_process_finished(\"Process\", &mut stderr_lines);\n\n      // the watcher process is still alive\n"
  },
  {
    "language": "Rust",
    "code": "        std::io::BufReader::new(stderr).lines().map(|r| r.unwrap());\n\n      assert!(stderr_lines.next().unwrap().contains(\"Process finished\"));\n      assert!(stdout_lines.next().unwrap().contains(\"Hello world\"));\n\n"
  },
  {
    "language": "Rust",
    "code": "      .stdin(std::process::Stdio::piped())\n      .stdout(std::process::Stdio::piped())\n      .stderr(std::process::Stdio::piped())\n      .spawn()\n      .unwrap();\n"
  },
  {
    "language": "Rust",
    "code": "    let temp_dir = TempDir::new().unwrap();\n    let exe_path = temp_dir.path().join(\"deno\");\n    let _ = std::fs::copy(util::deno_exe_path(), &exe_path).unwrap();\n    assert!(exe_path.exists());\n    let _mtime1 = std::fs::metadata(&exe_path).unwrap().modified().unwrap();\n"
  },
  {
    "language": "Rust",
    "code": "      .unwrap();\n    let exe_path = temp_dir.path().join(\"deno\");\n    let _ = std::fs::copy(util::deno_exe_path(), &exe_path).unwrap();\n    assert!(exe_path.exists());\n    let status = Command::new(&exe_path)\n"
  },
  {
    "language": "Rust",
    "code": "      .output()\n      .expect(\"failed to spawn script\");\n    let stdout_str = std::str::from_utf8(&output.stdout).unwrap().trim();\n    assert!(stdout_str.ends_with(\"hello, foo\"));\n  }\n"
  },
  {
    "language": "Rust",
    "code": "    std::fs::write(\n      &test,\n      \"\n      import { printHello3 } from \\\"./mod1.bundle.js\\\";\n      printHello3(); \",\n"
  },
  {
    "language": "Rust",
    "code": "      .arg(\"run\")\n      .arg(&bundle)\n      .output()\n      .expect(\"failed to spawn script\");\n    // check the output of the the bundle program.\n"
  },
  {
    "language": "Rust",
    "code": "\n    let output = util::deno_cmd()\n      .current_dir(util::root_path())\n      .arg(\"run\")\n      .arg(\"--allow-net\")\n"
  },
  {
    "language": "Rust",
    "code": "      } else {\n        std::env::set_var(\"NO_COLOR\", \"1\");\n        let err = exec::Command::new(deno_exe).arg(\"repl\").exec();\n        println!(\"err {}\", err);\n        unreachable!()\n"
  },
  {
    "language": "Rust",
    "code": "      if let Ok(mut master) = fork.is_parent() {\n        master.write_all(b\")\\n\").unwrap();\n        master.write_all(b\"]\\n\").unwrap();\n        master.write_all(b\"},\\n\").unwrap();\n        master.write_all(b\"close();\\n\").unwrap();\n"
  },
  {
    "language": "Rust",
    "code": "        master.write_all(b\"Symbol.it\\t\\n\").unwrap();\n        master.write_all(b\"close();\\n\").unwrap();\n\n        let mut output = String::new();\n        master.read_to_string(&mut output).unwrap();\n"
  },
  {
    "language": "Rust",
    "code": "\n        assert!(output.contains(\"Symbol(Symbol.iterator)\"));\n\n        fork.wait().unwrap();\n      } else {\n"
  },
  {
    "language": "Rust",
    "code": "        Some(vec![(\"NO_COLOR\".to_owned(), \"1\".to_owned())]),\n        false,\n      );\n      assert!(out.ends_with(\"3\\n\"));\n      assert!(err.is_empty());\n"
  },
  {
    "language": "Rust",
    "code": "\n      assert!(!out.contains(\"ignored\"));\n      assert!(err.is_empty());\n    }\n\n"
  },
  {
    "language": "Rust",
    "code": "        true,\n        \"repl\",\n        Some(vec![\"not_a_variable\"]),\n        None,\n        false,\n"
  },
  {
    "language": "Rust",
    "code": "      assert!(out.ends_with(\"undefined\\n123\\n\"));\n      assert!(err.is_empty());\n    }\n\n    #[test]\n"
  },
  {
    "language": "Rust",
    "code": "        Some(vec![(\"NO_COLOR\".to_owned(), \"1\".to_owned())]),\n        false,\n      );\n      assert!(out.ends_with(\"1\\n1\\n\"));\n      assert!(err.is_empty());\n"
  },
  {
    "language": "Rust",
    "code": "        Some(vec![\"_error = 1\", \"throw 2\", \"_error\"]),\n        Some(vec![(\"NO_COLOR\".to_owned(), \"1\".to_owned())]),\n        false,\n      );\n      println!(\"{}\", out);\n"
  },
  {
    "language": "Rust",
    "code": "    output: \"exit_sanitizer_test.out\",\n    exit_code: 1,\n  });\n\n  itest!(stdout_write_all {\n"
  },
  {
    "language": "Rust",
    "code": "  itest!(_014_duplicate_import {\n    args: \"run --quiet --reload --allow-read 014_duplicate_import.ts \",\n    output: \"014_duplicate_import.ts.out\",\n  });\n\n"
  },
  {
    "language": "Rust",
    "code": "  itest!(_019_media_types {\n    args: \"run --reload 019_media_types.ts\",\n    output: \"019_media_types.ts.out\",\n    http_server: true,\n  });\n"
  },
  {
    "language": "Rust",
    "code": "    http_server: true,\n  });\n\n  itest!(_023_no_ext {\n    args: \"run --reload 023_no_ext\",\n"
  },
  {
    "language": "Rust",
    "code": "  fn workers() {\n    let _g = util::http_server();\n    let status = util::deno_cmd()\n      .current_dir(util::tests_path())\n      .arg(\"test\")\n"
  },
  {
    "language": "Rust",
    "code": "\n  itest!(_045_proxy {\n    args: \"run -L debug --allow-net --allow-env --allow-run --allow-read --reload --quiet 045_proxy_test.ts\",\n    output: \"045_proxy_test.ts.out\",\n    http_server: true,\n"
  },
  {
    "language": "Rust",
    "code": "\n  itest!(lock_check_ok {\n    args: \"run --lock=lock_check_ok.json http://127.0.0.1:4545/cli/tests/003_relative_import.ts\",\n    output: \"003_relative_import.ts.out\",\n    http_server: true,\n"
  },
  {
    "language": "Rust",
    "code": "    exit_code: 10,\n    http_server: true,\n  });\n\n  itest!(lock_check_err_with_bundle {\n"
  },
  {
    "language": "Rust",
    "code": "    output: \"v8_flags.js.out\",\n  });\n\n  itest!(v8_flags_run {\n    args: \"run --v8-flags=--expose-gc v8_flags.js\",\n"
  },
  {
    "language": "Rust",
    "code": "  itest!(wasm_unreachable {\n    args: \"run wasm_unreachable.js\",\n    output: \"wasm_unreachable.out\",\n    exit_code: 1,\n  });\n"
  },
  {
    "language": "Rust",
    "code": "  itest!(fix_js_import_js {\n    args: \"run --quiet --reload fix_js_import_js.ts\",\n    output: \"fix_js_import_js.ts.out\",\n  });\n\n"
  },
  {
    "language": "Rust",
    "code": "  itest!(ts_import_from_js {\n    args: \"run --quiet --reload ts_import_from_js.js\",\n    output: \"ts_import_from_js.js.out\",\n    http_server: true,\n  });\n"
  },
  {
    "language": "Rust",
    "code": "      .arg(\"cli/tests/no_validate_asm.js\")\n      .stderr(std::process::Stdio::piped())\n      .stdout(std::process::Stdio::piped())\n      .spawn()\n      .unwrap()\n"
  },
  {
    "language": "Rust",
    "code": "      .current_dir(util::root_path())\n      .arg(\"cache\")\n      .arg(module_url.to_string())\n      .output()\n      .expect(\"Failed to spawn script\");\n"
  },
  {
    "language": "Rust",
    "code": "        .output()\n        .expect(\"failed to spawn coverage reporter\");\n\n      let actual =\n        util::strip_ansi_codes(std::str::from_utf8(&output.stdout).unwrap())\n"
  },
  {
    "language": "Rust",
    "code": "        .arg(\"--quiet\")\n        .arg(\"--unstable\")\n        .arg(format!(\"{}/\", tempdir.path().to_str().unwrap()))\n        .stdout(std::process::Stdio::piped())\n        .stderr(std::process::Stdio::inherit())\n"
  },
  {
    "language": "Rust",
    "code": "        let (_, err) = util::run_and_collect_output(\n          false,\n          &format!(\n            \"run --allow-{0}={1},{2} complex_permissions_test.ts {0} {3}\",\n            permission,\n"
  },
  {
    "language": "Rust",
    "code": "    #[test]\n    fn rw_no_prefix() {\n      const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n      for permission in &PERMISSION_VARIANTS {\n        let status = util::deno_cmd()\n"
  },
  {
    "language": "Rust",
    "code": "    }\n\n    #[test]\n    fn net_listen_allow_deno_land() {\n      let (_, err) = util::run_and_collect_output(\n"
  },
  {
    "language": "Rust",
    "code": "    false,\n\t\t\t\"run --allow-net=deno.land complex_permissions_test.ts netListen localhost:4545\",\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tfalse,\n"
  },
  {
    "language": "Rust",
    "code": "\n  mod inspector {\n    use super::*;\n\n    fn inspect_flag_with_unique_port(flag_prefix: &str) -> String {\n"
  },
  {
    "language": "Rust",
    "code": "        .expect(\"Can't connect\");\n      assert_eq!(response.status(), 101); // Switching protocols.\n\n      let (mut socket_tx, socket_rx) = socket.split();\n      let mut socket_rx =\n"
  },
  {
    "language": "Rust",
    "code": "        StdOut(\"hello from the inspector\"),\n        WsSend(r#\"{\"id\":5,\"method\":\"Debugger.resume\"},\"#),\n        WsRecv(r#\"{\"id\":5,\"result\":{}}\"#),\n        StdOut(\"hello from the script\"),\n      ];\n"
  },
  {
    "language": "Rust",
    "code": "      let stderr = child.stderr.as_mut().unwrap();\n      let mut stderr_lines =\n        std::io::BufReader::new(stderr).lines().map(|r| r.unwrap());\n      let ws_url = extract_ws_url_from_stderr(&mut stderr_lines);\n\n"
  },
  {
    "language": "Rust",
    "code": "      // We use tokio_tungstenite as a websocket client because warp (which is\n      // a dependency of Deno) uses it.\n      let (mut socket, _) = tokio_tungstenite::connect_async(ws_url)\n        .await\n        .expect(\"Can't connect\");\n"
  },
  {
    "language": "Rust",
    "code": "\n      let (mut socket_tx, socket_rx) = socket.split();\n      let mut socket_rx =\n        socket_rx.map(|msg| msg.unwrap().to_string()).filter(|msg| {\n          let pass = !msg.starts_with(r#\"{\"method\":\"Debugger.scriptParsed\",\"#);\n"
  },
  {
    "language": "Rust",
    "code": "      .arg(\"run\")\n      .arg(\"--allow-read\")\n      .arg(\"cli/tests/exec_path.ts\")\n      .stdout(std::process::Stdio::piped())\n      .spawn()\n"
  },
  {
    "language": "Rust",
    "code": "\n  #[cfg(windows)]\n  // Clippy suggests to remove the `NoStd` prefix from all variants. I disagree.\n  #[allow(clippy::enum_variant_names)]\n  enum WinProcConstraints {\n"
  },
  {
    "language": "Rust",
    "code": "    let output = run_deno_script_constrained(\n      util::tests_path().join(\"echo.ts\"),\n      WinProcConstraints::NoStdErr,\n    );\n    output.unwrap();\n"
  },
  {
    "language": "Rust",
    "code": "      .current_dir(util::root_path())\n      .env(\"NO_COLOR\", \"1\")\n      .arg(\"fmt\")\n      .arg(\"--check\")\n      .arg(\"--ignore=./\")\n"
  },
  {
    "language": "Rust",
    "code": "      .arg(&exe)\n      .arg(\"./test_util/std/examples/welcome.ts\")\n      .stdout(std::process::Stdio::piped())\n      .spawn()\n      .unwrap()\n"
  },
  {
    "language": "Rust",
    "code": "      .unwrap();\n    assert!(!status.success());\n  }\n\n  #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n"
  },
  {
    "language": "Rust",
    "code": "            Name::from_str(\"net\").unwrap(),\n            Name::from_str(\"example\").unwrap(),\n            0,\n            i32::MAX,\n            i32::MAX,\n"
  },
  {
    "language": "Rust",
    "code": "          let record =\n            Record::from_rdata(Name::from_str(\"foo\").unwrap(), u32::MAX, rdata);\n          let record_set = RecordSet::from(record);\n          map.insert(\n            RrKey::new(lookup_name_lower.clone(), RecordType::CNAME),\n"
  },
  {
    "language": "Rust",
    "code": "            record_set,\n          );\n\n          // Inserts TXT record\n          let rdata =\n"
  },
  {
    "language": "Rust",
    "code": "    {\n      let output = util::deno_cmd()\n        .current_dir(util::tests_path())\n        .env(\"NO_COLOR\", \"1\")\n        .arg(\"run\")\n"
  },
  {
    "language": "Rust",
    "code": "        std::fs::read_to_string(util::tests_path().join(\"resolve_dns.ts.out\"))\n          .unwrap();\n      assert_eq!(expected, out);\n    }\n\n"
  },
  {
    "language": "Rust",
    "code": "      let output = util::deno_cmd()\n        .current_dir(util::tests_path())\n        .env(\"NO_COLOR\", \"1\")\n        .arg(\"run\")\n        .arg(\"--unstable\")\n"
  },
  {
    "language": "Ruby",
    "code": "              '@version' => '1',\n              'foo' => 5,\n              'agent' => 'filebeat',\n              'log' => {\n                   'file' =>\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n  end\n\n  context 'when adding en entry to the batch' do\n    let (:simple_loki_config) {{'url' => 'http://localhost:3100'}}\n"
  },
  {
    "language": "Ruby",
    "code": "    it 'should add entry' do\n      plugin = LogStash::Plugin.lookup(\"output\", \"loki\").new(simple_loki_config)\n      expect(plugin.batch).to eql nil\n      expect(plugin.add_entry_to_batch(entry)).to eql true\n      expect(plugin.add_entry_to_batch(entry)).to eql true\n"
  },
  {
    "language": "Ruby",
    "code": "      sent = Queue.new\n      allow(loki).to receive(:send) do | batch|\n        Thread.new  do\n          sent << batch\n        end\n"
  },
  {
    "language": "Ruby",
    "code": "      loki.close\n    end\n  end\n\n  context 'http requests' do\n"
  },
  {
    "language": "Ruby",
    "code": "      #   push, <<\n      #   replace\n      #   length, size\n      #   ==\n      #   to_ary, to_a\n"
  },
  {
    "language": "Ruby",
    "code": "      # array aliases into enumerable\n      alias_method :each_index, :each_with_index\n      alias_method :slice, :[]\n      alias_method :values_at, :select\n      alias_method :map, :collect\n"
  },
  {
    "language": "Ruby",
    "code": "            result = self.to_a.send(method_name, *args, &block)\n            if result\n              new_arr = result.to_a\n              self.replace(new_arr)\n              if result.is_a?(Enumerator)\n"
  },
  {
    "language": "Ruby",
    "code": "      def unpack(klass)\n        if self.is(klass) then\n          klass.decode(self.value)\n        else\n          nil\n"
  },
  {
    "language": "Ruby",
    "code": "          raise UnexpectedStructType, \"Struct keys must be strings.\"\n        end\n        self.fields[key] ||= Google::Protobuf::Value.new\n        self.fields[key].from_ruby(value)\n      end\n"
  },
  {
    "language": "Ruby",
    "code": "# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
  },
  {
    "language": "Ruby",
    "code": "        mnew = TestMessage.decode(data)\n        mnew = mnew.dup\n        assert_equal mnew.inspect, m.inspect\n        assert TestMessage.encode(mnew) == data\n      end\n"
  },
  {
    "language": "Ruby",
    "code": "      optional :optional_double, :double,       7\n      optional :optional_string, :string,       8\n      optional :optional_bytes,  :bytes,        9\n      optional :optional_msg,    :message,      10, \"TestMessage2\"\n      optional :optional_enum,   :enum,         11, \"TestEnum\"\n"
  },
  {
    "language": "Ruby",
    "code": "      optional :key, :string, 1\n      optional :value, :message, 2, \"TestMessage2\"\n    end\n\n    add_message \"OneofMessage\" do\n"
  },
  {
    "language": "Ruby",
    "code": "      assert m.optional_bytes == \"\"\n      assert m.optional_msg == nil\n      assert m.optional_enum == :Default\n    end\n\n"
  },
  {
    "language": "Ruby",
    "code": "      end\n      assert_raise TypeError do\n        m.optional_msg = TestMessage.new  # expects TestMessage2\n      end\n\n"
  },
  {
    "language": "Ruby",
    "code": "      l2 = l.dup\n      assert l == l2\n      assert l.object_id != l2.object_id\n      l2.push 6\n      assert l.count == 4\n"
  },
  {
    "language": "Ruby",
    "code": "      m.repeated_int32 = l\n      assert m.repeated_int32 == [5, 2, 3, 4, 7, 8]\n      assert m.repeated_int32.object_id == l.object_id\n      l.push 42\n      assert m.repeated_int32.pop == 42\n"
  },
  {
    "language": "Ruby",
    "code": "      l += [1, 2, 3, 4]\n      l.replace([5, 6, 7, 8])\n      assert l == [5, 6, 7, 8]\n\n      l4 = Google::Protobuf::RepeatedField.new(:int32)\n"
  },
  {
    "language": "Ruby",
    "code": "        m[1] = 1\n      end\n      assert_raise Encoding::UndefinedConversionError do\n        bytestring = [\"FFFF\"].pack(\"H*\")\n        m[bytestring] = 1\n"
  },
  {
    "language": "Ruby",
    "code": "      assert m.object_id != m2.object_id\n      assert m[\"a\"].object_id == m2[\"a\"].object_id\n      assert m[\"b\"].object_id == m2[\"b\"].object_id\n\n      m2 = Google::Protobuf.deep_copy(m)\n"
  },
  {
    "language": "Ruby",
    "code": "      assert o != nil\n      assert o.class == Google::Protobuf::OneofDescriptor\n      assert o.name == \"my_oneof\"\n      oneof_count = 0\n      d.each_oneof{ |oneof|\n"
  },
  {
    "language": "Ruby",
    "code": "        oneof_count += 1\n        assert oneof == o\n      }\n      assert oneof_count == 1\n      assert o.count == 4\n"
  },
  {
    "language": "Ruby",
    "code": "      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :C\n      assert d.my_oneof == :d\n\n"
  },
  {
    "language": "Ruby",
    "code": "\n    def test_parse_serialize\n      m = TestMessage.new(:optional_int32 => 42,\n                          :optional_string => \"hello world\",\n                          :optional_enum => :B,\n"
  },
  {
    "language": "Ruby",
    "code": "        :repeated_float=>[],\n        :repeated_int32=>[],\n        :repeated_int64=>[],\n        :repeated_msg=>[],\n        :repeated_string=>[\"bar1\", \"bar2\"],\n"
  },
  {
    "language": "Ruby",
    "code": "    assert_equal \"bar\".encode!('ASCII-8BIT'), m.repeated_bytes.pop\n    assert_equal TestMessage2.new(:foo => 2), m.repeated_msg.pop\n    assert_equal TestMessage2.new(:foo => 1), m.repeated_msg.pop\n    assert_equal :B, m.repeated_enum.pop\n    assert_equal :A, m.repeated_enum.pop\n"
  },
  {
    "language": "Ruby",
    "code": "    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.clear\n"
  },
  {
    "language": "Ruby",
    "code": "    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr + ['fizz', 'buzz']\n"
  },
  {
    "language": "Ruby",
    "code": "  def test_sort_by!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n  end\n\n  def test_uniq!\n    m = TestMessage.new\n"
  },
  {
    "language": "Ruby",
    "code": "      assert m.optional_int64 == -0x1_0000_0000\n      m.optional_uint32 = 0x9000_0000\n      assert m.optional_uint32 == 0x9000_0000\n      m.optional_uint64 = 0x9000_0000_0000_0000\n      assert m.optional_uint64 == 0x9000_0000_0000_0000\n"
  },
  {
    "language": "Ruby",
    "code": "      assert l.object_id != l2.object_id\n      l2.push 6\n      assert l.count == 4\n      assert l2.count == 5\n\n"
  },
  {
    "language": "Ruby",
    "code": "      assert m.length == 0\n      assert m == {}\n\n      assert_raise TypeError do\n        m[1] = 1\n"
  },
  {
    "language": "Ruby",
    "code": "      end\n\n      m = Google::Protobuf::Map.new(\n        :string, :message, TestMessage,\n        { \"a\" => TestMessage.new(:optional_int32 => 42),\n"
  },
  {
    "language": "Ruby",
    "code": "      encoded_field_c = OneofMessage.encode(\n        OneofMessage.new(:c => TestMessage2.new(:foo => 1)))\n      encoded_field_d = OneofMessage.encode(OneofMessage.new(:d => :B))\n\n      d3 = OneofMessage.decode(\n"
  },
  {
    "language": "Ruby",
    "code": "      m.optional_enum = 1\n      assert m.optional_enum == :A\n      m.optional_enum = 100\n      assert m.optional_enum == 100\n    end\n"
  },
  {
    "language": "Ruby",
    "code": "      assert m.repeated_msg.object_id != m2.repeated_msg.object_id\n      assert m.repeated_msg[0].object_id != m2.repeated_msg[0].object_id\n    end\n\n    def test_eq\n"
  },
  {
    "language": "Ruby",
    "code": "      m = MapMessage.new(\n        :map_string_int32 => {\"a\" => 1, \"b\" => 2},\n        :map_string_msg => {\"a\" => TestMessage2.new(:foo => 1),\n                            \"b\" => TestMessage2.new(:foo => 2)})\n      expected_result = {\n"
  },
  {
    "language": "Ruby",
    "code": "\n      serialized = Recursive1.encode(m)\n      m2 = Recursive1.decode(serialized)\n      assert m == m2\n    end\n"
  },
  {
    "language": "Ruby",
    "code": "    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr.concat(['fizz', 'buzz'])\n    # end\n  end\n\n"
  },
  {
    "language": "Ruby",
    "code": "    assert_not_equal hash, m.repeated_string.hash\n  end\n\n  def test_plus\n    m = TestMessage.new\n"
  },
  {
    "language": "Ruby",
    "code": "\n  def test_reverse!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n"
  },
  {
    "language": "Ruby",
    "code": "    m.repeated_string += %w(foo bar baz)\n    orig_repeated_string = m.repeated_string.clone\n    result = m.repeated_string.shuffle!\n    assert_equal m.repeated_string, result\n    # NOTE: sometimes it doesn't change the order...\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(1,2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n"
  },
  {
    "language": "Ruby",
    "code": "  def test_sort_by!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n"
  },
  {
    "language": "Ruby",
    "code": "      arr.unshift('a', 'b')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('')\n    end\n"
  },
  {
    "language": "Ruby",
    "code": "    test_msg.repeated_string += %w(foo bar)\n    test_msg.repeated_bytes  += [\"bar\".encode!('ASCII-8BIT'), \"foo\".encode!('ASCII-8BIT')]\n    test_msg.repeated_msg    << TestMessage2.new(:foo => 1)\n    test_msg.repeated_msg    << TestMessage2.new(:foo => 2)\n    test_msg.repeated_enum   << :A\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n#\n# Protocol Buffers - Google's data interchange format\n# Copyright 2008 Google Inc.  All rights reserved.\n# https://developers.google.com/protocol-buffers/\n"
  },
  {
    "language": "Ruby",
    "code": "#     * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following disclaimer\n# in the documentation and/or other materials provided with the\n"
  },
  {
    "language": "Ruby",
    "code": "\n    when nil\n      fail \"Request didn't have requested output format\"\n    end\n  rescue StandardError => err\n"
  },
  {
    "language": "Ruby",
    "code": "  end\n  if v.empty?\n    puts \"\\t\\\"#{k}\\\"\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "\ndef to_tuples(item)\n  if item.is_a?(Hash)\n    return [[EMPTY_OBJECT,nil]] if item.empty?\n    final = []\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n  end\n  doc['doc_id']\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n  end\n  pair\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "  push(@db,'a4',1)\n  push(@db,'b',5)\n  push(@db,'c',2)\n  push(@db,'d',4)\n  push(@db,'e',3)\n"
  },
  {
    "language": "Ruby",
    "code": "      FDB::Tuple.unpack(key[@raw_prefix.length..-1])\n    end\n\n    def range(tuple=[])\n      rng = FDB::Tuple.range(tuple)\n"
  },
  {
    "language": "Ruby",
    "code": "# This source file is part of the FoundationDB open source project\n#\n# Copyright 2013-2018 Apple Inc. and the FoundationDB project authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
  },
  {
    "language": "Ruby",
    "code": "# https://apple.github.io/foundationdb/api-ruby.html\n\nmodule FDB\n  module Tuple\n    @@size_limits = (0..8).map {|x| (1 << (x*8)) - 1}\n"
  },
  {
    "language": "Ruby",
    "code": "      def <=> (other)\n        self.data <=> other.data\n      end\n      def to_s\n        self.data.each_byte.map { |b| b.to_s(16) } .join\n"
  },
  {
    "language": "Ruby",
    "code": "        v.slice(pos, length).chars.map { |b| (b.ord ^ 0xff).chr } .join\n      else\n        ret = v.slice(pos, length)\n        ret[0] = (ret[0].ord ^ 0x80).chr\n        ret\n"
  },
  {
    "language": "Ruby",
    "code": "        [val - (1 << (length*8)) + 1, pos+length+2]\n      elsif code == @@FALSE_CODE\n        [false, pos+1]\n      elsif code == @@TRUE_CODE\n        [true, pos+1]\n"
  },
  {
    "language": "Ruby",
    "code": "        raise RangeError, \"Integer magnitude is too large (more than 255 bytes)\" if v < -2**2040+1 || v > 2**2040-1\n        if v == 0\n          @@INT_ZERO_CODE.chr\n        elsif v > 0\n          if v > @@size_limits[-1]\n"
  },
  {
    "language": "Ruby",
    "code": "            n = bisect_left( @@size_limits, -v )\n            (@@INT_ZERO_CODE-n).chr + [@@size_limits[n]+v].pack(\"Q>\").slice(8-n, n)\n          end\n        end\n      elsif v.kind_of? TrueClass\n"
  },
  {
    "language": "Ruby",
    "code": "        return c unless c == 0\n        i += 1\n      end\n      tuple1.length <=> tuple2.length\n    end\n"
  },
  {
    "language": "Ruby",
    "code": "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"
  },
  {
    "language": "Ruby",
    "code": "  end\n\n  class Error < StandardError\n    attr_reader :code\n\n"
  },
  {
    "language": "Ruby",
    "code": "          FDB.ffi_callbacks[-1].index = entry.index\n          FDB.ffi_callbacks[entry.index] = FDB.ffi_callbacks[-1]\n          FDB.ffi_callbacks.pop\n        }\n        callback_wrapper(self, &block)\n"
  },
  {
    "language": "Ruby",
    "code": "      end\n      FDBC.fdb_future_set_callback(@fpointer, entry.callback, nil)\n    end\n\n    def self.wait_for_any(*futures)\n"
  },
  {
    "language": "Ruby",
    "code": "\n      ready_idx\n    end\n\n    private\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n  end\n\n  class Database < FormerFuture\n    attr_reader :options\n"
  },
  {
    "language": "Ruby",
    "code": "\n    def get_range(bkeysel, ekeysel, options={}, &block)\n      transact do |tr|\n        a = tr.get_range(bkeysel, ekeysel, options).to_a\n        if block_given?\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n    alias [] get\n\n    def get_key(keysel)\n      key = FDB.key_to_bytes(keysel.key)\n"
  },
  {
    "language": "Ruby",
    "code": "    private :to_selector\n\n    @@RangeEnum = Class.new do\n      include Enumerable\n\n"
  },
  {
    "language": "Ruby",
    "code": "              @mode = @@StreamingMode[\"EXACT\"][0]\n            end\n          end\n        end\n        Enumerable.instance_method(:to_a).bind(o).call\n"
  },
  {
    "language": "Ruby",
    "code": "\n    def get_committed_version\n      version = FFI::MemoryPointer.new :int64\n      FDBC.check_error FDBC.fdb_transaction_get_committed_version(@tpointer, version)\n      version.read_long_long\n"
  },
  {
    "language": "Ruby",
    "code": "\n    def get_versionstamp\n      Key.new(FDBC.fdb_transaction_get_versionstamp(@tpointer))\n    end\n\n"
  },
  {
    "language": "Ruby",
    "code": "    def getter\n      present = FFI::MemoryPointer.new :int\n      value = FFI::MemoryPointer.new :pointer\n      length = FFI::MemoryPointer.new :int\n      FDBC.check_error FDBC.fdb_future_get_value(@fpointer, present, value, length)\n"
  },
  {
    "language": "Ruby",
    "code": "  end\n\n  class Key < LazyString\n    def getter\n      key = FFI::MemoryPointer.new :pointer\n"
  },
  {
    "language": "Ruby",
    "code": "      key_length = FFI::MemoryPointer.new :int\n      FDBC.check_error FDBC.fdb_future_get_key(@fpointer, key, key_length)\n      if key_length.read_int.zero?\n        @value = ''\n      else\n"
  },
  {
    "language": "Ruby",
    "code": "          window_advanced = false\n          loop do\n            tr_state.lock.synchronize do\n              if window_advanced\n                tr.clear_range(@counters, @counters[start])\n"
  },
  {
    "language": "Ruby",
    "code": "            old_node.path != new_node.path\n          then\n            raise ArgumentError, 'Cannot move between partitions'\n          end\n\n"
  },
  {
    "language": "Ruby",
    "code": "\n        true\n      end\n    end\n\n"
  },
  {
    "language": "Ruby",
    "code": "        end\n\n        if !is_prefix_free?(tr.snapshot, prefix)\n          raise 'The directory layer has manually allocated prefixes that conflict with the automatic prefix allocator.'\n        end\n"
  },
  {
    "language": "Ruby",
    "code": "      if version[0] != @@VERSION[0]\n        raise \"Cannot load directory with version #{dir_ver} using directory layer #{layer_ver}\"\n      elsif version[1] != @@VERSION[1] && write_access\n        raise \"Directory with version #{dir_ver} is read-only \n              when opened using directory layer #{layer_ver}\"\n"
  },
  {
    "language": "Ruby",
    "code": "\n      node\n    end\n\n    def subdir_names_and_nodes(tr, node)\n"
  },
  {
    "language": "Ruby",
    "code": "        raise TypeError, 'Invalid path: must be a unicode string or an array of unicode strings'\n      end\n      name.dup.force_encoding('UTF-8')\n    end\n\n"
  },
  {
    "language": "Ruby",
    "code": "    def partition_subpath(path, directory_layer = @directory_layer)\n      self.path[directory_layer.path.length..-1] + path\n    end\n    private :partition_subpath\n\n"
  },
  {
    "language": "Ruby",
    "code": "\n    def range(tuple=[])\n      raise 'Cannot get range for the root of a directory partition.'\n    end\n\n"
  },
  {
    "language": "Ruby",
    "code": "    end\n\n    def get_layer_for_path(path)\n      if path.length == 0\n        @parent_directory_layer\n"
  },
  {
    "language": "Ruby",
    "code": "  def initialize\n    @stack = []\n  end\n  attr_reader :stack\n\n"
  },
  {
    "language": "Ruby",
    "code": "  attr_reader :is_database\n  attr_reader :is_snapshot\n\n  def push(val)\n    @stack.push([val, @index])\n"
  },
  {
    "language": "Ruby",
    "code": "    @db.transact do |tr|\n      tr.options.set_timeout(60*1000)\n      tr.options.set_read_system_keys\n      boundary_keys = FDB::Locality.get_boundary_keys(tr, \"\", \"\\xFF\\xFF\").to_a\n      for i in 0..boundary_keys.length-2\n"
  },
  {
    "language": "Ruby",
    "code": "      inst_tuple = FDB::Tuple.unpack inst_str.value\n      op = inst_tuple[0]\n\n      # puts \"#{@prefix} Instruction is #{inst_tuple}\"\n      # puts \"#{@prefix} Stack from #{@stack.stack.to_s}\"\n"
  },
  {
    "language": "Ruby",
    "code": "          inst.push(\"RESULT_NOT_PRESENT\") if obj == @db\n        when \"READ_CONFLICT_RANGE\"\n          inst.tr.add_read_conflict_range( inst.wait_and_pop, inst.wait_and_pop )\n          inst.push(\"SET_CONFLICT_RANGE\")\n        when \"WRITE_CONFLICT_RANGE\"\n"
  },
  {
    "language": "Ruby",
    "code": "            arr.push(inst.wait_and_pop)\n          end\n          (FDB::Tuple.range arr).each do |x|\n            inst.push(x)\n          end\n"
  },
  {
    "language": "Ruby",
    "code": "        when \"TUPLE_SORT\"\n            arr = []\n            inst.wait_and_pop.times do |i|\n                arr.push(FDB::Tuple.unpack inst.wait_and_pop)\n            end\n"
  },
  {
    "language": "Ruby",
    "code": "          @dir_list << directory.move(inst.tr, pop_tuples(inst), pop_tuples(inst))\n        elsif inst.op == 'DIRECTORY_MOVE_TO'\n          @dir_list << directory.move_to(inst.tr, pop_tuples(inst))\n        elsif inst.op == 'DIRECTORY_REMOVE'\n          count = inst.wait_and_pop\n"
  },
  {
    "language": "Ruby",
    "code": "          throw \"String #{str} does not start with raw prefix #{directory.key}\" if !str.start_with?(directory.key)\n          inst.push(str[directory.key.length..-1])\n        else\n          raise \"Unknown op #{inst.op}\"\n        end\n"
  },
  {
    "language": "Python",
    "code": "    nminibatches: int                 number of training minibatches per update. For recurrent policies,\n                                      should be smaller or equal than number of environments run in parallel.\n\n    noptepochs: int                   number of training epochs per update\n\n"
  },
  {
    "language": "Python",
    "code": "        if weight_loss_dict is not None:\n            weight_decay = tf.multiply(tf.nn.l2_loss(w), weight_decay_fc, name='weight_decay_loss')\n            if weight_loss_dict is not None:\n                weight_loss_dict[w] = weight_decay_fc\n                weight_loss_dict[b] = 0.0\n"
  },
  {
    "language": "Python",
    "code": "        result = tf.reshape(result, a_t_shape)\n        if reduce_dim != outter_dim:\n            a_dims = list(range(len(a_shape)))\n            a_dims.remove(outter_dim)\n            a_dims.insert(reduce_dim, outter_dim)\n"
  },
  {
    "language": "Python",
    "code": "                print(('get factor for '+param.name))\n            factors = searchFactors(t, graph)\n            factorTensors[param] = factors\n\n        ########\n"
  },
  {
    "language": "Python",
    "code": "            statsUpdates[aKey] = tf.Print(statsUpdates[aKey],\n                                          [tf.convert_to_tensor('step:'),\n                                           self.global_step,\n                                           tf.convert_to_tensor(\n                                               'computing stats'),\n"
  },
  {
    "language": "Python",
    "code": "            stats_eigen_var = self.eigen_reverse_lookup[mark]\n            updateOps.append(\n                tf.assign(stats_eigen_var, tensor, use_locking=True))\n\n        with tf.control_dependencies(updateOps):\n"
  },
  {
    "language": "Python",
    "code": "            GRAD_TRANSPOSE = False\n\n            fpropFactoredFishers = self.stats[var]['fprop_concat_stats']\n            bpropFactoredFishers = self.stats[var]['bprop_concat_stats']\n\n"
  },
  {
    "language": "Python",
    "code": "                        grad = tf.reshape(grad, [-1, D])\n                    GRAD_RESHAPE = True\n                elif len(grad.get_shape()) == 1:\n                    # reshape bias or 1D parameters\n                    D = int(grad.get_shape()[0])\n"
  },
  {
    "language": "Python",
    "code": "\n                    grad = tf.expand_dims(grad, 0)\n                    GRAD_RESHAPE = True\n                else:\n                    # 2D parameters\n"
  },
  {
    "language": "Python",
    "code": "                                                begin=[0, 0],\n                                                size=[C_plus_one - 1, -1])\n                    grad_dict[var_assnBias] = grad_assnBias\n                    grad = grad_assnWeights\n\n"
  },
  {
    "language": "Python",
    "code": "\n                if not self._async:\n                    # synchronous eigen-decomp updates\n                    updateFactorOps = tf.cond(tf.logical_and(tf.equal(tf.mod(self.stats_step, self._kfac_update),\n                                                                      tf.convert_to_tensor(0)),\n"
  },
  {
    "language": "Python",
    "code": "        self.save = functools.partial(save_variables, sess=sess)\n        self.load = functools.partial(load_variables, sess=sess)\n        self.train_model = train_model\n        self.step_model = step_model\n        self.step = step_model.step\n"
  },
  {
    "language": "Python",
    "code": "\n        if save_interval and (update % save_interval == 0 or update == 1) and logger.get_dir():\n            savepath = osp.join(logger.get_dir(), 'checkpoint%.5i'%update)\n            print('Saving to', savepath)\n            model.save(savepath)\n"
  },
  {
    "language": "Python",
    "code": "        network = cnn_small(),\n        timesteps_per_batch=512,\n        max_kl=0.001,\n        cg_iters=10,\n        cg_damping=1e-3,\n"
  },
  {
    "language": "Python",
    "code": "    vpreds = np.zeros(horizon, 'float32')\n    news = np.zeros(horizon, 'int32')\n    acs = np.array([ac for _ in range(horizon)])\n    prevacs = acs.copy()\n\n"
  },
  {
    "language": "Python",
    "code": "    '''\n\n    if MPI is not None:\n        nworkers = MPI.COMM_WORLD.Get_size()\n        rank = MPI.COMM_WORLD.Get_rank()\n"
  },
  {
    "language": "Python",
    "code": "    # var_list = [v for v in all_var_list if v.name.split(\"/\")[1].startswith(\"pol\")]\n    # vf_var_list = [v for v in all_var_list if v.name.split(\"/\")[1].startswith(\"vf\")]\n    var_list = get_pi_trainable_variables(\"pi\")\n    vf_var_list = get_vf_trainable_variables(\"pi\")\n\n"
  },
  {
    "language": "Python",
    "code": "        else:\n            listoflrpairs = [lrlocal]\n\n        lens, rews = map(flatten_lists, zip(*listoflrpairs))\n        lenbuffer.extend(lens)\n"
  },
  {
    "language": "Python",
    "code": "\ndef get_variables(scope):\n    return tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, scope)\n\ndef get_trainable_variables(scope):\n"
  },
  {
    "language": "Python",
    "code": "    print(\"Reset!\")\n    while len(actions) < numItr:\n        obs = env.reset()\n        print(\"ITERATION NUMBER \", len(actions))\n        goToGoal(env, obs)\n"
  },
  {
    "language": "Python",
    "code": "            hidden (int): number of hidden units that should be used in hidden layers\n            layers (int): number of hidden layers\n        \"\"\"\n        self.o_tf = inputs_tf['o']\n        self.g_tf = inputs_tf['g']\n"
  },
  {
    "language": "Python",
    "code": "        \"\"\"\n        T = episode_batch['u'].shape[1]\n        rollout_batch_size = episode_batch['u'].shape[0]\n        batch_size = batch_size_in_transitions\n\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport subprocess\nimport sys\nimport importlib\nimport inspect\n"
  },
  {
    "language": "Python",
    "code": "            Q_lr (float): learning rate for the Q (critic) network\n            pi_lr (float): learning rate for the pi (actor) network\n            norm_eps (float): a small value used in the normalizer to avoid numerical instabilities\n            norm_clip (float): normalized inputs are clipped to be in [-norm_clip, norm_clip]\n            max_u (float): maximum action magnitude, i.e. actions are in [-max_u, max_u]\n"
  },
  {
    "language": "Python",
    "code": "                # No need to preprocess the o_2 and g_2 since this is only used for stats\n\n                self.o_stats.update(transitions['o'])\n                self.g_stats.update(transitions['g'])\n\n"
  },
  {
    "language": "Python",
    "code": "        self.pi_adam.update(pi_grad, self.pi_lr)\n\n    def sample_batch(self):\n        if self.bc_loss: #use demonstration buffer to sample as well if bc_loss flag is set TRUE\n            transitions = self.buffer.sample(self.batch_size - self.demo_batch_size)\n"
  },
  {
    "language": "Python",
    "code": "        mask = np.concatenate((np.zeros(self.batch_size - self.demo_batch_size), np.ones(self.demo_batch_size)), axis = 0)\n\n        # networks\n        with tf.variable_scope('main') as vs:\n            if reuse:\n"
  },
  {
    "language": "Python",
    "code": "                vs.reuse_variables()\n            self.main = self.create_actor_critic(batch_tf, net_type='main', **self.__dict__)\n            vs.reuse_variables()\n        with tf.variable_scope('target') as vs:\n            if reuse:\n"
  },
  {
    "language": "Python",
    "code": "        self.init_target_net_op = list(\n            map(lambda v: v[0].assign(v[1]), zip(self.target_vars, self.main_vars)))\n        self.update_target_net_op = list(\n            map(lambda v: v[0].assign(self.polyak * v[0] + (1. - self.polyak) * v[1]), zip(self.target_vars, self.main_vars)))\n\n"
  },
  {
    "language": "Python",
    "code": "\n        if rank == 0:\n            logger.dump_tabular()\n\n        # save the policy if it's better than the previous ones\n"
  },
  {
    "language": "Python",
    "code": "    for name in ['T', 'rollout_batch_size', 'gamma', 'noise_eps', 'random_eps']:\n        rollout_params[name] = params[name]\n        eval_params[name] = params[name]\n\n    eval_env = eval_env or env\n"
  },
  {
    "language": "Python",
    "code": "class ReplayBuffer:\n    def __init__(self, buffer_shapes, size_in_transitions, T, sample_transitions):\n        \"\"\"Creates a replay buffer.\n\n        Args:\n"
  },
  {
    "language": "Python",
    "code": "            ag_new = obs_dict_new['achieved_goal']\n            success = np.array([i.get('is_success', 0.0) for i in info])\n\n            if any(done):\n                # here we assume all environments are done is ~same number of steps, so we terminate rollouts whenever any of the envs returns done\n"
  },
  {
    "language": "Python",
    "code": "        raise NotImplementedError\n\nclass SeqWriter(object):\n    def writeseq(self, seq):\n        raise NotImplementedError\n"
  },
  {
    "language": "Python",
    "code": "\nclass HumanOutputFormat(KVWriter, SeqWriter):\n    def __init__(self, filename_or_file):\n        if isinstance(filename_or_file, str):\n            self.file = open(filename_or_file, 'wt')\n"
  },
  {
    "language": "Python",
    "code": "    if dir is None:\n        dir = os.getenv('OPENAI_LOGDIR')\n    if dir is None:\n        dir = osp.join(tempfile.gettempdir(),\n            datetime.datetime.now().strftime(\"openai-%Y-%m-%d-%H-%M-%S-%f\"))\n"
  },
  {
    "language": "Python",
    "code": "        yield\n    finally:\n        Logger.CURRENT.close()\n        Logger.CURRENT = prevlogger\n\n"
  },
  {
    "language": "Python",
    "code": "    else:\n        raise NotImplementedError(\"Expected tensorboard file or directory containing them. Got %s\"%path)\n    tag2pairs = defaultdict(list)\n    maxstep = 0\n    for fname in fnames:\n"
  },
  {
    "language": "Python",
    "code": "        alg_module = import_module('.'.join(['rl_' + 'algs', alg, submodule]))\n\n    return alg_module\n\n\n"
  },
  {
    "language": "Python",
    "code": "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport time\n"
  },
  {
    "language": "Python",
    "code": "    mean = np.mean(reps, axis=0)\n    dists = euclidean_distances(reps, mean)\n    outliers = []\n    for path, dist in zip(paths, dists):\n        dist = dist.take(0)\n"
  },
  {
    "language": "Python",
    "code": "\nprint('\\nFound {} bad of {} URLs'.format(len(badURLs), len(urls)))\nif len(badURLs) > 0:\n    print(\"\\n\\n=== Bad URLs.\\n\")\n    for url in badURLs:\n"
  },
  {
    "language": "Python",
    "code": "            f.write(\"\\n\")\n\n\ndef computeMeanMain(args):\n    align = openface.AlignDlib(args.dlibFacePredictor)\n"
  },
  {
    "language": "Python",
    "code": "        if alignedPoints:\n            facePoints.append(alignedPoints)\n\n    facePointsNp = np.array(facePoints)\n    mean = np.mean(facePointsNp, axis=0)\n"
  },
  {
    "language": "Python",
    "code": "        :type path: str\n        \"\"\"\n        assert cls is not None\n        assert name is not None\n        assert path is not None\n"
  },
  {
    "language": "Python",
    "code": "\nTEMPLATE = np.float32([\n    (0.0792396913815, 0.339223741112), (0.0829219487236, 0.456955367943),\n    (0.0967927109165, 0.575648016728), (0.122141515615, 0.691921601066),\n    (0.168687863544, 0.800341263616), (0.239789390707, 0.895732504778),\n"
  },
  {
    "language": "Python",
    "code": "    (0.252418718401, 0.331052263829), (0.298663015648, 0.302646354002),\n    (0.355749724218, 0.303020650651), (0.403718978315, 0.33867711083),\n    (0.352507175597, 0.349987615384), (0.296791759886, 0.350478978225),\n    (0.631326076346, 0.334136672344), (0.679073381078, 0.29645404267),\n    (0.73597236153, 0.294721285802), (0.782865376271, 0.321305281656),\n"
  },
  {
    "language": "Python",
    "code": "        \"\"\"\n        assert facePredictor is not None\n\n        self.detector = dlib.get_frontal_face_detector()\n        self.predictor = dlib.shape_predictor(facePredictor)\n"
  },
  {
    "language": "Python",
    "code": "        assert rgbImg is not None\n\n        try:\n            return self.detector(rgbImg, 1)\n        except Exception as e:\n"
  },
  {
    "language": "Python",
    "code": "\n        npLandmarks = np.float32(landmarks)\n        npLandmarkIndices = np.array(landmarkIndices)\n\n        H = cv2.getAffineTransform(npLandmarks[npLandmarkIndices],\n"
  },
  {
    "language": "Python",
    "code": "nn = lua.require('nn')\ndpnn = lua.require('dpnn')\nimage = lua.require('image')\n\n\n"
  },
  {
    "language": "Python",
    "code": "\n            start = time.time()\n            X_train = np.array(X_train)\n            cls.fit(X_train, y[train])\n            trainTimeSec = time.time() - start\n"
  },
  {
    "language": "Python",
    "code": "                X_test.append(net.forward(img))\n            y_predict = cls.predict(X_test)\n            predictTimeSec = time.time() - start\n            allPredictTimeSec.append(predictTimeSec / len(test))\n            y_predict = np.array(y_predict)\n"
  },
  {
    "language": "Python",
    "code": "    return df\n\n\ndef plotAccuracy(workDir, largeFont, eigenFacesDf, fishFacesDf, lbphFacesDf,\n                 openfaceCPUsvmDf, openfaceGPUsvmDf):\n"
  },
  {
    "language": "Python",
    "code": "\nimport matplotlib as mpl\nmpl.use('Agg')\nimport matplotlib.pyplot as plt\nplt.style.use('bmh')\n"
  },
  {
    "language": "Python",
    "code": "import shutil  # For copy images\nimport errno\nimport sys\nimport operator\n\n"
  },
  {
    "language": "Python",
    "code": "        # ref:\n        # http://scikit-learn.org/stable/auto_examples/classification/plot_classifier_comparison.html#example-classification-plot-classifier-comparison-py\n        elif clfChoice == 'RadialSvm':  # Radial Basis Function kernel\n            # works better with C = 1 and gamma = 2\n            clf = SVC(C=1, kernel='rbf', probability=True, gamma=2)\n"
  },
  {
    "language": "Python",
    "code": "                      learn_rate_decays=0.9,\n                      # a factor the initial learning rate will be multiplied by\n                      # after each iteration of the training\n                      epochs=300,  # no of iternation\n                      # dropouts = 0.25, # Express the percentage of nodes that\n"
  },
  {
    "language": "Python",
    "code": "    folderName = []\n\n    for folder in fullFaceDirectory:\n        try:\n            noOfImages.append(len(os.listdir(folder)))\n"
  },
  {
    "language": "Python",
    "code": "        src = os.path.join(lfwPath, folderName_sorted[i])\n        try:\n            destFolder = os.path.join(\n                destPath, 'test_unknown_raw', folderName_sorted[i])\n            shutil.copytree(src, destFolder)\n"
  },
  {
    "language": "Python",
    "code": "                if args.verbose:\n                    print('Directory not copied. Error: %s' % e)\n\n    if args.verbose:\n        print (\"Copying test dataset from lfw took {} seconds.\".format(time.time() - start))\n"
  },
  {
    "language": "Python",
    "code": "            destPath,\n            'train_known_aligned'))\n\n    if args.verbose:\n        print (\"Extracting features from aligned train data took {} seconds.\".format(time.time() - start))\n"
  },
  {
    "language": "Python",
    "code": "        '--networkModel',\n        type=str,\n        help=\"Path to Torch network model.\",\n        default=os.path.join(\n            openfaceModelDir,\n"
  },
  {
    "language": "Python",
    "code": "    trainParser.add_argument(\n        'workDir',\n        type=str,\n        help=\"The input work directory containing 'reps.csv' and 'labels.csv'. Obtained from aligning a directory with 'align-dlib' and getting the representations with 'batch-represent'.\")\n\n"
  },
  {
    "language": "Python",
    "code": "\n    if args.mode == 'train':\n        train(args)\n    elif args.mode == 'infer':\n        # infer(args)\n"
  },
  {
    "language": "Python",
    "code": "# Brandon Amos\n# 2016-07-29\n\nimport argparse\nimport base64\n"
  },
  {
    "language": "Python",
    "code": "\n    if not os.path.isfile(alignedImgPath):\n        bgr = cv2.imread(rawImgPath)\n        if bgr is None:\n            return\n"
  },
  {
    "language": "Python",
    "code": "        if len(trainDfs[-1]) != len(testDfs[-1]):\n            print(\"Error: Train/test dataframe shapes \"\n                  \"for '{}' don't match: {}, {}\".format(\n                      d, trainDfs[-1].shape, testDfs[-1].shape))\n            sys.exit(-1)\n"
  },
  {
    "language": "Python",
    "code": "import cv2\nimport os\nimport pickle\nimport sys\n\n"
  },
  {
    "language": "Python",
    "code": "from sklearn.preprocessing import LabelEncoder\nfrom sklearn.svm import SVC\nfrom sklearn.grid_search import GridSearchCV\nfrom sklearn.mixture import GMM\nfrom sklearn.tree import DecisionTreeClassifier\n"
  },
  {
    "language": "Python",
    "code": "    if args.ldaDim > 0:\n        clf_final = clf\n        clf = Pipeline([('lda', LDA(n_components=args.ldaDim)),\n                        ('clf', clf_final)])\n\n"
  },
  {
    "language": "Python",
    "code": "    clf.fit(embeddings, labelsNum)\n\n    fName = \"{}/classifier.pkl\".format(args.workDir)\n    print(\"Saving classifier to '{}'\".format(fName))\n    with open(fName, 'w') as f:\n"
  },
  {
    "language": "Python",
    "code": "import openface\n\nfileDir = os.path.dirname(os.path.realpath(__file__))\nmodelDir = os.path.join(fileDir, '..', 'models')\ndlibModelDir = os.path.join(modelDir, 'dlib')\n"
  },
  {
    "language": "Python",
    "code": "\n    alignedFaces = []\n    for box in bb:\n        alignedFaces.append(\n            align.align(\n"
  },
  {
    "language": "Python",
    "code": "        maxI = np.argmax(predictions)\n        # max2 = np.argsort(predictions)[-3:][::-1][1]\n        persons.append(le.inverse_transform(maxI))\n        # print (str(le.inverse_transform(max2)) + \": \"+str( predictions [max2]))\n        # ^ prints the second prediction\n"
  },
  {
    "language": "Python",
    "code": "                        help=\"Default image dimension.\", default=96)\n    parser.add_argument(\n        '--captureDevice',\n        type=int,\n        default=0,\n"
  },
  {
    "language": "Python",
    "code": "            pass\n\n        for i, c in enumerate(confidences):\n            if c <= args.threshold:  # 0.5 is kept as threshold for known face.\n                persons[i] = \"_unknown\"\n"
  },
  {
    "language": "Python",
    "code": "    return p\n\n\ndef projectC(x, y, z):\n    rho = np.sqrt(x**2 + y**2)\n"
  },
  {
    "language": "Python",
    "code": "def draw(pts=[], clrs=[], cSz=400):\n    def toFrame(x):\n        return tuple((cSz * x).astype(np.int32))\n\n    cFrame = np.full((cSz, cSz, 3), 255, dtype=np.uint8)\n"
  },
  {
    "language": "Python",
    "code": "        '--dlibFacePredictor',\n        type=str,\n        help=\"Path to dlib's face predictor.\",\n        default=os.path.join(\n            dlibModelDir,\n"
  },
  {
    "language": "Python",
    "code": "\n        def __init__(self, img, bb, rep):\n            self.t = dlib.correlation_tracker()\n            self.t.start_track(img, bb)\n            self.rep = rep\n"
  },
  {
    "language": "Python",
    "code": "            cv2.rectangle(frame, bl, tr, color=color_cv, thickness=3)\n\n            tracked = False\n            for i in xrange(len(trackers) - 1, -1, -1):\n                t = trackers[i]\n"
  },
  {
    "language": "Python",
    "code": "                t.t.update(frame)\n                if t.overlap(bb):\n                    rep = t.updateRep(rep)\n                    pts.append(rep)\n                    clrs.append(color_cv)\n"
  },
  {
    "language": "Python",
    "code": "                for rep in self.unknownImgs[:numUnknownAdd]:\n                    # print(rep)\n                    X.append(rep)\n                    y.append(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "        d = self.getData()\n        if d is None:\n            return\n        else:\n            (X, y) = d\n"
  },
  {
    "language": "Python",
    "code": "        plt.figure()\n        for c, i in zip(colors, yVals):\n            name = \"Unknown\" if i == -1 else people[i]\n            plt.scatter(X_r[y == i, 0], X_r[y == i, 1], c=c, label=name)\n            plt.legend()\n"
  },
  {
    "language": "Python",
    "code": "        for bb in bbs:\n            # print(len(bbs))\n            landmarks = align.findLandmarks(rgbFrame, bb)\n            alignedFace = align.align(args.imgDim, rgbFrame, bb,\n                                      landmarks=landmarks,\n"
  },
  {
    "language": "Python",
    "code": "                        \"identity\": identity,\n                        \"representation\": rep.tolist()\n                    }\n                    self.sendMessage(json.dumps(msg))\n                else:\n"
  },
  {
    "language": "Python",
    "code": "# OpenFace demo tests.\n#\n# Copyright 2015-2016 Carnegie Mellon University\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
  },
  {
    "language": "Python",
    "code": "import tempfile\nimport sys\n\nfrom subprocess import Popen, PIPE\n\n"
  },
  {
    "language": "Python",
    "code": "    cmd = [sys.executable, os.path.join(openfaceDir, 'demos', 'classifier.py'),\n           'infer', '--multi',\n           os.path.join(openfaceDir, 'models', 'openface',\n                        'celeb-classifier.nn4.small2.v1.pkl'),\n           os.path.join(exampleImages, 'longoria-cooper.jpg')]\n"
  },
  {
    "language": "Python",
    "code": "    print(out)\n    print(err)\n    m = re.search('Predict (.*) with (.*) confidence', out)\n    assert m is not None\n    assert m.group(1) == 'Adrien_Brody'\n"
  },
  {
    "language": "Python",
    "code": "    cmd = [sys.executable, os.path.join(openfaceDir, 'util', 'align-dlib.py'),\n           os.path.join(lfwSubset, 'raw'), 'align', 'outerEyesAndNose',\n           os.path.join(imgWorkDir, 'aligned')]\n    p = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)\n    (out, err) = p.communicate()\n"
  },
  {
    "language": "Python",
    "code": "# OpenFace batch-represent tests.\n#\n# Copyright 2015-2016 Carnegie Mellon University\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
  },
  {
    "language": "Python",
    "code": "    p = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)\n    (out, err) = p.communicate()\n    print(out)\n    print(err)\n    assert p.returncode == 0\n"
  },
  {
    "language": "Python",
    "code": "    print(\"brody2:\", brody2)\n\n    cosDist = scipy.spatial.distance.cosine(brody1, brody2)\n    print('cosDist:', cosDist)\n    assert np.isclose(cosDist, 0.1568, atol=1e-4)\n"
  },
  {
    "language": "Python",
    "code": "\n  def getJSCode(self):\n    map = {\"paths\": self.paths, \"width\": self.width, \"height\": self.height, \"insets\": self.insets, \"projection\": self.projection}\n    header = \"/** JQVMap \" + self.projection['type'] + \" map for \" + self.name + \"  */\"\n    js = \"jQuery.fn.vectorMap('addMap', '\" + self.name + \"',\" + json.dumps(map) + \");\"\n"
  },
  {
    "language": "Python",
    "code": "    if not isPivot:\n      simpleRing = shapely.geometry.LineString(coords).simplify(self.tolerance)\n      if len(simpleRing.coords) <= 2:\n        return None\n      else:\n"
  },
  {
    "language": "Python",
    "code": "      new_geometries.append( Geometry(shapely.ops.cascaded_union( geometries ), rule['fields']) )\n    data_source.fields = config['fields']\n    data_source.geometries = new_geometries\n\n  def join_data(self, config, data_source):\n"
  },
  {
    "language": "Python",
    "code": "    for geometry in data_source.geometries:\n      if geometry.properties[config['on']] in data:\n        geometry.properties.update( data[geometry.properties[config['on']]] )\n    field_names = map(lambda f: f['name'], data_source.fields)\n    data_source.fields = data_source.fields + filter(lambda f: f['name'] not in field_names, config['fields'])\n"
  },
  {
    "language": "PowerShell",
    "code": "},\n\n# Adds an XmlElement to an XmlNode\n# Returns the new Element\nfunction New-XmlElement\n"
  },
  {
    "language": "PowerShell",
    "code": "    if($XmlNsManager)\n    {\n        return $XmlDoc.SelectSingleNode($XPath,$XmlNsManager)\n    }\n    else\n"
  },
  {
    "language": "PowerShell",
    "code": "\n<#\n  Converts SID to NT Account Name\n#>\nfunction ConvertTo-NtAccount\n"
  },
  {
    "language": "PowerShell",
    "code": "    [switch] $EnablePSRemoting,\n\n    [Parameter()]\n    [switch] $Preview\n)\n"
  },
  {
    "language": "PowerShell",
    "code": "    }\n    else\n    {\n        Add-Type -AssemblyName System.IO.Compression.FileSystem\n        $resolvedPath = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)\n"
  },
  {
    "language": "PowerShell",
    "code": "        try {\n            Invoke-WebRequest -Uri $downloadURL -OutFile $packagePath\n        } finally {\n            if (!$PSVersionTable.ContainsKey('PSEdition') -or $PSVersionTable.PSEdition -eq \"Desktop\") {\n                $ProgressPreference = $oldProgressPreference\n"
  },
  {
    "language": "PowerShell",
    "code": "                } else {\n                    Start-Process $packagePath -Wait\n                }\n            } else {\n                Expand-ArchiveInternal -Path $packagePath -DestinationPath $contentPath\n"
  },
  {
    "language": "PowerShell",
    "code": "        } finally {\n            if (!$PSVersionTable.ContainsKey('PSEdition') -or $PSVersionTable.PSEdition -eq \"Desktop\") {\n                $ProgressPreference = $oldProgressPreference\n            }\n        }\n"
  },
  {
    "language": "PowerShell",
    "code": "        if ($runningProcessName -ne 'pwsh') {\n            $env:Path = $Destination + [System.IO.Path]::PathSeparator + $env:Path\n        }\n    }\n\n"
  },
  {
    "language": "PowerShell",
    "code": "            $this.Version = $v\n            $this.NewVersion = $nv\n            $this.Path = $p\n        }\n    }\n"
  },
  {
    "language": "PowerShell",
    "code": "        \"Microsoft.PowerShell.MarkdownRender\"\n    )\n\n    $packages = [System.Collections.Generic.Dictionary[[string], [PkgVer[]] ]]::new()\n\n"
  },
  {
    "language": "PowerShell",
    "code": "        [System.Xml.XmlElement]$Element\n    )\n\n    $attribute = $signingXml.CreateAttribute($Name)\n    $attribute.Value = $value\n"
  },
  {
    "language": "PowerShell",
    "code": "\n[xml]$signingXml = Get-Content (Join-Path -Path $PSScriptRoot -ChildPath 'packagesigning.xml')\n$job = $signingXml.SignConfigXML.job\n\nforeach($file in $AuthenticodeDualFiles)\n"
  },
  {
    "language": "PowerShell",
    "code": "    New-FileElement -File $file -SignType 'MacDeveloper' -XmlDoc $signingXml -Job $job\n}\n\nforeach ($file in $LinuxFiles) {\n    New-FileElement -File $file -SignType 'LinuxPack' -XmlDoc $signingXml -Job $job\n"
  },
  {
    "language": "PowerShell",
    "code": "    param(\n        [Parameter(Mandatory = $true)] [string] $AzDevOpsFeedUserName,\n        [Parameter(Mandatory = $true)] [string] $AzDevOpsPAT,\n        [Parameter(Mandatory = $true)] [string] $Destination\n    )\n"
  },
  {
    "language": "PowerShell",
    "code": "    }\n\n    Process {\n        $allPackages += $packages\n    }\n"
  },
  {
    "language": "PowerShell",
    "code": "            \"tar\" { Start-PSPackage -Type tar @releaseTagParam }\n        }\n\n        if ($LTS) {\n            Start-PSPackage @releaseTagParam -LTS\n"
  },
  {
    "language": "PowerShell",
    "code": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n[cmdletbinding(DefaultParameterSetName='Build')]\nparam(\n    [Parameter(ParameterSetName='packageSigned')]\n"
  },
  {
    "language": "PowerShell",
    "code": "        Import-Module \"$location/vstsBuild\" -Force\n        Import-Module \"$location/dockerBasedBuild\" -Force\n        Clear-VstsTaskState\n\n        $buildParameters = @{\n"
  },
  {
    "language": "PowerShell",
    "code": "    [string] $fork = 'powershell',\n\n    [string] $branch = 'master',\n\n    [string] $location = \"$PWD\\powershell\",\n"
  },
  {
    "language": "PowerShell",
    "code": "    }\n\n    if (!$ComponentRegistration.IsPresent -and !$Symbols.IsPresent -and $Runtime -notmatch 'arm' -and $Runtime -notlike 'fxdependent*')\n    {\n        Write-Verbose \"Starting powershell packaging(msi)...\" -Verbose\n"
  },
  {
    "language": "PowerShell",
    "code": "'@\n\n    UbuntuAfterRemoveScript = @'\n#!/bin/sh\nset -e\n"
  },
  {
    "language": "PowerShell",
    "code": "    <key>CFBundleInfoDictionaryVersion</key>\n    <string>6.0</string>\n    <key>CFBundleName</key>\n    <string>PowerShell</string>\n    <key>CFBundlePackageType</key>\n"
  },
  {
    "language": "PowerShell",
    "code": "    <add key=\"powershell-core\" value=\"https://powershell.myget.org/F/powershell-core/api/v3/index.json\" />\n  </packageSources>\n</configuration>\n'@\n\n"
  },
  {
    "language": "PowerShell",
    "code": "</package>\n'@\n\n    GlobalToolSettingsFile = @'\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
  },
  {
    "language": "PowerShell",
    "code": "\n        [Parameter(ParameterSetName = \"ReleaseTag\")]\n        [ValidatePattern(\"^v\\d+\\.\\d+\\.\\d+(-\\w+(\\.\\d+)?)?$\")]\n        [ValidateNotNullOrEmpty()]\n        [string]$ReleaseTag,\n"
  },
  {
    "language": "PowerShell",
    "code": "\n        $PSModuleRestoreCorrect = $false\n\n        # Require PSModuleRestore for packaging without symbols\n        # But Disallow it when packaging with symbols\n"
  },
  {
    "language": "PowerShell",
    "code": "            } elseif ($Type -eq 'fxdependent-win-desktop') {\n                $params += '-Runtime', 'fxdependent-win-desktop'\n            } else {\n                $params += '-Runtime', $Runtime\n            }\n"
  },
  {
    "language": "PowerShell",
    "code": "                $Arguments = @{\n                    PackageNameSuffix = $NameSuffix\n                    PackageSourcePath = $Source\n                    PackageVersion = $Version\n                    Force = $Force\n"
  },
  {
    "language": "PowerShell",
    "code": "            }\n\n            { $_ -like \"fxdependent*\" } {\n                ## Remove PDBs from package to reduce size.\n                if(-not $IncludeSymbols.IsPresent) {\n"
  },
  {
    "language": "PowerShell",
    "code": "            try {\n                Push-Location -Path $Staging\n                tar $options $packagePath .\n            } finally {\n                Pop-Location\n"
  },
  {
    "language": "PowerShell",
    "code": "            }\n\n            if (Test-Path -Path $packagePath) {\n                Write-Log \"You can find the tarball package at $packagePath\"\n                return (Get-Item $packagePath)\n"
  },
  {
    "language": "PowerShell",
    "code": "{\n    $tempPath = [System.IO.Path]::GetTempPath()\n\n    $tempFolder = Join-Path -Path $tempPath -ChildPath ([System.IO.Path]::GetRandomFileName())\n    if (!(Test-Path -Path $tempFolder))\n"
  },
  {
    "language": "PowerShell",
    "code": "    )\n\n    $psModulePath = Split-Path -Path $PSScriptRoot\n    # Expand signed build\n    $buildPath = Join-Path -Path $psModulePath -ChildPath 'ExpandedBuild'\n"
  },
  {
    "language": "PowerShell",
    "code": "\n        # Setup staging directory so we don't change the original source directory\n        $Staging = \"$PSScriptRoot/staging\"\n        if ($PSCmdlet.ShouldProcess(\"Create staging folder\")) {\n            New-StagingFolder -StagingPath $Staging -PackageSourcePath $PackageSourcePath\n"
  },
  {
    "language": "PowerShell",
    "code": "\n        $Arguments = Get-FpmArguments `\n            -Name $Name `\n            -Version $packageVersion `\n            -Iteration $Iteration `\n"
  },
  {
    "language": "PowerShell",
    "code": "        [string]\n        $LinkDestination,\n        [Parameter(Mandatory)]\n        [string]\n        $linkTarget\n"
  },
  {
    "language": "PowerShell",
    "code": "    )\n\n    $Arguments = @(\n        \"--force\", \"--verbose\",\n        \"--name\", $Name,\n"
  },
  {
    "language": "PowerShell",
    "code": "                \"libicu\"\n            )\n        } elseif ($Environment.IsSUSEFamily) {\n            $Dependencies = @(\n                \"libopenssl1_0_0\",\n"
  },
  {
    "language": "PowerShell",
    "code": "                \"libicu\"\n            )\n        }\n\n        return $Dependencies\n"
  },
  {
    "language": "PowerShell",
    "code": "    return $appsfolder\n}\n\nfunction Get-PwshExecutablePath\n{\n"
  },
  {
    "language": "PowerShell",
    "code": "# Function to create a zip file of PDB\nfunction New-PdbZipPackage\n{\n    [CmdletBinding(SupportsShouldProcess=$true)]\n    param (\n"
  },
  {
    "language": "PowerShell",
    "code": "\n.PARAMETER PackageVersion\nVersion of the created package.\n\n.PARAMETER WinFxdBinPath\n"
  },
  {
    "language": "PowerShell",
    "code": "                Copy-Item -Path $dotnetRefAsmFolder -Destination $contentFolder -Recurse -Force\n                Write-Log \"Copied the reference assembly folder to contentFiles for the SDK package\"\n\n                # Copy the built-in module folders to the NuGet package, so 'dotnet publish' can deploy those modules to the $pshome module path.\n                # This is for enabling applications that hosts PowerShell to ship the built-in modules.\n"
  },
  {
    "language": "PowerShell",
    "code": "                    $refDoc = Join-Path -Path $refBinPath -ChildPath ([System.IO.Path]::ChangeExtension($asmFileName, \"xml\"))\n                    Copy-Item $refFile, $refDoc -Destination $refNugetPath -Force\n                    Write-Log \"Copied file '$refFile' and '$refDoc' to '$refNugetPath'\"\n                }\n            }\n"
  },
  {
    "language": "PowerShell",
    "code": "        if ($package.Version -notmatch '\\*' -and $package.Include)\n        {\n            # Get the name of the package\n            [PSCustomObject] @{\n                Name = $package.Include\n"
  },
  {
    "language": "PowerShell",
    "code": "            throw \"$assemblyName.xml was not found at: $Linux64BinPath\"\n        }\n\n        $genAPIArgs = \"$linuxDllPath\",\"-libPath:$Linux64BinPath,$Linux64BinPath\\ref\"\n        Write-Log \"GenAPI cmd: $genAPIExe $genAPIArgs\"\n"
  },
  {
    "language": "PowerShell",
    "code": "            Pattern = \"[System.Runtime.CompilerServices.NullableAttribute((byte)2)]\"\n            Replacement = \"/* [System.Runtime.CompilerServices.NullableAttribute((byte)2)] */\"\n        },\n        @{\n            ApplyTo = @(\"System.Management.Automation\", \"Microsoft.PowerShell.ConsoleHost\")\n"
  },
  {
    "language": "PowerShell",
    "code": "    if ($null -ne $reader)\n    {\n        $reader.Close()\n    }\n\n"
  },
  {
    "language": "PowerShell",
    "code": "        [string] $PackageRuntime,\n\n        # Configuration of the Product\n        [Parameter(Mandatory = $true)]\n        [ValidateNotNullOrEmpty()]\n"
  },
  {
    "language": "PowerShell",
    "code": "            $tokenParts = $token.Split('-')\n        }\n        elseif ($inIdentifier) {\n            $tokenParts = @($token)\n        }\n"
  },
  {
    "language": "PowerShell",
    "code": "    if ($identifierPortionTokens.Count -gt 0) {\n        $packageSemanticVersion += '-' + ($identifierPortionTokens -join '-')\n    }\n\n    $packageSemanticVersion\n"
  },
  {
    "language": "PowerShell",
    "code": "    # add all the file components to the patch\n    foreach($component in $components)\n    {\n        $id = $component.Id\n        $componentRef = $patchTemplateXml.CreateElement('ComponentRef','http://schemas.microsoft.com/wix/2006/wi')\n"
  },
  {
    "language": "PowerShell",
    "code": "    }\n\n    $displayName = $productName\n\n    if ($ProductSemanticVersion.Contains('-')) {\n"
  },
  {
    "language": "PowerShell",
    "code": "    # cp-459155 is 'CN=Microsoft Windows Store Publisher (Store EKU), O=Microsoft Corporation, L=Redmond, S=Washington, C=US'\n    # authenticodeFormer is 'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'\n    $releasePublisher = 'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'\n\n    $appxManifest = Get-Content \"$RepoRoot\\assets\\AppxManifest.xml\" -Raw\n"
  },
  {
    "language": "PowerShell",
    "code": "    $assets | ForEach-Object {\n        if ($isPreview) {\n            Copy-Item -Path \"$RepoRoot\\assets\\$_-Preview.png\" -Destination \"$ProductSourcePath\\assets\\$_.png\"\n        }\n        else {\n"
  },
  {
    "language": "PowerShell",
    "code": "        [ValidateNotNullOrEmpty()]\n        [ValidateScript( {Test-Path $_})]\n        [string] $FilesWxsPath = \"$RepoRoot\\assets\\wix\\Files.wxs\",\n\n        # File describing the MSI file components generated by heat\n"
  },
  {
    "language": "PowerShell",
    "code": "},\n\n# Get the ComponentGroup node in the files.wxs Xml Doc\nfunction Get-ComponentGroupNode\n{\n"
  },
  {
    "language": "PowerShell",
    "code": "        if ($packageBuildTokens)\n        {\n            if($packageBuildTokens.length -gt 4)\n            {\n                # MSIX will fail if it is more characters\n"
  },
  {
    "language": "PowerShell",
    "code": "    {\n        Write-Verbose \"passing through docker result$($result.length)...\" -Verbose\n        return $result\n    }\n    elseif($dockerExitCode -ne 0 -and $FailureAction -eq 'error')\n"
  },
  {
    "language": "PowerShell",
    "code": "},\n\n# This function is used for basic validation of PS packages during a release;\n# During the process Docker files are filled out and executed with Docker build;\n# During the build PS packages are downloaded onto Docker containers, installed and selected Pester tests from PowerShell Github repo are executed.\n"
  },
  {
    "language": "PowerShell",
    "code": "    }\n\n    Write-Verbose \"Using configuration:\" -Verbose\n    Write-Verbose ($map | Format-List | Out-String) -Verbose\n\n"
  },
  {
    "language": "PowerShell",
    "code": "#list recent journal events\nWrite-Host -Foreground Blue \"Get recent SystemD journal messages\"\nGet-SystemDJournal -args \"-xe\" |Out-Host\n\n#Drill into SystemD unit messages\n"
  },
  {
    "language": "PowerShell",
    "code": "        [Alias(\"h\")][Parameter(Position=2)][String[]] $Hour = \"*\",\n        [Alias(\"dm\")][Parameter(Position=3)][String[]] $DayOfMonth = \"*\",\n        [Alias(\"mo\")][Parameter(Position=4)][String[]] $Month = \"*\",\n        [Alias(\"dw\")][Parameter(Position=5)][String[]] $DayOfWeek = \"*\",\n        [Alias(\"c\")][Parameter(Mandatory=$true,Position=6)][String] $Command\n"
  },
  {
    "language": "PowerShell",
    "code": "@{\n\n# Script module or binary module file associated with this manifest.\nRootModule = 'CronTab.psm1'\n\n"
  },
  {
    "language": "PowerShell",
    "code": "        ApacheVirtualHost([string]$ServerName, [string]$DocumentRoot, [string[]]$ServerAliases, [string]$ServerAdmin, [string]$CustomLogPath, [string]$ErrorLogPath, [string]$VirtualHostIPAddress, [int]$VirtualHostPort, [string]$ConfigurationFile){\n            $this.ServerName = $ServerName\n            $this.DocumentRoot = $DocumentRoot\n            $this.ServerAliases = $ServerAliases\n            $this.ServerAdmin = $ServerAdmin\n"
  },
  {
    "language": "PowerShell",
    "code": "            if (!(Test-Path $VHostsDirectory)){\n                Write-Error \"Specified virtual hosts directory does not exist: $VHostsDirectory\"\n                exit 1\n            }\n            $VHostIPAddress = $this.VirtualHostIPAddress\n"
  },
  {
    "language": "PowerShell",
    "code": "                \"*ErrorLog*\"{$ErrorLogPath = $confline.split()[1].trim()}\n                \"*ServerAdmin*\"{$ServerAdmin = $confline.split()[1].trim()}\n               #Todo: Server aliases\n            }\n            if($confline -like \"*</VirtualHost>*\"){\n"
  },
  {
    "language": "PowerShell",
    "code": "            $ConfFile = $Matches.ConfFile.trim().split(\":\")[0].Replace('(','')\n        }else{\n            if ($line.trim().split()[0] -like \"*:*\"){\n                $ListenAddress = $line.trim().split()[0]\n            }elseif($line -like \"*.conf*\"){\n"
  },
  {
    "language": "PowerShell",
    "code": "        if ($null -ne $ServerName){\n            $vHost = [ApacheVirtualHost]::New($ServerName, $ConfFile, $ListenAddress.Split(\":\")[0],$ListenAddress.Split(\":\")[1])\n            $ExtProps = GetVHostProps $ConfFile $ServerName $ListenAddress\n            $vHost.DocumentRoot = $ExtProps.DocumentRoot\n            #Custom log requires additional handling. NYI\n"
  },
  {
    "language": "PowerShell",
    "code": "        }else{\n                & $global:sudocmd $cmd  -k restart\n        }\n\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "Activate.ps1 -Verbose\nActivates the Python virtual environment that contains the Activate.ps1 script,\nand shows extra information about the activation as it executes.\n\n.Example\n"
  },
  {
    "language": "PowerShell",
    "code": "Param(\n    [Parameter(Mandatory = $false)]\n    [String]\n    $VenvDir,\n    [Parameter(Mandatory = $false)]\n"
  },
  {
    "language": "PowerShell",
    "code": "        Write-Verbose \"  Got leaf-name of $VenvDir='$(Split-Path -Path $venvDir -Leaf)'\"\n        $Prompt = Split-Path -Path $venvDir -Leaf\n    }\n}\n\n"
  },
  {
    "language": "PowerShell",
    "code": "\nif (-not $Env:VIRTUAL_ENV_DISABLE_PROMPT) {\n\n    Write-Verbose \"Setting prompt to '$Prompt'\"\n\n"
  },
  {
    "language": "PowerShell",
    "code": "    $env:VIRTUAL_ENV_PROMPT = $Prompt\n}\n\n# Clear PYTHONHOME\nif (Test-Path -Path Env:PYTHONHOME) {\n"
  },
  {
    "language": "PowerShell",
    "code": "param(\n    [Parameter(Mandatory=$true)][string]$layout,\n    [Parameter(Mandatory=$true)][string]$msix,\n    [switch]$sign,\n    [string]$description,\n"
  },
  {
    "language": "PowerShell",
    "code": "if (-not $skiphash) {\n    # Display MD5 hash and size of each downloadable file\n    pushd $build\n    $files = gci python*.chm, *\\*.exe, *\\*.zip\n    if ($doc_htmlhelp) {\n"
  },
  {
    "language": "PowerShell",
    "code": "        cd $doc_htmlhelp\n        $files = ($files, (gci python*.chm)) | %{ $_ }\n    }\n    if ($embed) {\n        cd $embed\n"
  },
  {
    "language": "PowerShell",
    "code": "function Find-Tool {\n    param([string]$toolname)\n\n    $kitroot = (gp 'HKLM:\\SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\\').KitsRoot10\n    $tool = (gci -r \"$kitroot\\Bin\\*\\x64\\$toolname\" | sort FullName -Desc | select -First 1)\n"
  },
  {
    "language": "PowerShell",
    "code": "},\n\nSet-Alias SignTool (Find-Tool \"signtool.exe\") -Scope Script\n\nfunction Sign-File {\n"
  },
  {
    "language": "PowerShell",
    "code": "\n    # Where to place intermediate build files:\n    $IntermediateDir = \"$PSScriptRoot\\..\\VisualC-WinRT\\obj\\$SDLProjectName-$(Get-SDL-WinRT-Variant-Name $PlatformToolset)\\$Platform\"\n\n    #\n"
  },
  {
    "language": "PowerShell",
    "code": "#if ( ! (Build-SDL-WinRT-Variant \"SDL\" \"v110\" \"ARM\"))        { $DidAnyDLLBuildFail = $true }\n#if ( ! (Build-SDL-WinRT-Variant \"SDL\" \"v110\" \"Win32\"))      { $DidAnyDLLBuildFail = $true }\n#if ( ! (Build-SDL-WinRT-Variant \"SDL\" \"v110\" \"x64\"))        { $DidAnyDLLBuildFail = $true }\n\n# Build for Windows 8.1 and Windows RT 8.1, via VC++ 2013:\n"
  },
  {
    "language": "PowerShell",
    "code": "$kServiceBinaryPath = Resolve-Path ([System.IO.Path]::Combine($PSScriptRoot, '..', 'osquery', 'osqueryd', 'osqueryd.exe'))\n\n# Adapted from http://www.jonathanmedd.net/2014/01/testing-for-admin-privileges-in-powershell.html\nfunction Test-IsAdmin {\n  return ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(\n"
  },
  {
    "language": "PowerShell",
    "code": "      Write-Host \"Failed to install the Windows Event Log manifest.\" -foregroundcolor Yellow\n    }\n  } elseif ($uninstallWelManifest) {\n    if (-not (Test-Path $welManifestPath)) {\n      Write-Host \"[-] Failed to find the osquery Event Log manifest file! ($welManifestPath)\" -ForegroundColor Red\n"
  },
  {
    "language": "PowerShell",
    "code": "      Manufacturer='osquery'\n      InstallerVersion='200'\n      Platform='x64'\n      Languages='1033'\n      Compressed='yes'\n"
  },
  {
    "language": "PowerShell",
    "code": "# root directory of this source tree.</copyright>\n    <projectUrl>https://osquery.io</projectUrl>\n    <iconUrl>https://github.com/osquery/osquery/blob/master/tools/osquery.ico</iconUrl>\n    <licenseUrl>https://github.com/osquery/osquery/blob/master/LICENSE</licenseUrl>\n    <requireLicenseAcceptance>false</requireLicenseAcceptance>\n"
  },
  {
    "language": "PowerShell",
    "code": "  exit 0\n}\n\nfunction Main() {\n\n"
  },
  {
    "language": "PowerShell",
    "code": "\n    $usersSid = New-Object System.Security.Principal.SecurityIdentifier('S-1-5-32-545')\n    $usersGroup = $usersSid.Translate([System.Security.Principal.NTAccount])\n\n    $permGroups = @($systemUser, $adminsGroup, $usersGroup)\n"
  },
  {
    "language": "PowerShell",
    "code": "        $grantedPerm = 'FullControl'\n      }\n      $permission = $accnt.Value, $grantedPerm, $inheritanceFlag, $propagationFlag, $permType\n      $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission\n      $acl.SetAccessRule($accessRule)\n"
  },
  {
    "language": "PowerShell",
    "code": "  $vswhere = (Get-Command 'vswhere').Source\n  $vswhereArgs = @('-latest', '-legacy')\n  $vswhereOut = (Start-OsqueryProcess $vswhere $vswhereArgs).stdout\n  $vsinfo = New-Object -TypeName psobject\n  $vsinfo | Add-Member -MemberType NoteProperty -Name version -Value ''\n"
  },
  {
    "language": "PowerShell",
    "code": "\n. (Join-Path \"$PSScriptRoot\" \"osquery_utils.ps1\")\n\n# Remove the osquery path from the System PATH variable. Note: Here\n# we don't make use of our local vars, as Regex requires escaping the '\\'\n"
  },
  {
    "language": "PowerShell",
    "code": "\n# Ensure the service is stopped and processes are not running if exists.\n$svc = Get-WmiObject -ClassName Win32_Service -Filter \"Name='osqueryd'\"\nif ($svc -and $svc.State -eq 'Running') {\n  Stop-Service $serviceName\n"
  },
  {
    "language": "PowerShell",
    "code": "\n# avoid \"Unknown error on a send\" in Invoke-WebRequest\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n\n$InstallScriptUrl = 'https://dot.net/v1/dotnet-install.ps1'\n"
  },
  {
    "language": "PowerShell",
    "code": "},\n\nif($RunAllExe -and $Run -ne \"\") {\n    Write-Error \"$RunAllExe and $Run are not compatible\"\n    exit 1\n"
  },
  {
    "language": "PowerShell",
    "code": "    MakeAndAdd -token $t -HashTable $TestExes\n  }\n\n  if($TestExes.Count -lt 1) {\n     Write-Error \"Failed to extract tests from $Run\"\n"
  },
  {
    "language": "PowerShell",
    "code": "  $search_path = -join ($BinariesFolder, $pattern)\n  Write-Host \"Binaries Search Path: $search_path\"\n\n  $DiscoveredExe = @()\n  dir -Path $search_path | ForEach-Object {\n"
  },
  {
    "language": "PowerShell",
    "code": "        # Remove cached job info from the system\n        # Should be no output\n        Receive-Job -Job $completed | Out-Null\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "#REQUIRES -Version 2.0\n<#\n.SYNOPSIS\n    Common base of ArangoDB Windows build scripts.\n.DESCRIPTION\n"
  },
  {
    "language": "PowerShell",
    "code": "$bsversion = $bsversionParts[0]\n\nif ($bsversionParts.Length -gt 1) {\n  $bsversion += '-' + $bsversionParts[1].replace('.', '').replace('-', '_') # strip out invalid chars from the PreRelease part\n}\n"
  },
  {
    "language": "HTML",
    "code": "                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Project Edit</p>\n                </a>\n              </li>\n              <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "            </a>\n          </li>\n          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n              <i class=\"nav-icon fas fa-circle\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "                <span class=\"info-box-number\">93,139</span>\n              </div>\n              <!-- /.info-box-content -->\n            </div>\n            <!-- /.info-box -->\n"
  },
  {
    "language": "HTML",
    "code": "          </div>\n          <!-- /.col -->\n        </div>\n        <!-- /.row -->\n\n"
  },
  {
    "language": "HTML",
    "code": "                  <button type=\"button\" class=\"btn btn-tool\" data-card-widget=\"maximize\"><i class=\"fas fa-expand\"></i>\n                  </button>\n                </div>\n                <!-- /.card-tools -->\n              </div>\n"
  },
  {
    "language": "HTML",
    "code": "              <!-- /.card-header -->\n              <div class=\"card-body\">\n                The body of the card\n              </div>\n              <!-- /.card-body -->\n"
  },
  {
    "language": "HTML",
    "code": "                <div class=\"card-tools\">\n                  <button type=\"button\" class=\"btn btn-tool\" data-card-widget=\"collapse\">\n                    <i class=\"fas fa-minus\"></i>\n                  </button>\n                </div>\n"
  },
  {
    "language": "HTML",
    "code": "              </div>\n              <!-- /.card-body -->\n            </div>\n            <!-- /.card -->\n          </div>\n"
  },
  {
    "language": "HTML",
    "code": "              <!-- /.card-header -->\n              <div class=\"card-body\">\n                The body of the card\n              </div>\n              <!-- /.card-body -->\n"
  },
  {
    "language": "HTML",
    "code": "              </div>\n              <!-- /.card-header -->\n              <div class=\"card-body\">\n                The body of the card\n              </div>\n"
  },
  {
    "language": "HTML",
    "code": "              <!-- /.card-header -->\n              <div class=\"card-body\">\n                <!-- Conversations are loaded here -->\n                <div class=\"direct-chat-messages\">\n                  <!-- Message. Default to the left -->\n"
  },
  {
    "language": "HTML",
    "code": "                      <span class=\"direct-chat-name float-right\">Sarah Bullock</span>\n                      <span class=\"direct-chat-timestamp float-left\">23 Jan 2:05 pm</span>\n                    </div>\n                    <!-- /.direct-chat-infos -->\n                    <img class=\"direct-chat-img\" src=\"../dist/img/user3-128x128.jpg\" alt=\"Message User Image\">\n"
  },
  {
    "language": "HTML",
    "code": "                    </div>\n                    <!-- /.direct-chat-text -->\n                  </div>\n                  <!-- /.direct-chat-msg -->\n                </div>\n"
  },
  {
    "language": "HTML",
    "code": "              </div>\n              <!-- /.card-header -->\n              <div class=\"card-body\">\n                <!-- Conversations are loaded here -->\n                <div class=\"direct-chat-messages\">\n"
  },
  {
    "language": "HTML",
    "code": "                  </div>\n                  <!-- /.direct-chat-msg -->\n\n                  <!-- Message to the right -->\n                  <div class=\"direct-chat-msg right\">\n"
  },
  {
    "language": "HTML",
    "code": "                  <!-- /.contatcts-list -->\n                </div>\n                <!-- /.direct-chat-pane -->\n              </div>\n              <!-- /.card-body -->\n"
  },
  {
    "language": "HTML",
    "code": "\n          <div class=\"col-md-3\">\n            <!-- DIRECT CHAT WARNING -->\n            <div class=\"card card-warning direct-chat direct-chat-warning shadow\">\n              <div class=\"card-header\">\n"
  },
  {
    "language": "HTML",
    "code": "                <form action=\"#\" method=\"post\">\n                  <img class=\"img-fluid img-circle img-sm\" src=\"../dist/img/user4-128x128.jpg\" alt=\"Alt Text\">\n                  <!-- .img-push is used to add margin to elements next to floating images -->\n                  <div class=\"img-push\">\n                    <input type=\"text\" class=\"form-control form-control-sm\" placeholder=\"Press enter to post comment\">\n"
  },
  {
    "language": "HTML",
    "code": "                  <div class=\"card-img-overlay d-flex flex-column justify-content-end\">\n                    <h5 class=\"card-title text-primary text-white\">Card Title</h5>\n                    <p class=\"card-text text-white pb-2 pt-1\">Lorem ipsum dolor sit amet, consectetur adipisicing elit sed do eiusmod tempor.</p>\n                    <a href=\"#\" class=\"text-white\">Last update 2 mins ago</a>\n                  </div>\n"
  },
  {
    "language": "HTML",
    "code": "                      do eiusmod tempor. </p>\n                    <a href=\"#\" class=\"text-primary\">Last update 3 days ago</a>\n                  </div>\n                </div>\n              </div>\n"
  },
  {
    "language": "HTML",
    "code": "              <div class=\"media-body\">\n                <h3 class=\"dropdown-item-title\">\n                  Nora Silvester\n                  <span class=\"float-right text-sm text-warning\"><i class=\"fas fa-star\"></i></span>\n                </h3>\n"
  },
  {
    "language": "HTML",
    "code": "            <i class=\"fas fa-users mr-2\"></i> 8 friend requests\n            <span class=\"float-right text-muted text-sm\">12 hours</span>\n          </a>\n          <div class=\"dropdown-divider\"></div>\n          <a href=\"#\" class=\"dropdown-item\">\n"
  },
  {
    "language": "HTML",
    "code": "        </div>\n      </li>\n      <li class=\"nav-item\">\n        <a class=\"nav-link\" data-widget=\"fullscreen\" href=\"#\" role=\"button\">\n          <i class=\"fas fa-expand-arrows-alt\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "        </a>\n      </li>\n    </ul>\n  </nav>\n  <!-- /.navbar -->\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"../UI/modals.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Modals & Alerts</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "                  <p>Ribbons</p>\n                </a>\n              </li>\n            </ul>\n          </li>\n"
  },
  {
    "language": "HTML",
    "code": "                  <p>Validation</p>\n                </a>\n              </li>\n            </ul>\n          </li>\n"
  },
  {
    "language": "HTML",
    "code": "                    </a>\n                  </li>\n                </ul>\n              </li>\n              <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"../search/enhanced.html\" class=\"nav-link active\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Enhanced</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "                            </div>\n                        </div>\n                        <div class=\"form-group\">\n                            <div class=\"input-group input-group-lg\">\n                                <input type=\"search\" class=\"form-control form-control-lg\" placeholder=\"Type your keywords here\" value=\"Lorem ipsum\">\n"
  },
  {
    "language": "HTML",
    "code": "                            </div>\n                        </div>\n                    </div>\n                </div>\n            </form>\n"
  },
  {
    "language": "HTML",
    "code": "  <!-- /.control-sidebar -->\n</div>\n<!-- ./wrapper -->\n\n<!-- jQuery -->\n"
  },
  {
    "language": "HTML",
    "code": "                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Dashboard v2</p>\n                </a>\n              </li>\n              <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "              <p>\n                Widgets\n                <span class=\"right badge badge-danger\">New</span>\n              </p>\n            </a>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"../UI/icons.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Icons</p>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"../tables/jsgrid.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>jsGrid</p>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"../mailbox/read-mail.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Read</p>\n"
  },
  {
    "language": "HTML",
    "code": "                      <i class=\"far fa-dot-circle nav-icon\"></i>\n                      <p>Level 3</p>\n                    </a>\n                  </li>\n                </ul>\n"
  },
  {
    "language": "HTML",
    "code": "          <li class=\"nav-header\">LABELS</li>\n          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n              <i class=\"nav-icon far fa-circle text-danger\"></i>\n              <p class=\"text\">Important</p>\n"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n"
  },
  {
    "language": "HTML",
    "code": "            <div class=\"media\">\n              <img src=\"../../dist/img/user8-128x128.jpg\" alt=\"User Avatar\" class=\"img-size-50 img-circle mr-3\">\n              <div class=\"media-body\">\n                <h3 class=\"dropdown-item-title\">\n                  John Pierce\n"
  },
  {
    "language": "HTML",
    "code": "            <!-- Message Start -->\n            <div class=\"media\">\n              <img src=\"../../dist/img/user3-128x128.jpg\" alt=\"User Avatar\" class=\"img-size-50 img-circle mr-3\">\n              <div class=\"media-body\">\n                <h3 class=\"dropdown-item-title\">\n"
  },
  {
    "language": "HTML",
    "code": "\n      <!-- Sidebar Menu -->\n      <nav class=\"mt-2\">\n        <ul class=\"nav nav-pills nav-sidebar flex-column\" data-widget=\"treeview\" role=\"menu\" data-accordion=\"false\">\n          <!-- Add icons to the links using the .nav-icon class\n"
  },
  {
    "language": "HTML",
    "code": "            </ul>\n          </li>\n          <li class=\"nav-item menu-open\">\n            <a href=\"#\" class=\"nav-link active\">\n              <i class=\"nav-icon fas fa-search\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "            <a href=\"#\" class=\"nav-link\">\n              <i class=\"fas fa-circle nav-icon\"></i>\n              <p>Level 1</p>\n            </a>\n          </li>\n"
  },
  {
    "language": "HTML",
    "code": "                  </li>\n                  <li class=\"nav-item\">\n                    <a href=\"#\" class=\"nav-link\">\n                      <i class=\"far fa-dot-circle nav-icon\"></i>\n                      <p>Level 3</p>\n"
  },
  {
    "language": "HTML",
    "code": "            <div class=\"media\">\n              <img src=\"../../dist/img/user8-128x128.jpg\" alt=\"User Avatar\" class=\"img-size-50 img-circle mr-3\">\n              <div class=\"media-body\">\n                <h3 class=\"dropdown-item-title\">\n                  John Pierce\n"
  },
  {
    "language": "HTML",
    "code": "                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Advanced Elements</p>\n                </a>\n              </li>\n              <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "              </p>\n            </a>\n          </li>\n          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "                      <i class=\"far fa-circle nav-icon\"></i>\n                      <p>Forgot Password v1</p>\n                    </a>\n                  </li>\n                  <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"#\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Level 2</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n              <i class=\"nav-icon far fa-circle text-warning\"></i>\n              <p>Warning</p>\n            </a>\n"
  },
  {
    "language": "HTML",
    "code": "  <div class=\"content-wrapper\">\n\n    <!-- Main content -->\n    <section class=\"content\">\n        <div class=\"container-fluid\">\n"
  },
  {
    "language": "HTML",
    "code": "    <!-- Left navbar links -->\n    <ul class=\"navbar-nav\">\n      <li class=\"nav-item\">\n        <a class=\"nav-link\" data-widget=\"pushmenu\" href=\"#\" role=\"button\"><i class=\"fas fa-bars\"></i></a>\n      </li>\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"../index3.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Dashboard v3</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"UI/icons.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Icons</p>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"forms/editors.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Editors</p>\n"
  },
  {
    "language": "HTML",
    "code": "          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n              <i class=\"nav-icon far fa-envelope\"></i>\n              <p>\n                Mailbox\n"
  },
  {
    "language": "HTML",
    "code": "                  </li>\n                  <li class=\"nav-item\">\n                    <a href=\"examples/recover-password.html\" class=\"nav-link\">\n                      <i class=\"far fa-circle nav-icon\"></i>\n                      <p>Recover Password v1</p>\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"examples/pace.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Pace</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "\n  <!-- Content Wrapper. Contains page content -->\n  <div class=\"content-wrapper\">\n    <!-- Content Header (Page header) -->\n    <section class=\"content-header\">\n"
  },
  {
    "language": "HTML",
    "code": "                    <ul class=\"fc-color-picker\" id=\"color-chooser\">\n                      <li><a class=\"text-primary\" href=\"#\"><i class=\"fas fa-square\"></i></a></li>\n                      <li><a class=\"text-warning\" href=\"#\"><i class=\"fas fa-square\"></i></a></li>\n                      <li><a class=\"text-success\" href=\"#\"><i class=\"fas fa-square\"></i></a></li>\n                      <li><a class=\"text-danger\" href=\"#\"><i class=\"fas fa-square\"></i></a></li>\n"
  },
  {
    "language": "HTML",
    "code": "          zIndex        : 1070,\n          revert        : true, // will cause the event to go back to its\n          revertDuration: 0  //  original position after the drag\n        })\n\n"
  },
  {
    "language": "HTML",
    "code": "        },\n        {\n          title          : 'Long Event',\n          start          : new Date(y, m, d - 5),\n          end            : new Date(y, m, d - 2),\n"
  },
  {
    "language": "HTML",
    "code": "      <li class=\"nav-item d-none d-sm-inline-block\">\n        <a href=\"../../index3.html\" class=\"nav-link\">Home</a>\n      </li>\n      <li class=\"nav-item d-none d-sm-inline-block\">\n        <a href=\"#\" class=\"nav-link\">Contact</a>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"../layout/fixed-sidebar-custom.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Fixed Sidebar <small>+ Custom Area</small></p>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n            </ul>\n          </li>\n          <li class=\"nav-header\">MISCELLANEOUS</li>\n          <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "                  <p>Level 2</p>\n                </a>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"#\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "          <span class=\"dropdown-item dropdown-header\">15 Notifications</span>\n          <div class=\"dropdown-divider\"></div>\n          <a href=\"#\" class=\"dropdown-item\">\n            <i class=\"fas fa-envelope mr-2\"></i> 4 new messages\n            <span class=\"float-right text-muted text-sm\">3 mins</span>\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"../layout/top-nav.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Top Navigation</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Fixed Sidebar <small>+ Custom Area</small></p>\n                </a>\n              </li>\n              <li class=\"nav-item\">\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n              <li class=\"nav-item\">\n                <a href=\"../layout/collapsed-sidebar.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Collapsed Sidebar</p>\n"
  },
  {
    "language": "HTML",
    "code": "                </a>\n              </li>\n            </ul>\n          </li>\n          <li class=\"nav-item menu-open\">\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"../UI/timeline.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Timeline</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "              <i class=\"nav-icon far fa-envelope\"></i>\n              <p>\n                Mailbox\n                <i class=\"fas fa-angle-left right\"></i>\n              </p>\n"
  },
  {
    "language": "HTML",
    "code": "                </a>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"../search/enhanced.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "                    <a href=\"#\" class=\"nav-link\">\n                      <i class=\"far fa-dot-circle nav-icon\"></i>\n                      <p>Level 3</p>\n                    </a>\n                  </li>\n"
  },
  {
    "language": "HTML",
    "code": "                  <!-- ./col -->\n                  <div class=\"col-6 col-md-3 text-center\">\n                    <input type=\"text\" class=\"knob\" value=\"-80\" data-min=\"-150\" data-max=\"150\" data-width=\"90\"\n                           data-height=\"90\" data-fgColor=\"#00a65a\">\n\n"
  },
  {
    "language": "HTML",
    "code": "        // \"tron\" case\n        if (this.$.data('skin') == 'tron') {\n\n          var a   = this.angle(this.cv)  // Angle\n            ,\n"
  },
  {
    "language": "HTML",
    "code": "            <div class=\"input-group input-group-sm\">\n              <input class=\"form-control form-control-navbar\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\">\n              <div class=\"input-group-append\">\n                <button class=\"btn btn-navbar\" type=\"submit\">\n                  <i class=\"fas fa-search\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "      <!-- Messages Dropdown Menu -->\n      <li class=\"nav-item dropdown\">\n        <a class=\"nav-link\" data-toggle=\"dropdown\" href=\"#\">\n          <i class=\"far fa-comments\"></i>\n          <span class=\"badge badge-danger navbar-badge\">3</span>\n"
  },
  {
    "language": "HTML",
    "code": "                  <span class=\"float-right text-sm text-muted\"><i class=\"fas fa-star\"></i></span>\n                </h3>\n                <p class=\"text-sm\">I got your message bro</p>\n                <p class=\"text-sm text-muted\"><i class=\"far fa-clock mr-1\"></i> 4 Hours Ago</p>\n              </div>\n"
  },
  {
    "language": "HTML",
    "code": "          </a>\n          <div class=\"dropdown-divider\"></div>\n          <a href=\"#\" class=\"dropdown-item dropdown-footer\">See All Notifications</a>\n        </div>\n      </li>\n"
  },
  {
    "language": "HTML",
    "code": "  <aside class=\"main-sidebar sidebar-dark-primary elevation-4\">\n    <!-- Brand Logo -->\n    <a href=\"../../index3.html\" class=\"brand-link\">\n      <img src=\"../../dist/img/AdminLTELogo.png\" alt=\"AdminLTE Logo\" class=\"brand-image img-circle elevation-3\" style=\"opacity: .8\">\n      <span class=\"brand-text font-weight-light\">AdminLTE 3</span>\n"
  },
  {
    "language": "HTML",
    "code": "              </p>\n            </a>\n            <ul class=\"nav nav-treeview\">\n              <li class=\"nav-item\">\n                <a href=\"chartjs.html\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"../UI/timeline.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Timeline</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "              </li>\n            </ul>\n          </li>\n          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "                </ul>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"#\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "                <a href=\"#\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Level 2</p>\n                </a>\n              </li>\n"
  },
  {
    "language": "HTML",
    "code": "                <h3 class=\"card-title\">\n                  <i class=\"far fa-chart-bar\"></i>\n                  Area Chart\n                </h3>\n\n"
  },
  {
    "language": "HTML",
    "code": "      cos.push([i, Math.cos(i)])\n    }\n    var line_data1 = {\n      data : sin,\n      color: '#3c8dbc'\n"
  },
  {
    "language": "HTML",
    "code": "      display : 'none',\n      opacity : 0.8\n    }).appendTo('body')\n    $('#line-chart').bind('plothover', function (event, pos, item) {\n\n"
  },
  {
    "language": "HTML",
    "code": "      <li class=\"nav-item\">\n        <a class=\"nav-link\" data-widget=\"control-sidebar\" data-slide=\"true\" href=\"#\" role=\"button\">\n          <i class=\"fas fa-th-large\"></i>\n        </a>\n      </li>\n"
  },
  {
    "language": "HTML",
    "code": "                </a>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"../layout/collapsed-sidebar.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "              <li class=\"nav-item\">\n                <a href=\"../UI/timeline.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Timeline</p>\n                </a>\n"
  },
  {
    "language": "HTML",
    "code": "            </a>\n            <ul class=\"nav nav-treeview\">\n              <li class=\"nav-item\">\n                <a href=\"../examples/invoice.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "              <li class=\"nav-item\">\n                <a href=\"../examples/faq.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>FAQ</p>\n                </a>\n"
  },
  {
    "language": "HTML",
    "code": "              </p>\n            </a>\n            <ul class=\"nav nav-treeview\">\n              <li class=\"nav-item\">\n                <a href=\"#\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "                      <p>Login v1</p>\n                    </a>\n                  </li>\n                  <li class=\"nav-item\">\n                    <a href=\"../examples/register.html\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "                  </li>\n                </ul>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"#\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "              <li class=\"nav-item\">\n                <a href=\"#\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Level 2</p>\n                </a>\n"
  },
  {
    "language": "HTML",
    "code": "              <div class=\"card-header\">\n                <h3 class=\"card-title\">Stacked Bar Chart</h3>\n\n                <div class=\"card-tools\">\n                  <button type=\"button\" class=\"btn btn-tool\" data-card-widget=\"collapse\">\n"
  },
  {
    "language": "HTML",
    "code": "<!-- Page specific script -->\n<script>\n  $(function () {\n    /* ChartJS\n     * -------\n"
  },
  {
    "language": "HTML",
    "code": "      data: donutData,\n      options: donutOptions\n    })\n\n    //-------------\n"
  },
  {
    "language": "HTML",
    "code": "    var barChartCanvas = $('#barChart').get(0).getContext('2d')\n    var barChartData = $.extend(true, {}, areaChartData)\n    var temp0 = areaChartData.datasets[0]\n    var temp1 = areaChartData.datasets[1]\n    barChartData.datasets[0] = temp1\n"
  },
  {
    "language": "HTML",
    "code": "      </li>\n      <li class=\"nav-item d-none d-sm-inline-block\">\n        <a href=\"index3.html\" class=\"nav-link\">Home</a>\n      </li>\n      <li class=\"nav-item d-none d-sm-inline-block\">\n"
  },
  {
    "language": "HTML",
    "code": "      </li>\n      <!-- Notifications Dropdown Menu -->\n      <li class=\"nav-item dropdown\">\n        <a class=\"nav-link\" data-toggle=\"dropdown\" href=\"#\">\n          <i class=\"far fa-bell\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "              </p>\n            </a>\n            <ul class=\"nav nav-treeview\">\n              <li class=\"nav-item\">\n                <a href=\"./index.html\" class=\"nav-link\">\n"
  },
  {
    "language": "HTML",
    "code": "              <li class=\"nav-item\">\n                <a href=\"pages/UI/modals.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Modals & Alerts</p>\n                </a>\n"
  },
  {
    "language": "HTML",
    "code": "                </a>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"pages/UI/timeline.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "                  <p>jsGrid</p>\n                </a>\n              </li>\n            </ul>\n          </li>\n"
  },
  {
    "language": "HTML",
    "code": "          </li>\n          <li class=\"nav-item\">\n            <a href=\"#\" class=\"nav-link\">\n              <i class=\"nav-icon far fa-envelope\"></i>\n              <p>\n"
  },
  {
    "language": "HTML",
    "code": "              <li class=\"nav-item\">\n                <a href=\"pages/mailbox/mailbox.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n                  <p>Inbox</p>\n                </a>\n"
  },
  {
    "language": "HTML",
    "code": "                </a>\n              </li>\n              <li class=\"nav-item\">\n                <a href=\"pages/examples/faq.html\" class=\"nav-link\">\n                  <i class=\"far fa-circle nav-icon\"></i>\n"
  },
  {
    "language": "HTML",
    "code": "              <i class=\"nav-icon fas fa-circle\"></i>\n              <p>\n                Level 1\n                <i class=\"right fas fa-angle-left\"></i>\n              </p>\n"
  },
  {
    "language": "HTML",
    "code": "    <div class=\"content-header\">\n      <div class=\"container-fluid\">\n        <div class=\"row mb-2\">\n          <div class=\"col-sm-6\">\n            <h1 class=\"m-0\">Dashboard v2</h1>\n"
  },
  {
    "language": "HTML",
    "code": "          </div><!-- /.col -->\n          <div class=\"col-sm-6\">\n            <ol class=\"breadcrumb float-sm-right\">\n              <li class=\"breadcrumb-item\"><a href=\"#\">Home</a></li>\n              <li class=\"breadcrumb-item active\">Dashboard v2</li>\n"
  },
  {
    "language": "HTML",
    "code": "              </div>\n              <!-- /.card-header -->\n              <div class=\"card-body\">\n                <div class=\"row\">\n                  <div class=\"col-md-8\">\n"
  },
  {
    "language": "HTML",
    "code": "                        <div class=\"progress-bar bg-primary\" style=\"width: 80%\"></div>\n                      </div>\n                    </div>\n                    <!-- /.progress-group -->\n\n"
  },
  {
    "language": "HTML",
    "code": "                        <!-- /.direct-chat-text -->\n                      </div>\n                      <!-- /.direct-chat-msg -->\n\n                      <!-- Message to the right -->\n"
  },
  {
    "language": "HTML",
    "code": "              </div>\n              <!-- /.col -->\n\n              <div class=\"col-md-6\">\n                <!-- USERS LIST -->\n"
  },
  {
    "language": "HTML",
    "code": "                      <td><a href=\"pages/examples/invoice.html\">OR9842</a></td>\n                      <td>Call of Duty IV</td>\n                      <td><span class=\"badge badge-success\">Shipped</span></td>\n                      <td>\n                        <div class=\"sparkbar\" data-color=\"#00a65a\" data-height=\"20\">90,80,90,-70,61,-83,63</div>\n"
  },
  {
    "language": "HTML",
    "code": "              <!-- /.info-box-content -->\n            </div>\n            <!-- /.info-box -->\n            <div class=\"info-box mb-3 bg-success\">\n              <span class=\"info-box-icon\"><i class=\"far fa-heart\"></i></span>\n"
  },
  {
    "language": "HTML",
    "code": "                  </button>\n                </div>\n              </div>\n              <!-- /.card-header -->\n              <div class=\"card-body p-0\">\n"
  },
  {
    "language": "HTML",
    "code": "                      </span>\n                    </div>\n                  </li>\n                  <!-- /.item -->\n                  <li class=\"item\">\n"
  },
  {
    "language": "HTML",
    "code": "<nav class=\"main-header navbar navbar-expand navbar-white navbar-light\">\n  <ul class=\"navbar-nav\">\n    <li class=\"nav-item\">\n      <a class=\"nav-link\" data-widget=\"pushmenu\" href=\"#\"><i class=\"fa fa-bars\"></i></a>\n    </li>\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\n procedure Doors is\n    type Door_State is (Closed, Open);\n    type Door_List is array(Positive range 1..100) of Door_State;\n    The_Doors : Door_List := (others => Closed);\n begin\n    for I in 1..100 loop\n       for J in The_Doors'range loop\n          if J mod I = 0 then\n             if The_Doors(J) = Closed then\n                 The_Doors(J) := Open;\n             else\n                The_Doors(J) := Closed;\n             end if;\n          end if;\n       end loop;\n    end loop;\n    for I in The_Doors'range loop\n       Put_Line(Integer'Image(I) & \" is \" & Door_State'Image(The_Doors(I)));\n    end loop;\n end Doors;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n with Ada.Numerics.Elementary_Functions; use Ada.Numerics.Elementary_Functions;\n\n procedure Doors_Optimized is\n    Num : Float;\n begin\n    for I in 1..100 loop\n       Num := Sqrt(Float(I));\n       Put(Integer'Image(I) & \" is \");\n       if Float'Floor(Num) = Num then\n          Put_Line(\"Opened\");\n       else\n          Put_Line(\"Closed\");\n       end if;\n    end loop;\n end Doors_Optimized;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\nprocedure Game_24 is\n   subtype Operation is Character;\n   type Op_Array is array (Positive range <>) of Operation;\n   type Digit is range 1 .. 9;\n   type Digit_Array is array (Positive range <>) of Digit;\n   package Digit_IO is new Ada.Text_IO.Integer_IO (Digit);\n   package Random_Digit is new Ada.Numerics.Discrete_Random (Digit);\n   Digit_Generator : Random_Digit.Generator;\n   Given_Digits : array (1 .. 4) of Digit;\nbegin\n   Ada.Text_IO.Put_Line (\"24 Game\");\n   Ada.Text_IO.Put_Line (\"Generating 4 digits...\");\n   Random_Digit.Reset (Digit_Generator);\n   for I in Given_Digits'Range loop\n      Given_Digits (I) := Random_Digit.Random (Digit_Generator);\n   end loop;\n   Ada.Text_IO.Put (\"Your Digits:\");\n   for I in Given_Digits'Range loop\n      Digit_IO.Put (Given_Digits (I));\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Enter your Expression: \");\n   declare\n      Value : Integer;\n      Input_Operations : Op_Array (1 .. 3);\n      Input_Digits : Digit_Array (1 .. 4);\n      Unused_Digits : array (Given_Digits'Range) of Boolean :=\n        (others => True);\n   begin\n      -- get input\n      for I in 1 .. 4 loop\n         Digit_IO.Get (Input_Digits (I));\n         exit when I = 4;\n         Ada.Text_IO.Get (Input_Operations (I));\n      end loop;\n      -- check input\n      for I in Input_Digits'Range loop\n         declare\n            Found : Boolean := False;\n         begin\n            for J in Given_Digits'Range loop\n               if Unused_Digits (J) and then\n                 Given_Digits (J) = Input_Digits (I) then\n                  Unused_Digits (J) := False;\n                  Found := True;\n                  exit;\n               end if;\n            end loop;\n            if not Found then\n               Ada.Text_IO.Put_Line (\"Illegal Number used:\" &\n                                     Digit'Image (Input_Digits (I)));\n               return;\n            end if;\n         end;\n      end loop;\n      -- check value\n      Value := Integer (Input_Digits (Input_Digits'First));\n      for I in Input_Operations'Range loop\n         case Input_Operations (I) is\n            when '+' =>\n               Value := Value + Integer (Input_Digits (I + 1));\n            when '-' =>\n               Value := Value - Integer (Input_Digits (I + 1));\n            when '*' =>\n               Value := Value * Integer (Input_Digits (I + 1));\n            when '/' =>\n               Value := Value / Integer (Input_Digits (I + 1));\n            when others =>\n               Ada.Text_IO.Put_Line (\"Illegal Op used:\" &\n                                     Input_Operations (I));\n               return;\n         end case;\n      end loop;\n      if Value /= 24 then\n         Ada.Text_IO.Put_Line (\"Value\" & Integer'Image (Value) &\n                               \" is not 24!\");\n      else\n         Ada.Text_IO.Put_Line (\"You won!\");\n      end if;\n   end;\nend Game_24;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\n procedure Bottles is\n begin\n    for X in reverse 1..99 loop\n       Put_Line(Integer'Image(X) & \" bottles of beer on the wall\");\n       Put_Line(Integer'Image(X) & \" bottles of beer\");\n       Put_Line(\"Take one down, pass it around\");\n       Put_Line(Integer'Image(X - 1) & \" bottles of beer on the wall\");\n       New_Line;\n    end loop;\n end Bottles;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Tasking_99_Bottles is\n   subtype Num_Bottles is Natural range 1..99;\n   task Print is\n      entry Set (Num_Bottles);\n   end Print;\n   task body Print is\n      Num : Natural;\n   begin\n      for I in reverse Num_Bottles'range loop\n         select\n         accept\n            Set(I) do -- Rendezvous with Counter task I\n               Num := I;\n            end Set;\n            Put_Line(Integer'Image(Num) & \" bottles of beer on the wall\");\n            Put_Line(Integer'Image(Num) & \" bottles of beer\");\n            Put_Line(\"Take one down, pass it around\");\n            Put_Line(Integer'Image(Num - 1) & \" bottles of beer on the wall\");\n            New_Line;\n         or terminate; -- end when all Counter tasks have completed\n         end select;\n      end loop;\n   end Print;\n   task type Counter(I : Num_Bottles);\n   task body Counter is\n   begin\n      Print.Set(I);\n   end Counter;\n   type Task_Access is access Counter;\n\n   Task_List : array(Num_Bottles) of Task_Access;\n\nbegin\n   for I in Task_List'range loop -- Create 99 Counter tasks\n      Task_List(I) := new Counter(I);\n   end loop;\nend Tasking_99_Bottles;\n"
  },
  {
    "language": "Ada",
    "code": "-- Standard I/O Streams\n\nwith Ada.Integer_Text_Io;\nprocedure APlusB is\n   A, B : Integer;\nbegin\n   Ada.Integer_Text_Io.Get (Item => A);\n   Ada.Integer_Text_Io.Get (Item => B);\n   Ada.Integer_Text_Io.Put (A+B);\nend APlusB;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\n\nprocedure A_Plus_B is\n   type Small_Integers is range -2_000 .. +2_000;\n   subtype Input_Values is Small_Integers range -1_000 .. +1_000;\n   package IO is new Ada.Text_IO.Integer_IO (Num => Small_Integers);\n   A, B : Input_Values;\nbegin\n   IO.Get (A);\n   IO.Get (B);\n   IO.Put (A + B, Width => 4, Base => 10);\nend A_Plus_B;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Characters.Handling;\nuse Ada.Characters.Handling;\n\n\npackage Abc is\n    type Block_Faces is array(1..2) of Character;\n    type Block_List is array(positive range <>) of Block_Faces;\n    function Can_Make_Word(W: String; Blocks: Block_List) return Boolean;\nend Abc;\n\n\npackage body Abc is\n\nfunction Can_Make_Word(W: String; Blocks: Block_List) return Boolean is\n    Used : array(Blocks'Range) of Boolean := (Others => False);\n    subtype wIndex is Integer range W'First..W'Last;\n    wPos : wIndex;\nbegin\n    if W'Length = 0 then\n        return True;\n    end if;\n    wPos := W'First;\n    while True loop\n        declare\n            C : Character := To_Upper(W(wPos));\n            X : constant wIndex := wPos;\n        begin\n            for I in Blocks'Range loop\n                if (not Used(I)) then\n                    if C = To_Upper(Blocks(I)(1)) or C = To_Upper(Blocks(I)(2)) then\n                        Used(I) := True;\n                        if wPos = W'Last then\n                            return True;\n                        end if;\n                        wPos := wIndex'Succ(wPos);\n                        exit;\n                    end if;\n                end if;\n            end loop;\n            if X = wPos then\n                return False;\n            end if;\n        end;\n    end loop;\n    return False;\nend Can_Make_Word;\n\nend Abc;\n\nwith Ada.Text_IO, Ada.Strings.Unbounded, Abc;\nuse Ada.Text_IO, Ada.Strings.Unbounded, Abc;\n\nprocedure Abc_Problem is\n    Blocks : Block_List := (\n          ('B','O'), ('X','K'), ('D','Q'), ('C','P')\n        , ('N','A'), ('G','T'), ('R','E'), ('T','G')\n        , ('Q','D'), ('F','S'), ('J','W'), ('H','U')\n        , ('V','I'), ('A','N'), ('O','B'), ('E','R')\n        , ('F','S'), ('L','Y'), ('P','C'), ('Z','M')\n    );\n    function \"+\" (S : String) return Unbounded_String renames To_Unbounded_String;\n    words : array(positive range <>) of Unbounded_String := (\n          +\"A\"\n        , +\"BARK\"\n        , +\"BOOK\"\n        , +\"TREAT\"\n        , +\"COMMON\"\n        , +\"SQUAD\"\n        , +\"CONFUSE\"\n        -- Border cases:\n        -- , +\"CONFUSE2\"\n        -- , +\"\"\n    );\nbegin\n    for I in words'Range loop\n        Put_Line ( To_String(words(I)) & \": \" & Boolean'Image(Can_Make_Word(To_String(words(I)),Blocks)) );\n    end loop;\nend Abc_Problem;\n"
  },
  {
    "language": "Ada",
    "code": "type Queue is limited interface;\nprocedure Enqueue (Lounge : in out Queue; Item : in out Element) is abstract;\nprocedure Dequeue (Lounge : in out Queue; Item : in out Element) is abstract;\n"
  },
  {
    "language": "Ada",
    "code": "type Scheduler is task interface;\nprocedure Plan (Manager : in out Scheduler; Activity : in out Job) is abstract;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Finalization;\n...\ntype Node is abstract new Ada.Finalization.Limited_Controlled and Queue with record\n   Previous : not null access Node'Class := Node'Unchecked_Access;\n   Next     : not null access Node'Class := Node'Unchecked_Access;\nend record;\noverriding procedure Finalize (X : in out Node); -- Removes the node from its list if any\noverriding procedure Dequeue (Lounge : in out Node; Item : in out Element);\noverriding procedure Enqueue (Lounge : in out Node; Item : in out Element);\nprocedure Process (X : in out Node) is abstract; -- To be implemented\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Generic_Divisors;\n\nprocedure ADB_Classification is\n   function Same(P: Positive) return Positive is (P);\n   package Divisor_Sum is new Generic_Divisors\n     (Result_Type => Natural, None => 0, One => Same, Add =>  \"+\");\n\n   type Class_Type is (Deficient, Perfect, Abundant);\n\n   function Class(D_Sum, N: Natural) return Class_Type is\n      (if D_Sum < N then Deficient\n       elsif D_Sum = N then Perfect\n       else Abundant);\n\n   Cls: Class_Type;\n   Results: array (Class_Type) of Natural := (others => 0);\n\n   package NIO is new Ada.Text_IO.Integer_IO(Natural);\n   package CIO is new Ada.Text_IO.Enumeration_IO(Class_Type);\nbegin\n   for N in 1 .. 20_000 loop\n      Cls := Class(Divisor_Sum.Process(N), N);\n      Results(Cls) := Results(Cls)+1;\n   end loop;\n   for Class in Results'Range loop\n      CIO.Put(Class, 12);\n      NIO.Put(Results(Class), 8);\n      Ada.Text_IO.New_Line;\n   end loop;\n   Ada.Text_IO.Put_Line(\"--------------------\");\n   Ada.Text_IO.Put(\"Sum         \");\n   NIO.Put(Results(Deficient)+Results(Perfect)+Results(Abundant), 8);\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put_Line(\"====================\");\nend ADB_Classification;\n"
  },
  {
    "language": "Ada",
    "code": "with Accumulator;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Example is\n   package A is new Accumulator;\n   package B is new Accumulator;\nbegin\n   Put_Line (Integer'Image (A.The_Function (5)));\n   Put_Line (Integer'Image (B.The_Function (3)));\n   Put_Line (Float'Image (A.The_Function (2.3)));\nend;\n"
  },
  {
    "language": "Ada",
    "code": "generic package Accumulator is\n\n--  This Ada generic package represents an accumulator factory.\n--  The required function is provided as The_Function.\n--  The first call to The_Function sets the initial value.\n--  (Marius Amado-Alves)\n\n   function The_Function (X : Integer) return Integer;\n   function The_Function (X : Integer) return Float;\n   function The_Function (X : Float) return Float;\nend;\n"
  },
  {
    "language": "Ada",
    "code": "package body Accumulator is\n\n--  The accumulator lives through three states. It is in Virgin_State\n--  before any use of The_Function. It changes to Integer_State or\n--  Float_State, according to the input type used. The accumulation is\n--  memorized in variable I or F, according to the state. Float_State,\n--  once reached, is never left. A Float output on an Integer_State is\n--  simply a conversion, sans effect on state. (Marius Amado-Alves)\n\n   type State_T is (Virgin_State, Integer_State, Float_State);\n   State : State_T := Virgin_State;\n   I : Integer;\n   F : Float;\n\n   function The_Function (X : Float) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Float_State;\n            F := X;\n            return F;\n         when Integer_State =>\n            State := Float_State;\n            F := Float (I) + X;\n            return F;\n         when Float_State =>\n            F := F + X;\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return Float (I);\n         when Integer_State =>\n            I := I + X;\n            return Float (I);\n         when Float_State =>\n            F := F + Float (X);\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Integer is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return I;\n         when Integer_State =>\n            I := I + X;\n            return I;\n         when Float_State =>\n            F := F + Float (X);\n            return Integer (F);\n      end case;\n   end;\n\nend;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Ackermann is\n   function Ackermann (M, N : Natural) return Natural is\n   begin\n      if M = 0 then\n         return N + 1;\n      elsif N = 0 then\n         return Ackermann (M - 1, 1);\n      else\n         return Ackermann (M - 1, Ackermann (M, N - 1));\n      end if;\n   end Ackermann;\nbegin\n   for M in 0..3 loop\n      for N in 0..6 loop\n         Put (Natural'Image (Ackermann (M, N)));\n      end loop;\n      New_Line;\n   end loop;\nend Test_Ackermann;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Calendar;                       use Ada.Calendar;\nwith Ada.Numerics;                       use Ada.Numerics;\nwith Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;\nwith Ada.Text_IO;                        use Ada.Text_IO;\n\nprocedure Test_Integrator is\n   type Func is access function (T : Time) return Float;\n\n   function Zero (T : Time) return Float is\n   begin\n      return 0.0;\n   end Zero;\n\n   Epoch : constant Time := Clock;\n\n   function Sine (T : Time) return Float is\n   begin\n      return Sin (Pi * Float (T - Epoch));\n   end Sine;\n\n   task type Integrator is\n      entry Input  (Value : Func);\n      entry Output (Value : out Float);\n      entry Shut_Down;\n   end Integrator;\n\n   task body Integrator is\n      K  : Func  := Zero'Access;\n      S  : Float := 0.0;\n      F0 : Float := 0.0;\n      F1 : Float;\n      T0 : Time  := Clock;\n      T1 : Time;\n   begin\n      loop\n         select\n            accept Input (Value : Func) do\n               K := Value;\n            end Input;\n         or accept Output (Value : out Float) do\n               Value := S;\n            end Output;\n         or accept Shut_Down;\n            exit;\n         else\n            T1 := Clock;\n            F1 := K (T1);\n            S  := S + 0.5 * (F1 + F0) * Float (T1 - T0);\n            T0 := T1;\n            F0 := F1;\n         end select;\n      end loop;\n   end Integrator;\n\n   I : Integrator;\n   S : Float;\nbegin\n   I.Input (Sine'Access);\n   delay 2.0;\n   I.Input (Zero'Access);\n   delay 0.5;\n   I.Output (S);\n   Put_Line (\"Integrated\" & Float'Image (S) & \"s\");\n   I.Shut_Down;\nend Test_Integrator;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Dynamic is\n   package Abstract_Class is\n      type Class is limited interface;\n      function Boo (X : Class) return String is abstract;\n   end Abstract_Class;\n   use Abstract_Class;\n\n   package Base_Class is\n      type Base is new Class with null record;\n      overriding function Boo (X : Base) return String;\n   end Base_Class;\n\n   package body Base_Class is\n      function Boo (X : Base) return String is\n      begin\n         return \"I am Class\";\n      end Boo;\n   end Base_Class;\n   use Base_Class;\n\n   E : aliased Base;  -- An instance of Base\n\nbegin\n   -- Gone run-time\n   declare\n      type Monkey_Patch (Root : access Base) is new Class with record\n         Foo : Integer := 1;\n      end record;\n      overriding function Boo (X : Monkey_Patch) return String;\n      function Boo (X : Monkey_Patch) return String is\n      begin -- Delegation to the base\n         return X.Root.Boo;\n      end Boo;\n      EE : Monkey_Patch (E'Access); -- Extend E\n   begin\n      Put_Line (EE.Boo & \" with\" & Integer'Image (EE.Foo));\n   end;\nend Dynamic;\n"
  },
  {
    "language": "Ada",
    "code": "The_Address : System.Address;\nI : Integer;\nThe_Address := I'Address;\n"
  },
  {
    "language": "Ada",
    "code": "I : Integer;\nfor I'Address use 16#A100#;\n"
  },
  {
    "language": "Ada",
    "code": "I : Integer;\nJ : Integer;\nfor I'Address use J'Address;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\n\nprocedure Test_For_Primes is\n\n   type Pascal_Triangle_Type is array (Natural range <>) of Long_Long_Integer;\n\n   function Calculate_Pascal_Triangle (N : in Natural) return Pascal_Triangle_Type is\n      Pascal_Triangle : Pascal_Triangle_Type (0 .. N);\n   begin\n      Pascal_Triangle (0) := 1;\n      for I in Pascal_Triangle'First .. Pascal_Triangle'Last - 1 loop\n         Pascal_Triangle (1 + I) := 1;\n         for J in reverse 1 .. I loop\n            Pascal_Triangle (J) := Pascal_Triangle (J - 1) - Pascal_Triangle (J);\n         end loop;\n         Pascal_Triangle (0) := -Pascal_Triangle (0);\n      end loop;\n      return Pascal_Triangle;\n   end Calculate_Pascal_Triangle;\n\n   function Is_Prime (N : Integer) return Boolean is\n      I      : Integer;\n      Result : Boolean := True;\n      Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n   begin\n      I := N / 2;\n      while Result and I > 1 loop\n         Result := Result and Pascal_Triangle (I) mod Long_Long_Integer (N) = 0;\n         I := I - 1;\n      end loop;\n      return Result;\n   end Is_Prime;\n\n   function Image (N    : in Long_Long_Integer;\n                   Sign : in Boolean := False) return String is\n      Image : constant String := N'Image;\n   begin\n      if N < 0 then\n         return Image;\n      else\n         if Sign then\n            return \"+\" & Image (Image'First + 1 .. Image'Last);\n         else\n            return Image (Image'First + 1 .. Image'Last);\n         end if;\n      end if;\n   end Image;\n\n   procedure Show (Triangle : in Pascal_Triangle_Type) is\n      use Ada.Text_IO;\n   Begin\n      for I in reverse Triangle'Range loop\n         Put (Image (Triangle (I), Sign => True));\n         Put (\"x^\");\n         Put (Image (Long_Long_Integer (I)));\n         Put (\" \");\n      end loop;\n   end Show;\n\n   procedure Show_Pascal_Triangles is\n      use Ada.Text_IO;\n   begin\n      for N in 0 .. 9 loop\n         declare\n            Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n         begin\n            Put (\"(x-1)^\" & Image (Long_Long_Integer (N)) & \" = \");\n            Show (Pascal_Triangle);\n            New_Line;\n         end;\n      end loop;\n   end Show_Pascal_Triangles;\n\n   procedure Show_Primes is\n      use Ada.Text_IO;\n   begin\n      for N in 2 .. 63 loop\n         if Is_Prime (N) then\n            Put (N'Image);\n         end if;\n      end loop;\n      New_Line;\n   end Show_Primes;\n\nbegin\n   Show_Pascal_Triangles;\n   Show_Primes;\nend Test_For_Primes;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Characters.Latin_1;  use Ada.Characters.Latin_1;\nwith Ada.Text_IO;             use Ada.Text_IO;\nwith Strings_Edit;            use Strings_Edit;\n\nprocedure Column_Aligner is\n   Text : constant String :=\n      \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & NUL &\n      \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & NUL &\n      \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & NUL &\n      \"column$are$separated$by$at$least$one$space.\" & NUL &\n      \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & NUL &\n      \"justified,$right$justified,$or$center$justified$within$its$column.\" & NUL;\n   File    : File_Type;\n   Width   : array (1..1_000) of Natural := (others => 0);\n   Line    : String (1..200);\n   Column  : Positive := 1;\n   Start   : Positive := 1;\n   Pointer : Positive;\nbegin\n   Create (File, Out_File, \"columned.txt\");\n      -- Determining the widths of columns\n   for I in Text'Range loop\n      case Text (I) is\n         when '$' | NUL =>\n            Width (Column) := Natural'Max (Width (Column), I - Start + 1);\n            Start  := I + 1;\n            if Text (I) = NUL then\n               Column := 1;\n            else\n               Column := Column + 1;\n            end if;\n         when others =>\n            null;\n      end case;\n   end loop;\n      -- Formatting\n   for Align in Alignment loop\n      Column  := 1;\n      Start   := 1;\n      Pointer := 1;\n      for I in Text'Range loop\n         case Text (I) is\n            when '$' | NUL =>\n               Put -- Formatted output of a word\n               (  Destination => Line,\n                  Pointer     => Pointer,\n                  Value       => Text (Start..I - 1),\n                  Field       => Width (Column),\n                  Justify     => Align\n               );\n               Start  := I + 1;\n               if Text (I) = NUL then\n                  Put_Line (File, Line (1..Pointer - 1));\n                  Pointer := 1;\n                  Column := 1;\n               else\n                  Column := Column + 1;\n               end if;\n            when others =>\n               null;\n         end case;\n      end loop;\n   end loop;\n   Close (File);\nend Column_Aligner;\n"
  },
  {
    "language": "Ada",
    "code": "with Prime_Numbers, Ada.Text_IO;\n\nprocedure Test_Kth_Prime is\n\n   package Integer_Numbers is new\n     Prime_Numbers (Natural, 0, 1, 2);\n   use Integer_Numbers;\n\n   Out_Length: constant Positive := 10; -- 10 k-th almost primes\n   N: Positive; -- the \"current number\" to be checked\n\nbegin\n   for K in 1 .. 5 loop\n      Ada.Text_IO.Put(\"K =\" & Integer'Image(K) &\":  \");\n      N := 2;\n      for I in 1 .. Out_Length loop\n\t while Decompose(N)'Length /= K loop\n\t    N := N + 1;\n\t end loop; -- now N is Kth almost prime;\n\t Ada.Text_IO.Put(Integer'Image(Integer(N)));\n\t N := N + 1;\n      end loop;\n      Ada.Text_IO.New_Line;\n   end loop;\nend Test_Kth_Prime;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;\nwith Ada.Text_IO;            use Ada.Text_IO;\n\nprocedure Test_Amb is\n   type Alternatives is array (Positive range <>) of Unbounded_String;\n\n   type Amb (Count : Positive) is record\n      This : Positive := 1;\n      Left : access Amb;\n      List : Alternatives (1..Count);\n   end record;\n\n   function Image (L : Amb) return String is\n   begin\n      return To_String (L.List (L.This));\n   end Image;\n\n   function \"/\" (L, R : String) return Amb is\n      Result : Amb (2);\n   begin\n      Append (Result.List (1), L);\n      Append (Result.List (2), R);\n      return Result;\n   end \"/\";\n\n   function \"/\" (L : Amb; R : String) return Amb is\n      Result : Amb (L.Count + 1);\n   begin\n      Result.List (1..L.Count) := L.List ;\n      Append (Result.List (Result.Count), R);\n      return Result;\n   end \"/\";\n\n   function \"=\" (L, R : Amb) return Boolean is\n      Left : Unbounded_String renames L.List (L.This);\n   begin\n      return Element (Left, Length (Left)) = Element (R.List (R.This), 1);\n   end \"=\";\n\n   procedure Failure (L : in out Amb) is\n   begin\n      loop\n         if L.This < L.Count then\n            L.This := L.This + 1;\n         else\n            L.This := 1;\n            Failure (L.Left.all);\n         end if;\n         exit when L.Left = null or else L.Left.all = L;\n      end loop;\n   end Failure;\n\n   procedure Join (L : access Amb; R : in out Amb) is\n   begin\n      R.Left := L;\n      while L.all /= R loop\n         Failure (R);\n      end loop;\n   end Join;\n\n   W_1 : aliased Amb := \"the\" / \"that\" / \"a\";\n   W_2 : aliased Amb := \"frog\" / \"elephant\" / \"thing\";\n   W_3 : aliased Amb := \"walked\" / \"treaded\" / \"grows\";\n   W_4 : aliased Amb := \"slowly\" / \"quickly\";\nbegin\n   Join (W_1'Access, W_2);\n   Join (W_2'Access, W_3);\n   Join (W_3'Access, W_4);\n   Put_Line (Image (W_1) & ' ' & Image (W_2) & ' ' & Image (W_3) & ' ' & Image (W_4));\nend Test_Amb;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Generic_Divisors; use Ada.Text_IO;\n\nprocedure Amicable_Pairs is\n\n   function Same(P: Positive) return Positive is (P);\n\n   package Divisor_Sum is new Generic_Divisors\n     (Result_Type => Natural, None => 0, One => Same, Add =>  \"+\");\n\n   Num2 : Integer;\nbegin\n   for Num1 in 4 .. 20_000 loop\n      Num2 := Divisor_Sum.Process(Num1);\n      if Num1 < Num2 then\n\t if Num1 = Divisor_Sum.Process(Num2) then\n\t   Put_Line(Integer'Image(Num1) & \",\" & Integer'Image(Num2));\n\t end if;\n      end if;\n   end loop;\nend Amicable_Pairs;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Generic_Array_Sort;\nwith Ada.Containers.Indefinite_Vectors;\nprocedure Danagrams is\n   package StringVector is new Ada.Containers.Indefinite_Vectors\n      (Positive, String);\n   procedure StrSort is new Ada.Containers.Generic_Array_Sort\n      (Index_Type => Positive,\n      Element_Type => Character,\n      Array_Type => String);\n   function Derange (s1 : String; s2 : String) return Boolean is begin\n      for i in s1'Range loop\n         if (s1 (i) = s2 (i)) then return False; end if;\n      end loop;\n      return True;\n   end Derange;\n   File : File_Type;\n   len, foundlen : Positive := 1;\n   Vect, SVect : StringVector.Vector;\n   index, p1, p2 : StringVector.Extended_Index := 0;\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   while not End_Of_File (File) loop\n      declare str : String := Get_Line (File);\n      begin\n         len := str'Length;\n         if len > foundlen then\n            Vect.Append (str);\n            StrSort (str);\n            index := 0;\n            loop --  Loop through anagrams by index in vector of sorted strings\n               index := SVect.Find_Index (str, index + 1);\n               exit when index = StringVector.No_Index;\n               if Derange (Vect.Last_Element, Vect.Element (index)) then\n                     p1 := Vect.Last_Index; p2 := index;\n                     foundlen := len;\n               end if;\n            end loop;\n            SVect.Append (str);\n         end if;\n      end;\n   end loop;\n   Close (File);\n   Put_Line (Vect.Element (p1) & \" \" & Vect.Element (p2));\nend Danagrams;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nwith Ada.Containers.Indefinite_Ordered_Maps;\nwith Ada.Containers.Indefinite_Ordered_Sets;\n\nprocedure Words_Of_Equal_Characters is\n   package Set_Of_Words is new Ada.Containers.Indefinite_Ordered_Sets (String);\n   use Ada.Containers, Set_Of_Words;\n   package Anagrams is new Ada.Containers.Indefinite_Ordered_Maps (String, Set);\n   use Anagrams;\n\n   File   : File_Type;\n   Result : Map;\n   Max    : Count_Type := 1;\n\n   procedure Put (Position : Anagrams.Cursor) is\n      First : Boolean := True;\n      List  : Set renames Element (Position);\n      procedure Put (Position : Set_Of_Words.Cursor) is\n      begin\n         if First then\n            First := False;\n         else\n            Put (',');\n         end if;\n         Put (Element (Position));\n      end Put;\n   begin\n      if List.Length = Max then\n         Iterate (List, Put'Access);\n         New_Line;\n      end if;\n   end Put;\n\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   loop\n      declare\n         Word : constant String     := Get_Line (File);\n         Key  : String (Word'Range) := (others => Character'Last);\n         List : Set;\n         Position : Anagrams.Cursor;\n      begin\n         for I in Word'Range loop\n            for J in Word'Range loop\n               if Key (J) > Word (I) then\n                  Key (J + 1..I) := Key (J..I - 1);\n                  Key (J) := Word (I);\n                  exit;\n               end if;\n            end loop;\n         end loop;\n         Position := Find (Result, Key);\n         if Has_Element (Position) then\n            List := Element (Position);\n            Insert (List, Word);\n            Replace_Element (Result, Position, List);\n         else\n            Insert (List, Word);\n            Include (Result, Key, List);\n         end if;\n         Max := Count_Type'Max (Max, Length (List));\n      end;\n   end loop;\nexception\n   when End_Error =>\n      Iterate (Result, Put'Access);\n      Close (File);\nend Words_Of_Equal_Characters;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   type Float_Type is digits <>;\n   Gravitation : Float_Type;\npackage Pendulums is\n   type Pendulum is private;\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum;\n   function Get_X (From : Pendulum) return Float_Type;\n   function Get_Y (From : Pendulum) return Float_Type;\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration);\nprivate\n   type Pendulum is record\n      Length   : Float_Type;\n      Theta    : Float_Type;\n      X        : Float_Type;\n      Y        : Float_Type;\n      Velocity : Float_Type;\n   end record;\nend Pendulums;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Elementary_Functions;\npackage body Pendulums is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float_Type);\n\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum is\n      Result : Pendulum;\n   begin\n      Result.Length   := Length;\n      Result.Theta    := Theta0 / 180.0 * Ada.Numerics.Pi;\n      Result.X        := Math.Sin (Theta0) * Length;\n      Result.Y        := Math.Cos (Theta0) * Length;\n      Result.Velocity := 0.0;\n      return Result;\n   end New_Pendulum;\n\n   function Get_X (From : Pendulum) return Float_Type is\n   begin\n      return From.X;\n   end Get_X;\n\n   function Get_Y (From : Pendulum) return Float_Type is\n   begin\n      return From.Y;\n   end Get_Y;\n\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration) is\n      Acceleration : constant Float_Type := Gravitation / Item.Length *\n                                            Math.Sin (Item.Theta);\n   begin\n         Item.X        := Math.Sin (Item.Theta) * Item.Length;\n         Item.Y        := Math.Cos (Item.Theta) * Item.Length;\n         Item.Velocity := Item.Velocity +\n                          Acceleration  * Float_Type (Time);\n         Item.Theta    := Item.Theta +\n                          Item.Velocity * Float_Type (Time);\n   end Update_Pendulum;\nend Pendulums;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Calendar;\nwith Pendulums;\n\nprocedure Main is\n   package Float_Pendulum is new Pendulums (Float, -9.81);\n   use Float_Pendulum;\n   use type Ada.Calendar.Time;\n\n   My_Pendulum : Pendulum := New_Pendulum (10.0, 30.0);\n   Now, Before : Ada.Calendar.Time;\nbegin\n   Before := Ada.Calendar.Clock;\n   loop\n      Delay 0.1;\n      Now := Ada.Calendar.Clock;\n      Update_Pendulum (My_Pendulum, Now - Before);\n      Before := Now;\n      -- output positions relative to origin\n      -- replace with graphical output if wanted\n      Ada.Text_IO.Put_Line (\" X: \" & Float'Image (Get_X (My_Pendulum)) &\n                            \" Y: \" & Float'Image (Get_Y (My_Pendulum)));\n   end loop;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Gtk.Main;\nwith Gtk.Handlers;\nwith Gtk.Label;\nwith Gtk.Button;\nwith Gtk.Window;\nwith Glib.Main;\n\nprocedure Animation is\n   Scroll_Forwards : Boolean := True;\n\n   package Button_Callbacks is new Gtk.Handlers.Callback\n     (Gtk.Button.Gtk_Button_Record);\n\n   package Label_Timeout is new Glib.Main.Generic_Sources\n     (Gtk.Label.Gtk_Label);\n\n   package Window_Callbacks is new Gtk.Handlers.Return_Callback\n     (Gtk.Window.Gtk_Window_Record, Boolean);\n\n   --  Callback for click event\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class);\n\n   --  Callback for delete event\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean;\n\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class)\n   is\n      pragma Unreferenced (Object);\n   begin\n      Scroll_Forwards := not Scroll_Forwards;\n   end On_Button_Click;\n\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean\n   is\n      pragma Unreferenced (Object);\n   begin\n      Gtk.Main.Main_Quit;\n      return True;\n   end On_Main_Window_Delete;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean is\n      Text : constant String := Gtk.Label.Get_Text (Data);\n   begin\n      if Scroll_Forwards then\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'First + 1 .. Text'Last) & Text (Text'First));\n      else\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'Last) & Text (Text'First .. Text'Last - 1));\n      end if;\n      return True;\n   end Scroll_Text;\n\n   Main_Window     : Gtk.Window.Gtk_Window;\n   Text_Button     : Gtk.Button.Gtk_Button;\n   Scrolling_Text  : Gtk.Label.Gtk_Label;\n   Timeout_ID      : Glib.Main.G_Source_Id;\n   pragma Unreferenced (Timeout_ID);\n\nbegin\n   Gtk.Main.Init;\n   Gtk.Window.Gtk_New (Window => Main_Window);\n   Gtk.Label.Gtk_New (Label => Scrolling_Text, Str => \"Hello World! \");\n   Gtk.Button.Gtk_New (Button => Text_Button);\n   Gtk.Button.Add (Container => Text_Button, Widget => Scrolling_Text);\n   Button_Callbacks.Connect\n     (Widget => Text_Button,\n      Name   => \"clicked\",\n      Marsh  => Button_Callbacks.To_Marshaller (On_Button_Click'Access));\n   Timeout_ID :=\n     Label_Timeout.Timeout_Add\n       (Interval => 125,\n        Func     => Scroll_Text'Access,\n        Data     => Scrolling_Text);\n   Gtk.Window.Add (Container => Main_Window, Widget => Text_Button);\n   Window_Callbacks.Connect\n     (Widget => Main_Window,\n      Name   => \"delete_event\",\n      Marsh  => Window_Callbacks.To_Marshaller (On_Main_Window_Delete'Access));\n   Gtk.Window.Show_All (Widget => Main_Window);\n   Gtk.Main.Main;\nend Animation;\n"
  },
  {
    "language": "Ada",
    "code": "   function Fib (X: in Integer) return Integer is\n      function Actual_Fib (N: in Integer) return Integer is\n      begin\n         if N < 2 then\n            return N;\n         else\n            return Actual_Fib (N-1) + Actual_Fib (N-2);\n         end if;\n      end Actual_Fib;\n   begin\n      if X < 0 then\n         raise Constraint_Error;\n      else\n         return Actual_Fib (X);\n      end if;\n   end Fib;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io;\n with Ada.Integer_text_IO;\n\n procedure Call_Back_Example is\n    -- Purpose: Apply a callback to an array\n    -- Output: Prints the squares of an integer array to the console\n\n    -- Define the callback procedure\n    procedure Display(Location : Positive; Value : Integer) is\n    begin\n       Ada.Text_Io.Put(\"array(\");\n       Ada.Integer_Text_Io.Put(Item => Location, Width => 1);\n       Ada.Text_Io.Put(\") = \");\n       Ada.Integer_Text_Io.Put(Item => Value * Value, Width => 1);\n       Ada.Text_Io.New_Line;\n    end Display;\n\n    -- Define an access type matching the signature of the callback procedure\n    type Call_Back_Access is access procedure(L : Positive; V : Integer);\n\n    -- Define an unconstrained array type\n    type Value_Array is array(Positive range <>) of Integer;\n\n    -- Define the procedure performing the callback\n    procedure Map(Values : Value_Array; Worker : Call_Back_Access) is\n    begin\n       for I in Values'range loop\n          Worker(I, Values(I));\n       end loop;\n    end Map;\n\n    -- Define and initialize the actual array\n    Sample : Value_Array := (5,4,3,2,1);\n\n begin\n    Map(Sample, Display'access);\n end Call_Back_Example;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith GNATCOLL.GMP; use GNATCOLL.GMP;\nwith GNATCOLL.GMP.Integers; use GNATCOLL.GMP.Integers;\nprocedure ArbitraryInt is\n   type stracc is access String;\n   BigInt : Big_Integer;\n   len : Natural;\n   str : stracc;\nbegin\n   Set (BigInt, 5);\n   Raise_To_N (BigInt, Unsigned_Long (4**(3**2)));\n   str := new String'(Image (BigInt));\n   len := str'Length;\n   Put_Line (\"Size is:\"& Natural'Image (len));\n   Put_Line (str (1 .. 20) & \".....\" & str (len - 19 .. len));\nend ArbitraryInt;\n"
  },
  {
    "language": "Ada",
    "code": "type My_Pointer is access My_Object;\nfor My_Pointer'Storage_Pool use My_Pool;\n"
  },
  {
    "language": "Ada",
    "code": "with System.Storage_Elements;  use System.Storage_Elements;\nwith System.Storage_Pools;     use System.Storage_Pools;\n\npackage Arena_Pools is\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with private;\n   overriding\n      procedure Allocate\n                (  Pool      : in out Arena;\n                   Address   : out System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                );\n   overriding\n      procedure Deallocate\n                (  Pool      : in out Arena;\n                   Address   : System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                )  is null;\n   overriding\n      function Storage_Size (Pool : Arena) return Storage_Count;\nprivate\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with record\n      Free : Storage_Offset := 1;\n      Core : Storage_Array (1..Size);\n   end record;\nend Arena_Pools;\n"
  },
  {
    "language": "Ada",
    "code": "package body Arena_Pools is\n   procedure Allocate\n             (  Pool      : in out Arena;\n                Address   : out System.Address;\n                Size      : Storage_Count;\n                Alignment : Storage_Count\n             )  is\n      Free : constant Storage_Offset :=\n         Pool.Free + Alignment - Pool.Core (Pool.Free)'Address mod Alignment + Size;\n   begin\n      if Free - 1 > Pool.Size then\n         raise Storage_Error;\n      end if;\n      Pool.Free := Free;\n      Address := Pool.Core (Pool.Free - Size)'Address;\n   end Allocate;\n\n   function Storage_Size (Pool : Arena) return Storage_Count is\n   begin\n      return Pool.Size;\n   end Storage_Size;\nend Arena_Pools;\n"
  },
  {
    "language": "Ada",
    "code": "with Arena_Pools;\nuse  Arena_Pools;\n\nprocedure Test_Allocator is\n   Pool : Arena_Pools.Arena (1024);\n   type Integer_Ptr is access Integer;\n   for Integer_Ptr'Storage_Pool use Pool;\n\n   X : Integer_Ptr := new Integer'(1);\n   Y : Integer_Ptr := new Integer'(2);\n   Z : Integer_Ptr;\nbegin\n   Z := new Integer;\n   Z.all := X.all + Y.all;\nend Test_Allocator;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Complex_Types;\nwith Ada.Text_IO.Complex_IO;\n\nprocedure Complex_Operations is\n   -- Ada provides a pre-defined generic package for complex types\n   -- That package contains definitions for composition,\n   -- negation, addition, subtraction, multiplication, division,\n   -- conjugation, exponentiation, and absolute value, as well as\n   -- basic comparison operations.\n   -- Ada provides a second pre-defined package for sin, cos, tan, cot,\n   -- arcsin, arccos, arctan, arccot, and the hyperbolic versions of\n   -- those trigonometric functions.\n\n   -- The package Ada.Numerics.Generic_Complex_Types requires definition\n   -- with the real type to be used in the complex type definition.\n\n   package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Long_Float);\n   use Complex_Types;\n   package Complex_IO is new Ada.Text_IO.Complex_IO (Complex_Types);\n   use Complex_IO;\n   use Ada.Text_IO;\n\n   A : Complex := Compose_From_Cartesian (Re => 1.0, Im => 1.0);\n   B : Complex := Compose_From_Polar (Modulus => 1.0, Argument => 3.14159);\n   C : Complex;\n\nbegin\n   -- Addition\n   C := A + B;\n   Put(\"A + B = \"); Put(C);\n   New_Line;\n   -- Multiplication\n   C := A * B;\n   Put(\"A * B = \"); Put(C);\n   New_Line;\n   -- Inversion\n   C := 1.0 / A;\n   Put(\"1.0 / A = \"); Put(C);\n   New_Line;\n   -- Negation\n   C := -A;\n   Put(\"-A = \"); Put(C);\n   New_Line;\n   -- Conjugation\n   C := Conjugate (C);\nend Complex_Operations;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Arith_Geom_Mean is\n\n   type Num is digits 18; -- the largest value gnat/gcc allows\n   package N_IO is new Ada.Text_IO.Float_IO(Num);\n   package Math is new Ada.Numerics.Generic_Elementary_Functions(Num);\n\n   function AGM(A, G: Num) return Num is\n      Old_G: Num;\n      New_G: Num := G;\n      New_A: Num := A;\n   begin\n      loop\n         Old_G := New_G;\n         New_G := Math.Sqrt(New_A*New_G);\n         New_A := (Old_G + New_A) * 0.5;\n         exit when (New_A - New_G) <= Num'Epsilon;\n         -- Num'Epsilon denotes the relative error when performing arithmetic over Num\n      end loop;\n      return New_G;\n   end AGM;\n\nbegin\n   N_IO.Put(AGM(1.0, 1.0/Math.Sqrt(2.0)), Fore => 1, Aft => 17, Exp => 0);\nend Arith_Geom_Mean;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io;\nwith Ada.Integer_Text_IO;\n\nprocedure Integer_Arithmetic is\n   use Ada.Text_IO;\n   use Ada.Integer_Text_Io;\n\n   A, B : Integer;\nbegin\n   Get(A);\n   Get(B);\n   Put_Line(\"a+b = \" & Integer'Image(A + B));\n   Put_Line(\"a-b = \" & Integer'Image(A - B));\n   Put_Line(\"a*b = \" & Integer'Image(A * B));\n   Put_Line(\"a/b = \" & Integer'Image(A / B));\n   Put_Line(\"a mod b = \" & Integer'Image(A mod B)); -- Sign matches B\n   Put_Line(\"remainder of a/b = \" & Integer'Image(A rem B)); -- Sign matches A\n   Put_Line(\"a**b = \" & Integer'Image(A ** B));\n\nend Integer_Arithmetic;\n"
  },
  {
    "language": "Ada",
    "code": "type T is array (Positive range <>) of Integer;\nX : T := (1, 2, 3);\nY : T := X & (4, 5, 6); -- Concatenate X and (4, 5, 6)\n"
  },
  {
    "language": "Ada",
    "code": "procedure Array_Test is\n\n   A, B : array (1..20) of Integer;\n\n   -- Ada array indices may begin at any value, not just 0 or 1\n   C : array (-37..20) of integer\n\n   -- Ada arrays may be indexed by enumerated types, which are\n   -- discrete non-numeric types\n   type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\n   type Activities is (Work, Fish);\n   type Daily_Activities is array(Days) of Activities;\n   This_Week : Daily_Activities := (Mon..Fri => Work, Others => Fish);\n\n   -- Or any numeric type\n   type Fingers is range 1..4; -- exclude thumb\n   type Fingers_Extended_Type is array(fingers) of Boolean;\n   Fingers_Extended : Fingers_Extended_Type;\n\n   -- Array types may be unconstrained. The variables of the type\n   -- must be constrained\n   type Arr is array (Integer range <>) of Integer;\n   Uninitialized : Arr (1 .. 10);\n   Initialized_1 : Arr (1 .. 20) := (others => 1);\n   Initialized_2 : Arr := (1 .. 30 => 2);\n   Const         : constant Arr := (1 .. 10 => 1, 11 .. 20 => 2, 21 | 22 => 3);\n   Centered      : Arr (-50..50) := (0 => 1, Others => 0);\n\n   Result        : Integer\nbegin\n\n   A := (others => 0);     -- Assign whole array\n   B := (1 => 1, 2 => 1, 3 => 2, others => 0);\n                           -- Assign whole array, different values\n   A (1) := -1;            -- Assign individual element\n   A (2..4) := B (1..3);   -- Assign a slice\n   A (3..5) := (2, 4, -1); -- Assign a constant slice\n   A (3..5) := A (4..6);   -- It is OK to overlap slices when assigned\n\n   Fingers_Extended'First := False; -- Set first element of array\n   Fingers_Extended'Last := False;  -- Set last element of array\n\nend Array_Test;\n"
  },
  {
    "language": "Ada",
    "code": "pragma Assert (A = 42, \"Oops!\");\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Assertions;  use Ada.Assertions;\n...\nAssert (A = 42, \"Oops!\");\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Ordered_Maps;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;\n\nprocedure Associative_Array is\n\n   -- Instantiate the generic package Ada.Containers.Ordered_Maps\n\n   package Associative_Int is new Ada.Containers.Ordered_Maps(Unbounded_String, Integer);\n   use Associative_Int;\n\n   Color_Map : Map;\n   Color_Cursor : Cursor;\n   Success : Boolean;\n   Value : Integer;\nbegin\n\n   -- Add values to the ordered map\n\n   Color_Map.Insert(To_Unbounded_String(\"Red\"), 10, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Blue\"), 20, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Yellow\"), 5, Color_Cursor, Success);\n\n   -- retrieve values from the ordered map and print the value and key\n   -- to the screen\n\n   Value := Color_Map.Element(To_Unbounded_String(\"Red\"));\n   Ada.Text_Io.Put_Line(\"Red:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Blue\"));\n   Ada.Text_IO.Put_Line(\"Blue:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Yellow\"));\n   Ada.Text_IO.Put_Line(\"Yellow:\" & Integer'Image(Value));\nend Associative_Array;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Containers.Indefinite_Ordered_Maps;\n\nprocedure Test_Iteration is\n   package String_Maps is\n      new Ada.Containers.Indefinite_Ordered_Maps (String, Integer);\n   use String_Maps;\n   A     : Map;\n   Index : Cursor;\nbegin\n   A.Insert (\"hello\", 1);\n   A.Insert (\"world\", 2);\n   A.Insert (\"!\",     3);\n   Index := A.First;\n   while Index /= No_Element loop\n      Put_Line (Key (Index) & Integer'Image (Element (Index)));\n      Index := Next (Index);\n   end loop;\nend Test_Iteration;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\n\nprocedure Test_Updates is\n\n   type Bucket_Index is range 1..13;\n   package Random_Index is new Ada.Numerics.Discrete_Random (Bucket_Index);\n   use Random_Index;\n   type Buckets is array (Bucket_Index) of Natural;\n\n   protected type Safe_Buckets is\n      procedure Initialize (Value : Buckets);\n      function Get (I : Bucket_Index) return Natural;\n      procedure Transfer (I, J : Bucket_Index; Amount : Integer);\n      function Snapshot return Buckets;\n   private\n      Data : Buckets := (others => 0);\n   end Safe_Buckets;\n\n   protected body Safe_Buckets is\n      procedure Initialize (Value : Buckets) is\n      begin\n         Data := Value;\n      end Initialize;\n\n      function Get (I : Bucket_Index) return Natural is\n      begin\n         return Data (I);\n      end Get;\n\n      procedure Transfer (I, J : Bucket_Index; Amount : Integer) is\n         Increment : constant Integer :=\n            Integer'Max (-Data (J), Integer'Min (Data (I), Amount));\n      begin\n         Data (I) := Data (I) - Increment;\n         Data (J) := Data (J) + Increment;\n      end Transfer;\n\n      function Snapshot return Buckets is\n      begin\n         return Data;\n      end Snapshot;\n   end Safe_Buckets;\n\n   Data : Safe_Buckets;\n\n   task Equalize;\n   task Mess_Up;\n\n   task body Equalize is\n      Dice : Generator;\n      I, J : Bucket_Index;\n   begin\n      loop\n         I := Random (Dice);\n         J := Random (Dice);\n         Data.Transfer (I, J, (Data.Get (I) - Data.Get (J)) / 2);\n      end loop;\n   end Equalize;\n\n   task body Mess_Up is\n      Dice : Generator;\n   begin\n      loop\n         Data.Transfer (Random (Dice), Random (Dice), 100);\n      end loop;\n   end Mess_Up;\n\nbegin\n   Data.Initialize ((1,2,3,4,5,6,7,8,9,10,11,12,13));\n   loop\n      delay 1.0;\n      declare\n         State : Buckets := Data.Snapshot;\n         Sum   : Natural := 0;\n      begin\n         for Index in State'Range loop\n            Sum := Sum + State (Index);\n            Put (Integer'Image (State (Index)));\n         end loop;\n         Put (\" =\" & Integer'Image (Sum));\n         New_Line;\n      end;\n   end loop;\nend Test_Updates;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Numerics.Generic_Elementary_Functions;\nwith Ada.Numerics.Discrete_Random;\nprocedure Avglen is\n   package IIO is new Ada.Text_IO.Integer_IO (Positive); use IIO;\n   package LFIO is new Ada.Text_IO.Float_IO (Long_Float); use LFIO;\n   subtype FactN is Natural range 0..20;\n   TESTS : constant Natural := 1_000_000;\n\n   function Factorial (N : FactN) return Long_Float is\n      Result : Long_Float := 1.0;\n   begin\n      for I in 2..N loop Result := Result * Long_Float(I); end loop;\n      return Result;\n   end Factorial;\n\n   function Analytical (N : FactN) return Long_Float is\n      Sum : Long_Float := 0.0;\n   begin\n      for I in 1..N loop\n         Sum := Sum + Factorial(N) / Factorial(N - I) / Long_Float(N)**I;\n      end loop;\n      return Sum;\n   end Analytical;\n\n   function Experimental (N : FactN) return Long_Float is\n      subtype RandInt is Natural range 1..N;\n      package Random is new Ada.Numerics.Discrete_Random(RandInt);\n      seed : Random.Generator;\n      Num : RandInt;\n      count : Natural := 0;\n      bits : array(RandInt'Range) of Boolean;\n   begin\n      Random.Reset(seed);\n      for run in 1..TESTS loop\n         bits := (others  => false);\n         for I in RandInt'Range loop\n            Num := Random.Random(seed); exit when bits(Num);\n            bits(Num) := True; count := count + 1;\n         end loop;\n      end loop;\n      return Long_Float(count)/Long_Float(TESTS);\n   end Experimental;\n\n   A, E, err : Long_Float;\nbegin\n   Put_Line(\" N  avg    calc   %diff\");\n   for I in 1..20 loop\n      A := Analytical(I);  E := Experimental(I); err := abs(E-A)/A*100.0;\n      Put(I, Width=>2); Put(E ,Aft=>4, exp=>0); Put(A, Aft=>4, exp=>0);\n      Put(err, Fore=>3, Aft=>3, exp=>0); New_line;\n   end loop;\nend Avglen;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Float_Text_Io; use Ada.Float_Text_Io;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Mean_Main is\n   type Vector is array (Positive range <>) of Float;\n   function Mean (Item : Vector) return float with pre => Item'length > 0;\n   function Mean (Item : Vector) return Float is\n      Sum : Float := 0.0;\n   begin\n      for I in Item'range loop\n         Sum := Sum + Item(I);\n      end loop;\n\t  return Sum / Float(Item'Length);\n   end Mean;\n   A : Vector := (3.0, 1.0, 4.0, 1.0, 5.0, 9.0);\nbegin\n    Put(Item => Mean (A), Fore => 1, Exp => 0);\n   New_Line;\n   -- test for zero length vector\n   Put(Item => Mean(A (1..0)), Fore => 1, Exp => 0);\n   New_Line;\nend Mean_Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Mean_Angles is\n\n   type X_Real is digits 4;      -- or more digits for improved precision\n   subtype Real is X_Real range 0.0 .. 360.0; -- the range of interest\n   type Angles is array(Positive range <>) of Real;\n\n   procedure Put(R: Real) is\n      package IO is new Ada.Text_IO.Float_IO(Real);\n   begin\n      IO.Put(R, Fore => 3, Aft => 2, Exp => 0);\n   end Put;\n\n   function Mean_Angle(A: Angles) return Real is\n      Sin_Sum, Cos_Sum: X_Real := 0.0; -- X_Real since sums might exceed 360.0\n      package Math is new Ada.Numerics.Generic_Elementary_Functions(Real);\n      use Math;\n   begin\n      for I in A'Range loop\n        Sin_Sum := Sin_Sum + Sin(A(I), Cycle => 360.0);\n        Cos_Sum := Cos_Sum + Cos(A(I), Cycle => 360.0);\n      end loop;\n      return Arctan(Sin_Sum / X_Real(A'Length), Cos_Sum / X_Real(A'Length),\n                    Cycle => 360.0);\n        -- may raise Ada.Numerics.Argument_Error if inputs are\n        -- numerically instable, e.g., when Cos_Sum is 0.0\n   end Mean_Angle;\n\nbegin\n   Put(Mean_Angle((10.0, 20.0, 30.0)));     Ada.Text_IO.New_Line;    -- 20.00\n   Put(Mean_Angle((10.0, 350.0)));          Ada.Text_IO.New_Line;    --  0.00\n   Put(Mean_Angle((90.0, 180.0, 270.0, 360.0))); -- Ada.Numerics.Argument_Error!\nend Mean_Angles;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Float_Text_IO;\n\nprocedure FindMedian is\n\n    f: array(1..10) of float := ( 4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5 );\n    min_idx: integer;\n    min_val, median_val, swap: float;\n\nbegin\n    for i in f'range loop\n        min_idx := i;\n        min_val := f(i);\n        for j in i+1 .. f'last loop\n            if f(j) < min_val then\n                min_idx := j;\n                min_val := f(j);\n            end if;\n        end loop;\n        swap := f(i); f(i) := f(min_idx); f(min_idx) := swap;\n    end loop;\n\n    if f'length mod 2 /= 0 then\n        median_val := f( f'length/2+1 );\n    else\n        median_val := ( f(f'length/2) + f(f'length/2+1) ) / 2.0;\n    end if;\n\n    Ada.Text_IO.Put( \"Median value: \" );\n    Ada.Float_Text_IO.Put( median_val );\n    Ada.Text_IO.New_line;\nend FindMedian;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   type Element_Type is private;\n   type Element_Array is array (Positive range <>) of Element_Type;\npackage Mode is\n\n   function Get_Mode (Set : Element_Array) return Element_Array;\n\nend Mode;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Indefinite_Vectors;\n\npackage body Mode is\n\n   -- map Count to Elements\n   package Count_Vectors is new Ada.Containers.Indefinite_Vectors\n     (Element_Type => Element_Array,\n      Index_Type => Positive);\n\n   procedure Add (To : in out Count_Vectors.Vector; Item : Element_Type) is\n      use type Count_Vectors.Cursor;\n      Position : Count_Vectors.Cursor := To.First;\n      Found    : Boolean              := False;\n   begin\n      while not Found and then Position /= Count_Vectors.No_Element loop\n         declare\n            Elements : Element_Array := Count_Vectors.Element (Position);\n         begin\n            for I in Elements'Range loop\n               if Elements (I) = Item then\n                  Found := True;\n               end if;\n            end loop;\n         end;\n         if not Found then\n            Position := Count_Vectors.Next (Position);\n         end if;\n      end loop;\n      if Position /= Count_Vectors.No_Element then\n         -- element found, remove it and insert to next count\n         declare\n            New_Position : Count_Vectors.Cursor :=\n               Count_Vectors.Next (Position);\n         begin\n            -- remove from old position\n            declare\n               Old_Elements : Element_Array :=\n                  Count_Vectors.Element (Position);\n               New_Elements : Element_Array (1 .. Old_Elements'Length - 1);\n               New_Index    : Positive      := New_Elements'First;\n            begin\n               for I in Old_Elements'Range loop\n                  if Old_Elements (I) /= Item then\n                     New_Elements (New_Index) := Old_Elements (I);\n                     New_Index                := New_Index + 1;\n                  end if;\n               end loop;\n               To.Replace_Element (Position, New_Elements);\n            end;\n            -- new position not already there?\n            if New_Position = Count_Vectors.No_Element then\n               declare\n                  New_Array : Element_Array (1 .. 1) := (1 => Item);\n               begin\n                  To.Append (New_Array);\n               end;\n            else\n               -- add to new position\n               declare\n                  Old_Elements : Element_Array :=\n                     Count_Vectors.Element (New_Position);\n                  New_Elements : Element_Array (1 .. Old_Elements'Length + 1);\n               begin\n                  New_Elements (1 .. Old_Elements'Length) := Old_Elements;\n                  New_Elements (New_Elements'Last)        := Item;\n                  To.Replace_Element (New_Position, New_Elements);\n               end;\n            end if;\n         end;\n      else\n         -- element not found, add to count 1\n         Position := To.First;\n         if Position = Count_Vectors.No_Element then\n            declare\n               New_Array : Element_Array (1 .. 1) := (1 => Item);\n            begin\n               To.Append (New_Array);\n            end;\n         else\n            declare\n               Old_Elements : Element_Array :=\n                  Count_Vectors.Element (Position);\n               New_Elements : Element_Array (1 .. Old_Elements'Length + 1);\n            begin\n               New_Elements (1 .. Old_Elements'Length) := Old_Elements;\n               New_Elements (New_Elements'Last)        := Item;\n               To.Replace_Element (Position, New_Elements);\n            end;\n         end if;\n      end if;\n   end Add;\n\n   function Get_Mode (Set : Element_Array) return Element_Array is\n      Counts : Count_Vectors.Vector;\n   begin\n      for I in Set'Range loop\n         Add (Counts, Set (I));\n      end loop;\n      return Counts.Last_Element;\n   end Get_Mode;\n\nend Mode;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Mode;\nprocedure Main is\n   type Int_Array is array (Positive range <>) of Integer;\n   package Int_Mode is new Mode (Integer, Int_Array);\n\n   Test_1 : Int_Array := (1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6);\n   Result : Int_Array := Int_Mode.Get_Mode (Test_1);\nbegin\n   Ada.Text_IO.Put (\"Input: \");\n   for I in Test_1'Range loop\n      Ada.Text_IO.Put (Integer'Image (Test_1 (I)));\n      if I /= Test_1'Last then\n         Ada.Text_IO.Put (\",\");\n      end if;\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Result:\");\n   for I in Result'Range loop\n      Ada.Text_IO.Put (Integer'Image (Result (I)));\n      if I /= Result'Last then\n         Ada.Text_IO.Put (\",\");\n      end if;\n   end loop;\n   Ada.Text_IO.New_Line;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "package Pythagorean_Means is\n   type Set is array (Positive range <>) of Float;\n   function Arithmetic_Mean (Data : Set) return Float;\n   function Geometric_Mean  (Data : Set) return Float;\n   function Harmonic_Mean   (Data : Set) return Float;\nend Pythagorean_Means;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Elementary_Functions;\npackage body Pythagorean_Means is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float);\n   function \"**\" (Left, Right : Float) return Float renames Math.\"**\";\n\n   function Arithmetic_Mean (Data : Set) return Float is\n      Sum : Float := 0.0;\n   begin\n      for I in Data'Range loop\n         Sum := Sum + Data (I);\n      end loop;\n      return Sum / Float (Data'Length);\n   end Arithmetic_Mean;\n\n   function Geometric_Mean (Data : Set) return Float is\n      Product : Float := 1.0;\n   begin\n      for I in Data'Range loop\n         Product := Product * Data (I);\n      end loop;\n      return Product**(1.0/Float(Data'Length));\n   end Geometric_Mean;\n\n   function Harmonic_Mean (Data : Set) return Float is\n      Reciprocal_Sum : Float := 0.0;\n   begin\n      for I in Data'Range loop\n         Reciprocal_Sum := Reciprocal_Sum + Data (I)**(-1);\n      end loop;\n      return Float (Data'Length) / Reciprocal_Sum;\n   end Harmonic_Mean;\n\nend Pythagorean_Means;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Pythagorean_Means;\nprocedure Main is\n   My_Set : Pythagorean_Means.Set := (1.0, 2.0, 3.0, 4.0,  5.0,\n                                      6.0, 7.0, 8.0, 9.0, 10.0);\n   Arithmetic_Mean : Float := Pythagorean_Means.Arithmetic_Mean (My_Set);\n   Geometric_Mean  : Float := Pythagorean_Means.Geometric_Mean  (My_Set);\n   Harmonic_Mean   : Float := Pythagorean_Means.Harmonic_Mean   (My_Set);\nbegin\n   Ada.Text_IO.Put_Line (Float'Image (Arithmetic_Mean) & \" >= \" &\n                         Float'Image (Geometric_Mean)  & \" >= \" &\n                         Float'Image (Harmonic_Mean));\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Float_Text_IO; use Ada.Float_Text_IO;\nwith Ada.Numerics.Elementary_Functions;\nuse Ada.Numerics.Elementary_Functions;\nprocedure calcrms is\n\ttype float_arr is array(1..10) of Float;\n\t\n\tfunction rms(nums : float_arr) return Float is\n\t\tsum : Float := 0.0;\n\t\tbegin\n\t\tfor p in nums'Range loop\n\t\t\tsum := sum + nums(p)**2;\n\t\tend loop;\n\t\treturn sqrt(sum/Float(nums'Length));\n\tend rms;\n\n\tlist : float_arr;\nbegin\nlist := (1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0);\nput( rms(list) , Exp=>0);\nend calcrms;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   Max_Elements : Positive;\n   type Number is digits <>;\npackage Moving is\n   procedure Add_Number (N : Number);\n   function Moving_Average (N : Number) return Number;\n   function Get_Average return Number;\nend Moving;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Vectors;\n\npackage body Moving is\n   use Ada.Containers;\n\n   package Number_Vectors is new Ada.Containers.Vectors\n     (Element_Type => Number,\n      Index_Type   => Natural);\n\n   Current_List : Number_Vectors.Vector := Number_Vectors.Empty_Vector;\n\n   procedure Add_Number (N : Number) is\n   begin\n      if Natural (Current_List.Length) >= Max_Elements then\n         Current_List.Delete_First;\n      end if;\n      Current_List.Append (N);\n   end Add_Number;\n\n   function Get_Average return Number is\n      Average : Number := 0.0;\n      procedure Sum (Position : Number_Vectors.Cursor) is\n      begin\n         Average := Average + Number_Vectors.Element (Position);\n      end Sum;\n   begin\n      Current_List.Iterate (Sum'Access);\n      if Current_List.Length > 1 then\n         Average := Average / Number (Current_List.Length);\n      end if;\n      return Average;\n   end Get_Average;\n\n   function Moving_Average (N : Number) return Number is\n   begin\n      Add_Number (N);\n      return Get_Average;\n   end Moving_Average;\n\nend Moving;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Moving;\nprocedure Main is\n   package Three_Average is new Moving (Max_Elements => 3, Number => Float);\n   package Five_Average is new Moving (Max_Elements => 5, Number => Float);\nbegin\n   for I in 1 .. 5 loop\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-3: \" & Float'Image (Three_Average.Moving_Average (Float (I))));\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-5: \" & Float'Image (Five_Average.Moving_Average (Float (I))));\n   end loop;\n   for I in reverse 1 .. 5 loop\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-3: \" & Float'Image (Three_Average.Moving_Average (Float (I))));\n      Ada.Text_IO.Put_Line (\"Inserting\" & Integer'Image (I) &\n        \" into max-5: \" & Float'Image (Five_Average.Moving_Average (Float (I))));\n   end loop;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Discrete_Random;\nwith Ada.Text_IO;\nwith Ada.Strings.Fixed;\nprocedure Brackets is\n   package Random_Positive is new Ada.Numerics.Discrete_Random (Positive);\n   Positive_Generator : Random_Positive.Generator;\n   procedure Swap (Left, Right : in out Character) is\n      Temp : constant Character := Left;\n   begin\n      Left := Right;\n      Right := Temp;\n   end Swap;\n   function Generate_Brackets (Bracket_Count : Natural;\n                               Opening_Bracket : Character := '[';\n                               Closing_Bracket : Character := ']')\n            return String is\n      use Ada.Strings.Fixed;\n      All_Brackets : String := Bracket_Count * Opening_Bracket & Bracket_Count * Closing_Bracket;\n   begin\n      for I in All_Brackets'Range loop\n         Swap (All_Brackets (I), All_Brackets (Random_Positive.Random (Positive_Generator) mod (Bracket_Count * 2) + 1));\n      end loop;\n      return All_Brackets;\n   end Generate_Brackets;\n\n   function Check_Brackets (Test : String;\n                            Opening_Bracket : Character := '[';\n                            Closing_Bracket : Character := ']')\n            return Boolean is\n      Open : Natural := 0;\n   begin\n      for I in Test'Range loop\n         if Test (I) = Opening_Bracket then\n            Open := Open + 1;\n         elsif Test (I) = Closing_Bracket then\n            if Open = 0 then\n               return False;\n            else\n               Open := Open - 1;\n            end if;\n         end if;\n      end loop;\n      return True;\n   end Check_Brackets;\nbegin\n   Random_Positive.Reset (Positive_Generator);\n   Ada.Text_IO.Put_Line (\"Brackets\");\n   for I in 0 .. 4 loop\n      for J in 0 .. I loop\n         declare\n            My_String : constant String := Generate_Brackets (I);\n         begin\n            Ada.Text_IO.Put_Line (My_String & \": \" & Boolean'Image (Check_Brackets (My_String)));\n         end;\n      end loop;\n   end loop;\nend Brackets;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Finalization;\n\npackage BT is\n\n   type Balanced_Ternary is private;\n\n   -- conversions\n   function To_Balanced_Ternary (Num : Integer) return Balanced_Ternary;\n   function To_Balanced_Ternary (Str : String)  return Balanced_Ternary;\n   function To_Integer (Num : Balanced_Ternary)  return Integer;\n   function To_string (Num : Balanced_Ternary)   return String;\n\n   -- Arithmetics\n   -- unary minus\n   function \"-\" (Left : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n\n   -- subtraction\n   function \"-\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n\n   -- addition\n   function \"+\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n   -- multiplication\n   function \"*\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary;\n\nprivate\n   -- a balanced ternary number is a unconstrained array of (1,0,-1)\n   -- dinamically allocated, least significant trit leftmost\n   type Trit is range -1..1;\n   type Trit_Array is array (Positive range <>) of Trit;\n   pragma Pack(Trit_Array);\n\n   type Trit_Access is access Trit_Array;\n\n   type Balanced_Ternary is new Ada.Finalization.Controlled\n     with record\n\tRef : Trit_access;\n   end record;\n\n   procedure Initialize (Object : in out Balanced_Ternary);\n   procedure Adjust     (Object : in out Balanced_Ternary);\n   procedure Finalize   (Object : in out Balanced_Ternary);\n\nend BT;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Unchecked_Deallocation;\n\npackage body BT is\n\n   procedure Free is new Ada.Unchecked_Deallocation (Trit_Array, Trit_Access);\n\n   -- Conversions\n   -- String to BT\n   function To_Balanced_Ternary (Str: String) return Balanced_Ternary is\n      J : Positive := 1;\n      Tmp : Trit_Access;\n   begin\n      Tmp := new Trit_Array (1..Str'Last);\n      for I in reverse Str'Range loop\n\t case Str(I) is\n\t    when '+' => Tmp (J) := 1;\n\t    when '-' => Tmp (J) := -1;\n\t    when '0' => Tmp (J) := 0;\n\t    when others => raise Constraint_Error;\n\t end case;\n\t J := J + 1;\n      end loop;\n      return (Ada.Finalization.Controlled with Ref => Tmp);\n   end To_Balanced_Ternary;\n\n   -- Integer to BT\n   function To_Balanced_Ternary (Num: Integer) return Balanced_Ternary is\n      K      : Integer := 0;\n      D      : Integer;\n      Value  : Integer := Num;\n      Tmp    : Trit_Array(1..19); -- 19 trits is enough to contain\n                                   -- a 32 bits signed integer\n   begin\n      loop\n\t D := (Value mod 3**(K+1))/3**K;\n\t if D = 2 then D := -1; end if;\n\t Value := Value - D*3**K;\n\t K := K + 1;\n\t Tmp(K) := Trit(D);\n\t exit when Value = 0;\n      end loop;\n      return (Ada.Finalization.Controlled\n\t\twith Ref => new Trit_Array'(Tmp(1..K)));\n   end To_Balanced_Ternary;\n\n   -- BT to Integer --\n   -- If the BT number is too large Ada will raise CONSTRAINT ERROR\n   function To_Integer (Num : Balanced_Ternary) return Integer is\n      Value : Integer := 0;\n      Pos : Integer := 1;\n   begin\n      for I in Num.Ref.all'Range loop\n\t Value := Value + Integer(Num.Ref(I)) * Pos;\n\t Pos := Pos * 3;\n      end loop;\n      return Value;\n   end To_Integer;\n\n   -- BT to String --\n   function To_String (Num : Balanced_Ternary) return String is\n      I : constant Integer := Num.Ref.all'Last;\n      Result : String (1..I);\n   begin\n      for J in Result'Range loop\n\t case Num.Ref(I-J+1) is\n\t    when 0  => Result(J) := '0';\n\t    when -1 => Result(J) := '-';\n\t    when 1  => Result(J) := '+';\n\t end case;\n      end loop;\n      return Result;\n   end To_String;\n\n   -- unary minus --\n   function \"-\" (Left : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n      Result : constant Balanced_Ternary := Left;\n   begin\n      for I in Result.Ref.all'Range loop\n\t Result.Ref(I) := - Result.Ref(I);\n      end loop;\n      return Result;\n   end \"-\";\n\n   -- addition --\n   Carry : Trit;\n\n   function Add (Left, Right : in Trit)\n\t\treturn Trit is\n   begin\n      if Left /= Right then\n\t Carry := 0;\n\t return Left + Right;\n      else\n\t Carry := Left;\n\t return -Right;\n      end if;\n   end Add;\n   pragma Inline (Add);\n\n   function \"+\" (Left, Right : in Trit_Array)\n\t\treturn Balanced_Ternary is\n      Max_Size : constant Integer :=\n\tInteger'Max(Left'Last, Right'Last);\n      Tmp_Left, Tmp_Right : Trit_Array(1..Max_Size) := (others => 0);\n      Result : Trit_Array(1..Max_Size+1) := (others => 0);\n   begin\n      Tmp_Left (1..Left'Last) := Left;\n      Tmp_Right(1..Right'Last) := Right;\n      for I in Tmp_Left'Range loop\n\t Result(I) := Add (Result(I), Tmp_Left(I));\n\t Result(I+1) := Carry;\n\t Result(I) := Add(Result(I), Tmp_Right(I));\n\t Result(I+1) := Add(Result(I+1), Carry);\n      end loop;\n      -- remove trailing zeros\n      for I in reverse Result'Range loop\n\t if Result(I) /= 0 then\n\t    return (Ada.Finalization.Controlled\n\t\t      with Ref => new Trit_Array'(Result(1..I)));\n\t end if;\n      end loop;\n      return (Ada.Finalization.Controlled\n\t\twith Ref => new Trit_Array'(1 => 0));\n   end \"+\";\n\n   function \"+\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n   begin\n      return Left.Ref.all + Right.Ref.all;\n   end \"+\";\n\n   -- Subtraction\n   function \"-\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n   begin\n      return Left + (-Right);\n   end \"-\";\n\n   -- multiplication\n   function \"*\" (Left, Right : in Balanced_Ternary)\n\t\treturn Balanced_Ternary is\n      A, B : Trit_Access;\n      Result : Balanced_Ternary;\n   begin\n      if Left.Ref.all'Length > Right.Ref.all'Length then\n\t A := Right.Ref; B := Left.Ref;\n      else\n\t B := Right.Ref; A := Left.Ref;\n      end if;\n      for I in A.all'Range loop\n\t if A(I) /= 0 then\n\t    declare\n\t       Tmp_Result : Trit_Array (1..I+B.all'Length-1) := (others => 0);\n\t    begin\n\t       for J in B.all'Range loop\n\t\t  Tmp_Result(I+J-1) := B(J) * A(I);\n\t       end loop;\n\t       Result := Result.Ref.all + Tmp_Result;\n\t    end;\n\t end if;\n      end loop;\n      return Result;\n   end \"*\";\n\n   procedure Adjust (Object : in out Balanced_Ternary) is\n   begin\n      Object.Ref := new Trit_Array'(Object.Ref.all);\n   end Adjust;\n\n   procedure Finalize  (Object : in out Balanced_Ternary) is\n   begin\n      Free (Object.Ref);\n   end Finalize;\n\n   procedure Initialize (Object : in out Balanced_Ternary) is\n   begin\n      Object.Ref := new Trit_Array'(1 => 0);\n   end Initialize;\n\nend BT;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\nwith Ada.Integer_Text_Io; use Ada.Integer_Text_Io;\nwith BT; use BT;\n\nprocedure TestBT is\n   Result, A, B, C : Balanced_Ternary;\nbegin\n   A := To_Balanced_Ternary(\"+-0++0+\");\n   B := To_Balanced_Ternary(-436);\n   C := To_Balanced_Ternary(\"+-++-\");\n\n   Result := A * (B - C);\n\n   Put(\"a = \"); Put(To_integer(A), 4); New_Line;\n   Put(\"b = \"); Put(To_integer(B), 4); New_Line;\n   Put(\"c = \"); Put(To_integer(C), 4); New_Line;\n   Put(\"a * (b - c) = \"); Put(To_integer(Result), 4);\n   Put_Line (\" \" & To_String(Result));\nend TestBT;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Benford is\n\n   subtype Nonzero_Digit is Natural range 1 .. 9;\n   function First_Digit(S: String) return Nonzero_Digit is\n      (if S(S'First) in '1' .. '9'\n         then Nonzero_Digit'Value(S(S'First .. S'First))\n         else First_Digit(S(S'First+1 .. S'Last)));\n\n   package N_IO is new Ada.Text_IO.Integer_IO(Natural);\n\n   procedure Print(D: Nonzero_Digit; Counted, Sum: Natural) is\n      package Math is new Ada.Numerics.Generic_Elementary_Functions(Float);\n      package F_IO is new Ada.Text_IO.Float_IO(Float);\n      Actual: constant Float := Float(Counted) / Float(Sum);\n      Expected: constant Float := Math.Log(1.0 + 1.0 / Float(D), Base => 10.0);\n      Deviation: constant Float := abs(Expected-Actual);\n   begin\n      N_IO.Put(D, 5);\n      N_IO.Put(Counted, 14);\n      F_IO.Put(Float(Sum)*Expected, Fore => 16, Aft => 1, Exp => 0);\n      F_IO.Put(100.0*Actual, Fore => 9, Aft => 2, Exp => 0);\n      F_IO.Put(100.0*Expected, Fore => 11, Aft => 2, Exp => 0);\n      F_IO.Put(100.0*Deviation, Fore => 13, Aft => 2, Exp => 0);\n   end Print;\n\n   Cnt: array(Nonzero_Digit) of Natural := (1 .. 9 => 0);\n   D: Nonzero_Digit;\n   Sum: Natural := 0;\n   Counter: Positive;\n\nbegin\n   while not Ada.Text_IO.End_Of_File loop\n      -- each line in the input file holds Counter, followed by Fib(Counter)\n      N_IO.Get(Counter);\n        -- Counter and skip it, we just don't need it\n      D := First_Digit(Ada.Text_IO.Get_Line);\n        -- read the rest of the line and extract the first digit\n      Cnt(D) := Cnt(D)+1;\n      Sum := Sum + 1;\n   end loop;\n   Ada.Text_IO.Put_Line(\" Digit  Found[total]   Expected[total]    Found[%]\"\n                                          & \"   Expected[%]   Difference[%]\");\n   for I in Nonzero_Digit loop\n      Print(I, Cnt(I), Sum);\n      Ada.Text_IO.New_Line;\n   end loop;\nend Benford;\n"
  },
  {
    "language": "Ada",
    "code": "      -- N_IO.Get(Counter);\n"
  },
  {
    "language": "Ada",
    "code": "WITH GMP.Rationals, GMP.Integers, Ada.Text_IO, Ada.Strings.Fixed, Ada.Strings;\nUSE GMP.Rationals, GMP.Integers, Ada.Text_IO, Ada.Strings.Fixed, Ada.Strings;\n\nPROCEDURE Main IS\n\n   FUNCTION Bernoulli_Number (N : Natural) RETURN Unbounded_Fraction IS\n      FUNCTION \"/\" (Left, Right : Natural) RETURN Unbounded_Fraction IS\n        (To_Unbounded_Integer (Left) / To_Unbounded_Integer (Right));\n      A : ARRAY (0 .. N) OF Unbounded_Fraction;\n   BEGIN\n      FOR M IN 0 .. N LOOP\n         A (M) := 1 / (M + 1);\n         FOR J IN REVERSE 1 .. M LOOP\n            A (J - 1) := (J / 1 ) * (A (J - 1) - A (J));\n         END LOOP;\n      END LOOP;\n      RETURN A (0);\n   END Bernoulli_Number;\n\nBEGIN\n   FOR I IN 0 .. 60 LOOP\n      IF I MOD 2 = 0 OR I = 1 THEN\n         DECLARE\n            B : Unbounded_Fraction := Bernoulli_Number (I);\n            S : String := Image (GMP.Rationals.Numerator (B));\n         BEGIN\n            Put_Line (\"B (\" & (IF I < 10 THEN \" \" ELSE \"\") &  Trim (I'Img, Left)\n                      & \")=\" & (44 - S'Length) * \" \" & Image (B));\n         END;\n      END IF;\n   END LOOP;\nEND Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Strings.Unbounded;\n\nprocedure Best_Shuffle is\n\n   function Best_Shuffle (S : String) return String;\n\n   function Best_Shuffle (S : String) return String is\n      T : String (S'Range) := S;\n      Tmp : Character;\n   begin\n      for I in S'Range loop\n         for J in S'Range loop\n            if I /= J and S (I) /= T (J) and S (J) /= T (I) then\n               Tmp  := T (I);\n               T (I) := T (J);\n               T (J) := Tmp;\n            end if;\n         end loop;\n      end loop;\n      return T;\n   end Best_Shuffle;\n\n   Test_Cases : constant array (1 .. 6)\n     of Ada.Strings.Unbounded.Unbounded_String :=\n                  (Ada.Strings.Unbounded.To_Unbounded_String (\"abracadabra\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"seesaw\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"elk\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"grrrrrr\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"up\"),\n                   Ada.Strings.Unbounded.To_Unbounded_String (\"a\"));\n\nbegin -- main procedure\n   for Test_Case in Test_Cases'Range loop\n      declare\n         Original : constant String := Ada.Strings.Unbounded.To_String\n           (Test_Cases (Test_Case));\n         Shuffle  : constant String := Best_Shuffle (Original);\n         Score : Natural := 0;\n      begin\n         for I in Original'Range loop\n            if Original (I) = Shuffle (I) then\n               Score := Score + 1;\n            end if;\n         end loop;\n         Ada.Text_IO.Put_Line (Original & \", \" & Shuffle & \", (\" &\n                                Natural'Image (Score) & \" )\");\n      end;\n   end loop;\nend Best_Shuffle;\n"
  },
  {
    "language": "Ada",
    "code": "with ada.text_io; use ada.text_io;\nprocedure binary is\n  bit : array (0..1) of character := ('0','1');\n\n  function bin_image (n : Natural) return string is\n  (if n < 2 then (1 => bit (n)) else bin_image (n / 2) & bit (n mod 2));\n\n  test_values : array (1..3) of Natural := (5,50,9000);\nbegin\n  for test of test_values loop\n\tput_line (\"Output for\" & test'img & \" is \" & bin_image (test));\n  end loop;\nend binary;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Recursive_Binary_Search is\n   Not_Found : exception;\n\n   generic\n      type Index is range <>;\n      type Element is private;\n      type Array_Of_Elements is array (Index range <>) of Element;\n      with function \"<\" (L, R : Element) return Boolean is <>;\n   function Search (Container : Array_Of_Elements; Value : Element) return Index;\n\n   function Search (Container : Array_Of_Elements; Value : Element) return Index is\n      Mid : Index;\n   begin\n      if Container'Length > 0 then\n         Mid := (Container'First + Container'Last) / 2;\n         if Value < Container (Mid) then\n            if Container'First /= Mid then\n               return Search (Container (Container'First..Mid - 1), Value);\n            end if;\n         elsif Container (Mid) < Value then\n            if Container'Last /= Mid then\n               return Search (Container (Mid + 1..Container'Last), Value);\n            end if;\n         else\n            return Mid;\n         end if;\n      end if;\n      raise Not_Found;\n   end Search;\n\n   type Integer_Array is array (Positive range <>) of Integer;\n   function Find is new Search (Positive, Integer, Integer_Array);\n\n   procedure Test (X : Integer_Array; E : Integer) is\n   begin\n      New_Line;\n      for I in X'Range loop\n         Put (Integer'Image (X (I)));\n      end loop;\n      Put (\" contains\" & Integer'Image (E) & \" at\" & Integer'Image (Find (X, E)));\n   exception\n      when Not_Found =>\n         Put (\" does not contain\" & Integer'Image (E));\n   end Test;\nbegin\n   Test ((2, 4, 6, 8, 9), 2);\n   Test ((2, 4, 6, 8, 9), 1);\n   Test ((2, 4, 6, 8, 9), 8);\n   Test ((2, 4, 6, 8, 9), 10);\n   Test ((2, 4, 6, 8, 9), 9);\n   Test ((2, 4, 6, 8, 9), 5);\nend Test_Recursive_Binary_Search;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Binary_Search is\n   Not_Found : exception;\n\n   generic\n      type Index is range <>;\n      type Element is private;\n      type Array_Of_Elements is array (Index range <>) of Element;\n      with function \"<\" (L, R : Element) return Boolean is <>;\n   function Search (Container : Array_Of_Elements; Value : Element) return Index;\n\n   function Search (Container : Array_Of_Elements; Value : Element) return Index is\n      Low  : Index := Container'First;\n      High : Index := Container'Last;\n      Mid  : Index;\n   begin\n      if Container'Length > 0 then\n         loop\n            Mid := (Low + High) / 2;\n            if Value < Container (Mid) then\n               exit when Low = Mid;\n               High := Mid - 1;\n            elsif Container (Mid) < Value then\n               exit when High = Mid;\n               Low := Mid + 1;\n            else\n               return Mid;\n            end if;\n         end loop;\n      end if;\n      raise Not_Found;\n   end Search;\n\n   type Integer_Array is array (Positive range <>) of Integer;\n   function Find is new Search (Positive, Integer, Integer_Array);\n\n   procedure Test (X : Integer_Array; E : Integer) is\n   begin\n      New_Line;\n      for I in X'Range loop\n         Put (Integer'Image (X (I)));\n      end loop;\n      Put (\" contains\" & Integer'Image (E) & \" at\" & Integer'Image (Find (X, E)));\n   exception\n      when Not_Found =>\n         Put (\" does not contain\" & Integer'Image (E));\n   end Test;\nbegin\n   Test ((2, 4, 6, 8, 9), 2);\n   Test ((2, 4, 6, 8, 9), 1);\n   Test ((2, 4, 6, 8, 9), 8);\n   Test ((2, 4, 6, 8, 9), 10);\n   Test ((2, 4, 6, 8, 9), 9);\n   Test ((2, 4, 6, 8, 9), 5);\nend Test_Binary_Search;\n"
  },
  {
    "language": "Ada",
    "code": "declare\n   Data : Storage_Array (1..20); -- Data created\nbegin\n   Data := (others => 0); -- Assign all zeros\n   if Data = (1..10 => 0) then -- Compare with 10 zeros\n      declare\n         Copy : Storage_Array := Data; -- Copy Data\n      begin\n         if Data'Length = 0 then -- If empty\n            ...\n         end if;\n      end;\n   end if;\n   ... Data & 1 ...         -- The result is Data with byte 1 appended\n   ... Data & (1,2,3,4) ... -- The result is Data with bytes 1,2,3,4 appended\n   ... Data (3..5) ...      -- The result the substring of Data from 3 to 5\nend; -- Data destructed\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  char is_open[100] = { 0 };\n  int pass, door;\n\n  /* do the 100 passes */\n  for (pass = 0; pass < 100; ++pass)\n    for (door = pass; door < 100; door += pass+1)\n      is_open[door] = !is_open[door];\n\n  /* output the result */\n  for (door = 0; door < 100; ++door)\n    printf(\"door #%d is %s.\\n\", door+1, (is_open[door]? \"open\" : \"closed\"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NUM_DOORS 100\n\nint main(int argc, char *argv[])\n{\n  int is_open[NUM_DOORS] = { 0 } ;\n  int * doorptr, * doorlimit = is_open + NUM_DOORS ;\n  int pass ;\n\n  /* do the N passes, go backwards because the order is not important */\n  for ( pass= NUM_DOORS ; ( pass ) ; -- pass ) {\n    for ( doorptr= is_open + ( pass-1 ); ( doorptr < doorlimit ) ; doorptr += pass ) {\n      ( * doorptr ) ^= 1 ;\n    }\n  }\n\n  /* output results */\n  for ( doorptr= is_open ; ( doorptr != doorlimit ) ; ++ doorptr ) {\n    printf(\"door #%ld is %s\\n\", ( doorptr - is_open ) + 1, ( * doorptr ) ? \"open\" : \"closed\" ) ;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int square = 1, increment = 3, door;\n  for (door = 1; door <= 100; ++door)\n  {\n    printf(\"door #%d\", door);\n    if (door == square)\n    {\n      printf(\" is open.\\n\");\n      square += increment;\n      increment += 2;\n    }\n    else\n      printf(\" is closed.\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int door, square, increment;\n  for (door = 1, square = 1, increment = 1; door <= 100; door++ == square && (square += increment += 2))\n    printf(\"door #%d is %s.\\n\", door, (door == square? \"open\" : \"closed\"));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint i;\n\tfor (i = 1; i * i <= 100; i++)\n\t\tprintf(\"door %d open\\n\", i * i);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define n_cards 4\n#define solve_goal 24\n#define max_digit 9\n\ntypedef struct { int num, denom; } frac_t, *frac;\ntypedef enum { C_NUM = 0, C_ADD, C_SUB, C_MUL, C_DIV } op_type;\n\ntypedef struct expr_t *expr;\ntypedef struct expr_t {\n        op_type op;\n        expr left, right;\n        int value;\n} expr_t;\n\nvoid show_expr(expr e, op_type prec, int is_right)\n{\n        const char * op;\n        switch(e->op) {\n        case C_NUM:     printf(\"%d\", e->value);\n                        return;\n        case C_ADD:     op = \" + \"; break;\n        case C_SUB:     op = \" - \"; break;\n        case C_MUL:     op = \" x \"; break;\n        case C_DIV:     op = \" / \"; break;\n        }\n\n        if ((e->op == prec && is_right) || e->op < prec) printf(\"(\");\n        show_expr(e->left, e->op, 0);\n        printf(\"%s\", op);\n        show_expr(e->right, e->op, 1);\n        if ((e->op == prec && is_right) || e->op < prec) printf(\")\");\n}\n\nvoid eval_expr(expr e, frac f)\n{\n        frac_t left, right;\n        if (e->op == C_NUM) {\n                f->num = e->value;\n                f->denom = 1;\n                return;\n        }\n        eval_expr(e->left, &left);\n        eval_expr(e->right, &right);\n        switch (e->op) {\n        case C_ADD:\n                f->num = left.num * right.denom + left.denom * right.num;\n                f->denom = left.denom * right.denom;\n                return;\n        case C_SUB:\n                f->num = left.num * right.denom - left.denom * right.num;\n                f->denom = left.denom * right.denom;\n                return;\n        case C_MUL:\n                f->num = left.num * right.num;\n                f->denom = left.denom * right.denom;\n                return;\n        case C_DIV:\n                f->num = left.num * right.denom;\n                f->denom = left.denom * right.num;\n                return;\n        default:\n                fprintf(stderr, \"Unknown op: %d\\n\", e->op);\n                return;\n        }\n}\nint solve(expr ex_in[], int len)\n{\n        int i, j;\n        expr_t node;\n        expr ex[n_cards];\n        frac_t final;\n\n        if (len == 1) {\n                eval_expr(ex_in[0], &final);\n                if (final.num == final.denom * solve_goal && final.denom) {\n                        show_expr(ex_in[0], 0, 0);\n                        return 1;\n                }\n                return 0;\n        }\n\n        for (i = 0; i < len - 1; i++) {\n                for (j = i + 1; j < len; j++)\n                        ex[j - 1] = ex_in[j];\n                ex[i] = &node;\n                for (j = i + 1; j < len; j++) {\n                        node.left = ex_in[i];\n                        node.right = ex_in[j];\n                        for (node.op = C_ADD; node.op <= C_DIV; node.op++)\n                                if (solve(ex, len - 1))\n                                        return 1;\n\n                        node.left = ex_in[j];\n                        node.right = ex_in[i];\n                        node.op = C_SUB;\n                        if (solve(ex, len - 1)) return 1;\n                        node.op = C_DIV;\n                        if (solve(ex, len - 1)) return 1;\n\n                        ex[j] = ex_in[j];\n                }\n                ex[i] = ex_in[i];\n        }\n\n        return 0;\n}\n\nint solve24(int n[])\n{\n        int i;\n        expr_t ex[n_cards];\n        expr   e[n_cards];\n        for (i = 0; i < n_cards; i++) {\n                e[i] = ex + i;\n                ex[i].op = C_NUM;\n                ex[i].left = ex[i].right = 0;\n                ex[i].value = n[i];\n        }\n        return solve(e, n_cards);\n}\n\nint main()\n{\n        int i, j, n[] = { 3, 3, 8, 8, 9 };\n        srand(time(0));\n\n        for (j = 0; j < 10; j++) {\n                for (i = 0; i < n_cards; i++) {\n                        n[i] = 1 + (double) rand() * max_digit / RAND_MAX;\n                        printf(\" %d\", n[i]);\n                }\n                printf(\":  \");\n                printf(solve24(n) ? \"\\n\" : \"No solution\\n\");\n        }\n\n        return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <setjmp.h>\n#include <time.h>\n\njmp_buf ctx;\nconst char *msg;\n\nenum { OP_NONE = 0, OP_NUM, OP_ADD, OP_SUB, OP_MUL, OP_DIV };\n\ntypedef struct expr_t *expr, expr_t;\nstruct expr_t {\n\tint op, val, used;\n\texpr left, right;\n};\n\n#define N_DIGITS 4\nexpr_t digits[N_DIGITS];\n\nvoid gen_digits()\n{\n\tint i;\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].val = 1 + rand() % 9;\n}\n\n#define MAX_INPUT 64\nchar str[MAX_INPUT];\nint pos;\n\n#define POOL_SIZE 8\nexpr_t pool[POOL_SIZE];\nint pool_ptr;\n\nvoid reset()\n{\n\tint i;\n\tmsg = 0;\n\tpool_ptr = pos = 0;\n\tfor (i = 0; i < POOL_SIZE; i++) {\n\t\tpool[i].op = OP_NONE;\n\t\tpool[i].left = pool[i].right = 0;\n\t}\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].used = 0;\n}\n\n/* longish jumpish back to input cycle */\nvoid bail(const char *s)\n{\n\tmsg = s;\n\tlongjmp(ctx, 1);\n}\n\nexpr new_expr()\n{\n\tif (pool_ptr < POOL_SIZE)\n\t\treturn pool + pool_ptr++;\n\treturn 0;\n}\n\n/* check next input char */\nint next_tok()\n{\n\twhile (isspace(str[pos])) pos++;\n\treturn str[pos];\n}\n\n/* move input pointer forward */\nint take()\n{\n\tif (str[pos] != '\\0') return ++pos;\n\treturn 0;\n}\n\n/* BNF(ish)\nexpr = term { (\"+\")|(\"-\") term }\nterm = fact { (\"*\")|(\"/\") expr }\nfact =\tnumber\n\t| '(' expr ')'\n*/\n\nexpr get_fact();\nexpr get_term();\nexpr get_expr();\n\nexpr get_expr()\n{\n\tint c;\n\texpr l, r, ret;\n\tif (!(ret = get_term())) bail(\"Expected term\");\n\twhile ((c = next_tok()) == '+' || c == '-') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\t\tif (!(r = get_term())) bail(\"Expected term\");\n\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '+') ? OP_ADD : OP_SUB;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n\nexpr get_term()\n{\n\tint c;\n\texpr l, r, ret;\n\tret = get_fact();\n\twhile((c = next_tok()) == '*' || c == '/') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\n\t\tr = get_fact();\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '*') ? OP_MUL : OP_DIV;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n\nexpr get_digit()\n{\n\tint i, c = next_tok();\n\texpr ret;\n\tif (c >= '0' && c <= '9') {\n\t\ttake();\n\t\tret = new_expr();\n\t\tret->op = OP_NUM;\n\t\tret->val = c - '0';\n\t\tfor (i = 0; i < N_DIGITS; i++)\n\t\t\tif (digits[i].val == ret->val && !digits[i].used) {\n\t\t\t\tdigits[i].used = 1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\tbail(\"Invalid digit\");\n\t}\n\treturn 0;\n}\n\nexpr get_fact()\n{\n\tint c;\n\texpr l = get_digit();\n\tif (l) return l;\n\tif ((c = next_tok()) == '(') {\n\t\ttake();\n\t\tl = get_expr();\n\t\tif (next_tok() != ')') bail(\"Unbalanced parens\");\n\t\ttake();\n\t\treturn l;\n\t}\n\treturn 0;\n}\n\nexpr parse()\n{\n\tint i;\n\texpr ret = get_expr();\n\tif (next_tok() != '\\0')\n\t\tbail(\"Trailing garbage\");\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tif (!digits[i].used)\n\t\t\tbail(\"Not all digits are used\");\n\treturn ret;\n}\n\ntypedef struct frac_t frac_t, *frac;\nstruct frac_t { int denom, num; };\n\nint gcd(int m, int n)\n{\n\tint t;\n\twhile (m) {\n\t\tt = m; m = n % m; n = t;\n\t}\n\treturn n;\n}\n\n/* evaluate expression tree.  result in fraction form */\nvoid eval_tree(expr e, frac res)\n{\n\tfrac_t l, r;\n\tint t;\n\tif (e->op == OP_NUM) {\n\t\tres->num = e->val;\n\t\tres->denom = 1;\n\t\treturn;\n\t}\n\n\teval_tree(e->left, &l);\n\teval_tree(e->right, &r);\n\n\tswitch(e->op) {\n\tcase OP_ADD:\n\t\tres->num = l.num * r.denom + l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_SUB:\n\t\tres->num = l.num * r.denom - l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_MUL:\n\t\tres->num = l.num * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_DIV:\n\t\tres->num = l.num * r.denom;\n\t\tres->denom = l.denom * r.num;\n\t\tbreak;\n\t}\n\tif ((t = gcd(res->denom, res->num))) {\n\t\tres->denom /= t;\n\t\tres->num /= t;\n\t}\n}\n\nvoid get_input()\n{\n\tint i;\nreinput:\n\treset();\n\tprintf(\"\\nAvailable digits are:\");\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tprintf(\" %d\", digits[i].val);\n\tprintf(\". Type an expression and I'll check it for you, or make new numbers.\\n\"\n\t\t\"Your choice? [Expr/n/q] \");\n\n\twhile (1) {\n\t\tfor (i = 0; i < MAX_INPUT; i++) str[i] = '\\n';\n\t\tfgets(str, MAX_INPUT, stdin);\n\t\tif (*str == '\\0') goto reinput;\n\t\tif (str[MAX_INPUT - 1] != '\\n')\n\t\t\tbail(\"string too long\");\n\n\t\tfor (i = 0; i < MAX_INPUT; i++)\n\t\t\tif (str[i] == '\\n') str[i] = '\\0';\n\t\tif (str[0] == 'q') {\n\t\t\tprintf(\"Bye\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (str[0] == 'n') {\n\t\t\tgen_digits();\n\t\t\tgoto reinput;\n\t\t}\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tfrac_t f;\n\tsrand(time(0));\n\n\tgen_digits();\n\twhile(1) {\n\t\tget_input();\n\t\tsetjmp(ctx); /* if parse error, jump back here with err msg set */\n\t\tif (msg) {\n\t\t\t/* after error jump; announce, reset, redo */\n\t\t\tprintf(\"%s at '%.*s'\\n\", msg, pos, str);\n\t\t\tcontinue;\n\t\t}\n\n\t\teval_tree(parse(), &f);\n\n\t\tif (f.denom == 0) bail(\"Divide by zero\");\n\t\tif (f.denom == 1 && f.num == 24)\n\t\t\tprintf(\"You got 24.  Very good.\\n\");\n\t\telse {\n\t\t\tif (f.denom == 1)\n\t\t\t\tprintf(\"Eval to: %d, \", f.num);\n\t\t\telse\n\t\t\t\tprintf(\"Eval to: %d/%d, \", f.num, f.denom);\n\t\t\tprintf(\"no good.  Try again.\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <gmp.h>\n\n#define N 100000\nmpz_t p[N + 1];\n\nvoid calc(int n)\n{\n\tmpz_init_set_ui(p[n], 0);\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tint d = n - k * (3 * k - 1) / 2;\n\t\tif (d < 0) break;\n\n\t\tif (k&1)mpz_add(p[n], p[n], p[d]);\n\t\telse\tmpz_sub(p[n], p[n], p[d]);\n\n\t\td -= k;\n\t\tif (d < 0) break;\n\n\t\tif (k&1)mpz_add(p[n], p[n], p[d]);\n\t\telse\tmpz_sub(p[n], p[n], p[d]);\n\t}\n}\n\nint main(void)\n{\n\tint idx[] = { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n\tint at = 0;\n\n\tmpz_init_set_ui(p[0], 1);\n\n\tfor (int i = 1; idx[at]; i++) {\n\t\tcalc(i);\n\t\tif (i != idx[at]) continue;\n\n\t\tgmp_printf(\"%2d:\\t%Zd\\n\", i, p[i]);\n\t\tat++;\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n * 99 Bottles, C, KISS (i.e. keep it simple and straightforward) version\n */\n\n#include <stdio.h>\n\nint main(void)\n{\n  int n;\n\n  for( n = 99; n > 2; n-- )\n    printf(\n      \"%d bottles of beer on the wall, %d bottles of beer.\\n\"\n      \"Take one down and pass it around, %d bottles of beer on the wall.\\n\\n\",\n       n, n, n - 1);\n\n  printf(\n      \"2 bottles of beer on the wall, 2 bottles of beer.\\n\"\n      \"Take one down and pass it around, 1 bottle of beer on the wall.\\n\\n\"\n\n      \"1 bottle of beer on the wall, 1 bottle of beer.\\n\"\n      \"Take one down and pass it around, no more bottles of beer on the wall.\\n\\n\"\n\n      \"No more bottles of beer on the wall, no more bottles of beer.\\n\"\n      \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\");\n\n      return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n        if(argc == 99)\n                return 99;\n        if(argv[0] != NULL){\n                argv[0] = NULL;\n                argc = 0;\n        }\n        argc = main(argc + 1, argv);\n        printf(\"%d bottle%c of beer on the wall\\n\", argc, argc == 1?'\\0': 's');\n        printf(\"%d bottle%c of beer\\n\", argc, argc == 1?'\\0': 's');\n        printf(\"Take one down, pass it around\\n\");\n        printf(\"%d bottle%c of beer on the wall\\n\\n\", argc - 1, (argc - 1) == 1?'\\0': 's');\n        return argc - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nmain(){_=100;while(--_)printf(\"%i bottle%s of beer in the wall,\\n%i bottle%\"\n\"s of beer.\\nTake one down, pass it round,\\n%s%s\\n\\n\",_,_-1?\"s\":\"\",_,_-1?\"s\"\n:\"\",_-1?(char[]){(_-1)/10?(_-1)/10+48:(_-1)%10+48,(_-1)/10?(_-1)%10+48:2+30,\n(_-1)/10?32:0,0}:\"\",_-1?\"bottles of beer in the wall\":\"No more beers\");}\n"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main(void)\n{\n  (void) printf(SONG);\n  return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C",
    "code": "      int b =99,u =1;\n     #include<stdio.h>\n      char *d[16],y[]\n      = \"#:ottle/ of\"\n      \":eer_ a_Go<o5\"\n      \"st>y\\x20some6\"\n      \"_Take8;down4p\"\n      \"a=1rou7_17 _<\"\n      \"h;_ m?_nd_ on\"\n      \"_085wal\" \"l_ \"\n      \"b_e _ t_ss it\"\n      \"_?4bu_ore_9, \"\n      \"\\060.\"\"@, 9$\";\n     # define x  c  ^=\n    #include <string.h>\n   #define or(t,z) else\\\n  if(c==t && !(c = 0) &&\\\n (c =! z)); int p(char *t)\n{ char *s = t; int c; for (\nd[c = 0] = y; !t && (d[c +1\n]= strchr(s = d[c], '_'));*\n(d[++c]++) = 0); for(t = s?\ns:t;(c= *s++); c && putchar\n(c)) { if (!((( x 48)& ~0xf\n) && ( x 48)) ) p(d[c]), c=\n0 ; or('$', p(b - 99?\".\\n\":\n\".\" ) && p(b - 99? t : \"\"))\nor ('\\x40', c && p( d[!!b--\n+ 2])) or('/', c && p( b^1?\n\"s\": \"\")) or ('\\043', b++ ?\np(\"So6\" + --b):!printf(\"%d\"\n, b ? --b : (b += 99))) or(\n'S',!(++u % 3) * 32+ 78) or\n('.', puts(\".\"))}return c;}\n int main() {return p(0);}\n"
  },
  {
    "language": "C",
    "code": "// Standard input-output streams\n#include <stdio.h>\nint main()\n{\n   int a, b;\n   scanf(\"%d%d\", &a, &b);\n   printf(\"%d\\n\", a + b);\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// Input file: input.txt\n// Output file: output.txt\n#include <stdio.h>\nint main()\n{\n   freopen(\"input.txt\", \"rt\", stdin);\n   freopen(\"output.txt\", \"wt\", stdout);\n   int a, b;\n   scanf(\"%d%d\", &a, &b);\n   printf(\"%d\\n\", a + b);\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char **argv) //not sure if argv counts as input stream... certainly it is brought here via input stream.\n{\n   printf(\"%d\\n\", atoi(*(argv+1)) + atoi(*(argv+2)));\n   return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint can_make_words(char **b, char *word)\n{\n\tint i, ret = 0, c = toupper(*word);\n\n#define SWAP(a, b) if (a != b) { char * tmp = a; a = b; b = tmp; }\n\n\tif (!c) return 1;\n\tif (!b[0]) return 0;\n\n\tfor (i = 0; b[i] && !ret; i++) {\n\t\tif (b[i][0] != c && b[i][1] != c) continue;\n\t\tSWAP(b[i], b[0]);\n\t\tret = can_make_words(b + 1, word + 1);\n\t\tSWAP(b[i], b[0]);\n\t}\n\n\treturn ret;\n}\n\nint main(void)\n{\n\tchar* blocks[] = {\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n\t\t\"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n\t\t\"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n\t\t0 };\n\n\tchar *words[] = {\n\t\t\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\", 0\n\t};\n\n\tchar **w;\n\tfor (w = words; *w; w++)\n\t\tprintf(\"%s\\t%d\\n\", *w, can_make_words(blocks, *w));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#ifndef INTERFACE_ABS\n#define INTERFACE_ABS\n\ntypedef struct sAbstractCls *AbsCls;\n\ntypedef struct sAbstractMethods {\n    int         (*method1)(AbsCls c, int a);\n    const char *(*method2)(AbsCls c, int b);\n    void        (*method3)(AbsCls c, double d);\n} *AbstractMethods, sAbsMethods;\n\nstruct sAbstractCls {\n    AbstractMethods  klass;\n    void     *instData;\n};\n\n#define ABSTRACT_METHODS( cName, m1, m2, m3 ) \\\n    static sAbsMethods cName ## _Iface = { &m1, &m2, &m3 }; \\\n    AbsCls cName ## _Instance( void *clInst) { \\\n        AbsCls ac = malloc(sizeof(struct sAbstractCls)); \\\n        if (ac) { \\\n            ac->klass = &cName ## _Iface; \\\n            ac->instData = clInst; \\\n        }\\\n        return ac; }\n\n#define Abs_Method1( c, a) (c)->klass->method1(c, a)\n#define Abs_Method2( c, b) (c)->klass->method2(c, b)\n#define Abs_Method3( c, d) (c)->klass->method3(c, d)\n#define Abs_Free(c) \\\n  do { if (c) { free((c)->instData); free(c); } } while(0);\n\n#endif\n"
  },
  {
    "language": "C",
    "code": "#ifndef SILLY_H\n#define SILLY_H\n#include \"intefaceAbs.h\"\n#include <stdlib.h>\n\ntypedef struct sillyStruct *Silly;\nextern Silly NewSilly( double, const char *);\nextern AbsCls Silly_Instance(void *);\n\n#endif\n"
  },
  {
    "language": "C",
    "code": "#include \"silly.h\"\n#include <string.h>\n#include <stdio.h>\n\nstruct sillyStruct {\n    double  v1;\n    char   str[32];\n};\n\nSilly NewSilly(double vInit, const char *strInit)\n{\n    Silly sily = malloc(sizeof( struct sillyStruct ));\n    sily->v1 = vInit;\n    sily->str[0] = '\\0';\n    strncat(sily->str, strInit, 31);\n    return sily;\n}\n\nstatic\nint MyMethod1(  AbsCls c, int a)\n{\n    Silly s = (Silly)(c->instData);\n    return a+strlen(s->str);\n}\n\nstatic\nconst char *MyMethod2(AbsCls c, int b)\n{\n    Silly s = (Silly)(c->instData);\n    sprintf(s->str, \"%d\", b);\n    return s->str;\n}\n\nstatic\nvoid  MyMethod3(AbsCls c, double d)\n{\n    Silly s = (Silly)(c->instData);\n    printf(\"InMyMethod3, %f\\n\",s->v1 * d);\n}\n\nABSTRACT_METHODS( Silly, MyMethod1, MyMethod2, MyMethod3)\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include \"silly.h\"\n\nint main()\n{\n    AbsCls abster = Silly_Instance(NewSilly( 10.1, \"Green Tomato\"));\n\n    printf(\"AbsMethod1: %d\\n\", Abs_Method1(abster, 5));\n    printf(\"AbsMethod2: %s\\n\", Abs_Method2(abster, 4));\n    Abs_Method3(abster, 21.55);\n    Abs_Free(abster);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define de 0\n#define pe 1\n#define ab 2\n\nint main(){\n\tint sum = 0, i, j;\n\tint try_max = 0;\n\t//1 is deficient by default and can add it deficient list\n\tint   count_list[3] = {1,0,0};\n\tfor(i=2; i <= 20000; i++){\n\t\t//Set maximum to check for proper division\n\t\ttry_max = i/2;\n\t\t//1 is in all proper division number\n\t\tsum = 1;\n\t\tfor(j=2; j<try_max; j++){\n\t\t\t//Check for proper division\n\t\t\tif (i % j)\n\t\t\t\tcontinue; //Pass if not proper division\n\t\t\t//Set new maximum for divisibility check\n\t\t\ttry_max = i/j;\n\t\t\t//Add j to sum\n\t\t\tsum += j;\n\t\t\tif (j != try_max)\n\t\t\t\tsum += try_max;\n\t\t}\n\t\t//Categorize summation\n\t\tif (sum < i){\n\t\t\tcount_list[de]++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sum > i){\n\t\t\tcount_list[ab]++;\n\t\t\tcontinue;\n\t\t}\n\t\tcount_list[pe]++;\n\t}\n\tprintf(\"\\nThere are %d deficient,\" ,count_list[de]);\n\tprintf(\" %d perfect,\" ,count_list[pe]);\n\tprintf(\" %d abundant numbers between 1 and 20000.\\n\" ,count_list[ab]);\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n//~ Take a number n and return a function that takes a number i\n#define ACCUMULATOR(name,n) __typeof__(n) name (__typeof__(n) i) { \\\n    static __typeof__(n) _n=n; LOGIC; }\n//~ have it return n incremented by the accumulation of i\n#define LOGIC return _n+=i\nACCUMULATOR(x,1.0)\nACCUMULATOR(y,3)\nACCUMULATOR(z,'a')\n#undef LOGIC\nint main (void) {\n    printf (\"%f\\n\", x(5));   /* 6.000000 */\n    printf (\"%f\\n\", x(2.3)); /* 8.300000 */\n    printf (\"%i\\n\", y(5.0)); /* 8 */\n    printf (\"%i\\n\", y(3.3)); /* 11 */\n    printf (\"%c\\n\", z(5));   /* f */\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint ackermann(int m, int n)\n{\n        if (!m) return n + 1;\n        if (!n) return ackermann(m - 1, 1);\n        return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n        int m, n;\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint m_bits, n_bits;\nint *cache;\n\nint ackermann(int m, int n)\n{\n        int idx, res;\n        if (!m) return n + 1;\n\n        if (n >= 1<<n_bits) {\n                printf(\"%d, %d\\n\", m, n);\n                idx = 0;\n        } else {\n                idx = (m << n_bits) + n;\n                if (cache[idx]) return cache[idx];\n        }\n\n        if (!n) res = ackermann(m - 1, 1);\n        else    res = ackermann(m - 1, ackermann(m, n - 1));\n\n        if (idx) cache[idx] = res;\n        return res;\n}\nint main()\n{\n        int m, n;\n\n        m_bits = 3;\n        n_bits = 20;  /* can save n values up to 2**20 - 1, that's 1 meg */\n        cache = malloc(sizeof(int) * (1 << (m_bits + n_bits)));\n        memset(cache, 0, sizeof(int) * (1 << (m_bits + n_bits)));\n\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nConsole.WriteLine(\"Hello World\");\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nconst double X = 3.141592653;\ndouble x = 3.141592653589793;\nConsole.WriteLine(x + X);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A;\n}\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nint[] B = {1, 2, 3};\nConsole.WriteLine(A[0] + A[1] + A[2]);\nConsole.WriteLine(B[0] + B[1] + B[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = new string[3];\nA[0] = \"a\";\nA[1] = \"b\";\nA[2] = \"c\";\nConsole.WriteLine(A[0] + A[1] + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nstring x = A[1];\nstring y = A[2];\nConsole.WriteLine(x + y);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nstring x = A[1];\nA[0] = \"d\";\nA[1] = A[2];\nA[2] = x;\nConsole.WriteLine(A[0] + A[1] + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\npublic class FileManipulator\n{\n    public void MoveFile(string sourceFilePath, string destinationFilePath)\n    {\n        File.Move(sourceFilePath, destinationFilePath);\n    }\n\n    public string ReadFile(string filePath)\n    {\n        return File.ReadAllText(filePath);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Graph<T>\n{\n    private Dictionary<T, List<T>> adjacencyList = new Dictionary<T, List<T>>();\n\n    public void AddVertex(T vertex)\n    {\n        adjacencyList[vertex] = new List<T>();\n    }\n\n    public void AddEdge(T from, T to)\n    {\n        if (!adjacencyList.ContainsKey(from))\n            AddVertex(from);\n        adjacencyList[from].Add(to);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class DataCompression\n{\n    public byte[] CompressData(byte[] data)\n    {\n        using (System.IO.MemoryStream output = new System.IO.MemoryStream())\n        {\n            using (System.IO.Compression.DeflateStream compressor = new System.IO.Compression.DeflateStream(output, System.IO.Compression.CompressionMode.Compress))\n            {\n                compressor.Write(data, 0, data.Length);\n            }\n            return output.ToArray();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading;\n\npublic class MultithreadingDemo\n{\n    public void RunMultipleThreads()\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            Thread thread = new Thread(DoWork);\n            thread.Start();\n        }\n    }\n\n    private void DoWork()\n    {\n        // Work to be done in each thread\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Xml;\n\npublic class XMLProcessor\n{\n    public void ValidateXML(string xmlContent)\n    {\n        XmlDocument xmlDoc = new XmlDocument();\n        xmlDoc.LoadXml(xmlContent);\n        // Perform validation or manipulation on XML data\n    }\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nint x = A.Length;\nConsole.WriteLine(x);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[, ] A = new int[, ] {{1,2},\n{3,4},\n{5,6},\n{7,8}};\nConsole.WriteLine(A[0,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[,, ] B = new int[,, ] {\n{{1,2,3},\n{4,5,6}},\n{{7,8,9},\n{10,11,12}}\n};\nConsole.WriteLine(B[0,1,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[,] C = new int[2,3];\nC[0,0] = 5;\nC[0,1] = 6;\nC[0,2] = 5;\nC[1,0] = 5;\nC[1,1] = 5;\nC[1,2] = 5;\nConsole.WriteLine(C[0,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "class HelloWorld {\nstatic void Main() {\nint a, b, c;\na = 1;\na += 1;\na = b = c = 1;\nConsole.WriteLine(a + b + c);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 1;\nint b = 2;\nint c = 3;\nif(a < b){c += 1;} else {c -= 1;}\nConsole.WriteLine(\"c=\" + c);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[] A = {1, 2, 3};\nif(A[0] < A[1]){A[2] += 1;}\nConsole.WriteLine(\"A[2]=\" + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint i = 0;\nwhile (i < 5) {\nConsole.WriteLine(\"i = \" + i);\ni++;\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint i = 0;\ndo {\nConsole.WriteLine(\"i = \" + i);\ni++;\n}\nwhile (i < 5);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nint i = 0;\nstring t = \"\";\nwhile (i < A.Length) {\nt += \"\\n i[\" + i + \"]=\" + A[i];\ni++;\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nint i = 0;\nstring t = \"\";\ndo {\nt += \"\\n i[\" + i + \"]=\" + A[i];\ni++;\n}\nwhile (i < A.Length);\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 5;\nint b = 0;\nfor (int i = 0; i < a; i++) {\nb += i;\n}\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nstring t = \"\";\nfor (int i = 0; i < A.Length; i++) {\nt += \"\\n A[\" + i + \"]=\" + A[i];\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[, ] A = new string[, ] {\n{\"a\",\"b\"},\n{\"c\",\"d\"},\n{\"e\",\"f\"},\n{\"g\",\"h\"}\n};\nstring t = \"\";\nint x = A.GetLength(0);\nint y = A.GetLength(1);\nfor (int i = 0; i < x; i++) {\nfor (int j = 0; j < y; j++) {\nt += \"\\n A[\"+i+\",\"+j+\"]=\" + A[i,j];\n}\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[, ] A = new string[, ] {\n{\"a\",\"b\"},\n{\"c\",\"d\"},\n{\"e\",\"f\"},\n{\"g\",\"h\"}\n};\nstring t = \"\";\nint n = A.GetLength(0);\nint m = A.GetLength(1);\nint i = 0;\nint j = 0;\nfor (int v = 0; v < n*m; v++) {\nj = v % m;\nif(v!=0 && j == 0){i++;}\nt += v + \" A[\"+i+\",\"+j+\"]=\";\nt += A[i,j] + \"\\n\";\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic int compute(int x)\n{\nreturn x + x / x - x * x;\n}\nstatic void Main(string[] args)\n{\nint a = 10;\nint b = compute(a);\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nConsole.WriteLine(\"Code 65 is the:'\" + (char) 65 + \"' letter\");\nConsole.WriteLine(\"Letter A has the code:'\" + (int) 'A' + \"'\");\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic string compute(string t, string [] a)\n{\nfor (int i = 0; i < a.Length; i++) {\nt += \"\\n a[\" + i + \"]=\" + a[i];\n}\nreturn t;\n}\nstatic void Main(string[] args)\n{\nstring[] a = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nstring t = \"\";\nstring b = compute(t, a);\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 3;\nint b = c(c(c(c(a))));\nb = -b;\nConsole.WriteLine(b);\n}\nstatic int c(int x)\n{return x + x / x - x * x;}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main(string[] args)\n{\nint[] a = {1, 2, 3, 4, 5};\nint t = 0;\nint b = c1(t, a);\nConsole.WriteLine(b);\n}\nstatic int c1(int t, int[] a){\nreturn 5 + c2(t, a);\n}\nstatic int c2(int t, int[] a){\nreturn c3(t, a) + 5;\n}\nstatic int c3(int t, int[] a){\nint s = 1;\nreturn s + c4(t, a);\n}\nstatic int c4(int t, int[] a){\nreturn c5(t, a) + c5(t, a);\n}\nstatic int c5(int t, int[] a){\nfor (int i = 0; i < a.Length; i++) {\nt += a[i];\n}\nreturn t;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic int for_loop(int a, int b, int r){\na++;\nr += 5;\nif(a>=b){\nreturn r;\n} else {\nreturn for_loop(a, b, r);\n}\n}\nstatic void Main() {\nint a = for_loop(0, 7, 0);\nConsole.WriteLine(a);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic const double a = 3.1415;\npublic static int b;\nstatic int compute()\n{\nint x = b;\nreturn x + x / x - x * x;\n}\nstatic void Main(string[] args)\n{\nb = 11;\nint c = compute();\nConsole.WriteLine(c + \"\\n\" + a);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic static int a;\nstatic void Main() {\na = 10;\nint b = pure(a);\nConsole.WriteLine(b + \" & \" + a);\nint c = inpure(a);\nConsole.WriteLine(c + \" & \" + a);\nint d = pure(a);\nConsole.WriteLine(d + \" & \" + a);\n}\nstatic int pure(int x){\nreturn x + x / x - x * x;\n}\nstatic int inpure(int x){\na = 11;\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic static int b;\npublic static int a;\nstatic void Main() {\na = 16;\nb = f(a);\nConsole.WriteLine(b);\np();\nConsole.WriteLine(b);\n}\nstatic int f(int x){\nreturn x + x / x - x * x;\n}\nstatic void p(){\nint x = a - 11;\nb = x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = \"*******%%**********%%******\";\nstring q = \"%%\";\nint b = a.Length;\nint c = a.Replace(q, \"\").Length;\nif(c < b){\nConsole.WriteLine(\"a contains q\");\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = x(\"*\", \"\", 10);\nConsole.WriteLine(\"Repeat:\\n[\" + a + \"]\");\nint b = sum(23);\nConsole.WriteLine(\"Sum:[\" + b + \"]\");\nint c = factorial(10);\nConsole.WriteLine(\n\"Factorial:\\n[\" + c + \"]\"\n);\nint[] d = sequence(5, new int[5], 0, 5);\nConsole.WriteLine(\n\"A sequence:\\n[{0}\",\nstring.Join(\",\", d) + \"]\"\n);\nint[] e = fibonacci(2,\nnew int[3] {1,2,3}, 5);\nConsole.WriteLine(\n\"Fibonacci:\\n[{0}\",\nstring.Join(\",\", e) + \"]\"\n);\nint[] q = {1, 3, 3, 4, 5, 9};\nint f = sum_array(q.Length - 1, q, 0);\nConsole.WriteLine(\n\"Sum array:[\" + f + \"]\"\n);\n}\nstatic string x(string c, string s,\nint n){\ns += c;\nif(s.Length>=n){\nreturn s;\n} else {\nreturn x(c, s, n);\n}\n}\nstatic int sum(int n){\nif (n <= 1) {return n;}\nreturn n + sum(n - 1);\n}\nstatic int factorial(int n){\nif (n <= 1) {\nreturn n;\n} else {\nreturn factorial(n - 1) * n;\n}\n}\nstatic int[] sequence(int n, int[] m,\nint i, int t){\nm[i] = n;\ni++;\nif (i >= t) {\nreturn m;\n} else {\nreturn sequence((n-1)+(n-2),\nm, i, t);\n}\n}\nstatic int[] fibonacci(int n, int[] m,\nint t){\nn++;\nArray.Resize(ref m, n+1);\nm[n] = m[n-1] + m[n-2];\nif (n >= t) {\nreturn m;\n} else {\nreturn fibonacci(n, m, t);\n}\n}\nstatic int sum_array(int n, int[] q,\nint r){\nr += q[n];\nif (n <= 0) {\nreturn r;\n} else {\nreturn sum_array(n - 1, q, r);\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = distribution(3, 21);\nConsole.WriteLine(a);\n}\nstatic string distribution(\nint start, int stop){\nstring t = \"\";\nfor (int i = start; i < stop; i++) {\nt += compute(i) + \"\\n\";\n}\nreturn t;\n}\nstatic int compute(int x){\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[] a = distribution(3, 21);\nConsole.WriteLine(string.Join(\"\\n\", a));\n}\nstatic int[] distribution(\nint start, int stop){\nint[] b = new int[stop - start];\nfor (int i = start; i < stop; i++) {\nb[i - start] = compute(i);\n}\nreturn b;\n}\nstatic int compute(int x){\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nint a, b, c;\na = 7;\nb = 3;\na = 7; b = 3;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\npublic class SpectralForecast\n{\npublic static void Main(string[] args)\n{\nstring A = \"10.3,23.4,44.8,63.2,44.1,35.1,46.5,62.6,50.4\";\nstring B = \"18.8,43.1,52.2,45.5,46.8,46.6,67.9,66.3,70.4\";\nstring[] nA = A.Split(',');\nstring[] nB = B.Split(',');\nstring M = \"\";\ndouble maxA = 0;\ndouble maxB = 0;\ndouble d = 33;\ndouble v = 0;\ndouble[] tA = new double[nA.Length];\ndouble[] tB = new double[nB.Length];\nfor(int i=0; i < nA.Length; i++)\n{\ntA[i] = double.Parse(nA[i]);\ntB[i] = double.Parse(nB[i]);\nif (tA[i] > maxA){maxA = tA[i];}\nif (tB[i] > maxB){maxB = tB[i];}\n}\ndouble maxAB = Math.Max(maxA, maxB);\nfor(int i=0; i < tA.Length; i++) {\nv = ((d/maxA)*tA[i])+(((maxAB-d)/maxB)*tB[i]);\nM += Math.Round(v, 2);\nif(i < tA.Length-1){M += ',';}\n}\nConsole.WriteLine (M);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nString a = \"this is \";\nString b = a +\n\"C\t\"output\";\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nString a = \"this is \"; String b = a + \"C  }\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\n42\n3.14159265358979323846264\n'a'\n\"this text\"\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint x = 12;\nint y = 15;\nstring color = \"green\";\nstring xname = \"Paul\";\nbool logic = true;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint x = 12;\nint y = 15;\nstring color = \"green\";\nstring xname = \"Paul\";\nbool logic = true;\nConsole.WriteLine(logic);\nConsole.WriteLine(x + y);\nConsole.WriteLine(color + x);\nConsole.WriteLine(x + xname);\nConsole.WriteLine(x + y + color);\nConsole.WriteLine(color + x + y);\nConsole.WriteLine(x + x / x - x * x);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Matrix\n{\n    private int[,] data;\n\n    public Matrix(int rows, int cols)\n    {\n        data = new int[rows, cols];\n    }\n\n    public int this[int row, int col]\n    {\n        get { return data[row, col]; }\n        set { data[row, col] = value; }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class CustomList<T>\n{\n    private T[] items;\n    private int count;\n\n    public CustomList()\n    {\n        items = new T[10];\n        count = 0;\n    }\n\n    public void Add(T item)\n    {\n        if (count < items.Length)\n        {\n            items[count] = item;\n            count++;\n        }\n        else\n        {\n            // Resize the array or handle full list\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Employee\n{\n    public string Name { get; set; }\n    public decimal Salary { get; set; }\n\n    public override string ToString()\n    {\n        return $\"Name: {Name}, Salary: {Salary:C}\";\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\npublic class FileManager\n{\n    public void CopyFile(string sourcePath, string destinationPath)\n    {\n        File.Copy(sourcePath, destinationPath);\n    }\n\n    public void DeleteFile(string filePath)\n    {\n        File.Delete(filePath);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading.Tasks;\n\npublic class AsyncOperations\n{\n    public async Task<string> FetchDataAsync(string url)\n    {\n        using (var client = new System.Net.Http.HttpClient())\n        {\n            return await client.GetStringAsync(url);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Polynomial\n{\n    private double[] coefficients;\n\n    public double this[int index]\n    {\n        get { return coefficients[index]; }\n        set { coefficients[index] = value; }\n    }\n\n    public int Degree\n    {\n        get { return coefficients.Length - 1; }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\npublic class LINQSample\n{\n    public void FilterData()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        var evenNumbers = numbers.Where(n => n % 2 == 0);\n        foreach (var num in evenNumbers)\n        {\n            Console.WriteLine(num);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class FibonacciSeries\n{\n    public int CalculateFibonacci(int n)\n    {\n        if (n <= 1)\n            return n;\n        return CalculateFibonacci(n - 1) + CalculateFibonacci(n - 2);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text.RegularExpressions;\n\npublic class RegexValidation\n{\n    public bool IsValidEmail(string email)\n    {\n        return Regex.IsMatch(email, @\"^\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\");\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class PrimeNumberCheck\n{\n    public bool IsPrime(int number)\n    {\n        if (number <= 1) return false;\n        for (int i = 2; i <= Math.Sqrt(number); i++)\n        {\n            if (number % i == 0) return false;\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class EncryptionHelper\n{\n    private string key = \"YourSecretKey\";\n\n    public string Encrypt(string data)\n    {\n        // Encryption logic using 'key'\n        return \"encrypted_data\";\n    }\n\n    public string Decrypt(string encryptedData)\n    {\n        // Decryption logic using 'key'\n        return \"decrypted_data\";\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Diagnostics;\n\npublic class PerformanceAnalyzer\n{\n    public void MeasurePerformance()\n    {\n        Stopwatch stopwatch = new Stopwatch();\n        stopwatch.Start();\n\n        // Code to measure performance\n\n        stopwatch.Stop();\n        Console.WriteLine(\"Elapsed time: \" + stopwatch.Elapsed);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class DateManipulation\n{\n    public DateTime GetNextWeekday(DateTime date, DayOfWeek dayOfWeek)\n    {\n        int daysUntilTarget = ((int)dayOfWeek - (int)date.DayOfWeek + 7) % 7;\n        return date.AddDays(daysUntilTarget);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class SimpleCalculator\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n\n    public int Subtract(int a, int b)\n    {\n        return a - b;\n    }\n\n    public int Multiply(int a, int b)\n    {\n        return a * b;\n    }\n\n    public double Divide(int a, int b)\n    {\n        if (b == 0)\n            throw new DivideByZeroException();\n        return (double)a / b;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class CustomQueue<T>\n{\n    private List<T> items = new List<T>();\n\n    public void Enqueue(T item)\n    {\n        items.Add(item);\n    }\n\n    public T Dequeue()\n    {\n        if (items.Count == 0)\n            throw new InvalidOperationException(\"Queue is empty\");\n\n        T item = items[0];\n        items.RemoveAt(0);\n        return item;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading;\n\npublic class ThreadDemo\n{\n    public void RunThreadExample()\n    {\n        Thread thread = new Thread(DoWork);\n        thread.Start();\n    }\n\n    private void DoWork()\n    {\n        // Code to be executed in the thread\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Net.Http;\n\npublic class WebRequestHandler\n{\n    private HttpClient client = new HttpClient();\n\n    public async void MakeRequest(string url)\n    {\n        HttpResponseMessage response = await client.GetAsync(url);\n        if (response.IsSuccessStatusCode)\n        {\n            string content = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(content);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class RandomNumberGenerator\n{\n    private static readonly Random random = new Random();\n\n    public int GenerateRandomNumber(int min, int max)\n    {\n        return random.Next(min, max + 1);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class PathOperations\n{\n    public string GetFullPath(string relativePath)\n    {\n        return System.IO.Path.GetFullPath(relativePath);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class StringReversal\n{\n    public string ReverseString(string input)\n    {\n        char[] charArray = input.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n  bool is_open[100] = { false };\n\n  // do the 100 passes\n  for (int pass = 0; pass < 100; ++pass)\n    for (int door = pass; door < 100; door += pass+1)\n      is_open[door] = !is_open[door];\n\n  // output the result\n  for (int door = 0; door < 100; ++door)\n    std::cout << \"door #\" << door+1 << (is_open[door]? \" is open.\" : \" is closed.\") << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n  int square = 1, increment = 3;\n  for (int door = 1; door <= 100; ++door)\n  {\n    std::cout << \"door #\" << door;\n    if (door == square)\n    {\n      std::cout << \" is open.\" << std::endl;\n      square += increment;\n      increment += 2;\n    }\n    else\n      std::cout << \" is closed.\" << std::endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> //compiled with \"Dev-C++\" , from RaptorOne\n\nint main()\n{\n    for(int i=1; i*i<=100; i++)\n            std::cout<<\"Door \"<<i*i<<\" is open!\"<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>    // compiled with clang (tags/RELEASE_600/final)\n#include <type_traits> // or g++ (GCC) 7.3.1 20180406 -- from hare1039\nnamespace functional_list // basic building block for template meta programming\n{\nstruct NIL\n{\n\tusing head = NIL;\n\tusing tail = NIL;\n\tfriend std::ostream& operator << (std::ostream& os, NIL const) { return os; }\n};\n\ntemplate <typename H, typename T = NIL>\nstruct list\n{\n\tusing head = H;\n\tusing tail = T;\n};\n\ntemplate <int i>\nstruct integer\n{\n\tstatic constexpr int value = i;\n\tfriend std::ostream& operator << (std::ostream& os, integer<i> const) { os << integer<i>::value; return os;}\n};\n\ntemplate <typename L, int nTH> constexpr\nauto at()\n{\n\tif constexpr (nTH == 0)\n\t\treturn (typename L::head){};\n\telse if constexpr (not std::is_same_v<typename L::tail, NIL>)\n\t\treturn at<typename L::tail, nTH - 1>();\n\telse\n\t\treturn NIL{};\n}\ntemplate <typename L, int nTH>\nusing at_t = decltype(at<L, nTH>());\n\ntemplate <typename L, typename elem> constexpr\nauto prepend() { return list<elem, L>{}; }\n\ntemplate <typename L, typename elem>\nusing prepend_t = decltype(prepend<L, elem>());\n\t\ntemplate <int Size, typename Dat = integer<0>> constexpr\nauto gen_list()\n{\n\tif constexpr (Size == 0)\n\t\treturn NIL{};\n\telse\n\t{\n\t\tusing next = decltype(gen_list<Size - 1, Dat>());\n\t\treturn prepend<next, Dat>();\n\t}\n}\ntemplate <int Size, typename Dat = integer<0>>\nusing gen_list_t = decltype(gen_list<Size, Dat>());\n\t\n} namespace fl = functional_list;\n\nconstexpr int door_amount = 101; // index from 1 to 100\n\ntemplate <typename L, int current, int moder> constexpr\nauto construct_loop()\n{\n\tusing val_t = fl::at_t<L, current>;\n\tif constexpr (std::is_same_v<val_t, fl::NIL>)\n\t\treturn fl::NIL{};\n\telse\n\t{\n\t\tconstexpr int val = val_t::value;\n\t\tusing val_add_t = fl::integer<val + 1>;\n\t\tusing val_old_t = fl::integer<val>;\n\t\n\t\tif constexpr (current == door_amount)\n\t\t{\n\t\t\tif constexpr(current % moder == 0)\n\t\t\t\treturn fl::list<val_add_t>{};\n\t\t\telse\n\t\t\t\treturn fl::list<val_old_t>{};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tusing sub_list = decltype(construct_loop<L, current + 1, moder>());\n\t\t\tif constexpr(current % moder == 0)\n\t\t\t\treturn fl::prepend<sub_list, val_add_t>();\n\t\t\telse\n\t\t\t\treturn fl::prepend<sub_list, val_old_t>();\n\t\t}\n\t}\n}\n\ntemplate <int iteration> constexpr\nauto construct()\n{\n\tif constexpr (iteration == 1) // door index = 1\n\t{\n\t\tusing l = fl::gen_list_t<door_amount>;\n\t\treturn construct_loop<l, 0, iteration>();\n\t}\n\telse\n\t{\n\t\tusing prev_iter_list = decltype(construct<iteration - 1>());\n\t\treturn construct_loop<prev_iter_list, 0, iteration>();\n\t}\n}\n\ntemplate <typename L, int pos> constexpr\nvoid show_ans()\n{\n\tif constexpr (std::is_same_v<typename L::head, fl::NIL>)\n\t\treturn;\n\telse\n\t{\n\t\tif constexpr (L::head::value % 2 == 1)\n\t\t\tstd::cout << \"Door \" << pos << \" is opened.\\n\";\n\t\tshow_ans<typename L::tail, pos + 1>();\n\t}\n}\n\nint main()\n{\n\tusing result = decltype(construct<100>());\n\tshow_ans<result, 0>();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ratio>\n#include <array>\n#include <algorithm>\n#include <random>\n\ntypedef short int Digit;  // Typedef for the digits data type.\n\nconstexpr Digit nDigits{4};      // Amount of digits that are taken into the game.\nconstexpr Digit maximumDigit{9}; // Maximum digit that may be taken into the game.\nconstexpr short int gameGoal{24};    // Desired result.\n\ntypedef std::array<Digit, nDigits> digitSet; // Typedef for the set of digits in the game.\ndigitSet d;\n\nvoid printTrivialOperation(std::string operation) { // Prints a commutative operation taking all the digits.\n\tbool printOperation(false);\n\tfor(const Digit& number : d) {\n\t\tif(printOperation)\n\t\t\tstd::cout << operation;\n\t\telse\n\t\t\tprintOperation = true;\n\t\tstd::cout << number;\n\t}\n\tstd::cout << std::endl;\n}\n\nvoid printOperation(std::string prefix, std::string operation1, std::string operation2, std::string operation3, std::string suffix = \"\") {\n\tstd::cout << prefix << d[0] << operation1 << d[1] << operation2 << d[2] << operation3 << d[3] << suffix << std::endl;\n}\n\nint main() {\n\tstd::mt19937_64 randomGenerator;\n\tstd::uniform_int_distribution<Digit> digitDistro{1, maximumDigit};\n\t// Let us set up a number of trials:\n\tfor(int trial{10}; trial; --trial) {\n\t\tfor(Digit& digit : d) {\n\t\t\tdigit = digitDistro(randomGenerator);\n\t\t\tstd::cout << digit << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t\tstd::sort(d.begin(), d.end());\n\t\t// We start with the most trivial, commutative operations:\n\t\tif(std::accumulate(d.cbegin(), d.cend(), 0) == gameGoal)\n\t\t\tprintTrivialOperation(\" + \");\n\t\tif(std::accumulate(d.cbegin(), d.cend(), 1, std::multiplies<Digit>{}) == gameGoal)\n\t\t\tprintTrivialOperation(\" * \");\n\t\t// Now let's start working on every permutation of the digits.\n\t\tdo {\n\t\t\t// Operations with 2 symbols + and one symbol -:\n\t\t\tif(d[0] + d[1] + d[2] - d[3] == gameGoal) printOperation(\"\", \" + \", \" + \", \" - \"); // If gameGoal is ever changed to a smaller value, consider adding more operations in this category.\n\t\t\t// Operations with 2 symbols + and one symbol *:\n\t\t\tif(d[0] * d[1] + d[2] + d[3] == gameGoal) printOperation(\"\", \" * \", \" + \", \" + \");\n\t\t\tif(d[0] * (d[1] + d[2]) + d[3] == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" ) + \");\n\t\t\tif(d[0] * (d[1] + d[2] + d[3]) == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" + \", \" )\");\n\t\t\t// Operations with one symbol + and 2 symbols *:\n\t\t\tif((d[0] * d[1] * d[2]) + d[3] == gameGoal) printOperation(\"( \", \" * \", \" * \", \" ) + \");\n\t\t\tif(d[0] * d[1] * (d[2] + d[3]) == gameGoal) printOperation(\"( \", \" * \", \" * ( \", \" + \", \" )\");\n\t\t\tif((d[0] * d[1]) + (d[2] * d[3]) == gameGoal) printOperation(\"( \", \" * \", \" ) + ( \", \" * \", \" )\");\n\t\t\t// Operations with one symbol - and 2 symbols *:\n\t\t\tif((d[0] * d[1] * d[2]) - d[3] == gameGoal) printOperation(\"( \", \" * \", \" * \", \" ) - \");\n\t\t\tif(d[0] * d[1] * (d[2] - d[3]) == gameGoal) printOperation(\"( \", \" * \", \" * ( \", \" - \", \" )\");\n\t\t\tif((d[0] * d[1]) - (d[2] * d[3]) == gameGoal) printOperation(\"( \", \" * \", \" ) - ( \", \" * \", \" )\");\n\t\t\t// Operations with one symbol +, one symbol *, and one symbol -:\n\t\t\tif(d[0] * d[1] + d[2] - d[3] == gameGoal) printOperation(\"\", \" * \", \" + \", \" - \");\n\t\t\tif(d[0] * (d[1] + d[2]) - d[3] == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" ) - \");\n\t\t\tif(d[0] * (d[1] - d[2]) + d[3] == gameGoal) printOperation(\"\", \" * ( \", \" - \", \" ) + \");\n\t\t\tif(d[0] * (d[1] + d[2] - d[3]) == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" - \", \" )\");\n\t\t\tif(d[0] * d[1] - (d[2] + d[3]) == gameGoal) printOperation(\"\", \" * \", \" - ( \", \" + \", \" )\");\n\t\t\t// Operations with one symbol *, one symbol /, one symbol +:\n\t\t\tif(d[0] * d[1] == (gameGoal - d[3]) * d[2]) printOperation(\"( \", \" * \", \" / \", \" ) + \");\n\t\t\tif(((d[0] * d[1]) + d[2]) == gameGoal * d[3]) printOperation(\"(( \", \" * \", \" ) + \", \" ) / \");\n\t\t\tif((d[0] + d[1]) * d[2] == gameGoal * d[3]) printOperation(\"(( \", \" + \", \" ) * \", \" ) / \");\n\t\t\tif(d[0] * d[1] == gameGoal * (d[2] + d[3])) printOperation(\"( \", \" * \", \" ) / ( \", \" + \", \" )\");\n\t\t\t// Operations with one symbol *, one symbol /, one symbol -:\n\t\t\tif(d[0] * d[1] == (gameGoal + d[3]) * d[2]) printOperation(\"( \", \" * \", \" / \", \" ) - \");\n\t\t\tif(((d[0] * d[1]) - d[2]) == gameGoal * d[3]) printOperation(\"(( \", \" * \", \" ) - \", \" ) / \");\n\t\t\tif((d[0] - d[1]) * d[2] == gameGoal * d[3]) printOperation(\"(( \", \" - \", \" ) * \", \" ) / \");\n\t\t\tif(d[0] * d[1] == gameGoal * (d[2] - d[3])) printOperation(\"( \", \" * \", \" ) / ( \", \" - \", \" )\");\n\t\t\t// Operations with 2 symbols *, one symbol /:\n\t\t\tif(d[0] * d[1] * d[2] == gameGoal * d[3]) printOperation(\"\", \" * \", \" * \", \" / \");\n\t\t\tif(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\"\", \" * \", \" / ( \", \" * \", \" )\");\n\t\t\t// Operations with 2 symbols /, one symbol -:\n\t\t\tif(d[0] * d[3] == gameGoal * (d[1] * d[3] - d[2])) printOperation(\"\", \" / ( \", \" - \", \" / \", \" )\");\n\t\t\t// Operations with 2 symbols /, one symbol *:\n\t\t\tif(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\"( \", \" * \", \" / \", \" ) / \", \"\");\n\t\t} while(std::next_permutation(d.begin(), d.end())); // All operations are repeated for all possible permutations of the numbers.\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <random>\n#include <iostream>\n#include <stack>\n#include <set>\n#include <string>\n#include <functional>\nusing namespace std;\n\nclass RPNParse\n{\npublic:\n  stack<double> stk;\n  multiset<int> digits;\n\n  void op(function<double(double,double)> f)\n  {\n    if(stk.size() < 2)\n      throw \"Improperly written expression\";\n    int b = stk.top(); stk.pop();\n    int a = stk.top(); stk.pop();\n    stk.push(f(a, b));\n  }\n\n  void parse(char c)\n  {\n    if(c >= '0' && c <= '9')\n    {\n      stk.push(c - '0');\n      digits.insert(c - '0');\n    }\n    else if(c == '+')\n      op([](double a, double b) {return a+b;});\n    else if(c == '-')\n      op([](double a, double b) {return a-b;});\n    else if(c == '*')\n      op([](double a, double b) {return a*b;});\n    else if(c == '/')\n      op([](double a, double b) {return a/b;});\n  }\n\n  void parse(string s)\n  {\n    for(int i = 0; i < s.size(); ++i)\n      parse(s[i]);\n  }\n\n  double getResult()\n  {\n    if(stk.size() != 1)\n      throw \"Improperly written expression\";\n    return stk.top();\n  }\n};\n\nint main()\n{\n  random_device seed;\n  mt19937 engine(seed());\n  uniform_int_distribution<> distribution(1, 9);\n  auto rnd = bind(distribution, engine);\n\n  multiset<int> digits;\n  cout << \"Make 24 with the digits: \";\n  for(int i = 0; i < 4; ++i)\n  {\n    int n = rnd();\n    cout << \" \" << n;\n    digits.insert(n);\n  }\n  cout << endl;\n\n  RPNParse parser;\n\n  try\n  {\n    string input;\n    getline(cin, input);\n    parser.parse(input);\n\n    if(digits != parser.digits)\n      cout << \"Error: Not using the given digits\" << endl;\n    else\n    {\n      double r = parser.getResult();\n      cout << \"Result: \" << r << endl;\n\n      if(r > 23.999 && r < 24.001)\n        cout << \"Good job!\" << endl;\n      else\n        cout << \"Try again.\" << endl;\n    }\n  }\n  catch(char* e)\n  {\n    cout << \"Error: \" << e << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Calculate hypotenuse n of OTT assuming only nothingness, unity, and hyp[n-1] if n>1\n// Nigel Galloway, May 6th., 2013\n#include <gmpxx.h>\nint N{123456};\nmpz_class hyp[N-3];\nconst mpz_class G(const int n,const int g){return g>n?0:(g==1 or n-g<2)?1:hyp[n-g-2];};\nvoid G_hyp(const int n){for(int i=0;i<N-2*n-1;i++) n==1?hyp[n-1+i]=1+G(i+n+1,n+1):hyp[n-1+i]+=G(i+n+1,n+1);}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nint main(){\n  N=25;\n  for (int n=1; n<N/2; n++){\n    G_hyp(n);\n    for (int g=0; g<N-3; g++) std::cout << std::setw(4) << hyp[g];\n    std::cout << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "int main(){\n  N = 25;\n  std::cout << std::setw(N+52) << \"1\" << std::endl;\n  std::cout << std::setw(N+55) << \"1     1\" << std::endl;\n  std::cout << std::setw(N+58) << \"1     1     1\" << std::endl;\n  std::string ott[N-3];\n  for (int n=1; n<N/2; n++) {\n    G_hyp(n);\n    for (int g=(n-1)*2; g<N-3; g++) {\n      std::string t = hyp[g-(n-1)].get_str();\n      //if (t.size()==1) t.insert(t.begin(),1,' ');\n      ott[g].append(t);\n      ott[g].append(6-t.size(),' ');\n    }\n  }\n  for(int n = 0; n<N-3; n++) {\n    std::cout <<std::setw(N+43-3*n) << 1 << \"     \" << ott[n];\n    for (int g = (n+1)/2; g>0; g--) {\n      std::string t{hyp[g-1].get_str()};\n      t.append(6-t.size(),' ');\n      std::cout << t;\n    }\n    std::cout << \"1     1\" << std::endl;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint main(){\n  for (int n=1; n<N/2; n++) G_hyp(n);\n  std::cout << \"G(23)     = \" << hyp[21] << std::endl;\n  std::cout << \"G(123)    = \" << hyp[121] << std::endl;\n  std::cout << \"G(1234)   = \" << hyp[1232] << std::endl;\n  std::cout << \"G(12345)  = \" << hyp[12343] << std::endl;\n  mpz_class r{3};\n  for (int i = 0; i<N-3; i++) r += hyp[i];\n  std::cout << \"G(123456) = \" << r << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing std::cout;\n\nint main()\n{\n  for(int bottles(99); bottles > 0; bottles -= 1){\n    cout << bottles << \" bottles of beer on the wall\\n\"\n         << bottles << \" bottles of beer\\n\"\n         << \"Take one down, pass it around\\n\"\n         << bottles - 1 << \" bottles of beer on the wall\\n\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntemplate<int max, int min> struct bottle_countdown\n{\n  static const int middle = (min + max)/2;\n  static void print()\n  {\n    bottle_countdown<max, middle+1>::print();\n    bottle_countdown<middle, min>::print();\n  }\n};\n\ntemplate<int value> struct bottle_countdown<value, value>\n{\n  static void print()\n  {\n    std::cout << value << \" bottles of beer on the wall\\n\"\n              << value << \" bottles of beer\\n\"\n              << \"Take one down, pass it around\\n\"\n              << value-1 << \" bottles of beer\\n\\n\";\n  }\n};\n\nint main()\n{\n  bottle_countdown<100, 1>::print();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid rec(int bottles)\n{\nif ( bottles!=0)\n {\n     cout << bottles << \" bottles of beer on the wall\" << endl;\n        cout << bottles << \" bottles of beer\" << endl;\n        cout << \"Take one down, pass it around\" << endl;\n        cout << --bottles << \" bottles of beer on the wall\\n\" << endl;\n    rec(bottles);\n }\n}\n\nint main()\n {\nrec(99);\nsystem(\"pause\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ostream>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main()\n{\n  std::cout << SONG;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                          //>,_\n                        //Beer Song>,_\n                       #include <iostream>\n                      using namespace std;\n                     int main(){ for( int\n                    b=-1; b<99;  cout <<\n                   '\\n') for ( int w=0;\n                  w<3; cout << \".\\n\"){\n                 if (w==2) cout << ((\n                b--) ?\"Take one dow\"\n               \"n and pass it arou\"\n              \"nd\":\"Go to the sto\"\n             \"re and buy some mo\"\n            \"re\"); if (b<0) b=99\n           ; do{ if (w) cout <<\n          \", \"; if (b) cout <<\n          b;  else  cout << (\n         (w) ? 'n' : 'N') <<\n         \"o more\"; cout <<\n         \" bottle\" ;  if\n        (b!=1) cout <<\n       's' ; cout <<\n       \" of beer\";\n      if (w!=1)\n     cout  <<\n    \" on th\"\n   \"e wall\"\n  ;} while\n (!w++);}\n  return\n       0\n       ;\n       }\n      //\n  // by barrym 2011-05-01\n     // no bottles were harmed in the\n            // making of this program!!!\n"
  },
  {
    "language": "C++",
    "code": "// Standard input-output streams\n#include <iostream>\nusing namespace std;\nint main()\n{\n   int a, b;\n   cin >> a >> b;\n   cout << a + b << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Input file: input.txt\n// Output file: output.txt\n#include <fstream>\nusing namespace std;\nint main()\n{\n   ifstream in(\"input.txt\");\n   ofstream out(\"output.txt\");\n   int a, b;\n   in >> a >> b;\n   out << a + b << endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cctype>\n\n\ntypedef std::pair<char,char> item_t;\ntypedef std::vector<item_t> list_t;\n\nbool can_make_word(const std::string& w, const list_t& vals) {\n    std::set<uint32_t> used;\n    while (used.size() < w.size()) {\n        const char c = toupper(w[used.size()]);\n        uint32_t x = used.size();\n        for (uint32_t i = 0, ii = vals.size(); i < ii; ++i) {\n            if (used.find(i) == used.end()) {\n                if (toupper(vals[i].first) == c || toupper(vals[i].second) == c) {\n                    used.insert(i);\n                    break;\n                }\n            }\n        }\n        if (x == used.size()) break;\n    }\n    return used.size() == w.size();\n}\n\n\nint main() {\n    list_t vals{ {'B','O'}, {'X','K'}, {'D','Q'}, {'C','P'}, {'N','A'}, {'G','T'}, {'R','E'}, {'T','G'}, {'Q','D'}, {'F','S'}, {'J','W'}, {'H','U'}, {'V','I'}, {'A','N'}, {'O','B'}, {'E','R'}, {'F','S'}, {'L','Y'}, {'P','C'}, {'Z','M'} };\n    std::vector<std::string> words{\"A\",\"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"};\n    for (const std::string& w : words) {\n        std::cout << w << \": \" << std::boolalpha << can_make_word(w,vals) << \".\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "class Abs {\npublic:\n\tvirtual int method1(double value) = 0;\n\tvirtual int add(int a, int b){\n\t\treturn a+b;\n\t}\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> findProperDivisors ( int n ) {\n   std::vector<int> divisors ;\n   for ( int i = 1 ; i < n / 2 + 1 ; i++ ) {\n      if ( n % i == 0 )\n\t divisors.push_back( i ) ;\n   }\n   return divisors  ;\n}\n\nint main( ) {\n   std::vector<int> deficients , perfects , abundants , divisors ;\n   for ( int n = 1 ; n < 20001 ; n++ ) {\n      divisors = findProperDivisors( n ) ;\n      int sum = std::accumulate( divisors.begin( ) , divisors.end( ) , 0 ) ;\n      if ( sum < n ) {\n\t deficients.push_back( n ) ;\n      }\n      if ( sum == n ) {\n\t perfects.push_back( n ) ;\n      }\n      if ( sum > n ) {\n\t abundants.push_back( n ) ;\n      }\n   }\n   std::cout << \"Deficient : \" << deficients.size( ) << std::endl ;\n   std::cout << \"Perfect   : \" << perfects.size( ) << std::endl ;\n   std::cout << \"Abundant  : \" << abundants.size( ) << std::endl ;\n   return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nclass Acc\n{\npublic:\n    Acc(int init)\n        : _type(intType)\n        , _intVal(init)\n    {}\n\n    Acc(float init)\n        : _type(floatType)\n        , _floatVal(init)\n    {}\n\n    int operator()(int x)\n    {\n        if( _type == intType )\n        {\n            _intVal += x;\n            return _intVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return static_cast<int>(_floatVal);\n        }\n    }\n\n    float operator()(float x)\n    {\n        if( _type == intType )\n        {\n            _floatVal = _intVal + x;\n            _type = floatType;\n            return _floatVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return _floatVal;\n        }\n    }\nprivate:\n    enum {floatType, intType} _type;\n    float _floatVal;\n    int _intVal;\n};\n\nint main()\n{\n    Acc a(1);\n    a(5);\n    Acc(3);\n    std::cout << a(2.3f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n\ntemplate <typename T>\nstd::function<T(T)> makeAccumulator(T sum) {\n\treturn [=](T increment) mutable {\n\t\treturn sum += increment;\n\t};\n}\n\nint main() {\n\tauto acc = makeAccumulator<float>(1);\n\tacc(5);\n\tmakeAccumulator(3);\n\tstd::cout << acc(2.3) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "struct CumulantBase_\n{\n   virtual ~CumulantBase_();\n   virtual std::ostream& Write(std::ostream& dst) const = 0;\n};\n\ntemplate<class T_> struct Cumulant_ : CumulantBase_\n{\n   T_ val_;\n   Cumulant_(const T_& val) : val_(val) {}\n   std::ostream& Write(std::ostream& dst) const override\n   {\n      return dst << val_;\n   }\n};\n\nstruct Accumulator_\n{\n   std::unique_ptr<CumulantBase_> val_;\n   template<class T_> Accumulator_(const T_& val) { Set(val); }\n   template<class T_> void Set(const T_& val) { val_.reset(new Cumulant_<T_>(val)); }\n"
  },
  {
    "language": "C++",
    "code": "// still inside struct Accumulator_\n\t// various operator() implementations provide a de facto multimethod\n\tAccumulator_& operator()(int more)\n\t{\n\t\tif (auto i = CoerceInt(*val_))\n\t\t\tSet(+i + more);\n\t\telse if (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(int) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(double more)\n\t{\n\t\tif (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(double) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(const String_& more)\n\t{\n\t\tif (auto s = CoerceString(*val_))\n\t\t\tSet(+s + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(string) failed\");\n\t\treturn *this;\n\t}\n};\n"
  },
  {
    "language": "C++",
    "code": "// recognize cumulants by type\nboost::optional<int> CoerceInt(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<int>*>(&c))\n\t\treturn p->val_;\n\treturn boost::optional<int>();\n}\nboost::optional<double> CoerceDouble(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<double>*>(&c))\n\t\treturn p->val_;\n\tif (auto i = CoerceInt(c))\n\t\treturn boost::optional<double>(i);\n\treturn boost::optional<double>();\n}\nboost::optional<String_> CoerceString(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<String_>*>(&c))\n\t\treturn p->val_;\n\treturn boost::optional<String_>();\n}\n"
  },
  {
    "language": "C++",
    "code": "std::ostream& operator<<(std::ostream& dst, const Accumulator_& acc)\n{\n\treturn acc.val_->Write(dst);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m < 4; ++m) {\n    for (unsigned int n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing big_int = boost::multiprecision::cpp_int;\n\nbig_int ipow(big_int base, big_int exp) {\n  big_int result(1);\n  while (exp) {\n    if (exp & 1) {\n      result *= base;\n    }\n    exp >>= 1;\n    base *= base;\n  }\n  return result;\n}\n\nbig_int ackermann(unsigned m, unsigned n) {\n  static big_int (*ack)(unsigned, big_int) =\n      [](unsigned m, big_int n)->big_int {\n    switch (m) {\n    case 0:\n      return n + 1;\n    case 1:\n      return n + 2;\n    case 2:\n      return 3 + 2 * n;\n    case 3:\n      return 5 + 8 * (ipow(big_int(2), n) - 1);\n    default:\n      return n == 0 ? ack(m - 1, big_int(1)) : ack(m - 1, ack(m, n - 1));\n    }\n  };\n  return ack(m, big_int(n));\n}\n\nint main() {\n  for (unsigned m = 0; m < 4; ++m) {\n    for (unsigned n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n\n  std::cout << \"A(4, 1) = \" << ackermann(4, 1) << \"\\n\";\n\n  std::stringstream ss;\n  ss << ackermann(4, 2);\n  auto text = ss.str();\n  std::cout << \"A(4, 2) = (\" << text.length() << \" digits)\\n\"\n            << text.substr(0, 80) << \"\\n...\\n\"\n            << text.substr(text.length() - 80) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atomic>\n#include <chrono>\n#include <cmath>\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nclass Integrator\n{\n  public:\n    using clock_type = std::chrono::high_resolution_clock;\n    using dur_t      = std::chrono::duration<double>;\n    using func_t     = double(*)(double);\n\n    explicit Integrator(func_t f = nullptr);\n    ~Integrator();\n    void input(func_t new_input);\n    double output() { return integrate(); }\n\n  private:\n    std::atomic_flag continue_;\n    std::mutex       mutex;\n    std::thread      worker;\n\n    func_t                       func;\n    double                       state = 0;\n    //Improves precision by reducing sin result error on large values\n    clock_type::time_point const beginning = clock_type::now();\n    clock_type::time_point       t_prev = beginning;\n\n    void do_work();\n    double integrate();\n};\n\nIntegrator::Integrator(func_t f) : func(f)\n{\n    continue_.test_and_set();\n    worker = std::thread(&Integrator::do_work, this);\n}\n\nIntegrator::~Integrator()\n{\n    continue_.clear();\n    worker.join();\n}\n\nvoid Integrator::input(func_t new_input)\n{\n    integrate();\n    std::lock_guard<std::mutex> lock(mutex);\n    func = new_input;\n}\n\nvoid Integrator::do_work()\n{\n    while(continue_.test_and_set()) {\n        integrate();\n        std::this_thread::sleep_for(1ms);\n    }\n}\n\ndouble Integrator::integrate()\n{\n    std::lock_guard<std::mutex> lock(mutex);\n    auto now = clock_type::now();\n    dur_t start = t_prev - beginning;\n    dur_t fin   =    now - beginning;\n    if(func)\n        state += (func(start.count()) + func(fin.count())) * (fin - start).count() / 2;\n    t_prev = now;\n    return state;\n}\n\ndouble sine(double time)\n{\n    constexpr double PI = 3.1415926535897932;\n    return std::sin(2 * PI * 0.5 * time);\n}\n\nint main()\n{\n    Integrator foo(sine);\n    std::this_thread::sleep_for(2s);\n    foo.input(nullptr);\n    std::this_thread::sleep_for(500ms);\n    std::cout << foo.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\nusing namespace std;\n\nconst int pasTriMax = 61;\n\nuint64_t pasTri[pasTriMax + 1];\n\nvoid pascalTriangle(unsigned long n)\n// Calculate the n'th line 0.. middle\n{\n    unsigned long j, k;\n\n    pasTri[0] = 1;\n    j = 1;\n    while (j <= n)\n    {\n        j++;\n        k = j / 2;\n        pasTri[k] = pasTri[k - 1];\n        for ( ;k >= 1; k--)\n            pasTri[k] += pasTri[k - 1];\n    }\n}\n\nbool isPrime(unsigned long n)\n{\n    if (n > pasTriMax)\n    {\n        cout << n << \" is out of range\" << endl;\n        exit(1);\n    }\n\n    pascalTriangle(n);\n    bool res = true;\n    int i = n / 2;\n    while (res && (i > 1))\n    {\n        res = res && (pasTri[i] % n == 0);\n        i--;\n    }\n    return res;\n}\n\nvoid expandPoly(unsigned long n)\n{\n    const char vz[] = {'+', '-'};\n\n    if (n > pasTriMax)\n    {\n        cout << n << \" is out of range\" << endl;\n        exit(1);\n    }\n\n    switch (n)\n    {\n        case 0:\n            cout << \"(x-1)^0 = 1\" << endl;\n            break;\n        case 1:\n            cout << \"(x-1)^1 = x-1\" << endl;\n            break;\n        default:\n            pascalTriangle(n);\n            cout << \"(x-1)^\" << n << \" = \";\n            cout << \"x^\" << n;\n            bool bVz = true;\n            int nDiv2 = n / 2;\n            for (unsigned long j = n - 1; j > nDiv2; j--, bVz = !bVz)\n                cout << vz[bVz] << pasTri[n - j] << \"*x^\" << j;\n            for (unsigned long j = nDiv2; j > 1; j--, bVz = !bVz)\n                cout << vz[bVz] << pasTri[j] << \"*x^\" << j;\n            cout << vz[bVz] << pasTri[1] << \"*x\";\n            bVz = !bVz;\n            cout << vz[bVz] << pasTri[0] << endl;\n            break;\n    }\n}\n\nint main()\n{\n    for (unsigned long n = 0; n <= 9; n++)\n        expandPoly(n);\n    for (unsigned long n = 2; n <= pasTriMax; n++)\n        if (isPrime(n))\n            cout << setw(3) << n;\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <list>\n\nbool k_prime(unsigned n, unsigned k) {\n    unsigned f = 0;\n    for (unsigned p = 2; f < k && p * p <= n; p++)\n        while (0 == n % p) { n /= p; f++; }\n    return f + (n > 1 ? 1 : 0) == k;\n}\n\nstd::list<unsigned> primes(unsigned k, unsigned n)  {\n    std::list<unsigned> list;\n    for (unsigned i = 2;list.size() < n;i++)\n        if (k_prime(i, k)) list.push_back(i);\n    return list;\n}\n\nint main(const int argc, const char* argv[]) {\n    using namespace std;\n    for (unsigned k = 1; k <= 5; k++) {\n        ostringstream os(\"\");\n        const list<unsigned> l = primes(k, 10);\n        for (list<unsigned>::const_iterator i = l.begin(); i != l.end(); i++)\n            os << setw(4) << *i;\n        cout << \"k = \" << k << ':' << os.str() << endl;\n    }\n\n\treturn EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nint main() {\n    std::vector<int> alreadyDiscovered;\n    std::unordered_map<int, int> divsumMap;\n    int count = 0;\n\n    for (int N = 1; N <= 20000; ++N)\n    {\n        int divSumN = 0;\n\n        for (int i = 1; i <= N / 2; ++i)\n        {\n            if (fmod(N, i) == 0)\n            {\n                divSumN += i;\n            }\n        }\n\n        // populate map of integers to the sum of their proper divisors\n        if (divSumN != 1) // do not include primes\n            divsumMap[N] = divSumN;\n\n        for (std::unordered_map<int, int>::iterator it = divsumMap.begin(); it != divsumMap.end(); ++it)\n        {\n            int M = it->first;\n            int divSumM = it->second;\n            int divSumN = divsumMap[N];\n\n            if (N != M && divSumM == N && divSumN == M)\n            {\n                // do not print duplicate pairs\n                if (std::find(alreadyDiscovered.begin(), alreadyDiscovered.end(), N) != alreadyDiscovered.end())\n                    break;\n\n                std::cout << \"[\" << M << \", \" << N << \"]\" << std::endl;\n\n                alreadyDiscovered.push_back(M);\n                alreadyDiscovered.push_back(N);\n                count++;\n            }\n        }\n    }\n\n    std::cout << count << \" amicable pairs discovered\" << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <string>\n\nbool is_deranged(const std::string& left, const std::string& right)\n{\n    return (left.size() == right.size()) &&\n        (std::inner_product(left.begin(), left.end(), right.begin(), 0, std::plus<int>(), std::equal_to<char>()) == 0);\n}\n\nint main()\n{\n    std::ifstream input(\"unixdict.txt\");\n    if (!input) {\n        std::cerr << \"can't open input file\\n\";\n        return EXIT_FAILURE;\n    }\n\n    typedef std::set<std::string> WordList;\n    typedef std::map<std::string, WordList> AnagraMap;\n    AnagraMap anagrams;\n\n    std::pair<std::string, std::string> result;\n    size_t longest = 0;\n\n    for (std::string value; input >> value; /**/) {\n        std::string key(value);\n        std::sort(key.begin(), key.end());\n\n        if (longest < value.length()) { // is it a long candidate?\n            if (0 < anagrams.count(key)) { // is it an anagram?\n                for (const auto& prior : anagrams[key]) {\n                    if (is_deranged(prior, value)) { // are they deranged?\n                        result = std::make_pair(prior, value);\n                        longest = value.length();\n                    }\n                }\n            }\n        }\n        anagrams[key].insert(value);\n    }\n\n    std::cout << result.first << ' ' << result.second << '\\n';\n    return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nint main() {\n  std::ifstream in(\"unixdict.txt\");\n  typedef  std::map<std::string, std::vector<std::string> > AnagramMap;\n  AnagramMap anagrams;\n\n  std::string word;\n  size_t count = 0;\n  while (std::getline(in, word)) {\n    std::string key = word;\n    std::sort(key.begin(), key.end());\n    // note: the [] op. automatically inserts a new value if key does not exist\n    AnagramMap::mapped_type & v = anagrams[key];\n    v.push_back(word);\n    count = std::max(count, v.size());\n  }\n\n  in.close();\n\n  for (AnagramMap::const_iterator it = anagrams.begin(), e = anagrams.end();\n       it != e; it++)\n    if (it->second.size() >= count) {\n      std::copy(it->second.begin(), it->second.end(),\n                std::ostream_iterator<std::string>(std::cout, \", \"));\n      std::cout << std::endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __wxPendulumDlg_h__\n#define __wxPendulumDlg_h__\n\n// ---------------------\n/// @author Martin Ettl\n/// @date   2013-02-03\n// ---------------------\n\n#ifdef __BORLANDC__\n#pragma hdrstop\n#endif\n\n#ifndef WX_PRECOMP\n#include <wx/wx.h>\n#include <wx/dialog.h>\n#else\n#include <wx/wxprec.h>\n#endif\n#include <wx/timer.h>\n#include <wx/dcbuffer.h>\n#include <cmath>\n\nclass wxPendulumDlgApp : public wxApp\n{\n    public:\n        bool OnInit();\n        int OnExit();\n};\n\nclass wxPendulumDlg : public wxDialog\n{\n    public:\n\n        wxPendulumDlg(wxWindow *parent, wxWindowID id = 1, const wxString &title = wxT(\"wxPendulum\"),\n\t\t\t\t const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize,\n\t\t\t\t long style = wxSUNKEN_BORDER | wxCAPTION | wxRESIZE_BORDER | wxSYSTEM_MENU | wxDIALOG_NO_PARENT | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxCLOSE_BOX);\n\n        virtual ~wxPendulumDlg();\n\t\n\t\t// Event handler\n        void wxPendulumDlgPaint(wxPaintEvent& event);\n        void wxPendulumDlgSize(wxSizeEvent& event);\n        void OnTimer(wxTimerEvent& event);\n\n    private:\n\n\t\t// a pointer to a timer object\n        wxTimer *m_timer;\n\n\t\tunsigned int m_uiLength;\n\t\tdouble  \t m_Angle;\n\t\tdouble       m_AngleVelocity;\n\n        enum wxIDs\n        {\n            ID_WXTIMER1 = 1001,\n            ID_DUMMY_VALUE_\n        };\n\n        void OnClose(wxCloseEvent& event);\n        void CreateGUIControls();\n\n        DECLARE_EVENT_TABLE()\n};\n\n#endif // __wxPendulumDlg_h__\n"
  },
  {
    "language": "C++",
    "code": "// ---------------------\n/// @author Martin Ettl\n/// @date   2013-02-03\n// ---------------------\n\n#include \"wxPendulumDlg.hpp\"\n#include <wx/pen.h>\n\nIMPLEMENT_APP(wxPendulumDlgApp)\n\nbool wxPendulumDlgApp::OnInit()\n{\n    wxPendulumDlg* dialog = new wxPendulumDlg(NULL);\n    SetTopWindow(dialog);\n    dialog->Show(true);\n    return true;\n}\n\nint wxPendulumDlgApp::OnExit()\n{\n    return 0;\n}\n\nBEGIN_EVENT_TABLE(wxPendulumDlg, wxDialog)\n    EVT_CLOSE(wxPendulumDlg::OnClose)\n    EVT_SIZE(wxPendulumDlg::wxPendulumDlgSize)\n    EVT_PAINT(wxPendulumDlg::wxPendulumDlgPaint)\n    EVT_TIMER(ID_WXTIMER1, wxPendulumDlg::OnTimer)\nEND_EVENT_TABLE()\n\nwxPendulumDlg::wxPendulumDlg(wxWindow *parent, wxWindowID id, const wxString &title, const wxPoint &position, const wxSize& size, long style)\n    : wxDialog(parent, id, title, position, size, style)\n{\n    CreateGUIControls();\n}\n\nwxPendulumDlg::~wxPendulumDlg()\n{\n}\n\nvoid wxPendulumDlg::CreateGUIControls()\n{\n    SetIcon(wxNullIcon);\n    SetSize(8, 8, 509, 412);\n    Center();\n\n\tm_uiLength = 200;\n\tm_Angle    = M_PI/2.;\n\tm_AngleVelocity = 0;\n\n    m_timer = new wxTimer();\n    m_timer->SetOwner(this, ID_WXTIMER1);\n    m_timer->Start(20);\n}\n\nvoid wxPendulumDlg::OnClose(wxCloseEvent& WXUNUSED(event))\n{\n    Destroy();\n}\n\nvoid wxPendulumDlg::wxPendulumDlgPaint(wxPaintEvent& WXUNUSED(event))\n{\n    SetBackgroundStyle(wxBG_STYLE_CUSTOM);\n    wxBufferedPaintDC dc(this);\n\n    // Get window dimensions\n    wxSize sz = GetClientSize();\n\t// determine the center of the canvas\n    const wxPoint center(wxPoint(sz.x / 2, sz.y / 2));\n\n    // create background color\n    wxColour powderblue = wxColour(176,224,230);\n\n    // draw powderblue background\n    dc.SetPen(powderblue);\n    dc.SetBrush(powderblue);\n    dc.DrawRectangle(0, 0, sz.x, sz.y);\n\n    // draw lines\n\twxPen Pen(*wxBLACK_PEN);\n\tPen.SetWidth(1);\n    dc.SetPen(Pen);\n    dc.SetBrush(*wxBLACK_BRUSH);\n\n    double angleAccel, dt = 0.15;\n\n    angleAccel = (-9.81 / m_uiLength) * sin(m_Angle);\n    m_AngleVelocity += angleAccel * dt;\n    m_Angle += m_AngleVelocity * dt;\n\n    int anchorX = sz.x / 2, anchorY = sz.y / 4;\n    int ballX = anchorX + (int)(sin(m_Angle) * m_uiLength);\n    int ballY = anchorY + (int)(cos(m_Angle) * m_uiLength);\n    dc.DrawLine(anchorX, anchorY, ballX, ballY);\n\n    dc.SetBrush(*wxGREY_BRUSH);\n    dc.DrawEllipse(anchorX - 3, anchorY - 4, 7, 7);\n\n    dc.SetBrush(wxColour(255,255,0)); // yellow\n    dc.DrawEllipse(ballX - 7, ballY - 7, 20, 20);\n}\n\nvoid wxPendulumDlg::wxPendulumDlgSize(wxSizeEvent& WXUNUSED(event))\n{\n    Refresh();\n}\n\nvoid wxPendulumDlg::OnTimer(wxTimerEvent& WXUNUSED(event))\n{\n\t// force refresh\n\tRefresh();\n}\n"
  },
  {
    "language": "C++",
    "code": "double fib(double n)\n{\n  if(n < 0)\n  {\n    throw \"Invalid argument passed to fib\";\n  }\n  else\n  {\n    struct actual_fib\n    {\n        static double calc(double n)\n        {\n          if(n < 2)\n          {\n            return n;\n          }\n          else\n          {\n            return calc(n-1) + calc(n-2);\n          }\n        }\n    };\n\n    return actual_fib::calc(n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\nusing namespace std;\n\ndouble fib(double n)\n{\n  if(n < 0)\n    throw \"Invalid argument\";\n\n  function<double(double)> actual_fib = [&](double n)\n  {\n    if(n < 2) return n;\n    return actual_fib(n-1) + actual_fib(n-2);\n  };\n\n  return actual_fib(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "double fib(double n)\n{\n  if(n < 0)\n  {\n    throw \"Invalid argument passed to fib\";\n  }\n  else\n  {\n    struct actual_fib\n    {\n      double operator()(double n)\n      {\n        if(n < 2)\n        {\n          return n;\n        }\n        else\n        {\n          return (*this)(n-1) + (*this)(n-2);\n        }\n      }\n    };\n\n    return actual_fib()(n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nstd::ostream& operator<<(std::ostream& out, const std::string s) {\n    return out << s.c_str();\n}\n\nstruct gecos_t {\n    std::string fullname, office, extension, homephone, email;\n\n    friend std::ostream& operator<<(std::ostream&, const gecos_t&);\n};\n\nstd::ostream& operator<<(std::ostream& out, const gecos_t& g) {\n    return out << g.fullname << ',' << g.office << ',' << g.extension << ',' << g.homephone << ',' << g.email;\n}\n\nstruct passwd_t {\n    std::string account, password;\n    int uid, gid;\n    gecos_t gecos;\n    std::string directory, shell;\n\n    passwd_t(const std::string& a, const std::string& p, int u, int g, const gecos_t& ge, const std::string& d, const std::string& s)\n        : account(a), password(p), uid(u), gid(g), gecos(ge), directory(d), shell(s)\n    {\n        //empty\n    }\n\n    friend std::ostream& operator<<(std::ostream&, const passwd_t&);\n};\n\nstd::ostream& operator<<(std::ostream& out, const passwd_t& p) {\n    return out << p.account << ':' << p.password << ':' << p.uid << ':' << p.gid << ':' << p.gecos << ':' << p.directory << ':' << p.shell;\n}\n\nstd::vector<passwd_t> passwd_list{\n    {\n        \"jsmith\", \"x\", 1001, 1000,\n        {\"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\"},\n        \"/home/jsmith\", \"/bin/bash\"\n    },\n    {\n        \"jdoe\", \"x\", 1002, 1000,\n        {\"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\"},\n        \"/home/jdoe\", \"/bin/bash\"\n    }\n};\n\nint main() {\n    // Write the first two records\n    std::ofstream out_fd(\"passwd.txt\");\n    for (size_t i = 0; i < passwd_list.size(); ++i) {\n        out_fd << passwd_list[i] << '\\n';\n    }\n    out_fd.close();\n\n    // Append the third record\n    out_fd.open(\"passwd.txt\", std::ios::app);\n    out_fd << passwd_t(\"xyz\", \"x\", 1003, 1000, { \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\" }, \"/home/xyz\", \"/bin/bash\") << '\\n';\n    out_fd.close();\n\n    // Verify the record was appended\n    std::ifstream in_fd(\"passwd.txt\");\n    std::string line, temp;\n    while (std::getline(in_fd, temp)) {\n        // the last line of the file is empty, make sure line contains the last record\n        if (!temp.empty()) {\n            line = temp;\n        }\n    }\n    if (line.substr(0, 4) == \"xyz:\") {\n        std::cout << \"Appended record: \" << line << '\\n';\n    } else {\n        std::cout << \"Failed to find the expected record appended.\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> //cout for printing\n#include <algorithm> //for_each defined here\n\n//create the function (print the square)\nvoid print_square(int i) {\n  std::cout << i*i << \" \";\n}\n\nint main() {\n  //create the array\n  int ary[]={1,2,3,4,5};\n  //stl for_each\n  std::for_each(ary,ary+5,print_square);\n  return 0;\n}\n//prints 1 4 9 16 25\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  // cout for printing\n#include <algorithm> // for_each defined here\n#include <vector>    // stl vector class\n\n// create the function (print the square)\nvoid print_square(int i) {\n  std::cout << i*i << \" \";\n}\n\nint main() {\n  // create the array\n  std::vector<int> ary;\n  ary.push_back(1);\n  ary.push_back(2);\n  ary.push_back(3);\n  ary.push_back(4);\n  ary.push_back(5);\n  // stl for_each\n  std::for_each(ary.begin(),ary.end(),print_square);\n  return 0;\n}\n//prints 1 4 9 16 25\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>   // cout for printing\n#include <algorithm>  // for_each defined here\n#include <vector>     // stl vector class\n#include <functional> // bind and ptr_fun\n\n// create a binary function (print any two arguments together)\ntemplate<class type1,class type2>\nvoid print_juxtaposed(type1 x, type2 y) {\n  std::cout << x << y;\n}\n\nint main() {\n  // create the array\n  std::vector<int> ary;\n  ary.push_back(1);\n  ary.push_back(2);\n  ary.push_back(3);\n  ary.push_back(4);\n  ary.push_back(5);\n  // stl for_each, using binder and adaptable unary function\n  std::for_each(ary.begin(),ary.end(),std::bind2nd(std::ptr_fun(print_juxtaposed<int,std::string>),\"x \"));\n  return 0;\n}\n//prints 1x 2x 3x 4x 5x\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\nusing namespace boost::lambda;\nvector<int> ary(10);\nint i = 0;\nfor_each(ary.begin(), ary.end(), _1 = ++var(i)); // init array\ntransform(ary.begin(), ary.end(), ostream_iterator<int>(cout, \" \"), _1 * _1); // square and output\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nint main() {\n   std::vector<int> intVec(10);\n   std::iota(std::begin(intVec), std::end(intVec), 1 ); // Fill the vector\n   std::transform(std::begin(intVec) , std::end(intVec), std::begin(intVec),\n\t [](int i) { return i * i ; } ); // Transform it with closures\n   std::copy(std::begin(intVec), end(intVec) ,\n\t std::ostream_iterator<int>(std::cout, \" \"));\n   std::cout << std::endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <boost/multiprecision/gmp.hpp>\n#include <string>\n\nnamespace mp = boost::multiprecision;\n\nint main(int argc, char const *argv[])\n{\n    // We could just use (1 << 18) instead of tmpres, but let's point out one\n    // pecularity with gmp and hence boost::multiprecision: they won't accept\n    // a second mpz_int with pow(). Therefore, if we stick to multiprecision\n    // pow we need to convert_to<uint64_t>().\n    uint64_t tmpres = mp::pow(mp::mpz_int(4)\n                            , mp::pow(mp::mpz_int(3)\n                                    , 2).convert_to<uint64_t>()\n                                      ).convert_to<uint64_t>();\n    mp::mpz_int res = mp::pow(mp::mpz_int(5), tmpres);\n    std::string s = res.str();\n    std::cout << s.substr(0, 20)\n              << \"...\"\n              << s.substr(s.length() - 20, 20) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "T* foo = new(arena) T;\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cassert>\n#include <new>\n\n// This class basically provides a global stack of pools; it is not thread-safe, and pools must be destructed in reverse order of construction\n// (you definitely want something better in production use :-))\nclass Pool\n{\npublic:\n  Pool(std::size_type sz);\n  ~Pool();\n  static Pool& current() { return *cur; }\n  void* allocate(std::size_type sz, std::size_t alignment);\nprivate:\n  char* memory; // char* instead of void* enables pointer arithmetic\n  char* free;\n  char* end;\n  Pool* prev;\n  static Pool* cur;\n\n  // prohibit copying\n  Pool(Pool const&); // not implemented\n  Pool& operator=(Pool const&); // not implemented\n};\n\nPool* pool::cur = 0;\n\nPool::Pool(std::size_type size):\n  memory(static_cast<char*>(::operator new(size))),\n  free(memory),\n  end(memory + size))\n{\n  prev = cur;\n  cur = this;\n}\n\nPool::~Pool()\n{\n  ::operator delete(memory);\n  cur = prev;\n}\n\nvoid* Pool::allocate(std::size_t size, std::size_t alignment)\n{\n  char* start = free;\n\n  // align the pointer\n  std::size_t extra = (start - memory) % aligment;\n  if (extra != 0)\n  {\n    extra = alignment - extra;\n  }\n\n  // test if we can still allocate that much memory\n  if (end - free < size + extra)\n    throw std::bad_alloc();\n\n  // the free memory now starts after the newly allocated object\n  free = start + size + extra;\n  return start;\n}\n\n// this is just a simple C-like struct, except that it uses a specific allocation/deallocation function.\nstruct X\n{\n  int member;\n  void* operator new(std::size_t);\n  void operator delete(void*) {} // don't deallocate memory for single objects\n};\n\nvoid* X::operator new(std::size_t size)\n{\n  // unfortunately C++ doesn't offer a portable way to find out alignment\n  // however, using the size as alignment is always safe (although usually wasteful)\n  return Pool::current().allocate(size, size);\n}\n\n// Example program\nint main()\n{\n  Pool my_pool(3*sizeof(X));\n  X* p1 = new X; // uses the allocator function defined above\n  X* p2 = new X;\n  X* p3 = new X;\n  delete p3; // doesn't really deallocate the memory because operator delete has an empty body\n\n  try\n  {\n    X* p4 = new X; // should fail\n    assert(false);\n  }\n  catch(...)\n  {\n  }\n\n  X* p5 = new X[10]; // uses global array allocation routine because we didn't provide operator new[] and operator delete[]\n  delete[] p5; // global array deallocation\n\n  Pool* my_second_pool(1000); // a large pool\n  X* p6 = new X; // allocate a new object from that pool\n  X* p7 = new X;\n  delete my_second_pool // also deallocates the memory for p6 and p7\n\n} // Here my_pool goes out of scope, deallocating the memory for p1, p2 and p3\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing std::complex;\n\nvoid complex_operations() {\n  complex<double> a(1.0, 1.0);\n  complex<double> b(3.14159, 1.25);\n\n  // addition\n  std::cout << a + b << std::endl;\n  // multiplication\n  std::cout << a * b << std::endl;\n  // inversion\n  std::cout << 1.0 / a << std::endl;\n  // negation\n  std::cout << -a << std::endl;\n  // conjugate\n  std::cout << std::conj(a) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <boost/spirit.hpp>\n #include <boost/spirit/tree/ast.hpp>\n #include <string>\n #include <cassert>\n #include <iostream>\n #include <istream>\n #include <ostream>\n\n using boost::spirit::rule;\n using boost::spirit::parser_tag;\n using boost::spirit::ch_p;\n using boost::spirit::real_p;\n\n using boost::spirit::tree_node;\n using boost::spirit::node_val_data;\n\n // The grammar\n struct parser: public boost::spirit::grammar<parser>\n {\n   enum rule_ids { addsub_id, multdiv_id, value_id, real_id };\n\n   struct set_value\n   {\n     set_value(parser const& p): self(p) {}\n     void operator()(tree_node<node_val_data<std::string::iterator,\n                                             double> >& node,\n                     std::string::iterator begin,\n                     std::string::iterator end) const\n     {\n       node.value.value(self.tmp);\n     }\n     parser const& self;\n   };\n\n   mutable double tmp;\n\n   template<typename Scanner> struct definition\n   {\n     rule<Scanner, parser_tag<addsub_id> > addsub;\n     rule<Scanner, parser_tag<multdiv_id> > multdiv;\n     rule<Scanner, parser_tag<value_id> > value;\n     rule<Scanner, parser_tag<real_id> > real;\n\n     definition(parser const& self)\n     {\n       using namespace boost::spirit;\n       addsub = multdiv\n         >> *((root_node_d[ch_p('+')] | root_node_d[ch_p('-')]) >> multdiv);\n       multdiv = value\n         >> *((root_node_d[ch_p('*')] | root_node_d[ch_p('/')]) >> value);\n       value = real | inner_node_d[('(' >> addsub >> ')')];\n       real = leaf_node_d[access_node_d[real_p[assign_a(self.tmp)]][set_value(self)]];\n     }\n\n     rule<Scanner, parser_tag<addsub_id> > const& start() const\n     {\n       return addsub;\n     }\n   };\n };\n\n template<typename TreeIter>\n double evaluate(TreeIter const& i)\n {\n   double op1, op2;\n   switch (i->value.id().to_long())\n   {\n   case parser::real_id:\n     return i->value.value();\n   case parser::value_id:\n   case parser::addsub_id:\n   case parser::multdiv_id:\n     op1 = evaluate(i->children.begin());\n     op2 = evaluate(i->children.begin()+1);\n     switch(*i->value.begin())\n     {\n     case '+':\n       return op1 + op2;\n     case '-':\n       return op1 - op2;\n     case '*':\n       return op1 * op2;\n     case '/':\n       return op1 / op2;\n     default:\n       assert(!\"Should not happen\");\n     }\n   default:\n     assert(!\"Should not happen\");\n   }\n   return 0;\n }\n\n // the read/eval/write loop\n int main()\n {\n   parser eval;\n   std::string line;\n   while (std::cout << \"Expression: \"\n          && std::getline(std::cin, line)\n          && !line.empty())\n   {\n     typedef boost::spirit::node_val_data_factory<double> factory_t;\n     boost::spirit::tree_parse_info<std::string::iterator, factory_t> info =\n       boost::spirit::ast_parse<factory_t>(line.begin(), line.end(),\n                                           eval, boost::spirit::space_p);\n     if (info.full)\n     {\n       std::cout << \"Result: \" << evaluate(info.trees.begin()) << std::endl;\n     }\n     else\n     {\n       std::cout << \"Error in expression.\" << std::endl;\n     }\n   }\n };\n"
  },
  {
    "language": "C++",
    "code": "#include <gmpxx.h>\n\nvoid agm(mpf_class& rop1, mpf_class& rop2, const mpf_class& op1,\n        const mpf_class& op2)\n{\n    rop1 = (op1 + op2) / 2;\n    rop2 = op1 * op2;\n    mpf_sqrt(rop2.get_mpf_t(), rop2.get_mpf_t());\n}\n\nint main(void)\n{\n    mpf_set_default_prec(300000);\n    mpf_class x0, y0, resA, resB, Z;\n\n    x0 = 1;\n    y0 = 0.5;\n    Z  = 0.25;\n    mpf_sqrt(y0.get_mpf_t(), y0.get_mpf_t());\n\n    int n = 1;\n    for (int i = 0; i < 8; i++) {\n        agm(resA, resB, x0, y0);\n        Z -= n * (resA - x0) * (resA - x0);\n        n *= 2;\n\n        agm(x0, y0, resA, resB);\n        Z -= n * (x0 - resA) * (x0 - resA);\n        n *= 2;\n    }\n\n    x0 = x0 * x0 / Z;\n    gmp_printf (\"%.100000Ff\\n\", x0.get_mpf_t());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define _cin\tios_base::sync_with_stdio(0);\tcin.tie(0);\n#define rep(a, b)\tfor(ll i =a;i<=b;++i)\n\ndouble agm(double a, double g)\t\t//ARITHMETIC GEOMETRIC MEAN\n{\tdouble epsilon = 1.0E-16,a1,g1;\n\tif(a*g<0.0)\n\t{\tcout<<\"Couldn't find arithmetic-geometric mean of these numbers\\n\";\n\t\texit(1);\n\t}\n\twhile(fabs(a-g)>epsilon)\n\t{\ta1 = (a+g)/2.0;\n\t\tg1 = sqrt(a*g);\n\t\ta = a1;\n\t\tg = g1;\n\t}\n\treturn a;\n}\n\nint main()\n{\t_cin;    //fast input-output\n\tdouble x, y;\n\tcout<<\"Enter X and Y: \";\t//Enter two numbers\n\tcin>>x>>y;\n\tcout<<\"\\nThe Arithmetic-Geometric Mean of \"<<x<<\" and \"<<y<<\" is \"<<agm(x, y);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n  int a, b;\n  std::cin >> a >> b;\n  std::cout << \"a+b = \" << a+b << \"\\n\";\n  std::cout << \"a-b = \" << a-b << \"\\n\";\n  std::cout << \"a*b = \" << a*b << \"\\n\";\n  std::cout << \"a/b = \" << a/b << \", remainder \" << a%b << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include \"math.h\"\n#include \"boost/rational.hpp\"\n\ntypedef  boost::rational<int> frac;\n\nbool is_perfect(int c)\n{\n    frac sum(1, c);\n    for (int f = 2;f < sqrt(static_cast<float>(c)); ++f){\n\n        if (c % f == 0) sum += frac(1,f) + frac(1, c/f);\n    }\n    if (sum.denominator() == 1){\n \treturn (sum == 1);\n    }\n    return false;\n}\n\nint main()\n{\n    for (int candidate = 2; candidate < 0x80000; ++candidate){\n        if (is_perfect(candidate))\n\t        std::cout << candidate << \" is perfect\" << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nint main()\n{\n  std::vector<int> a(3), b(4);\n  a[0] = 11; a[1] = 12; a[2] = 13;\n  b[0] = 21; b[1] = 22; b[2] = 23; b[3] = 24;\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for (int i = 0; i < a.size(); ++i)\n    std::cout << \"a[\" << i << \"] = \" << a[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nint main() {\n  std::vector<int> a {1, 2, 3, 4};\n  std::vector<int> b {5, 6, 7, 8, 9};\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for(int& i: a) std::cout << i << \" \";\n  std::cout << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntemplate <typename T1, typename T2>\nint* concatArrays( T1& array_1, T2& array_2) {\n  int arrayCount_1 = sizeof(array_1) / sizeof(array_1[0]);\n  int arrayCount_2 = sizeof(array_2) / sizeof(array_2[0]);\n  int newArraySize = arrayCount_1 + arrayCount_2;\n\n  int *p = new int[newArraySize];\n\n  for (int i = 0; i < arrayCount_1; i++) {\n    p[i] = array_1[i];\n  }\n\n  for (int i = arrayCount_1; i < newArraySize; i++) {\n    int newIndex = i-arrayCount_2;\n\n    if (newArraySize % 2 == 1)\n\tnewIndex--;\n\n    p[i] = array_2[newIndex];\n    cout << \"i: \" << i << endl;\n    cout << \"array_2[i]: \" << array_2[newIndex] << endl;\n    cout << endl;\n  }\n\n  return p;\n}\n\nint main() {\n\n  int ary[4] = {1, 2, 3, 123};\n  int anotherAry[3] = {4, 5, 6};\n\n  int *r = concatArrays(ary, anotherAry);\n\n  cout << *(r + 0) << endl;\n  cout << *(r + 1) << endl;\n  cout << *(r + 2) << endl;\n  cout << *(r + 3) << endl;\n  cout << *(r + 4) << endl;\n  cout << *(r + 5) << endl;\n  cout << *(r + 6) << endl;\n\n  delete r;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <vector>\n\n// These headers are only needed for the demonstration\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n\n// This is a template function that works for any array-like object\ntemplate <typename Array>\nvoid demonstrate(Array& array)\n{\n  // Array element access\n  array[2] = \"Three\";  // Fast, but unsafe - if the index is out of bounds you\n                       // get undefined behaviour\n  array.at(1) = \"Two\"; // *Slightly* less fast, but safe - if the index is out\n                       // of bounds, an exception is thrown\n\n  // Arrays can be used with standard algorithms\n  std::reverse(begin(array), end(array));\n  std::for_each(begin(array), end(array),\n    [](typename Array::value_type const& element) // in C++14, you can just use auto\n    {\n      std::cout << element << ' ';\n    });\n\n  std::cout << '\\n';\n}\n\nint main()\n{\n  // Compile-time sized fixed-size array\n  auto fixed_size_array = std::array<std::string, 3>{ \"One\", \"Four\", \"Eight\" };\n  // If you do not supply enough elements, the remainder are default-initialized\n\n  // Dynamic array\n  auto dynamic_array = std::vector<std::string>{ \"One\", \"Four\" };\n  dynamic_array.push_back(\"Eight\"); // Dynamically grows to accept new element\n\n  // All types of arrays can be used more or less interchangeably\n  demonstrate(fixed_size_array);\n  demonstrate(dynamic_array);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert> // assert.h also works\n\nint main()\n{\n  int a;\n  // ... input or change a here\n\n  assert(a == 42); // Aborts program if a is not 42, unless the NDEBUG macro was defined\n                    // when including <cassert>, in which case it has no effect\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostreams>\n\nint main()\n{\n  // Create the map.\n  std::map<int, double> exampleMap;\n\n  // Choose our key\n  int myKey = 7;\n\n  // Choose our value\n  double myValue = 3.14;\n\n  // Assign a value to the map with the specified key.\n  exampleMap[myKey] = myValue;\n\n  // Retrieve the value\n  double myRetrievedValue = exampleMap[myKey];\n\n  // Display our retrieved value.\n  std::cout << myRetrievedValue << std::endl;\n\n  // main() must return 0 on success.\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "std::map<A, B> exampleMap\n"
  },
  {
    "language": "C++",
    "code": "std::map<int, double> exampleMap\n"
  },
  {
    "language": "C++",
    "code": "exampleMap[7] = 3.14\n"
  },
  {
    "language": "C++",
    "code": "int myKey = 7;\ndouble myValue = 3.14;\nexampleMap[myKey] = myValue;\n"
  },
  {
    "language": "C++",
    "code": "exampleMap.insert(std::pair<int, double>(7,3.14));\n"
  },
  {
    "language": "C++",
    "code": "exampleMap.insert(std::make_pair(7,3.14));\n"
  },
  {
    "language": "C++",
    "code": "myValue = exampleMap[myKey]\n"
  },
  {
    "language": "C++",
    "code": "double myValue = 0.0;\nstd::map<int, double>::iterator myIterator = exampleMap.find(myKey);\nif(exampleMap.end() != myIterator)\n{\n  // Return the value for that key.\n  myValue = myIterator->second;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  std::map<std::string, int> dict {\n    {\"One\", 1},\n    {\"Two\", 2},\n    {\"Three\", 7}\n  };\n\n  dict[\"Three\"] = 3;\n\n  std::cout << \"One: \" << dict[\"One\"] << std::endl;\n  std::cout << \"Key/Value pairs: \" << std::endl;\n  for(auto& kv: dict) {\n    std::cout << \"  \" << kv.first << \": \" << kv.second << std::endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "std::map<std::string, int> myDict;\nmyDict[\"hello\"] = 1;\nmyDict[\"world\"] = 2;\nmyDict[\"!\"] = 3;\n\n// iterating over key-value pairs:\nfor (std::map<std::string, int>::iterator it = myDict.begin(); it != myDict.end(); ++it) {\n    // the thing pointed to by the iterator is an std::pair<const std::string, int>&\n    const std::string& key = it->first;\n    int& value = it->second;\n    std::cout << \"key = \" << key << \", value = \" << value << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <chrono>\n#include <iomanip>\n#include <iostream>\n#include <mutex>\n#include <random>\n#include <thread>\n\nusing namespace std;\n\nconstexpr int bucket_count = 15;\n\nvoid equalizer(array<int, bucket_count>& buckets,\n               array<mutex, bucket_count>& bucket_mutex) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);\n\n    while (true) {\n        int from = dist_bucket(gen);\n        int to = dist_bucket(gen);\n        if (from != to) {\n            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);\n            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);\n            int diff = buckets[from] - buckets[to];\n            int amount = abs(diff / 2);\n            if (diff < 0) {\n                swap(from, to);\n            }\n            buckets[from] -= amount;\n            buckets[to] += amount;\n        }\n    }\n}\n\nvoid randomizer(array<int, bucket_count>& buckets,\n                array<mutex, bucket_count>& bucket_mutex) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);\n\n    while (true) {\n        int from = dist_bucket(gen);\n        int to = dist_bucket(gen);\n        if (from != to) {\n            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);\n            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);\n            uniform_int_distribution<> dist_amount(0, buckets[from]);\n            int amount = dist_amount(gen);\n            buckets[from] -= amount;\n            buckets[to] += amount;\n        }\n    }\n}\n\nvoid print_buckets(const array<int, bucket_count>& buckets) {\n    int total = 0;\n    for (const int& bucket : buckets) {\n        total += bucket;\n        cout << setw(3) << bucket << ' ';\n    }\n    cout << \"= \" << setw(3) << total << endl;\n}\n\nint main() {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist(0, 99);\n\n    array<int, bucket_count> buckets;\n    array<mutex, bucket_count> bucket_mutex;\n    for (int& bucket : buckets) {\n        bucket = dist(gen);\n    }\n    print_buckets(buckets);\n\n    thread t_eq(equalizer, ref(buckets), ref(bucket_mutex));\n    thread t_rd(randomizer, ref(buckets), ref(bucket_mutex));\n\n    while (true) {\n        this_thread::sleep_for(chrono::seconds(1));\n        for (mutex& mutex : bucket_mutex) {\n            mutex.lock();\n        }\n        print_buckets(buckets);\n        for (mutex& mutex : bucket_mutex) {\n            mutex.unlock();\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <random>\n#include <vector>\n#include <iostream>\n\n#define MAX_N 20\n#define TIMES 1000000\n\n/**\n * Used to generate a uniform random distribution\n */\nstatic std::random_device rd;  //Will be used to obtain a seed for the random number engine\nstatic std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()\nstatic std::uniform_int_distribution<> dis;\n\nint randint(int n) {\n    int r, rmax = RAND_MAX / n * n;\n    dis=std::uniform_int_distribution(0,rmax) ;\n    r = dis(gen);\n    return r / (RAND_MAX / n);\n}\n\nunsigned long factorial(size_t n) {\n    //Factorial using dynamic programming to memoize the values.\n    static std::vector<unsigned long>factorials{1,1,2};\n\tfor (;factorials.size() <= n;)\n\t    factorials.push_back(factorials.back()*factorials.size());\n\treturn factorials[n];\n}\n\nlong double expected(size_t n) {\n    long double sum = 0;\n    for (size_t i = 1; i <= n; i++)\n        sum += factorial(n) / pow(n, i) / factorial(n - i);\n    return sum;\n}\n\nint test(int n, int times) {\n    int i, count = 0;\n    for (i = 0; i < times; i++) {\n        unsigned int x = 1, bits = 0;\n        while (!(bits & x)) {\n            count++;\n            bits |= x;\n            x = static_cast<unsigned int>(1 << randint(n));\n        }\n    }\n    return count;\n}\n\nint main() {\n    puts(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\");\n\n    int n;\n    for (n = 1; n <= MAX_N; n++) {\n        int cnt = test(n, TIMES);\n        long double avg = (double)cnt / TIMES;\n        long double theory = expected(static_cast<size_t>(n));\n        long double diff = (avg / theory - 1) * 100;\n        printf(\"%2d %8.4f %8.4f %6.3f%%\\n\", n, static_cast<double>(avg), static_cast<double>(theory), static_cast<double>(diff));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n\ndouble mean(const std::vector<double>& numbers)\n{\n     if (numbers.size() == 0)\n          return 0;\n\n     double sum = 0;\n     for (std::vector<double>::iterator i = numbers.begin(); i != numbers.end(); i++)\n          sum += *i;\n     return sum / numbers.size();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n\ndouble mean(const std::vector<double>& numbers)\n{\n    if (numbers.empty())\n        return 0;\n    return std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic interface IShape\n{\n    double GetArea();\n}\n\nclass Rectangle : IShape\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n\n    public double GetArea()\n    {\n        return Width * Height;\n    }\n}\n\nclass Circle : IShape\n{\n    public double Radius { get; set; }\n\n    public double GetArea()\n    {\n        return Math.PI * Radius * Radius;\n    }\n}\n\nclass ShapeCalculator\n{\n    public double CalculateTotalArea(IShape[] shapes)\n    {\n        double totalArea = 0;\n        foreach (var shape in shapes)\n        {\n            totalArea += shape.GetArea();\n        }\n        return totalArea;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Database\n{\n    private List<string> data = new List<string>();\n\n    public void Insert(string item)\n    {\n        data.Add(item);\n    }\n\n    public void Delete(string item)\n    {\n        data.Remove(item);\n    }\n\n    public void DisplayAllItems()\n    {\n        foreach (var item in data)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\nclass DataManager\n{\n    public void ManageData()\n    {\n        Database db = new Database();\n        db.Insert(\"Item 1\");\n        db.Insert(\"Item 2\");\n        db.Delete(\"Item 1\");\n        db.DisplayAllItems();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class ComplexNumber\n{\n    public double Real { get; private set; }\n    public double Imaginary { get; private set; }\n\n    public ComplexNumber(double real, double imaginary)\n    {\n        Real = real;\n        Imaginary = imaginary;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber c1, ComplexNumber c2)\n    {\n        return new ComplexNumber(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);\n    }\n\n    public override string ToString()\n    {\n        return $\"({Real} + {Imaginary}i)\";\n    }\n}\n\nclass ComplexNumberOperations\n{\n    public void PerformComplexOperations()\n    {\n        ComplexNumber num1 = new ComplexNumber(3, 4);\n        ComplexNumber num2 = new ComplexNumber(2, 7);\n        ComplexNumber sum = num1 + num2;\n        Console.WriteLine(\"Sum: \" + sum);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic abstract class Shape\n{\n    public abstract double Area();\n}\n\nclass Circle : Shape\n{\n    public double Radius { get; set; }\n\n    public override double Area()\n    {\n        return Math.PI * Radius * Radius;\n    }\n}\n\nclass Square : Shape\n{\n    public double SideLength { get; set; }\n\n    public override double Area()\n    {\n        return SideLength * SideLength;\n    }\n}\n\nclass ShapeCalculator\n{\n    public double CalculateTotalArea(Shape[] shapes)\n    {\n        double totalArea = 0;\n        foreach (var shape in shapes)\n        {\n            totalArea += shape.Area();\n        }\n        return totalArea;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "class HundredDoors {\n    public static void main(String[] args) {\n        boolean[] doors = new boolean[101];\n\n        for (int i = 1; i < doors.length; i++) {\n            for (int j = i; j < doors.length; j += i) {\n                doors[j] = !doors[j];\n            }\n        }\n\n        for (int i = 1; i < doors.length; i++) {\n            if (doors[i]) {\n                System.out.printf(\"Door %d is open.%n\", i);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\n\npublic class HundredDoors {\n    public static void main(String[] args) {\n        final int n = 100;\n        var a = new BitSet(n);\n        for (int i = 1; i <= n; i++) {\n            for (int j = i - 1; j < n; j += i) {\n                a.flip(j);\n            }\n        }\n        a.stream().map(i -> i + 1).forEachOrdered(System.out::println);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "class HundredDoors {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++)\n            System.out.printf(\"Door %d is open.%n\", i * i);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nclass HundredDoors {\n    public static void main(String args[]) {\n        String openDoors = IntStream.rangeClosed(1, 100)\n                .filter(i -> Math.pow((int) Math.sqrt(i), 2) == i)\n                .mapToObj(Integer::toString)\n                .collect(Collectors.joining(\", \"));\n        System.out.printf(\"Open doors: %s%n\", openDoors);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {\n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\nimport static java.lang.Math.min;\n\npublic class Test {\n\n    static List<BigInteger> cumu(int n) {\n        List<List<BigInteger>> cache = new ArrayList<>();\n        cache.add(asList(BigInteger.ONE));\n\n        for (int L = cache.size(); L < n + 1; L++) {\n            List<BigInteger> r = new ArrayList<>();\n            r.add(BigInteger.ZERO);\n            for (int x = 1; x < L + 1; x++)\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\n            cache.add(r);\n        }\n        return cache.get(n);\n    }\n\n    static List<BigInteger> row(int n) {\n        List<BigInteger> r = cumu(n);\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Rows:\");\n        for (int x = 1; x < 11; x++)\n            System.out.printf(\"%2d: %s%n\", x, row(x));\n\n        System.out.println(\"\\nSums:\");\n        for (int x : new int[]{23, 123, 1234}) {\n            List<BigInteger> c = cumu(x);\n            System.out.printf(\"%s %s%n\", x, c.get(c.size() - 1));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.text.MessageFormat;\n\npublic class Beer {\n    static String bottles(int n) {\n        return MessageFormat.format(\"{0,choice,0#No more bottles|1#One bottle|2#{0} bottles} of beer\", n);\n    }\n\n    public static void main(String[] args) {\n        String bottles = bottles(99);\n        for (int n = 99; n > 0; ) {\n            System.out.println(bottles + \" on the wall\");\n            System.out.println(bottles);\n            System.out.println(\"Take one down, pass it around\");\n            bottles = bottles(--n);\n            System.out.println(bottles + \" on the wall\");\n            System.out.println();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Beer {\n    public static void main(String[] args) {\n        int bottles = 99;\n        StringBuilder sb = new StringBuilder();\n        String verse1 = \" bottles of beer on the wall\\n\";\n        String verse2 = \" bottles of beer.\\nTake one down, pass it around,\\n\";\n        String verse3 = \"Better go to the store and buy some more.\";\n\n        while (bottles > 0)\n            sb.append(bottles).append(verse1).append(bottles).append(verse2).append(--bottles).append(verse1).append(\"\\n\");\n\n        System.out.println(sb.append(verse3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Beer {\n    public static void main(String args[]) {\n        song(99);\n    }\n\n    public static void song(int bottles) {\n        if (bottles >= 0) {\n            if (bottles > 1)\n                System.out.println(bottles + \" bottles of beer on the wall\\n\" + bottles + \" bottles of beer\\nTake one down, pass it around\\n\" + (bottles - 1) + \" bottles of beer on the wall.\\n\");\n            else if (bottles == 1)\n                System.out.println(bottles + \" bottle of beer on the wall\\n\" + bottles + \" bottle of beer\\nTake one down, pass it around\\n\" + (bottles - 1) + \" bottles of beer on the wall.\\n\");\n            else\n                System.out.println(bottles + \" bottles of beer on the wall\\n\" + bottles + \" bottles of beer\\nBetter go to the store and buy some more!\");\n            song(bottles - 1);\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.BorderLayout;\nimport java.awt.event.ActionEvent;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.JTextArea;\n\npublic class Beer extends JFrame {\n    private int x;\n    private JTextArea text;\n\n    public static void main(String[] args) {\n        new Beer().setVisible(true);\n    }\n\n    public Beer() {\n        x = 99;\n\n        JButton take = new JButton(\"Take one down, pass it around\");\n        take.addActionListener(this::onTakeClick);\n\n        text = new JTextArea(4, 30);\n        text.setText(x + \" bottles of beer on the wall\\n\" + x + \" bottles of beer\");\n        text.setEditable(false);\n\n        setLayout(new BorderLayout());\n        add(text, BorderLayout.CENTER);\n        add(take, BorderLayout.PAGE_END);\n        pack();\n        setLocationRelativeTo(null);\n        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n    }\n\n    private void onTakeClick(ActionEvent event) {\n        JOptionPane.showMessageDialog(null, --x + \" bottles of beer on the wall\");\n        text.setText(x + \" bottles of beer on the wall\\n\" + x + \" bottles of beer\");\n        if (x == 0) {\n            dispose();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); // Standard input\n        System.out.println(in.nextInt() + in.nextInt()); // Standard output\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class SumDif {\n   StreamTokenizer in;\n   PrintWriter out;\n\n   public static void main(String[] args) throws IOException {\n      new SumDif().run();\n   }\n\n   private int nextInt() throws IOException {\n      in.nextToken();\n      return (int)in.nval;\n   }\n\n   public void run() throws IOException {\n      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // Standard input\n      out = new PrintWriter(new OutputStreamWriter(System.out)); // Standard output\n      solve();\n      out.flush();\n   }\n\n   private void solve() throws IOException {\n      out.println(nextInt() + nextInt());\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.nio.charset.Charset;\n\npublic class AplusB {\n    public static void main(String[] args) throws IOException {\n        StreamTokenizer in = new StreamTokenizer(new InputStreamReader(System.in, Charset.defaultCharset()));\n        in.nextToken();\n        int a = (int) in.nval;\n        in.nextToken();\n        int b = (int) in.nval;\n\n        try (Writer out = new OutputStreamWriter(System.out, Charset.defaultCharset())) {\n            out.write(Integer.toString(a + b));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "grammar aplusb ;\n\noptions {\n\tlanguage = Java;\n}\n\naplusb\t:\t(WS* e1=Num WS+ e2=Num NEWLINE {System.out.println($e1.text + \" + \" + $e2.text + \" = \" + (Integer.parseInt($e1.text) + Integer.parseInt($e2.text)));})+\n\t;\nNum\t:\t'-'?('0'..'9')+\n\t;\nWS\t:\t(' ' | '\\t')\n\t;\nNEWLINE\t:\tWS* '\\r'? '\\n'\n        ;\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ABC {\n\n    public static void main(String[] args) {\n        List<String> blocks = Arrays.asList(\n                \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n                \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n                \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\");\n\n        for (String word : Arrays.asList(\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\")) {\n            System.out.printf(\"%s: %s%n\", word.isEmpty() ? \"\\\"\\\"\" : word, canMakeWord(word, blocks));\n        }\n    }\n\n    public static boolean canMakeWord(String word, List<String> blocks) {\n        if (word.isEmpty())\n            return true;\n\n        char c = word.charAt(0);\n        for (int i = 0; i < blocks.size(); i++) {\n            String b = blocks.get(i);\n            if (b.charAt(0) != c && b.charAt(1) != c)\n                continue;\n            Collections.swap(blocks, 0, i);\n            if (canMakeWord(word.substring(1), blocks.subList(1, blocks.size())))\n                return true;\n            Collections.swap(blocks, 0, i);\n        }\n\n        return false;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public interface Inter {\n    int method1(double value);\n    int method2(String name);\n    int add(int a, int b);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n\n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n\n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n\n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Accumulator\n    //implements java.util.function.UnaryOperator<Number> // Java 8\n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t// Acts like sum += n, but chooses long or double.\n\t// Converts weird types (like BigInteger) to double.\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.function.UnaryOperator;\n\npublic class AccumulatorFactory {\n\n    public static UnaryOperator<Number> accumulator(Number sum0) {\n\t// Allows sum[0] = ... inside lambda.\n\tNumber[] sum = { sum0 };\n\n\t// Acts like n -> sum[0] += n, but chooses long or double.\n\t// Converts weird types (like BigInteger) to double.\n\treturn n -> (longable(sum[0]) && longable(n)) ?\n\t    (sum[0] = sum[0].longValue() + n.longValue()) :\n\t    (sum[0] = sum[0].doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tUnaryOperator<Number> x = accumulator(1);\n\tx.apply(5);\n\taccumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class AccumulatorFactory {\n\n    public interface Accumulator {\n        double add(double x);\n    }\n\n    private static Accumulator accumulator(final double initial) {\n        return new Accumulator() {\n            private double sum = initial;\n\n            @Override\n            public double add(double x) {\n                return sum += x;\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        Accumulator x = accumulator(1.0);\n        x.add(5.0);\n        System.out.println(accumulator(3.0));\n        System.out.println(x.add(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.function.DoubleUnaryOperator;\n\npublic interface AccumulatorFactory {\n  public static DoubleUnaryOperator accumulator(double element) {\n    double[] sum = { element };\n    return value -> sum[0] += value;\n  }\n\n  public static void main(String... arguments) {\n    DoubleUnaryOperator x = accumulator(1.0);\n    x.applyAsDouble(5.0);\n    System.out.println(accumulator(3.0));\n    System.out.println(x.applyAsDouble(2.3));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Accumulator {\n    private Long sumA; // non-null if we're working in the integer domain\n    private double sumB;\n    public Accumulator(Number sum0) {\n\tif (sum0 instanceof Double) {\n\t    sumB = sum0.doubleValue();\n\t} else {\n\t    sumA = sum0.longValue();\n\t}\n    }\n    public Number call(Number n) {\n        if (sumA != null) {\n\t    if (n instanceof Double) {\n\t\tsumB = n.doubleValue() + sumA;\n\t\tsumA = null;\n\t\treturn sumB;\n\t    }\n            return sumA += n.longValue();\n        }\n        return sumB += n.doubleValue();\n    }\n\n    public static void main(String[] args) {\n        Accumulator x = new Accumulator(1);\n        x.call(5);\n        Accumulator y = new Accumulator(3);\n        System.out.println(y+\" has value \"+y.call(0));\n        System.out.println(x.call(2.3));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var doors=[];\nfor(var i=0;i<100;i++)\n doors[i]=false;             //create doors\nfor(var i=1;i<=100;i++)\n for(var i2=i-1,g;i2<100;i2+=i)\n  doors[i2]=!doors[i2];      //toggle doors\nfor(var i=1;i<=100;i++)      //read doors\n console.log(\"Door %d is %s\",i,doors[i-1]?\"open\":\"closed\")\n"
  },
  {
    "language": "JavaScript",
    "code": "// Array comprehension style\n[ for (i of Array.apply(null, { length: 100 })) i ].forEach((_, i) => {\n  var door = i + 1\n  var sqrt = Math.sqrt(door);\n\n  if (sqrt === (sqrt | 0)) {\n    console.log(\"Door %d is open\", door);\n  }\n});\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n\n\n    // ONLY PERFECT SQUARES HAVE AN ODD NUMBER OF INTEGER FACTORS\n    // (Leaving the door open at the end of the process)\n\n    return perfectSquaresUpTo(n);\n\n\n    // perfectSquaresUpTo :: Int -> [Int]\n    function perfectSquaresUpTo(n) {\n        return range(1, Math.floor(Math.sqrt(n)))\n            .map(x => x * x);\n    }\n\n\n    // GENERIC\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, step) {\n        let d = (step || 1) * (n >= m ? 1 : -1);\n\n        return Array.from({\n            length: Math.floor((n - m) / d) + 1\n        }, (_, i) => m + (i * d));\n    }\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n    'use strict';\n\n\n    // finalDoors :: Int -> [(Int, Bool)]\n    function finalDoors(n) {\n        var lstRange = range(1, n);\n\n        return lstRange\n            .reduce(function (a, _, k) {\n                var m = k + 1;\n\n                return a.map(function (x, i) {\n                    var j = i + 1;\n\n                    return [j, j % m ? x[1] : !x[1]];\n                });\n            }, zip(\n                lstRange,\n                replicate(n, false)\n            ));\n    };\n\n\n\n    // GENERIC FUNCTIONS\n\n    // zip :: [a] -> [b] -> [(a,b)]\n    function zip(xs, ys) {\n        return xs.length === ys.length ? (\n            xs.map(function (x, i) {\n                return [x, ys[i]];\n            })\n        ) : undefined;\n    }\n\n    // replicate :: Int -> a -> [a]\n    function replicate(n, a) {\n        var v = [a],\n            o = [];\n\n        if (n < 1) return o;\n        while (n > 1) {\n            if (n & 1) o = o.concat(v);\n            n >>= 1;\n            v = v.concat(v);\n        }\n        return o.concat(v);\n    }\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, delta) {\n        var d = delta || 1,\n            blnUp = n > m,\n            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,\n            a = Array(lng),\n            i = lng;\n\n        if (blnUp)\n            while (i--) a[i] = (d * i) + m;\n        else\n            while (i--) a[i] = m - (d * i);\n\n        return a;\n    }\n\n\n    return finalDoors(n)\n        .filter(function (tuple) {\n            return tuple[1];\n        })\n        .map(function (tuple) {\n            return {\n                door: tuple[0],\n                open: tuple[1]\n            };\n        });\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "[{\"door\":1, \"open\":true}, {\"door\":4, \"open\":true}, {\"door\":9, \"open\":true}, {\"door\":16, \"open\":true}, {\"door\":25, \"open\":true}, {\"door\":36, \"open\":true}, {\"door\":49, \"open\":true}, {\"door\":64, \"open\":true}, {\"door\":81, \"open\":true}, {\"door\":100, \"open\":true}]\n"
  },
  {
    "language": "JavaScript",
    "code": "for (var door = 1; door <= 100; door++) {\n  var sqrt = Math.sqrt(door);\n  if (sqrt === (sqrt | 0)) {\n    console.log(\"Door %d is open\", door);\n  }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "for(var door=1;i<10/*Math.sqrt(100)*/;i++){\n console.log(\"Door %d is open\",i*i);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n    'use strict';\n\n    return range(1, 100)\n        .filter(function (x) {\n            return integerFactors(x)\n                .length % 2;\n        });\n\n    function integerFactors(n) {\n        var rRoot = Math.sqrt(n),\n            intRoot = Math.floor(rRoot),\n\n            lows = range(1, intRoot)\n            .filter(function (x) {\n                return (n % x) === 0;\n            });\n\n        // for perfect squares, we can drop the head of the 'highs' list\n        return lows.concat(lows.map(function (x) {\n                return n / x;\n            })\n            .reverse()\n            .slice((rRoot === intRoot) | 0));\n    }\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, delta) {\n        var d = delta || 1,\n            blnUp = n > m,\n            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,\n            a = Array(lng),\n            i = lng;\n\n        if (blnUp)\n            while (i--) a[i] = (d * i) + m;\n        else\n            while (i--) a[i] = m - (d * i);\n\n        return a;\n    }\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "(function (n) {\n    'use strict';\n\n    return perfectSquaresUpTo(100);\n\n    function perfectSquaresUpTo(n) {\n        return range(1, Math.floor(Math.sqrt(n)))\n            .map(function (x) {\n                return x * x;\n            });\n    }\n\n    // GENERIC\n\n    // range(intFrom, intTo, optional intStep)\n    // Int -> Int -> Maybe Int -> [Int]\n    function range(m, n, delta) {\n        var d = delta || 1,\n            blnUp = n > m,\n            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,\n            a = Array(lng),\n            i = lng;\n\n        if (blnUp)\n            while (i--) a[i] = (d * i) + m;\n        else\n            while (i--) a[i] = m - (d * i);\n        return a;\n    }\n\n})(100);\n"
  },
  {
    "language": "JavaScript",
    "code": "[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n"
  },
  {
    "language": "JavaScript",
    "code": "Array.apply(null, { length: 100 })\n  .map((v, i) => i + 1)\n    .forEach(door => {\n      var sqrt = Math.sqrt(door);\n\n      if (sqrt === (sqrt | 0)) {\n        console.log(\"Door %d is open\", door);\n      }\n    });\n"
  },
  {
    "language": "JavaScript",
    "code": "var ar=[],order=[0,1,2],op=[],val=[];\nvar NOVAL=9999,oper=\"+-*/\",out;\n\nfunction rnd(n){return Math.floor(Math.random()*n)}\n\nfunction say(s){\n try{document.write(s+\"<br>\")}\n catch(e){WScript.Echo(s)}\n}\n\nfunction getvalue(x,dir){\n var r=NOVAL;\n if(dir>0)++x;\n while(1){\n  if(val[x]!=NOVAL){\n   r=val[x];\n   val[x]=NOVAL;\n   break;\n  }\n  x+=dir;\n }\n return r*1;\n}\n\nfunction calc(){\n var c=0,l,r,x;\n val=ar.join('/').split('/');\n while(c<3){\n  x=order[c];\n  l=getvalue(x,-1);\n  r=getvalue(x,1);\n  switch(op[x]){\n   case 0:val[x]=l+r;break;\n   case 1:val[x]=l-r;break;\n   case 2:val[x]=l*r;break;\n   case 3:\n   if(!r||l%r)return 0;\n   val[x]=l/r;\n  }\n  ++c;\n }\n return getvalue(-1,1);\n}\n\nfunction shuffle(s,n){\n var x=n,p=eval(s),r,t;\n while(x--){\n  r=rnd(n);\n  t=p[x];\n  p[x]=p[r];\n  p[r]=t;\n }\n}\n\nfunction parenth(n){\n while(n>0)--n,out+='(';\n while(n<0)++n,out+=')';\n}\n\nfunction getpriority(x){\n for(var z=3;z--;)if(order[z]==x)return 3-z;\n return 0;\n}\n\nfunction showsolution(){\n var x=0,p=0,lp=0,v=0;\n while(x<4){\n  if(x<3){\n   lp=p;\n   p=getpriority(x);\n   v=p-lp;\n   if(v>0)parenth(v);\n  }\n  out+=ar[x];\n  if(x<3){\n   if(v<0)parenth(v);\n   out+=oper.charAt(op[x]);\n  }\n  ++x;\n }\n parenth(-p);\n say(out);\n}\n\nfunction solve24(s){\n var z=4,r;\n while(z--)ar[z]=s.charCodeAt(z)-48;\n out=\"\";\n for(z=100000;z--;){\n  r=rnd(256);\n  op[0]=r&3;\n  op[1]=(r>>2)&3;\n  op[2]=(r>>4)&3;\n  shuffle(\"ar\",4);\n  shuffle(\"order\",3);\n  if(calc()!=24)continue;\n  showsolution();\n  break;\n }\n}\n\nsolve24(\"1234\");\nsolve24(\"6789\");\nsolve24(\"1127\");\n"
  },
  {
    "language": "JavaScript",
    "code": "function twentyfour(numbers, input) {\n    var invalidChars = /[^\\d\\+\\*\\/\\s-\\(\\)]/;\n\n    var validNums = function(str) {\n        // Create a duplicate of our input numbers, so that\n        // both lists will be sorted.\n        var mnums = numbers.slice();\n        mnums.sort();\n\n        // Sort after mapping to numbers, to make comparisons valid.\n        return str.replace(/[^\\d\\s]/g, \" \")\n            .trim()\n            .split(/\\s+/)\n            .map(function(n) { return parseInt(n, 10); })\n            .sort()\n            .every(function(v, i) { return v === mnums[i]; });\n    };\n\n    var validEval = function(input) {\n        try {\n            return eval(input);\n        } catch (e) {\n            return {error: e.toString()};\n        }\n    };\n\n    if (input.trim() === \"\") return \"You must enter a value.\";\n    if (input.match(invalidChars)) return \"Invalid chars used, try again. Use only:\\n + - * / ( )\";\n    if (!validNums(input)) return \"Wrong numbers used, try again.\";\n    var calc = validEval(input);\n    if (typeof calc !== 'number') return \"That is not a valid input; please try again.\";\n    if (calc !== 24) return \"Wrong answer: \" + String(calc) + \"; please try again.\";\n    return input + \" == 24.  Congratulations!\";\n};\n\n// I/O below.\n\nwhile (true) {\n    var numbers = [1, 2, 3, 4].map(function() {\n        return Math.floor(Math.random() * 8 + 1);\n    });\n\n    var input = prompt(\n        \"Your numbers are:\\n\" + numbers.join(\" \") +\n        \"\\nEnter expression. (use only + - * / and parens).\\n\", +\"'x' to exit.\", \"\");\n\n    if (input === 'x') {\n        break;\n    }\n    alert(twentyfour(numbers, input));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "(function () {\n    var cache = [\n        [1]\n    ];\n//this was never needed.\n   /* function PyRange(start, end, step) {\n        step = step || 1;\n        if (!end) {\n            end = start;\n            start = 0;\n        }\n        var arr = [];\n        for (var i = start; i < end; i += step) arr.push(i);\n        return arr;\n    }*/\n\n    function cumu(n) {\n        var /*ra = PyRange(cache.length, n + 1),*/ //Seems there is a better version for this\n            r, l, x, Aa, Mi;\n       // for (ll in ra) { too pythony\n       for (l=cache.length;l<n+1;l++) {\n            r = [0];\n//            l = ra[ll];\n//            ran = PyRange(1, l + 1);\n//            for (xx in ran) {\n            for(x=1;x<l+1;x++){\n//                x = ran[xx];\n                r.push(r[r.length - 1] + (Aa = cache[l - x < 0 ? cache.length - (l - x) : l - x])[(Mi = Math.min(x, l - x)) < 0 ? Aa.length - Mi : Mi]);\n            }\n            cache.push(r);\n        }\n        return cache[n];\n    }\n\n    function row(n) {\n        var r = cumu(n),\n//            rra = PyRange(n),\n            leArray = [],\n            i;\n//        for (ii in rra) {\n        for (i=0;i<n;i++) {\n//            i = rra[ii];\n            leArray.push(r[i + 1] - r[i]);\n        }\n        return leArray;\n    }\n\n    console.log(\"Rows:\");\n    for (iterator = 1; iterator < 12; iterator++) {\n        console.log(row(iterator));\n    }\n\n    console.log(\"Sums\")[23, 123, 1234, 12345].foreach(function (a) {\n        var s = cumu(a);\n        console.log(a, s[s.length - 1]);\n    });\n})()\n"
  },
  {
    "language": "JavaScript",
    "code": "var beer = 99;\nwhile (beer > 0) {\n  var verse = [\n    beer + \" bottles of beer on the wall,\",\n    beer + \" bottles of beer!\",\n    \"Take one down, pass it around\",\n    (beer - 1) + \" bottles of beer on the wall!\"\n  ].join(\"\\n\");\n\n  console.log(verse);\n\n  beer--;\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "let beer = 99;\nwhile (beer > 0) {\n  let verse = `${beer} bottles of beer on the wall,\n  ${beer} bottles of beer!\n  Take one down, pass it around\n  ${beer-1} bottles of beer on the wall`;\n\n  console.log(verse);\n  beer--;\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var bottles = 99;\nvar songTemplate  = \"{X} bottles of beer on the wall \\n\" +\n                    \"{X} bottles of beer \\n\"+\n                    \"Take one down, pass it around \\n\"+\n                    \"{X-1} bottles of beer on the wall \\n\";\n\nfunction song(x, txt) {\n  return txt.replace(/\\{X\\}/gi, x).replace(/\\{X-1\\}/gi, x-1) + (x > 1 ? song(x-1, txt) : \"\");\n}\n\nconsole.log(song(bottles, songTemplate));\n"
  },
  {
    "language": "JavaScript",
    "code": "// Line breaks are in HTML\nvar beer; while ((beer = typeof beer === \"undefined\" ? 99 : beer) > 0) document.write( beer + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer on the wall<br>\" + beer + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer<br>Take one down, pass it around<br>\" + (--beer) + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer on the wall<br>\" );\n"
  },
  {
    "language": "JavaScript",
    "code": "Array.from(Array(100).keys()).splice(1).reverse().forEach(n => console.log(`${n} bottle${n !== 1 ? 's' : ''} of beer on the wall\\n${n} bottle${n !== 1 ? 's' : ''} of beer\\nTake one down, pass it around\\n${n - 1} bottle${n - 1 !== 1 ? 's' : ''} of beer on the wall\\n\\n`));\n"
  },
  {
    "language": "JavaScript",
    "code": "function Bottles(count) {\n  this.count = count || 99;\n}\n\nBottles.prototype.take = function() {\n  var verse = [\n    this.count + \" bottles of beer on the wall,\",\n    this.count + \" bottles of beer!\",\n    \"Take one down, pass it around\",\n    (this.count - 1) + \" bottles of beer on the wall!\"\n  ].join(\"\\n\");\n\n  console.log(verse);\n\n  this.count--;\n};\n\nBottles.prototype.sing = function() {\n  while (this.count) {\n    this.take();\n  }\n};\n\nvar bar = new Bottles(99);\nbar.sing();\n"
  },
  {
    "language": "JavaScript",
    "code": "function bottleSong(n) {\n  if (!isFinite(Number(n)) || n == 0) n = 100;\n  var a  = '%% bottles of beer',\n      b  = ' on the wall',\n      c  = 'Take one down, pass it around',\n      r  = '<br>'\n      p  = document.createElement('p'),\n      s  = [],\n      re = /%%/g;\n\n  while(n) {\n    s.push((a+b+r+a+r+c+r).replace(re, n) + (a+b).replace(re, --n));\n  }\n  p.innerHTML = s.join(r+r);\n  document.body.appendChild(p);\n}\n\nwindow.onload = bottleSong;\n"
  },
  {
    "language": "JavaScript",
    "code": "<html>\n<body>\n<div id='input'></div>\n<div id='output'></div>\n<script type='text/javascript'>\nvar a = window.prompt('enter A number', '');\nvar b = window.prompt('enter B number', '');\ndocument.getElementById('input').innerHTML = a + ' ' + b;\n\nvar sum = Number(a) + Number(b);\ndocument.getElementById('output').innerHTML = sum;\n</script>\n</body>\n</html>\n"
  },
  {
    "language": "JavaScript",
    "code": "process.openStdin().on (\n    'data',\n    function (line) {\n        var xs = String(line).match(/^\\s*(\\d+)\\s+(\\d+)\\s*/)\n        console.log (\n            xs ? Number(xs[1]) + Number(xs[2]) : 'usage: <number> <number>'\n        )\n        process.exit()\n    }\n)\n"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.on(\"data\", buffer => {\n  console.log(\n    (buffer + \"\").trim().split(\" \").map(Number).reduce((a, v) => a + v, 0)\n  );\n});\n"
  },
  {
    "language": "Julia",
    "code": "doors = falses(100)\nfor a in 1:100, b in a:a:100\n    doors[b] = !doors[b]\nend\nfor a = 1:100\n    println(\"Door $a is \" * (doors[a] ? \"open.\" : \"closed.\"))\nend\n"
  },
  {
    "language": "Julia",
    "code": "for i in 1:10 println(\"Door $(i^2) is open.\") end\n"
  },
  {
    "language": "Julia",
    "code": "function solve24(nums)\n    length(nums) != 4 && error(\"Input must be a 4-element Array\")\n    syms = [+,-,*,/]\n    for x in syms, y in syms, z in syms\n        for i = 1:24\n            a,b,c,d = nthperm(nums,i)\n            if round(x(y(a,b),z(c,d)),5) == 24\n                return \"($a$y$b)$x($c$z$d)\"\n            elseif round(x(a,y(b,z(c,d))),5) == 24\n                return \"$a$x($b$y($c$z$d))\"\n            elseif round(x(y(z(c,d),b),a),5) == 24\n                return \"(($c$z$d)$y$b)$x$a\"\n            elseif round(x(y(b,z(c,d)),a),5) == 24\n                return \"($b$y($c$z$d))$x$a\"\n            end\n        end\n    end\n    return \"0\"\nend\n"
  },
  {
    "language": "Julia",
    "code": "validexpr(ex::Expr) = ex.head == :call && ex.args[1] in [:*,:/,:+,:-] && all(validexpr, ex.args[2:end])\nvalidexpr(ex::Int) = true\nvalidexpr(ex::Any) = false\nfindnumbers(ex::Number) = Int[ex]\nfindnumbers(ex::Expr) = vcat(map(findnumbers, ex.args)...)\nfindnumbers(ex::Any) = Int[]\nfunction twentyfour()\n    digits = sort!(rand(1:9, 4))\n    while true\n        print(\"enter expression using $digits => \")\n        ex = parse(readline())\n        try\n            validexpr(ex) || error(\"only *, /, +, - of integers is allowed\")\n            nums = sort!(findnumbers(ex))\n            nums == digits || error(\"expression $ex used numbers $nums != $digits\")\n            val = eval(ex)\n            val == 24 || error(\"expression $ex evaluated to $val, not 24\")\n            println(\"you won!\")\n            return\n        catch e\n            if isa(e, ErrorException)\n                println(\"incorrect: \", e.msg)\n            else\n                rethrow()\n            end\n        end\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Combinatorics, StatsBase\n\nnamesofline(n) = counts([x[1] for x in integer_partitions(n)])\n\nfunction centerjustpyramid(n)\n    maxwidth = length(string(namesofline(n)))\n    for i in 1:n\n        s = string(namesofline(i))\n        println(\" \" ^ div(maxwidth - length(s), 2), s)\n    end\nend\n\ncenterjustpyramid(25)\n\nconst cachecountpartitions = Dict{BigInt,BigInt}()\nfunction countpartitions(n::BigInt)\n    if n < 0\n        0\n    elseif n < 2\n        1\n    elseif (np = get(cachecountpartitions, n, 0)) > 0\n        np\n    else\n        np = 0\n        sgn = 1\n        for k = 1:n\n            np += sgn * (countpartitions(n - (k*(3k-1)) >> 1) + countpartitions(n - (k*(3k+1)) >> 1))\n            sgn = -sgn\n        end\n        cachecountpartitions[n] = np\n    end\nend\n\nG(n) = countpartitions(BigInt(n))\n\nfor g in [23, 123, 1234, 12345]\n    @time println(\"\\nG($g) is $(G(g))\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "for i = 99:-1:1 print(\"\\n$i bottles of beer on the wall\\n$i bottles of beer\\nTake one down, pass it around\\n$(i-1) bottles of beer on the wall\\n\") end\n"
  },
  {
    "language": "Julia",
    "code": "bottles(n) = n==0 ? \"No more bottles\" :\n             n==1 ? \"1 bottle\" :\n             \"$n bottles\"\n\nfor n = 99:-1:1\n    println(\"\"\"\n        $(bottles(n)) of beer on the wall\n        $(bottles(n)) of beer\n        Take one down, pass it around\n        $(bottles(n-1)) of beer on the wall\n    \"\"\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "bottles(n) = \"$(n==0 ? \"No more\" : n) bottle$(n==1 ? \"\" : \"s\")\"\n"
  },
  {
    "language": "Julia",
    "code": "input = parse.(Int, split(readline(stdin)))\nprintln(stdout, sum(input))\n"
  },
  {
    "language": "Julia",
    "code": "julia> println(parse(Int, readuntil(stdin, ' ')) + parse(Int, readuntil(stdin, '\\n')))\n1 2\n3\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nfunction abc(str::AbstractString, list)\n    isempty(str) && return true\n    for i in eachindex(list)\n        str[end] in list[i] &&\n            any([abc(str[1:end-1], deleteat!(copy(list), i))]) &&\n            return true\n    end\n    return false\nend\n\nlet test = [\"A\", \"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"],\n    list = [\"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\n            \"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"]\n    for str in test\n        @printf(\"%-8s |  %s\\n\", str, abc(str, list))\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "abstract type \u00abname\u00bb end\nabstract type \u00abname\u00bb <: \u00absupertype\u00bb end\n"
  },
  {
    "language": "Julia",
    "code": "abstract type Number end\nabstract type Real          <: Number end\nabstract type FloatingPoint <: Real end\nabstract type Integer       <: Real end\nabstract type Signed        <: Integer end\nabstract type Unsigned      <: Integer end\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib(p::Int64, a::Int64)\n    n = one(p)\n    pcon = one(p)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum(n::Int64)\n    dsum = one(n)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "const L = 2*10^4\niclasslabel = [\"Deficient\", \"Perfect\", \"Abundant\"]\niclass = zeros(Int64, 3)\niclass[1] = one(Int64) #by convention 1 is deficient\n\nfor n in 2:L\n    if isprime(n)\n        iclass[1] += 1\n    else\n        iclass[sign(divisorsum(n)-n)+2] += 1\n    end\nend\n\nprintln(\"Classification of integers from 1 to \", L)\nfor i in 1:3\n    println(\"   \", iclasslabel[i], \", \", iclass[i])\nend\n"
  },
  {
    "language": "Julia",
    "code": "function accumulator(i)\n\tf(n) = i += n\n\treturn f\nend\n\nx = accumulator(1)\n@show x(5)\n\naccumulator(3)\n@show x(2.3)\n"
  },
  {
    "language": "Julia",
    "code": "function ack(m,n)\n    if m == 0\n        return n + 1\n    elseif n == 0\n        return ack(m-1,1)\n    else\n        return ack(m-1,ack(m,n-1))\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "ack2(m::Integer, n::Integer) = m == 0 ? n + 1 : n == 0 ? ack2(m - 1, 1) : ack2(m - 1, ack2(m, n - 1))\n"
  },
  {
    "language": "Julia",
    "code": "using Memoize\n@memoize ack3(m::Integer, n::Integer) = m == 0 ? n + 1 : n == 0 ? ack3(m - 1, 1) : ack3(m - 1, ack3(m, n - 1))\n"
  },
  {
    "language": "Julia",
    "code": "mutable struct Integrator\n    func::Function\n    runningsum::Float64\n    dt::Float64\n    running::Bool\n    function Integrator(f::Function, dt::Float64)\n        this = new()\n        this.func = f\n        this.runningsum = 0.0\n        this.dt = dt\n        this.running = false\n        return this\n    end\nend\n\nfunction run(integ::Integrator, lastval::Float64 = 0.0)\n    lasttime = time()\n    while integ.running\n        sleep(integ.dt)\n        newtime = time()\n        measuredinterval = newtime - lasttime\n        newval = integ.func(measuredinterval)\n        integ.runningsum += (lastval + newval) * measuredinterval / 2.0\n        lasttime = newtime\n        lastval = newval\n    end\nend\n\nstart!(integ::Integrator) = (integ.running = true; @async run(integ))\nstop!(integ) = (integ.running = false)\nf1(t) = sin(2\u03c0 * t)\nf2(t) = 0.0\n\nit = Integrator(f1, 0.00001)\nstart!(it)\nsleep(2.0)\nit.func = f2\nsleep(0.5)\nv2 = it.runningsum\nprintln(\"After 2.5 seconds, integrator value was $v2\")\n"
  },
  {
    "language": "Julia",
    "code": "{\"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    },\n    {\n      \"type\": \"mobile\",\n      \"number\": \"123 456-7890\"\n    }]}\n"
  },
  {
    "language": "Julia",
    "code": "mutable struct Contact\n    name::String\n    phonenumber::Dict{Any,Any}\nend\n\nperson = Contact(\"Jane Doe\", Dict())\nperson.phonenumber[\"home\"] = \"212 555-1234\"\n"
  },
  {
    "language": "Julia",
    "code": "julia> x = [1, 2, 3]\njulia> ptr = pointer_from_objref(x)\nPtr{Void} @0x000000010282e4a0\njulia> unsafe_pointer_to_objref(ptr)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n"
  },
  {
    "language": "Julia",
    "code": "julia> A = [1, 2.3, 4]\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 4.0\n\njulia> p = pointer(A)\nPtr{Float64} @0x0000000113f70d60\n\njulia> unsafe_load(p, 3)\n4.0\n\njulia> unsafe_store!(p, 3.14159, 3)\njulia> A\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 3.14149\n\njulia> pointer_to_array(p, (3,))\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 3.14149\n"
  },
  {
    "language": "Julia",
    "code": "julia>\njulia> q = convert(Ptr{Float64}, 0x0000000113f70d68)\nPtr{Float64} @0x0000000113f70d68\n\njulia> B = pointer_to_array(q, (2,))\n2-element Array{Float64,1}:\n 2.3\n 3.14149\n"
  },
  {
    "language": "Julia",
    "code": "function polycoefs(n::Int64)\n    pc = typeof(n)[]\n    if n < 0\n        return pc\n    end\n    sgn = one(n)\n    for k in n:-1:0\n        push!(pc, sgn*binomial(n, k))\n        sgn = -sgn\n    end\n    return pc\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nfunction stringpoly(n::Int64)\n    if n < 0\n        return \"\"\n    end\n    st = @sprintf \"(x - 1)^{%d} & = & \" n\n    for (i, c) in enumerate(polycoefs(n))\n        if i == 1\n            op = \"\"\n            ac = c\n        elseif c < 0\n            op = \"-\"\n            ac = abs(c)\n        else\n            op = \"+\"\n            ac = abs(c)\n        end\n        p = n + 1 - i\n        if p == 0\n            st *= @sprintf \" %s %d\\\\\\\\\" op ac\n        elseif ac == 1\n            st *= @sprintf \" %s x^{%d}\" op p\n        else\n            st *= @sprintf \" %s %dx^{%d}\" op ac p\n        end\n    end\n    return st\nend\n"
  },
  {
    "language": "Julia",
    "code": "function isaksprime(n::Int64)\n    if n < 2\n        return false\n    end\n    for c in polycoefs(n)[2:(end-1)]\n        if c%n != 0\n            return false\n        end\n    end\n    return true\nend\n"
  },
  {
    "language": "Julia",
    "code": "println(\"<math>\")\nprintln(\"\\\\begin{array}{lcl}\")\nfor i in 0:10\n    println(stringpoly(i))\nend\nprintln(\"\\\\end{array}\")\nprintln(\"</math>\\n\")\n\nL = 50\nprint(\"AKS primes less than \", L, \":  \")\nsep = \"\"\nfor i in 1:L\n    if isaksprime(i)\n        print(sep, i)\n        sep = \", \"\n    end\nend\nprintln()\n"
  },
  {
    "language": "Julia",
    "code": "txt = \"\"\"Given\\$a\\$txt\\$file\\$of\\$many\\$lines,\\$where\\$fields\\$within\\$a\\$line\\$\nare\\$delineated\\$by\\$a\\$single\\$'dollar'\\$character,\\$write\\$a\\$program\nthat\\$aligns\\$each\\$column\\$of\\$fields\\$by\\$ensuring\\$that\\$words\\$in\\$each\\$\ncolumn\\$are\\$separated\\$by\\$at\\$least\\$one\\$space.\nFurther,\\$allow\\$for\\$each\\$word\\$in\\$a\\$column\\$to\\$be\\$either\\$left\\$\njustified,\\$right\\$justified,\\$or\\$center\\$justified\\$within\\$its\\$column.\"\"\"\n\n# left/right/center justification of strings:\nljust(s, width) = s * \" \"^max(0, width - length(s))\nrjust(s, width) = \" \"^max(0, width - length(s)) * s\nfunction center(s, width)\n  pad = width - length(s)\n  if pad <= 0\n    return s\n  else\n    pad2 = div(pad, 2)\n    return \" \"^pad2 * s * \" \"^(pad - pad2)\n  end\nend\n\nparts = [split(rstrip(line, '$'), '$') for line in split(txt, '\\n')]\n\nmax_widths = zeros(Int, maximum(length, parts))\nfor line in parts\n  for (i, word) in enumerate(line)\n    max_widths[i] = max(max_widths[i], length(word))\n  end\nend\nmax_widths += 1 # separate cols by at least one space\n\nfor (label, justify) in ((\"Left\", ljust), (\"Right\",rjust), (\"Center\",center))\n  println(label, \" column-aligned output:\")\n  for line in parts\n    for (j, word) in enumerate(line)\n      print(justify(word, max_widths[j]))\n    end\n    println()\n  end\n  println(\"-\"^sum(max_widths))\nend\n"
  },
  {
    "language": "Julia",
    "code": "function aliquotclassifier{T<:Integer}(n::T)\n    a = T[n]\n    b = divisorsum(a[end])\n    len = 1\n    while len < 17 && !(b in a) && 0 < b && b < 2^47+1\n        push!(a, b)\n        b = divisorsum(a[end])\n        len += 1\n    end\n    if b in a\n        1 < len || return (\"Perfect\", a)\n        if b == a[1]\n            2 < len || return (\"Amicable\", a)\n            return (\"Sociable\", a)\n        elseif b == a[end]\n            return (\"Aspiring\", a)\n        else\n            return (\"Cyclic\", push!(a, b))\n        end\n    end\n    push!(a, b)\n    b != 0 || return (\"Terminating\", a)\n    return (\"Non-terminating\", a)\nend\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib{T<:Integer}(p::T, a::T)\n    n = one(T)\n    pcon = one(T)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum{T<:Integer}(n::T)\n    dsum = one(T)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nprintln(\"Classification Tests:\")\ntests = [1:12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\nfor i in tests\n    (class, a) = aliquotclassifier(i)\n    println(@sprintf(\"%8d => \", i), @sprintf(\"%16s, \", class), a)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(undef,N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(undef,N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "# This is a general purpose AMB function that takes a two-argument failure function and\n# arbitrary number of iterable objects and returns the first solution found as an array\n# this function is in essence an iterative backtracking solver\n\nfunction amb(failure, itrs...)\n    n = length(itrs)\n    if n == 1 return end\n    states = Vector(n)\n    values = Vector(n)\n    # starting point, we put down the first value from the first iterable object\n    states[1] = start(itrs[1])\n    values[1], states[1] = next(itrs[1], states[1])\n    i = 1\n    # main solver loop\n    while true\n        # test for failure\n        if i > 1 && failure(values[i-1], values[i])\n            # loop for generating a new value upon failure\n            # in fact this would be way more readable using goto, but Julia doesn't seem to have that :(\n            while true\n                # if we failed, we must generate a new value, but first we must check whether there is any\n                if done(itrs[i], states[i])\n                    # backtracking step with sanity check in case we ran out of values from the current generator\n                    if i == 1\n                        return\n                    else\n                        i -= 1\n                        continue\n                    end\n                else\n                    # if there is indeed a new value, generate it\n                    values[i], states[i] = next(itrs[i], states[i])\n                    break\n                end\n            end\n        else\n            # no failure branch\n            # if solution is ready (i.e. all generators are used) just return it\n            if i == n return values end\n            # else start up the next generator\n            i += 1\n            states[i] = start(itrs[i])\n            values[i], states[i] = next(itrs[i], states[i])\n        end\n    end\nend\n\n# Call our generic AMB function according to the task description and\n# form the solution sentence from the returned array of words\namb((s1,s2) -> s1[end] != s2[1], # failure function\n    [\"the\", \"that\", \"a\"],\n    [\"frog\", \"elephant\", \"thing\"],\n    [\"walked\", \"treaded\", \"grows\"],\n    [\"slowly\", \"quickly\"]) |>\n    x -> join(x, \" \") |>\n    println\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib(p::Int64, a::Int64)\n    n = one(p)\n    pcon = one(p)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum(n::Int64)\n    dsum = one(n)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nconst L = 2*10^4\nacnt = 0\n\nprintln(\"Amicable pairs not greater than \", L)\n\nfor i in 2:L\n    !isprime(i) || continue\n    j = divisorsum(i)\n    j < i && divisorsum(j) == i || continue\n    acnt += 1\n    println(@sprintf(\"%4d\", acnt), \" => \", j, \", \", i)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Base.isless\n# Let's define the less than operator for any two vectors that have the same type:\n# This does lexicographic comparison, we use it on vectors of chars in this task.\nfunction Base.isless(t1, t2)\n    for (a, b) in zip(t1, t2) # zip only to the shorter length\n        if !isequal(a, b)\n            return isless(a, b)\n        end\n    end\n    return length(t1) < length(t2)\nend\n\n# The sort function of Julia doesn't work on strings, so we write one:\n# This returns a sorted vector of the chars of the given string\nsortchars(s::AbstractString) = sort(collect(Char, s))\n\n# Custom comparator function for sorting the loaded wordlist\nsortanagr(s1::AbstractString, s2::AbstractString) =\n    if length(s1) != length(s2) length(s1) < length(s2) else sortchars(s1) < sortchars(s2) end\n\n# Tests if two strings are deranged anagrams, returns a bool:\n# in our case s2 is never longer than s1\nfunction deranged(s1::AbstractString, s2::AbstractString)\n    # Tests for derangement first\n    for (a, b) in zip(s1, s2)\n        if a == b return false end\n    end\n    # s1 and s2 are deranged, but are they anagrams at all?\n    return sortchars(s1) == sortchars(s2)\nend\n\n# Task starts here, we load the wordlist line by line, strip eol char, and sort the wordlist\n# in a way that ensures that longer words come first and anagrams go next to each other\nwords = sort(open(readlines, \"./data/unixdict.txt\"), rev = true, lt = sortanagr)\n\n# Now we just look for deranged anagrams in the neighbouring words of the sorted wordlist\nfor i in 1:length(words)-1\n    if deranged(words[i], words[i+1])\n        # The first match is guaranteed to be the longest due to the custom sorting\n        println(\"The longest deranged anagrams are $(words[i]) and $(words[i+1])\")\n        break\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\nwordlist = open(readlines, download(url))\n\nwsort(word::AbstractString) = join(sort(collect(word)))\n\nfunction anagram(wordlist::Vector{<:AbstractString})\n    dict = Dict{String, Set{String}}()\n    for word in wordlist\n        sorted = wsort(word)\n        push!(get!(dict, sorted, Set{String}()), word)\n    end\n    wcnt = maximum(length, values(dict))\n    return collect(Iterators.filter((y) -> length(y) == wcnt, values(dict)))\nend\n\nprintln.(anagram(wordlist))\n"
  },
  {
    "language": "Julia",
    "code": "using Luxor\nusing Colors\nusing BoundaryValueDiffEq\n\n# constants for differential equations and movie\nconst g = 9.81\nconst L = 1.0                         # pendulum length in meters\nconst bobd = 0.10                     # pendulum bob diameter in meters\nconst framerate = 50.0                # intended frame rate/sec\nconst t0 = 0.0                        # start time (s)\nconst tf = 2.3                        # end simulation time (s)\nconst dtframe = 1.0/framerate         # time increment per frame\nconst tspan = LinRange(t0, tf, Int(floor(tf*framerate)))  # array of time points in animation\n\nconst bgcolor = \"black\"               # gif background\nconst leaderhue = (0.80, 0.70, 0.20)  # gif swing arm hue light gold\nconst hslcolors = [HSL(col) for col in (distinguishable_colors(\n                   Int(floor(tf*framerate)+3),[RGB(1,1,1)])[2:end])]\nconst giffilename = \"pendulum.gif\"    # output file\n\n# differential equations\nsimplependulum(du, u, p, t) = (\u03b8=u[1]; d\u03b8=u[2]; du[1]=d\u03b8; du[2]=-(g/L)*sin(\u03b8))\nbc2(residual, u, p, t) = (residual[1] = u[end\u00f72][1] + pi/2; residual[2] = u[end][1] - pi/2)\nbvp2 = BVProblem(simplependulum, bc2, [pi/2,pi/2], (tspan[1],tspan[end]))\nsol2 = solve(bvp2, MIRK4(), dt=dtframe) # use the MIRK4 solver for TwoPointBVProblem\n\n# movie making background\nbackdrop(scene, framenumber) = background(bgcolor)\n\nfunction frame(scene, framenumber)\n    u1, u2 = sol2.u[framenumber]\n    y, x = L*cos(u1), L*sin(u1)\n    sethue(leaderhue)\n    poly([Point(-4.0, 0.0), Point(4.0, 0.0),\n          Point(160.0x,160.0y)], :fill)\n    sethue(Colors.HSV(framenumber*4.0, 1, 1))\n    circle(Point(160.0x,160.0y), 160bobd, :fill)\n    text(string(\"frame $framenumber of $(scene.framerange.stop)\"),\n        Point(0.0, -190.0),\n        halign=:center)\nend\n\nmuv = Movie(400, 400, \"Pendulum Demo\", 1:length(tspan))\nanimate(muv, [Scene(muv, backdrop),\n              Scene(muv, frame, easingfunction=easeinoutcubic)],\n              creategif=true, pathname=giffilename)\n"
  },
  {
    "language": "Julia",
    "code": "using Tk\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction windowanim(stepinterval::Float64)\n    wind = Window(\"Animation\", 300, 100)\n    frm = Frame(wind)\n    hello = \"Hello World!                                           \"\n    but = Button(frm, width=30, text=hello)\n    rightward = true\n    callback(s) = (rightward = !rightward)\n    bind(but, \"command\", callback)\n    pack(frm, expand=true, fill = \"both\")\n    pack(but, expand=true, fill = \"both\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    while true\n        but[:text] = permut[ppos]\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if ppos > pmod\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if ppos < 1\n                ppos = pmod\n            end\n        end\n    end\nend\n\nwindowanim(frameinterval)\n"
  },
  {
    "language": "Julia",
    "code": "using Gtk.ShortNames\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction textanimation(stepinterval::Float64)\n    hello = \"Hello World!                        \"\n    win = Window(\"Animation\", 210, 40) |> (Frame() |> (but = Button(\"Switch Directions\")))\n    rightward = true\n    switchdirections(s) = (rightward = !rightward)\n    signal_connect(switchdirections, but, \"clicked\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    nobreak = true\n    endit(w) = (nobreak = false)\n    signal_connect(endit, win, :destroy)\n    showall(win)\n    while nobreak\n        setproperty!(but, :label, permut[ppos])\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if(ppos > pmod)\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if(ppos < 1)\n                ppos = pmod\n            end\n        end\n    end\nend\n\ntextanimation(frameinterval)\n"
  },
  {
    "language": "Julia",
    "code": "function fib(n)\n    if n < 0\n        throw(ArgumentError(\"negative arguments not allowed\"))\n    end\n    aux(m) = m < 2 ? one(m) : aux(m-1) + aux(m-2)\n    aux(n)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using SHA  # security instincts say do not write bare passwords to a shared file even in toy code :)\n\nmutable struct Personnel\n    fullname::String\n    office::String\n    extension::String\n    homephone::String\n    email::String\n    Personnel(ful,off,ext,hom,ema) = new(ful,off,ext,hom,ema)\nend\n\nmutable struct Passwd\n     account::String\n     password::String\n     uid::Int32\n     gid::Int32\n     personal::Personnel\n     directory::String\n     shell::String\n     Passwd(acc,pas,uid,gid,per,dir,she) =  new(acc,pas,uid,gid,per,dir,she)\nend\n\nfunction writepasswd(filename, passrecords)\n    if(passrecords isa Array) == false\n        passrecords = [passrecords]\n    end\n    fh = open(filename, \"a\") # should throw an exception if cannot open in a locked or exclusive mode for append\n    for pas in passrecords\n        record = join([pas.account, bytes2hex(sha256(pas.password)), pas.uid, pas.gid,\n                 join([pas.personal.fullname, pas.personal.office, pas.personal.extension,\n                 pas.personal.homephone, pas.personal.email], ','),\n                 pas.directory, pas.shell], ':')\n        write(fh, record, \"\\n\")\n    end\n    close(fh)\nend\n\nconst jsmith = Passwd(\"jsmith\",\"x\",1001, 1000, Personnel(\"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\"), \"/home/jsmith\", \"/bin/bash\")\nconst jdoe = Passwd(\"jdoe\",\"x\",1002, 1000, Personnel(\"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\"), \"/home/jdoe\", \"/bin/bash\")\nconst xyz = Passwd(\"xyz\",\"x\",1003, 1000, Personnel(\"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\"), \"/home/xyz\", \"/bin/bash\")\n\nconst pfile = \"pfile.csv\"\nwritepasswd(pfile, [jsmith, jdoe])\nprintln(\"Before last record added, file is:\\n$(readstring(pfile))\")\nwritepasswd(pfile, xyz)\nprintln(\"After last record added, file is:\\n$(readstring(pfile))\")\n"
  },
  {
    "language": "Julia",
    "code": "numbers = [1, 3, 5, 7]\n\n@show [n ^ 2 for n in numbers]                  # list comprehension\nsquare(x) = x ^ 2; @show map(square, numbers)   # functional form\n@show map(x -> x ^ 2, numbers)                  # functional form with anonymous function\n@show [n * n for n in numbers]    \t\t\t\t# no need for a function,\n@show numbers .* numbers                        # element-wise operation\n@show numbers .^ 2                              # includes .+, .-, ./, comparison, and bitwise operations as well\n"
  },
  {
    "language": "Julia",
    "code": "julia> @elapsed bigstr = string(BigInt(5)^4^3^2)\n0.017507363\n\njulia> length(bigstr)\n183231\n\njulia> bigstr[1:20]\n\"62060698786608744707\"\n\njulia> bigstr[end-20:end]\n\"892256259918212890625\"\n"
  },
  {
    "language": "Julia",
    "code": "matrix = zeros(Float64, (1000,1000,1000))\n# use matrix, then when done set variable to 0 to garbage collect the matrix:\nmatrix = 0 # large memory pool will now be collected when needed\n"
  },
  {
    "language": "Julia",
    "code": "julia> z1 = 1.5 + 3im\njulia> z2 = 1.5 + 1.5im\njulia> z1 + z2\n3.0 + 4.5im\njulia> z1 - z2\n0.0 + 1.5im\njulia> z1 * z2\n-2.25 + 6.75im\njulia> z1 / z2\n1.5 + 0.5im\njulia> - z1\n-1.5 - 3.0im\njulia> conj(z1), z1'   # two ways to conjugate\n(1.5 - 3.0im,1.5 - 3.0im)\njulia> abs(z1)\n3.3541019662496847\njulia> z1^z2\n-1.102482955327779 - 0.38306415117199305im\njulia> real(z1)\n1.5\njulia> imag(z1)\n3.0\n"
  },
  {
    "language": "Julia",
    "code": "julia> expr=\"2 * (3 -1) + 2 * 5\"\n\"2 * (3 -1) + 2 * 5\"\n\njulia> parsed = parse(expr) #Julia provides low-level access to language parser for AST/Expr creation\n:(+(*(2,-(3,1)),*(2,5)))\n\njulia> t = typeof(parsed)\nExpr\n\njulia> names(t) #shows type fields\n(:head,:args,:typ)\n\njulia> parsed.args #Inspect our 'Expr' type innards\n3-element Any Array:\n :+\n :(*(2,-(3,1)))\n :(*(2,5))\n\njulia> typeof(parsed.args[2]) #'Expr' types can nest\nExpr\n\njulia> parsed.args[2].args\n3-element Any Array:\n  :*\n 2\n  :(-(3,1))\n\njulia> parsed.args[2].args[3].args #Will nest until lowest level of AST\n3-element Any Array:\n  :-\n 3\n 1\n\njulia> eval(parsed)\n14\n\njulia> eval(parse(\"1 - 5 * 2 / 20 + 1\"))\n1.5\n\njulia> eval(parse(\"2 * (3 + ((5) / (7 - 11)))\"))\n3.5\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nagm1step(x, y) = (x + y) / 2, sqrt(x * y)\n\nfunction approx\u03c0step(x, y, z, n::Integer)\n    a, g = agm1step(x, y)\n    k = n + 1\n    s = z + 2 ^ (k + 1) * (a ^ 2 - g ^ 2)\n    return a, g, s, k\nend\n\napprox\u03c0(a, g, s) = 4a ^ 2 / (1 - s)\n\nfunction testmakepi()\n\tsetprecision(512)\n\ta, g, s, k = BigFloat(1.0), 1 / \u221aBigFloat(2.0), BigFloat(0.0), 0\n\told\u03c0 = BigFloat(0.0)\n\tprintln(\"Approximating \u03c0 using \", precision(BigFloat), \"-bit floats.\")\n\tprintln(\"   k     Error  Result\")\n\tfor i in 1:100\n\t\ta, g, s, k = approx\u03c0step(a, g, s, k)\n\t\test\u03c0 = approx\u03c0(a, g, s)\n\t\tif abs(est\u03c0 - old\u03c0) < 2eps(est\u03c0) break end\n\t\told\u03c0 = est\u03c0\n\t\terr = abs(\u03c0 - est\u03c0)\n\t\t@printf(\"%4d%10.1e%68.60e\\n\", i, err, est\u03c0)\n\tend\nend\n\ntestmakepi()\n"
  },
  {
    "language": "Julia",
    "code": "function agm(x, y, e::Real = 5)\n    (x \u2264 0 || y \u2264 0 || e \u2264 0) && throw(DomainError(\"x, y must be strictly positive\"))\n    g, a = minmax(x, y)\n    while e * eps(x) < a - g\n        a, g = (a + g) / 2, sqrt(a * g)\n    end\n    a\nend\n\nx, y = 1.0, 1 / \u221a2\nprintln(\"# Using literal-precision float numbers:\")\n@show agm(x, y)\n\nprintln(\"# Using half-precision float numbers:\")\nx, y = Float32(x), Float32(y)\n@show agm(x, y)\n\nprintln(\"# Using \", precision(BigFloat), \"-bit float numbers:\")\nx, y = big(1.0), 1 / \u221abig(2.0)\n@show agm(x, y)\n"
  },
  {
    "language": "Julia",
    "code": "function arithmetic (a = parse(Int, readline()), b = parse(Int, readline()))\n  for op in  [+,-,*,div,rem]\n    println(\"a $op b = $(op(a,b))\")\n  end\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\ndivisors(n) = foldl((a, (p, e)) -> vcat((a * [p^i for i in 0:e]')...), factor(n), init=[1])\n\nisperfect(n) = sum(1 // d for d in divisors(n)) == 2\n\nlo, hi = 2, 2^19\nprintln(\"Perfect numbers between \", lo, \" and \", hi, \": \", collect(filter(isperfect, lo:hi)))\n"
  },
  {
    "language": "Julia",
    "code": "a = [1,2,3]\nb = [4,5,6]\nab = [a;b]\n# the above bracket notation simply generates a call to vcat\nab = vcat(a,b)\n# hcat is short for `horizontal concatenation`\nab = hcat(a,b) \t#ab -> 3x2 matrix\n# the append!(a,b) method is mutating, appending `b` to `a`\nappend!(a,b)\t# a now equals [1,2,3,4,5,6]\n"
  },
  {
    "language": "Julia",
    "code": "const x = 5\n\n# @assert macro checks the supplied conditional expression, with the expression\n# returned in the failed-assertion message\n@assert x == 42\n# ERROR: LoadError: AssertionError: x == 42\n\n# Julia also has type assertions of the form, x::Type which can be appended to\n# variable for type-checking at any point\nx::String\n# ERROR: LoadError: TypeError: in typeassert, expected String, got Int64\n"
  },
  {
    "language": "Julia",
    "code": "dict = Dict('a' => 97, 'b' => 98) # list keys/values\n# Dict{Char,Int64} with 2 entries:\n#   'b' => 98\n#   'a' => 97\n\ndict = Dict(c => Int(c) for c = 'a':'d') # dict comprehension\n# Dict{Char,Int64} with 4 entries:\n#   'b' => 98\n#   'a' => 97\n#   'd' => 100\n#   'c' => 99\n\ndict['\u00e9'] = 233; dict # add an element\n# Dict{Char,Int64} with 3 entries:\n#   'b' => 98\n#   'a' => 97\n#   '\u00e9' => 233\n\nemptydict = Dict() # create an empty dict\n# Dict{Any,Any} with 0 entries\n\ndict[\"a\"] = 1 # type mismatch\n# ERROR: MethodError: Cannot `convert` an object of type String to an object of type Char\n\ntypeof(dict) # type is infered correctly\n# Dict{Char,Int64}\n"
  },
  {
    "language": "Julia",
    "code": "dict = Dict(\"hello\" => 13, \"world\" => 31, \"!\" => 71)\n\n# applying a function to key-value pairs:\nforeach(println, dict)\n\n# iterating over key-value pairs:\nfor (key, value) in dict\n    println(\"dict[$key] = $value\")\nend\n\n# iterating over keys:\nfor key in keys(dict)\n    @show key\nend\n\n# iterating over values:\nfor value in values(dict)\n    @show value\nend\n"
  },
  {
    "language": "Julia",
    "code": "using StatsBase\n\nfunction runall()\n    nbuckets = 16\n    unfinish = true\n    spinner = ReentrantLock()\n    buckets = rand(1:99, nbuckets)\n    totaltrans = 0\n\n    bucketsum() = sum(buckets)\n    smallpause() = sleep(rand() / 2000)\n    picktwo() = (samplepair(nbuckets)...)\n    function equalizer()\n        while unfinish\n            smallpause()\n            if trylock(spinner)\n                i, j = picktwo()\n                sm = buckets[i] + buckets[j]\n                m = fld(sm + 1, 2)\n                buckets[i], buckets[j] = m, sm - m\n                totaltrans += 1\n                unlock(spinner)\n            end\n        end\n    end\n    function redistributor()\n        while unfinish\n            smallpause()\n            if trylock(spinner)\n                i, j = picktwo()\n                sm = buckets[i] + buckets[j]\n                buckets[i] = rand(0:sm)\n                buckets[j] = sm - buckets[i]\n                totaltrans += 1\n                unlock(spinner)\n            end\n        end\n    end\n    function accountant()\n        count = 0\n        while count < 16\n            smallpause()\n            if trylock(spinner)\n                println(\"Current state of buckets: $buckets. Total in buckets: $(bucketsum())\")\n                unlock(spinner)\n                count += 1\n                sleep(1)\n            end\n        end\n        unfinish = false\n    end\n    t = time()\n    @async equalizer()\n    @async redistributor()\n    @async accountant()\n    while unfinish sleep(0.25) end\n    println(\"Total transactions: $totaltrans ($(round(Int, totaltrans / (time() - t))) unlocks per second).\")\nend\n\nrunall()\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nanalytical(n::Integer) = sum(factorial(n) / big(n) ^ i / factorial(n - i) for i = 1:n)\n\nfunction test(n::Integer, times::Integer = 1000000)\n    c = 0\n    for i = range(0, times)\n        x, bits = 1, 0\n        while (bits & x) == 0\n            c += 1\n            bits |= x\n            x = 1 << rand(0:(n - 1))\n        end\n    end\n    return c / times\nend\n\nfunction main(n::Integer)\n    println(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\")\n    for n in 1:n\n        avg = test(n)\n        theory = analytical(n)\n        diff = (avg / theory - 1) * 100\n        @printf(STDOUT, \"%2d %8.4f %8.4f %6.3f%%\\n\", n, avg, theory, diff)\n    end\nend\n\nmain(20)\n"
  },
  {
    "language": "Julia",
    "code": "julia> using Statistics; mean([1,2,3])\n2.0\njulia> mean(1:10)\n5.5\njulia> mean([])\nERROR: mean of empty collection undefined: []\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\nmeandegrees(degrees) = radians2degrees(atan2(mean(sind(degrees)), mean(cosd(degrees))))\n"
  },
  {
    "language": "Julia",
    "code": "julia> meandegrees([350, 10])\n0.0\n\njulia> meandegrees([90, 180, 270, 360]])\n0.0\n\njulia> meandegrees([10, 20, 30]])\n19.999999999999996\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\n\nfunction meantime(times::Array, dlm::String=\":\")\n    c = \u03c0 / (12 * 60 * 60)\n    a = map(x -> parse.(Int, x), split.(times, dlm))\n    \u03d5 = collect(3600t[1] + 60t[2] + t[3] for t in a)\n    d = angle(mean(exp.(c * im * \u03d5))) / 2\u03c0 # days\n    if d < 0 d += 1 end\n    # Convert to h:m:s\n    h = trunc(Int, d * 24)\n    m = trunc(Int, d * 24 * 60) - h * 60\n    s = trunc(Int, d * 24 * 60 * 60) - h * 60 * 60 - m * 60\n    return \"$h:$m:$s\"\nend\n\ntimes = String[\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]\nmtime = meantime(times)\nprintln(\"Times:\")\nprintln.(times)\nprintln(\"Mean: $mtime\")\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\nfunction median2(n)\n\ts = sort(n)\n\tlen = length(n)\n\tif len % 2 == 0\n\t\treturn (s[floor(Int, len / 2) + 1] + s[floor(Int, len / 2)]) / 2\n\telse\n\t\treturn  s[floor(Int, len / 2) + 1]\n\tend\nend\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]\nb = [4.1, 7.2, 1.7, 9.3, 4.4, 3.2]\n\n@show a b median2(a) median(a) median2(b) median(b)\n"
  },
  {
    "language": "Julia",
    "code": "function modes(values)\n    dict = Dict() # Values => Number of repetitions\n    modesArray = typeof(values[1])[] # Array of the modes so far\n    max = 0 # Max of repetitions so far\n\n    for v in values\n        # Add one to the dict[v] entry (create one if none)\n        if v in keys(dict)\n            dict[v] += 1\n        else\n            dict[v] = 1\n        end\n\n        # Update modesArray if the number of repetitions\n        # of v reaches or surpasses the max value\n        if dict[v] >= max\n            if dict[v] > max\n                empty!(modesArray)\n                max += 1\n            end\n            append!(modesArray, [v])\n        end\n    end\n\n    return modesArray\nend\n\nprintln(modes([1,3,6,6,6,6,7,7,12,12,17]))\nprintln(modes((1,1,2,4,4)))\n"
  },
  {
    "language": "Julia",
    "code": "amean(A) = sum(A)/length(A)\n\ngmean(A) = prod(A)^(1/length(A))\n\nhmean(A) = length(A)/sum(1./A)\n"
  },
  {
    "language": "Julia",
    "code": "sqrt(sum(A.^2.) / length(A))\n"
  },
  {
    "language": "Julia",
    "code": "sqrt(mean(A.^2.))\n"
  },
  {
    "language": "Julia",
    "code": "sqrt(sum(x -> x*x, A) / length(A))\n"
  },
  {
    "language": "Julia",
    "code": "function rms(A)\n   s = 0.0\n   for a in A\n      s += a*a\n   end\n   return sqrt(s / length(A))\nend\n"
  },
  {
    "language": "Julia",
    "code": "norm(A) / sqrt(length(A))\n"
  },
  {
    "language": "Julia",
    "code": "using Statistics\n"
  },
  {
    "language": "Julia",
    "code": "function movingaverage(::Type{T} = Float64; lim::Integer = -1) where T<:Real\n\tbuffer = Vector{T}(0)\n\tif lim == -1\n\t\t# unlimited buffer\n\t\treturn (y::T) -> begin\n\t\t\tpush!(buffer, y)\n\t\t\treturn mean(buffer)\n\t\tend\n\telse\n\t\t# limited size buffer\n\t\treturn (y) -> begin\n\t\t\tpush!(buffer, y)\n\t\t\tif length(buffer) > lim shift!(buffer) end\n\t\t\treturn mean(buffer)\n\t\tend\n\tend\nend\n\ntest = movingaverage()\n@show test(1.0) # mean([1])\n@show test(2.0) # mean([1, 2])\n@show test(3.0) # mean([1, 2, 3])\n"
  },
  {
    "language": "Kotlin",
    "code": "fun oneHundredDoors(): List<Int> {\n    val doors = BooleanArray(100, { false })\n    for (i in 0..99) {\n        for (j in i..99 step (i + 1)) {\n            doors[j] = !doors[j]\n        }\n    }\n    return doors\n        .mapIndexed { i, b -> i to b }\n        .filter { it.second }\n        .map { it.first + 1 }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\nimport java.util.Random\n\nconst val N_CARDS = 4\nconst val SOLVE_GOAL = 24\nconst val MAX_DIGIT = 9\n\nclass Frac(val num: Int, val den: Int)\n\nenum class OpType { NUM, ADD, SUB, MUL, DIV }\n\nclass Expr(\n    var op:    OpType = OpType.NUM,\n    var left:  Expr?  = null,\n    var right: Expr?  = null,\n    var value: Int    = 0\n)\n\nfun showExpr(e: Expr?, prec: OpType, isRight: Boolean) {\n    if (e == null) return\n    val op = when (e.op) {\n        OpType.NUM -> { print(e.value); return }\n        OpType.ADD -> \" + \"\n        OpType.SUB -> \" - \"\n        OpType.MUL -> \" x \"\n        OpType.DIV -> \" / \"\n    }\n\n    if ((e.op == prec && isRight) || e.op < prec) print(\"(\")\n    showExpr(e.left, e.op, false)\n    print(op)\n    showExpr(e.right, e.op, true)\n    if ((e.op == prec && isRight) || e.op < prec) print(\")\")\n}\n\nfun evalExpr(e: Expr?): Frac {\n    if (e == null) return Frac(0, 1)\n    if (e.op == OpType.NUM) return Frac(e.value, 1)\n    val l = evalExpr(e.left)\n    val r = evalExpr(e.right)\n    return when (e.op) {\n        OpType.ADD -> Frac(l.num * r.den + l.den * r.num, l.den * r.den)\n        OpType.SUB -> Frac(l.num * r.den - l.den * r.num, l.den * r.den)\n        OpType.MUL -> Frac(l.num * r.num, l.den * r.den)\n        OpType.DIV -> Frac(l.num * r.den, l.den * r.num)\n        else       -> throw IllegalArgumentException(\"Unknown op: ${e.op}\")\n    }\n}\n\nfun solve(ea: Array<Expr?>, len: Int): Boolean {\n    if (len == 1) {\n        val final = evalExpr(ea[0])\n        if (final.num == final.den * SOLVE_GOAL && final.den != 0) {\n            showExpr(ea[0], OpType.NUM, false)\n            return true\n        }\n    }\n\n    val ex = arrayOfNulls<Expr>(N_CARDS)\n    for (i in 0 until len - 1) {\n        for (j in i + 1 until len) ex[j - 1] = ea[j]\n        val node = Expr()\n        ex[i] = node\n        for (j in i + 1 until len) {\n            node.left = ea[i]\n            node.right = ea[j]\n            for (k in OpType.values().drop(1)) {\n                node.op = k\n                if (solve(ex, len - 1)) return true\n            }\n            node.left = ea[j]\n            node.right = ea[i]\n            node.op = OpType.SUB\n            if (solve(ex, len - 1)) return true\n            node.op = OpType.DIV\n            if (solve(ex, len - 1)) return true\n            ex[j] = ea[j]\n        }\n        ex[i] = ea[i]\n    }\n    return false\n}\n\nfun solve24(n: IntArray) =\n    solve (Array(N_CARDS) { Expr(value = n[it]) }, N_CARDS)\n\nfun main(args: Array<String>) {\n    val r = Random()\n    val n = IntArray(N_CARDS)\n    for (j in 0..9) {\n        for (i in 0 until N_CARDS) {\n            n[i] = 1 + r.nextInt(MAX_DIGIT)\n            print(\" ${n[i]}\")\n        }\n        print(\":  \")\n        println(if (solve24(n)) \"\" else \"No solution\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\nimport java.util.Scanner\nimport java.util.Stack\n\ninternal object Game24 {\n    fun run() {\n        val r = Random()\n        val digits = IntArray(4).map { r.nextInt(9) + 1 }\n        println(\"Make 24 using these digits: $digits\")\n        print(\"> \")\n\n        val s = Stack<Float>()\n        var total = 0L\n        val cin = Scanner(System.`in`)\n        for (c in cin.nextLine()) {\n            when (c) {\n                in '0'..'9' -> {\n                    val d = c - '0'\n                    total += (1 shl (d * 5)).toLong()\n                    s += d.toFloat()\n                }\n                else ->\n                    if (\"+/-*\".indexOf(c) != -1) {\n                        s += c.applyOperator(s.pop(), s.pop())\n                    }\n            }\n        }\n\n        when {\n            tally(digits) != total ->\n                print(\"Not the same digits. \")\n            s.peek().compareTo(target) == 0 ->\n                println(\"Correct!\")\n            else ->\n                print(\"Not correct.\")\n        }\n    }\n\n    private fun Char.applyOperator(a: Float, b: Float) = when (this) {\n        '+' -> a + b\n        '-' -> b - a\n        '*' -> a * b\n        '/' -> b / a\n        else -> Float.NaN\n    }\n\n    private fun tally(a: List<Int>): Long = a.reduce({ t, i -> t + (1 shl (i * 5)) }).toLong()\n\n    private val target = 24\n}\n\nfun main(args: Array<String>) = Game24.run()\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.min\nimport java.math.BigInteger\nimport java.util.ArrayList\nimport java.util.Arrays.asList\n\nfun namesOfGod(n: Int): List<BigInteger> {\n    val cache = ArrayList<List<BigInteger>>()\n    cache.add(asList(BigInteger.ONE))\n\n    (cache.size..n).forEach { l ->\n        val r = ArrayList<BigInteger>()\n        r.add(BigInteger.ZERO)\n\n        (1..l).forEach { x ->\n            r.add(r[r.size - 1] + cache[l - x][min(x, l - x)])\n        }\n        cache.add(r)\n    }\n    return cache[n]\n}\n\nfun row(n: Int) = namesOfGod(n).let { r -> (0 until n).map { r[it + 1] - r[it] } }\n\nfun main(args: Array<String>) {\n    println(\"Rows:\")\n    (1..25).forEach {\n        System.out.printf(\"%2d: %s%n\", it, row(it))\n    }\n\n    println(\"\\nSums:\")\n    intArrayOf(23, 123, 1234, 1234).forEach {\n        val c = namesOfGod(it)\n        System.out.printf(\"%s %s%n\", it, c[c.size - 1])\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    for (i in 99.downTo(1)) {\n        println(\"$i bottles of beer on the wall\")\n        println(\"$i bottles of beer\")\n        println(\"Take one down, pass it around\")\n    }\n    println(\"No more bottles of beer on the wall!\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun main(args: Array<String>) {\n    val r = Regex(\"\"\"-?\\d+[ ]+-?\\d+\"\"\")\n    while(true) {\n        print(\"Enter two integers separated by space(s) or q to quit: \")\n        val input: String = readLine()!!.trim()\n        if (input == \"q\" || input == \"Q\") break\n        if (!input.matches(r)) {\n            println(\"Invalid input, try again\")\n            continue\n        }\n        val index = input.lastIndexOf(' ')\n        val a = input.substring(0, index).trimEnd().toInt()\n        val b = input.substring(index + 1).toInt()\n        if (Math.abs(a) > 1000 || Math.abs(b) > 1000) {\n            println(\"Both numbers must be in the interval [-1000, 1000] - try again\")\n        }\n        else {\n            println(\"Their sum is ${a + b}\\n\")\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "object ABC_block_checker {\n    fun run() {\n        val blocks = arrayOf(\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\")\n\n        println(\"\\\"\\\": \" + blocks.canMakeWord(\"\"))\n        val words = arrayOf(\"A\", \"BARK\", \"book\", \"treat\", \"COMMON\", \"SQuAd\", \"CONFUSE\")\n        for (w in words)  println(\"$w: \" + blocks.canMakeWord(w))\n    }\n\n    private fun Array<String>.swap(i: Int, j: Int) {\n        val tmp = this[i]\n        this[i] = this[j]\n        this[j] = tmp\n    }\n\n    private fun Array<String>.canMakeWord(word: String): Boolean {\n        if (word.isEmpty())\n            return true\n\n        val c = Character.toUpperCase(word.first())\n        var i = 0\n        forEach { b ->\n            if (b.first().toUpperCase() == c || b[1].toUpperCase() == c) {\n                swap(0, i)\n                if (drop(1).toTypedArray().canMakeWord(word.substring(1)))\n                    return true\n                swap(0, i)\n            }\n            i++\n        }\n\n        return false\n    }\n}\n\nfun main(args: Array<String>) = ABC_block_checker.run()\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\ninterface Announcer {\n    fun announceType()\n\n    // interface can contain non-abstract members but cannot store state\n    fun announceName() {\n        println(\"I don't have a name\")\n    }\n}\n\nabstract class Animal: Announcer {\n    abstract fun makeNoise()\n\n    // abstract class can contain non-abstract members\n    override fun announceType() {\n        println(\"I am an Animal\")\n    }\n}\n\nclass Dog(private val name: String) : Animal() {\n    override fun makeNoise() {\n       println(\"Woof!\")\n    }\n\n    override fun announceName() {\n       println(\"I'm called $name\")\n    }\n}\n\nclass Cat: Animal() {\n    override fun makeNoise() {\n       println(\"Meow!\")\n    }\n\n    override fun announceType() {\n       println(\"I am a Cat\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val d = Dog(\"Fido\")\n    with(d) {\n        makeNoise()\n        announceType()  // inherits Animal's implementation\n        announceName()\n    }\n    println()\n    val c = Cat()\n    with(c) {\n        makeNoise()\n        announceType()\n        announceName()  // inherits Announcer's implementation\n   }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun sumProperDivisors(n: Int) =\n    if (n < 2) 0 else (1..n / 2).filter { (n % it) == 0 }.sum()\n\nfun main(args: Array<String>) {\n    var sum: Int\n    var deficient = 0\n    var perfect = 0\n    var abundant = 0\n\n    for (n in 1..20000) {\n        sum = sumProperDivisors(n)\n        when {\n            sum < n -> deficient++\n            sum == n -> perfect++\n            sum > n -> abundant++\n        }\n    }\n\n    println(\"The classification of the numbers from 1 to 20,000 is as follows:\\n\")\n    println(\"Deficient = $deficient\")\n    println(\"Perfect   = $perfect\")\n    println(\"Abundant  = $abundant\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun foo(n: Double): (d: Double) -> Double {\n    var nn = n\n    return { nn += it; nn }\n}\n\nfun foo(n: Int): (i: Int) -> Int {\n    var nn = n\n    return { nn += it; nn }\n}\n\nfun main(args: Array<String>) {\n    val x = foo(1.0) // calls 'Double' overload\n    x(5.0)\n    foo(3.0)\n    println(x(2.3))\n    val y = foo(1)   // calls 'Int' overload\n    y(5)\n    foo(5)\n    println(y(2))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun A(m: Long, n: Long): Long = when {\n    m == 0L -> n + 1\n    m > 0L -> when {\n        n == 0L -> A(m - 1, 1)\n        n > 0L -> A(m - 1, A(m, n - 1))\n        else -> throw IllegalArgumentException(\"illegal n\")\n    }\n    else -> throw IllegalArgumentException(\"illegal m\")\n}\n\nfun main(args: Array<String>) {\n    val M: Long = 4\n    val N: Long = 20\n    val r = 0..N\n    for (m  in 0..M) {\n        print(\"\\nA($m, $r) =\")\n        var able = true\n        r.forEach {\n            try {\n                if (able) {\n                    val a = A(m, it)\n                    print(\" %6d\".format(a))\n                } else\n                    print(\"      ?\")\n            } catch(e: Throwable) {\n                print(\"      ?\")\n                able = false\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import org.apache.directory.api.ldap.model.exception.LdapException\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection\nimport java.io.IOException\nimport java.util.logging.Level\nimport java.util.logging.Logger\n\nclass LDAP(map: Map<String, String>) {\n    fun run() {\n        var connection: LdapNetworkConnection? = null\n        try {\n            if (info) log.info(\"LDAP Connection to $hostname on port $port\")\n            connection = LdapNetworkConnection(hostname, port.toInt())\n\n            try {\n                if (info) log.info(\"LDAP bind\")\n                connection.bind()\n            } catch (e: LdapException) {\n                log.severe(e.toString())\n            }\n\n            try {\n                if (info) log.info(\"LDAP unbind\")\n                connection.unBind()\n            } catch (e: LdapException) {\n                log.severe(e.toString())\n            }\n        } finally {\n            try {\n                if (info) log.info(\"LDAP close connection\")\n                connection!!.close()\n            } catch (e: IOException) {\n                log.severe(e.toString())\n            }\n        }\n    }\n\n    private val log = Logger.getLogger(LDAP::class.java.name)\n    private val info = log.isLoggable(Level.INFO)\n    private val hostname: String by map\n    private val port: String by map\n}\n\nfun main(args: Array<String>) = LDAP(mapOf(\"hostname\" to \"localhost\", \"port\"  to \"10389\")).run()\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.0\n\nimport kotlin.math.*\n\ntypealias Function = (Double) -> Double\n\n/**\n * Integrates input function K over time\n * S + (t1 - t0) * (K(t1) + K(t0)) / 2\n */\nclass Integrator {\n    private val start: Long\n    private @Volatile var running = false\n    private lateinit var func: Function\n    private var t0 = 0.0\n    private var v0 = 0.0\n    private var sum = 0.0\n\n    constructor(func: Function) {\n        start = System.nanoTime()\n        setFunc(func)\n        Thread(this::integrate).start()\n    }\n\n    fun setFunc(func: Function) {\n        this.func = func\n        v0 = func(0.0)\n        t0 = 0.0\n    }\n\n    fun getOutput() = sum\n\n    fun stop() {\n        running = false\n    }\n\n    private fun integrate() {\n        running = true\n        while (running) {\n            try {\n                Thread.sleep(1)\n                update()\n            }\n            catch(e: InterruptedException) {\n                return\n            }\n        }\n    }\n\n    private fun update() {\n        val t1 = (System.nanoTime() - start) / 1.0e9\n        val v1 = func(t1)\n        val rect = (t1 - t0) * (v0 + v1) / 2.0\n        sum  += rect\n        t0 = t1\n        v0 = v1\n    }\n}\n\nfun main(args: Array<String>) {\n    val integrator = Integrator( { sin(PI * it) } )\n    Thread.sleep(2000)\n\n    integrator.setFunc( { 0.0 } )\n    Thread.sleep(500)\n\n    integrator.stop()\n    println(integrator.getOutput())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nclass SomeClass {\n    val runtimeVariables = mutableMapOf<String, Any>()\n}\n\nfun main(args: Array<String>) {\n    val sc = SomeClass()\n    println(\"Create two variables at runtime: \")\n    for (i in 1..2) {\n        println(\"  Variable #$i:\")\n        print(\"       Enter name  : \")\n        val name = readLine()!!\n        print(\"       Enter value : \")\n        val value = readLine()!!\n        sc.runtimeVariables.put(name, value)\n        println()\n    }\n    while (true) {\n        print(\"Which variable do you want to inspect ? \")\n        val name = readLine()!!\n        val value = sc.runtimeVariables[name]\n        if (value == null) {\n            println(\"There is no variable of that name, try again\")\n        } else {\n            println(\"Its value is '${sc.runtimeVariables[name]}'\")\n            return\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    val intVar = nativeHeap.alloc<IntVar>()\n    intVar.value = 42\n    with(intVar) { println(\"Value is $value, address is $rawPtr\") }\n    nativeHeap.free(intVar)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun binomial(n: Int, k: Int): Long = when {\n    n < 0 || k < 0 -> throw IllegalArgumentException(\"negative numbers not allowed\")\n    k == 0         -> 1L\n    k == n         -> 1L\n    else           -> {\n        var prod = 1L\n        var div  = 1L\n        for (i in 1..k) {\n            prod *= (n + 1 - i)\n            div  *= i\n            if (prod % div == 0L) {\n                prod /= div\n                div = 1L\n            }\n        }\n        prod\n    }\n}\n\nfun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n    return (1 until n).none { binomial(n, it) % n.toLong() != 0L }\n}\n\nfun main(args: Array<String>) {\n    var coeff: Long\n    var sign: Int\n    var op: String\n    for (n in 0..9) {\n        print(\"(x - 1)^$n = \")\n        sign = 1\n        for (k in n downTo 0) {\n            coeff = binomial(n, k)\n            op = if (sign == 1) \" + \" else \" - \"\n            when (k) {\n                n    -> print(\"x^$n\")\n                0    -> println(\"${op}1\")\n                else -> print(\"$op${coeff}x^$k\")\n            }\n            if (n == 0) println()\n            sign *= -1\n        }\n    }\n    // generate primes under 62\n    var p = 2\n    val primes = mutableListOf<Int>()\n    do {\n        if (isPrime(p)) primes.add(p)\n        if (p != 2) p += 2 else p = 3\n    }\n    while (p < 62)\n    println(\"\\nThe prime numbers under 62 are:\")\n    println(primes)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.nio.charset.StandardCharsets\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\nenum class AlignFunction {\n    LEFT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + s.length + 's').format(s)) },\n    RIGHT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + l + 's').format(s)) },\n    CENTER { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + ((l + s.length) / 2) + 's').format(s)) };\n\n    abstract operator fun invoke(s: String, l: Int): String\n}\n\n/** Aligns fields into columns, separated by \"|\".\n * @constructor Initializes columns aligner from lines in a list of strings.\n * @property lines Lines in a single string. Empty string does form a column.\n */\nclass ColumnAligner(val lines: List<String>) {\n     operator fun invoke(a: AlignFunction) : String {\n        var result = \"\"\n        for (lineWords in words) {\n            for (i in lineWords.indices) {\n                if (i == 0)\n                    result += '|'\n                result += a(lineWords[i], column_widths[i])\n                result += '|'\n            }\n            result += '\\n'\n        }\n        return result\n    }\n\n    private val words = arrayListOf<Array<String>>()\n    private val column_widths = arrayListOf<Int>()\n\n    init {\n        lines.forEach  {\n            val lineWords = java.lang.String(it).split(\"\\\\$\")\n            words += lineWords\n            for (i in lineWords.indices) {\n                if (i >= column_widths.size) {\n                    column_widths += lineWords[i].length\n                } else {\n                    column_widths[i] = Math.max(column_widths[i], lineWords[i].length)\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isEmpty()) {\n        println(\"Usage: ColumnAligner file [L|R|C]\")\n        return\n    }\n    val ca = ColumnAligner(Files.readAllLines(Paths.get(args[0]), StandardCharsets.UTF_8))\n    val alignment = if (args.size >= 2) args[1] else \"L\"\n    when (alignment) {\n        \"L\" -> print(ca(AlignFunction.LEFT))\n        \"R\" -> print(ca(AlignFunction.RIGHT))\n        \"C\" -> print(ca(AlignFunction.CENTER))\n        else -> System.err.println(\"Error! Unknown alignment: \" + alignment)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\ndata class Classification(val sequence: List<Long>, val aliquot: String)\n\nconst val THRESHOLD = 1L shl 47\n\nfun sumProperDivisors(n: Long): Long {\n    if (n < 2L) return 0L\n    val sqrt = Math.sqrt(n.toDouble()).toLong()\n    var sum = 1L + (2L..sqrt)\n        .filter { n % it == 0L }\n        .map { it + n / it }\n        .sum()\n    if (sqrt * sqrt == n) sum -= sqrt\n    return sum\n}\n\nfun classifySequence(k: Long): Classification {\n    require(k > 0)\n    var last = k\n    val seq = mutableListOf(k)\n    while (true) {\n        last = sumProperDivisors(last)\n        seq.add(last)\n        val n = seq.size\n        val aliquot = when {\n            last == 0L                  -> \"Terminating\"\n            n == 2 && last == k         -> \"Perfect\"\n            n == 3 && last == k         -> \"Amicable\"\n            n >= 4 && last == k         -> \"Sociable[${n - 1}]\"\n            last == seq[n - 2]          -> \"Aspiring\"\n            last in seq.slice(1..n - 3) -> \"Cyclic[${n - 1 - seq.indexOf(last)}]\"\n            n == 16 || last > THRESHOLD -> \"Non-Terminating\"\n            else                        -> \"\"\n        }\n        if (aliquot != \"\") return Classification(seq, aliquot)\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\"Aliqot classifications - periods for Sociable/Cyclic in square brackets:\\n\")\n    for (k in 1L..10) {\n        val (seq, aliquot) = classifySequence(k)\n        println(\"${\"%2d\".format(k)}: ${aliquot.padEnd(15)} $seq\")\n    }\n\n    val la = longArrayOf(\n        11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488\n    )\n    println()\n\n    for (k in la) {\n        val (seq, aliquot) = classifySequence(k)\n        println(\"${\"%7d\".format(k)}: ${aliquot.padEnd(15)} $seq\")\n    }\n\n    println()\n\n    val k = 15355717786080L\n    val (seq, aliquot) = classifySequence(k)\n    println(\"$k: ${aliquot.padEnd(15)} $seq\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun Int.k_prime(x: Int): Boolean {\n    var n = x\n    var f = 0\n    var p = 2\n    while (f < this && p * p <= n) {\n        while (0 == n % p) { n /= p; f++ }\n        p++\n    }\n    return f + (if (n > 1) 1 else 0) == this\n}\n\nfun Int.primes(n : Int) : List<Int> {\n    var i = 2\n    var list = mutableListOf<Int>()\n    while (list.size < n) {\n        if (k_prime(i)) list.add(i)\n        i++\n    }\n    return list\n}\n\nfun main(args: Array<String>) {\n    for (k in 1..5)\n        println(\"k = $k: \" + k.primes(10))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.41\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nfun main(args: Array<String>) = amb {\n    val a = amb(\"the\", \"that\", \"a\")\n    val b = amb(\"frog\", \"elephant\", \"thing\")\n    val c = amb(\"walked\", \"treaded\", \"grows\")\n    val d = amb(\"slowly\", \"quickly\")\n\n    if (a[a.lastIndex] != b[0]) amb()\n    if (b[b.lastIndex] != c[0]) amb()\n    if (c[c.lastIndex] != d[0]) amb()\n\n    println(listOf(a, b, c, d))\n\n\n    val x = amb(1, 2, 3)\n    val y = amb(7, 6, 4, 5)\n    if (x * y != 8) amb()\n    println(listOf(x, y))\n}\n\n\nclass AmbException(): Exception(\"Refusing to execute\")\ndata class AmbPair<T>(val cont: Continuation<T>, val valuesLeft: MutableList<T>)\n\n@RestrictsSuspension\nclass AmbEnvironment {\n    val ambList = mutableListOf<AmbPair<*>>()\n\n    suspend fun <T> amb(value: T, vararg rest: T): T = suspendCoroutineOrReturn { cont ->\n        if (rest.size > 0) {\n            ambList.add(AmbPair(clone(cont), mutableListOf(*rest)))\n        }\n\n        value\n    }\n\n    suspend fun amb(): Nothing = suspendCoroutine<Nothing> { }\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <R> amb(block: suspend AmbEnvironment.() -> R): R {\n    var result: R? = null\n    var toThrow: Throwable? = null\n\n    val dist = AmbEnvironment()\n    block.startCoroutine(receiver = dist, completion = object : Continuation<R> {\n        override val context: CoroutineContext get() = EmptyCoroutineContext\n        override fun resume(value: R) { result = value }\n        override fun resumeWithException(exception: Throwable) { toThrow = exception }\n    })\n\n    while (result == null && toThrow == null && !dist.ambList.isEmpty()) {\n        val last = dist.ambList.run { this[lastIndex] }\n\n        if (last.valuesLeft.size == 1) {\n            dist.ambList.removeAt(dist.ambList.lastIndex)\n            last.apply {\n                (cont as Continuation<Any?>).resume(valuesLeft[0])\n            }\n        } else {\n            val value = last.valuesLeft.removeAt(last.valuesLeft.lastIndex)\n            (clone(last.cont) as Continuation<Any?>).resume(value)\n        }\n    }\n\n    if (toThrow != null)\n    {\n        throw toThrow!!\n    }\n    else if (result != null)\n    {\n        return result!!\n    }\n    else\n    {\n        throw AmbException()\n    }\n}\n\nval UNSAFE = Class.forName(\"sun.misc.Unsafe\")\n    .getDeclaredField(\"theUnsafe\")\n    .apply { isAccessible = true }\n    .get(null) as sun.misc.Unsafe\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <T: Any> clone(obj: T): T {\n    val clazz = obj::class.java\n    val copy = UNSAFE.allocateInstance(clazz) as T\n    copyDeclaredFields(obj, copy, clazz)\n    return copy\n}\n\ntailrec fun <T> copyDeclaredFields(obj: T, copy: T, clazz: Class<out T>) {\n    for (field in clazz.declaredFields) {\n        field.isAccessible = true\n        val v = field.get(obj)\n        field.set(copy, if (v === obj) copy else v)\n    }\n    val superclass = clazz.superclass\n    if (superclass != null) copyDeclaredFields(obj, copy, superclass)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun sumProperDivisors(n: Int): Int {\n    if (n < 2) return 0\n    return (1..n / 2).filter{ (n % it) == 0 }.sum()\n}\n\nfun main(args: Array<String>) {\n    val sum = IntArray(20000, { sumProperDivisors(it) } )\n    println(\"The pairs of amicable numbers below 20,000 are:\\n\")\n    for(n in 2..19998) {\n        val m = sum[n]\n        if (m > n && m < 20000 && n == sum[m]) {\n            println(n.toString().padStart(5) + \" and \" + m.toString().padStart(5))\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\n\nfun isDeranged(s1: String, s2: String): Boolean {\n    return (0 until s1.length).none { s1[it] == s2[it] }\n}\n\nfun main(args: Array<String>) {\n    val url = URL(\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) {\n            anagrams.put(key, mutableListOf<String>())\n            anagrams[key]!!.add(word)\n        }\n        else {\n            val deranged = anagrams[key]!!.any { isDeranged(it, word) }\n            if (deranged) {\n                anagrams[key]!!.add(word)\n                count = Math.max(count, word.length)\n            }\n        }\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size > 1 && it[0].length == count }\n        .forEach { println(it) }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\nimport kotlin.math.max\n\nfun main() {\n    val url = URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) anagrams[key] = mutableListOf()\n        anagrams[key]?.add(word)\n        count = max(count, anagrams[key]?.size ?: 0)\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size == count }\n        .forEach { println(it) }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.awt.*\nimport java.util.concurrent.*\nimport javax.swing.*\n\nclass Pendulum(private val length: Int) : JPanel(), Runnable {\n    init {\n        val f = JFrame(\"Pendulum\")\n        f.add(this)\n        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        f.pack()\n        f.isVisible = true\n        isDoubleBuffered = true\n    }\n\n    override fun paint(g: Graphics) {\n        with(g) {\n            color = Color.WHITE\n            fillRect(0, 0, width, height)\n            color = Color.BLACK\n            val anchor = Element(width / 2, height / 4)\n            val ball = Element((anchor.x + Math.sin(angle) * length).toInt(), (anchor.y + Math.cos(angle) * length).toInt())\n            drawLine(anchor.x, anchor.y, ball.x, ball.y)\n            fillOval(anchor.x - 3, anchor.y - 4, 7, 7)\n            fillOval(ball.x - 7, ball.y - 7, 14, 14)\n        }\n    }\n\n    override fun run() {\n        angleVelocity += -9.81 / length * Math.sin(angle) * dt\n        angle += angleVelocity * dt\n        repaint()\n    }\n\n    override fun getPreferredSize() = Dimension(2 * length + 50, length / 2 * 3)\n\n    private data class Element(val x: Int, val y: Int)\n\n    private val dt = 0.1\n    private var angle = Math.PI / 2\n    private var angleVelocity = 0.0\n}\n\nfun main(a: Array<String>) {\n    val executor = Executors.newSingleThreadScheduledExecutor()\n    executor.scheduleAtFixedRate(Pendulum(200), 0, 15, TimeUnit.MILLISECONDS)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.0\n\nimport java.awt.Dimension\nimport java.awt.event.MouseAdapter\nimport java.awt.event.MouseEvent\nimport java.util.*\nimport javax.swing.JFrame\nimport javax.swing.JLabel\n\nclass Rotate : JFrame() {\n    val text = \"Hello World! \"\n    val label = JLabel(text)\n    var rotRight = true\n    var startIdx = 0\n\n    init {\n        preferredSize = Dimension(96, 64)\n        label.addMouseListener(object: MouseAdapter() {\n            override fun mouseClicked(evt: MouseEvent) {\n                rotRight = !rotRight\n            }\n        })\n        add(label)\n        pack()\n        defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        isVisible = true\n    }\n}\n\nfun getRotatedText(text: String, startIdx: Int): String {\n    val ret = StringBuilder()\n    var i = startIdx\n    do {\n        ret.append(text[i++])\n        i %= text.length\n    }\n    while (i != startIdx)\n    return ret.toString()\n}\n\nfun main(args: Array<String>) {\n    val rot = Rotate()\n    val task = object : TimerTask() {\n        override fun run() {\n            if (rot.rotRight) {\n                if (--rot.startIdx < 0) rot.startIdx += rot.text.length\n            }\n            else {\n                if (++rot.startIdx >= rot.text.length) rot.startIdx -= rot.text.length\n            }\n            rot.label.text = getRotatedText(rot.text, rot.startIdx)\n        }\n    }\n    Timer(false).schedule(task, 0, 500)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun fib(n: Int): Int {\n   require(n >= 0)\n   fun fib1(k: Int, a: Int, b: Int): Int =\n       if (k == 0) a else fib1(k - 1, b, a + b)\n   return fib1(n, 0, 1)\n}\n\nfun main(args: Array<String>) {\n    for (i in 0..20) print(\"${fib(i)} \")\n    println()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.41\n\nimport java.io.File\n\nclass Record(\n    val account: String,\n    val password: String,\n    val uid: Int,\n    val gid: Int,\n    val gecos: List<String>,\n    val directory: String,\n    val shell: String\n){\n    override fun toString() =\n        \"$account:$password:$uid:$gid:${gecos.joinToString(\",\")}:$directory:$shell\"\n}\n\nfun parseRecord(line: String): Record {\n    val fields = line.split(':')\n    return Record(\n        fields[0],\n        fields[1],\n        fields[2].toInt(),\n        fields[3].toInt(),\n        fields[4].split(','),\n        fields[5],\n        fields[6]\n    )\n}\n\nfun main(args: Array<String>) {\n    val startData = listOf(\n        \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n        \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\"\n    )\n    val records = startData.map { parseRecord(it) }\n    val f = File(\"passwd.csv\")\n    f.printWriter().use {\n        for (record in records) it.println(record)\n    }\n    println(\"Initial records:\\n\")\n    f.forEachLine {\n        println(parseRecord(it))\n    }\n\n    val newData = \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n    val record = parseRecord(newData)\n    if (!f.setWritable(true, true)) {\n        println(\"\\nFailed to make file writable only by owner\\n.\")\n    }\n    f.appendText(\"$record\\n\")\n    println(\"\\nRecords after another one is appended:\\n\")\n    f.forEachLine {\n        println(parseRecord(it))\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)  // build\n    val function = { i: Int -> i * i } // function to apply\n    val list = array.map { function(it) } // process each item\n    println(list) // print results\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigInteger\n\nfun main(args: Array<String>) {\n    val x = BigInteger.valueOf(5).pow(Math.pow(4.0, 3.0 * 3.0).toInt())\n    val y = x.toString()\n    val len = y.length\n    println(\"5^4^3^2 = ${y.substring(0, 20)}...${y.substring(len - 20)} and has $len digits\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    memScoped {\n        val intVar1 = alloc<IntVar>()\n        intVar1.value = 1\n        val intVar2 = alloc<IntVar>()\n        intVar2.value = 2\n        println(\"${intVar1.value} + ${intVar2.value} = ${intVar1.value + intVar2.value}\")\n    }\n    // native memory used by intVar1 & intVar2 is automatically freed when memScoped block ends\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class Complex(private val real: Double, private val imag: Double) {\n    operator fun plus(other: Complex) = Complex(real + other.real, imag + other.imag)\n\n    operator fun times(other: Complex) = Complex(\n        real * other.real - imag * other.imag,\n        real * other.imag + imag * other.real\n    )\n\n    fun inv(): Complex {\n        val denom = real * real + imag * imag\n        return Complex(real / denom, -imag / denom)\n    }\n\n    operator fun unaryMinus() = Complex(-real, -imag)\n\n    operator fun minus(other: Complex) = this + (-other)\n\n    operator fun div(other: Complex) = this * other.inv()\n\n    fun conj() = Complex(real, -imag)\n\n    override fun toString() =\n        if (imag >= 0.0) \"$real + ${imag}i\"\n        else \"$real - ${-imag}i\"\n}\n\nfun main(args: Array<String>) {\n    val x = Complex(1.0, 3.0)\n    val y = Complex(5.0, 2.0)\n    println(\"x     =  $x\")\n    println(\"y     =  $y\")\n    println(\"x + y =  ${x + y}\")\n    println(\"x - y =  ${x - y}\")\n    println(\"x * y =  ${x * y}\")\n    println(\"x / y =  ${x / y}\")\n    println(\"-x    =  ${-x}\")\n    println(\"1 / x =  ${x.inv()}\")\n    println(\"x*    =  ${x.conj()}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.10\n\n/* if string is empty, returns zero */\nfun String.toDoubleOrZero() = this.toDoubleOrNull() ?: 0.0\n\nfun multiply(s: String): String {\n    val b = s.split('*').map { it.toDoubleOrZero() }\n    return (b[0] * b[1]).toString()\n}\n\nfun divide(s: String): String {\n    val b = s.split('/').map { it.toDoubleOrZero() }\n    return (b[0] / b[1]).toString()\n}\n\nfun add(s: String): String {\n    var t = s.replace(Regex(\"\"\"^\\+\"\"\"), \"\").replace(Regex(\"\"\"\\++\"\"\"), \"+\")\n    val b = t.split('+').map { it.toDoubleOrZero() }\n    return (b[0] + b[1]).toString()\n}\n\nfun subtract(s: String): String {\n    var t = s.replace(Regex(\"\"\"(\\+-|-\\+)\"\"\"), \"-\")\n    if (\"--\" in t) return add(t.replace(\"--\", \"+\"))\n    val b = t.split('-').map { it.toDoubleOrZero() }\n    return (if (b.size == 3) -b[1] - b[2] else b[0] - b[1]).toString()\n}\n\nfun evalExp(s: String): String {\n    var t = s.replace(Regex(\"\"\"[()]\"\"\"), \"\")\n    val reMD = Regex(\"\"\"\\d+\\.?\\d*\\s*[*/]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reM  = Regex( \"\"\"\\*\"\"\")\n    val reAS = Regex(\"\"\"-?\\d+\\.?\\d*\\s*[+-]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reA  = Regex(\"\"\"\\d\\+\"\"\")\n\n    while (true) {\n        val match = reMD.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reM.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, multiply(exp))\n            else\n                t.replace(exp, divide(exp))\n    }\n\n    while (true) {\n        val match = reAS.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reA.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, add(exp))\n            else\n                t.replace(exp, subtract(exp))\n    }\n\n    return t\n}\n\nfun evalArithmeticExp(s: String): Double {\n    var t = s.replace(Regex(\"\"\"\\s\"\"\"), \"\").replace(\"\"\"^\\+\"\"\", \"\")\n    val rePara = Regex(\"\"\"\\([^()]*\\)\"\"\")\n    while(true) {\n        val match = rePara.find(t)\n        if (match == null) break\n        val exp = match.value\n        t = t.replace(exp, evalExp(exp))\n    }\n    return evalExp(t).toDoubleOrZero()\n}\n\nfun main(arsg: Array<String>) {\n    listOf(\n        \"2+3\",\n        \"2+3/4\",\n        \"2*3-4\",\n        \"2*(3+4)+5/6\",\n        \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n        \"2*-3--4+-0.25\",\n         \"-4 - 3\",\n         \"((((2))))+ 3 * 5\",\n         \"1 + 2 * (3 + (4 * 5 + 6 * 7 * 8) - 9) / 10\",\n         \"1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22/(7 + 2*(3 - 1)) - 1)) + 1\"\n    ).forEach { println(\"$it = ${evalArithmeticExp(it)}\") }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.math.MathContext\n\nval con1024 = MathContext(1024)\nval bigTwo  = BigDecimal(2)\nval bigFour = bigTwo * bigTwo\n\nfun bigSqrt(bd: BigDecimal, con: MathContext): BigDecimal {\n    var x0 = BigDecimal.ZERO\n    var x1 = BigDecimal.valueOf(Math.sqrt(bd.toDouble()))\n    while (x0 != x1) {\n        x0 = x1\n        x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con)\n    }\n    return x1\n}\n\nfun main(args: Array<String>) {\n    var a = BigDecimal.ONE\n    var g = a.divide(bigSqrt(bigTwo, con1024), con1024)\n    var t : BigDecimal\n    var sum = BigDecimal.ZERO\n    var pow = bigTwo\n    while (a != g) {\n        t = (a + g).divide(bigTwo, con1024)\n        g = bigSqrt(a * g, con1024)\n        a = t\n        pow *= bigTwo\n        sum += (a * a - g * g) * pow\n    }\n    val pi = (bigFour * a * a).divide(BigDecimal.ONE - sum, con1024)\n    println(pi)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun agm(a: Double, g: Double): Double {\n    var aa = a             // mutable 'a'\n    var gg = g             // mutable 'g'\n    var ta: Double         // temporary variable to hold next iteration of 'aa'\n    val epsilon = 1.0e-16  // tolerance for checking if limit has been reached\n\n    while (true) {\n        ta = (aa + gg) / 2.0\n        if (Math.abs(aa - ta) <= epsilon) return ta\n        gg = Math.sqrt(aa * gg)\n        aa = ta\n    }\n}\n\nfun main(args: Array<String>) {\n    println(agm(1.0, 1.0 / Math.sqrt(2.0)))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun main(args: Array<String>) {\n    val r = Regex(\"\"\"-?\\d+[ ]+-?\\d+\"\"\")\n    while(true) {\n        print(\"Enter two integers separated by space(s) or q to quit: \")\n        val input: String = readLine()!!.trim()\n        if (input == \"q\" || input == \"Q\") break\n        if (!input.matches(r)) {\n            println(\"Invalid input, try again\")\n            continue\n        }\n        val index = input.lastIndexOf(' ')\n        val a = input.substring(0, index).trimEnd().toLong()\n        val b = input.substring(index + 1).toLong()\n        println(\"$a + $b = ${a + b}\")\n        println(\"$a - $b = ${a - b}\")\n        println(\"$a * $b = ${a * b}\")\n        if (b != 0L) {\n            println(\"$a / $b = ${a / b}\")  // rounds towards zero\n            println(\"$a % $b = ${a % b}\")  // if non-zero, matches sign of first operand\n        }\n        else {\n            println(\"$a / $b = undefined\")\n            println(\"$a % $b = undefined\")\n        }\n        val d = Math.pow(a.toDouble(), b.toDouble())\n        print(\"$a ^ $b = \")\n        if (d % 1.0 == 0.0) {\n            if (d >= Long.MIN_VALUE.toDouble() && d <= Long.MAX_VALUE.toDouble())\n                println(\"${d.toLong()}\")\n            else\n                println(\"out of range\")\n        }\n        else if (!d.isFinite())\n            println(\"not finite\")\n        else\n            println(\"not integral\")\n        println()\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nfun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\n\ninfix fun Long.ldiv(denom: Long) = Frac(this, denom)\n\ninfix fun Int.idiv(denom: Int) = Frac(this.toLong(), denom.toLong())\n\nfun Long.toFrac() = Frac(this, 1)\n\nfun Int.toFrac() = Frac(this.toLong(), 1)\n\nclass Frac : Comparable<Frac> {\n    val num: Long\n    val denom: Long\n\n    companion object {\n        val ZERO = Frac(0, 1)\n        val ONE  = Frac(1, 1)\n    }\n\n    constructor(n: Long, d: Long) {\n        require(d != 0L)\n        var nn = n\n        var dd = d\n        if (nn == 0L) {\n            dd = 1\n        }\n        else if (dd < 0) {\n            nn = -nn\n            dd = -dd\n        }\n        val g = Math.abs(gcd(nn, dd))\n        if (g > 1) {\n            nn /= g\n            dd /= g\n        }\n        num = nn\n        denom = dd\n    }\n\n    constructor(n: Int, d: Int) : this(n.toLong(), d.toLong())\n\n    operator fun plus(other: Frac) =\n        Frac(num * other.denom + denom * other.num, other.denom * denom)\n\n    operator fun unaryPlus() = this\n\n    operator fun unaryMinus() = Frac(-num, denom)\n\n    operator fun minus(other: Frac) = this + (-other)\n\n    operator fun times(other: Frac) = Frac(this.num * other.num, this.denom * other.denom)\n\n    operator fun rem(other: Frac) = this - Frac((this / other).toLong(), 1) * other\n\n    operator fun inc() = this + ONE\n    operator fun dec() = this - ONE\n\n    fun inverse(): Frac {\n        require(num != 0L)\n        return Frac(denom, num)\n    }\n\n    operator fun div(other: Frac) = this * other.inverse()\n\n    fun abs() = if (num >= 0) this else -this\n\n    override fun compareTo(other: Frac): Int {\n        val diff = this.toDouble() - other.toDouble()\n        return when {\n            diff < 0.0  -> -1\n            diff > 0.0  -> +1\n            else        ->  0\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n       if (other == null || other !is Frac) return false\n       return this.compareTo(other) == 0\n    }\n\n    override fun hashCode() = num.hashCode() xor denom.hashCode()\n\n    override fun toString() = if (denom == 1L) \"$num\" else \"$num/$denom\"\n\n    fun toDouble() = num.toDouble() / denom\n\n    fun toLong() = num / denom\n}\n\nfun isPerfect(n: Long): Boolean {\n    var sum = Frac(1, n)\n    val limit = Math.sqrt(n.toDouble()).toLong()\n    for (i in 2L..limit) {\n        if (n % i == 0L) sum += Frac(1, i) + Frac(1, n / i)\n    }\n    return sum == Frac.ONE\n}\n\nfun main(args: Array<String>) {\n    var frac1 = Frac(12, 3)\n    println (\"frac1 = $frac1\")\n    var frac2 = 15 idiv 2\n    println(\"frac2 = $frac2\")\n    println(\"frac1 <= frac2 is ${frac1 <= frac2}\")\n    println(\"frac1 >= frac2 is ${frac1 >= frac2}\")\n    println(\"frac1 == frac2 is ${frac1 == frac2}\")\n    println(\"frac1 != frac2 is ${frac1 != frac2}\")\n    println(\"frac1 + frac2 = ${frac1 + frac2}\")\n    println(\"frac1 - frac2 = ${frac1 - frac2}\")\n    println(\"frac1 * frac2 = ${frac1 * frac2}\")\n    println(\"frac1 / frac2 = ${frac1 / frac2}\")\n    println(\"frac1 % frac2 = ${frac1 % frac2}\")\n    println(\"inv(frac1)    = ${frac1.inverse()}\")\n    println(\"abs(-frac1)   = ${-frac1.abs()}\")\n    println(\"inc(frac2)    = ${++frac2}\")\n    println(\"dec(frac2)    = ${--frac2}\")\n    println(\"dbl(frac2)    = ${frac2.toDouble()}\")\n    println(\"lng(frac2)    = ${frac2.toLong()}\")\n    println(\"\\nThe Perfect numbers less than 2^19 are:\")\n    // We can skip odd numbers as no known perfect numbers are odd\n    for (i in 2 until (1 shl 19) step 2) {\n        if (isPerfect(i.toLong())) print(\"  $i\")\n    }\n    println()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val a: Array<Int> = arrayOf(1, 2, 3) // initialise a\n    val b: Array<Int> = arrayOf(4, 5, 6) // initialise b\n    val c: Array<Int> = (a.toList() + b.toList()).toTypedArray()\n    println(c)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun arrayConcat(a: Array<Any>, b: Array<Any>): Array<Any> {\n    return Array(a.size + b.size, { if (it in a.indices) a[it] else b[it - a.size] })\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val a: Collection<Int> = listOf(1, 2, 3) // initialise a\n    val b: Collection<Int> = listOf(4, 5, 6) // initialise b\n    val c: Collection<Int> = a + b\n    println(c)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(x: Array<String>) {\n    var a = arrayOf(1, 2, 3, 4)\n    println(a.asList())\n    a += 5\n    println(a.asList())\n    println(a.reversedArray().asList())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6 (assert.kt)\n\nfun main(args: Array<String>) {\n   val a = 42\n   assert(a == 43)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    // map definition:\n    val map = mapOf(\"foo\" to 5,\n                    \"bar\" to 10,\n                    \"baz\" to 15,\n                    \"foo\" to 6)\n\n    // retrieval:\n    println(map[\"foo\"]) // => 6\n    println(map[\"invalid\"]) // => null\n\n    // check keys:\n    println(\"foo\" in map) // => true\n    println(\"invalid\" in map) // => false\n\n    // iterate over keys:\n    for (k in map.keys) print(\"$k \")\n    println()\n\n    // iterate over values:\n    for (v in map.values) print(\"$v \")\n    println()\n\n    // iterate over key, value pairs:\n    for ((k, v) in map) println(\"$k => $v\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(a: Array<String>) {\n    val map = mapOf(\"hello\" to 1, \"world\" to 2, \"!\" to 3)\n\n    with(map) {\n        entries.forEach { println(\"key = ${it.key}, value = ${it.value}\") }\n        keys.forEach { println(\"key = $it\") }\n        values.forEach { println(\"value = $it\") }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.0\n\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.concurrent.thread\n\nconst val NUM_BUCKETS = 10\n\nclass Buckets(data: IntArray) {\n    private val data = data.copyOf()\n\n    operator fun get(index: Int) = synchronized(data) { data[index] }\n\n    fun transfer(srcIndex: Int, dstIndex: Int, amount: Int): Int {\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Negative amount: $amount\")\n        }\n        if (amount == 0) return 0\n        synchronized(data) {\n            var a = amount\n            if (data[srcIndex] - a < 0) a = data[srcIndex]\n            if (data[dstIndex] + a < 0) a = Int.MAX_VALUE - data[dstIndex]\n            if (a < 0) throw IllegalStateException()\n            data[srcIndex] -= a\n            data[dstIndex] += a\n            return a\n        }\n    }\n\n    val buckets get() = synchronized(data) { data.copyOf() }\n\n    fun transferRandomAmount() {\n        val rnd = ThreadLocalRandom.current()\n        while (true) {\n            val srcIndex = rnd.nextInt(NUM_BUCKETS)\n            val dstIndex = rnd.nextInt(NUM_BUCKETS)\n            val amount = rnd.nextInt() and Int.MAX_VALUE\n            transfer(srcIndex, dstIndex, amount)\n        }\n    }\n\n    fun equalize() {\n        val rnd = ThreadLocalRandom.current()\n        while (true) {\n            val srcIndex = rnd.nextInt(NUM_BUCKETS)\n            val dstIndex = rnd.nextInt(NUM_BUCKETS)\n            val amount = (this[srcIndex] - this[dstIndex]) / 2\n            if (amount >= 0) transfer(srcIndex, dstIndex, amount)\n        }\n    }\n\n    fun print() {\n        while (true) {\n            val nextPrintTime = System.currentTimeMillis() + 3000\n            while (true) {\n                val now = System.currentTimeMillis()\n                if (now >= nextPrintTime) break\n                try {\n                    Thread.sleep(nextPrintTime - now)\n                }\n                catch (e: InterruptedException) {\n                    return\n                }\n            }\n            val bucketValues = buckets\n            println(\"Current values: ${bucketValues.total} ${bucketValues.asList()}\")\n        }\n    }\n}\n\nval IntArray.total: Long get() {\n    var sum = 0L\n    for (d in this) sum += d\n    return sum\n}\n\nfun main(args: Array<String>) {\n    val rnd = ThreadLocalRandom.current()\n    val values = IntArray(NUM_BUCKETS) { rnd.nextInt() and Int.MAX_VALUE }\n    println(\"Initial array:  ${values.total} ${values.asList()}\")\n    val buckets = Buckets(values)\n    thread(name = \"equalizer\")   { buckets.equalize() }\n    thread(name = \"transferrer\") { buckets.transferRandomAmount() }\n    thread(name = \"printer\")     { buckets.print() }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "const val NMAX  = 20\nconst val TESTS = 1000000\nval rand = java.util.Random()\n\nfun avg(n: Int): Double {\n    var sum = 0\n    for (t in 0 until TESTS) {\n        val v = BooleanArray(NMAX)\n        var x = 0\n        while (!v[x]) {\n            v[x] = true\n            sum++\n            x = rand.nextInt(n)\n        }\n    }\n    return sum.toDouble() / TESTS\n}\n\nfun ana(n: Int): Double {\n    val nn = n.toDouble()\n    var term = 1.0\n    var sum = 1.0\n    for (i in n - 1 downTo 1) {\n        term *= i / nn\n        sum += term\n    }\n    return sum\n}\n\nfun main(args: Array<String>) {\n    println(\" N    average    analytical    (error)\")\n    println(\"===  =========  ============  =========\")\n    for (n in 1..NMAX) {\n        val a = avg(n)\n        val b = ana(n)\n        println(String.format(\"%3d   %6.4f   %10.4f      (%4.2f%%)\", n, a, b, Math.abs(a - b) / b * 100.0))\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val nums = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)\n    println(\"average = %f\".format(nums.average()))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun meanAngle(angles: DoubleArray): Double {\n    val sinSum = angles.sumByDouble {  Math.sin(it * Math.PI / 180.0) }\n    val cosSum = angles.sumByDouble {  Math.cos(it * Math.PI / 180.0) }\n    return Math.atan2(sinSum / angles.size, cosSum / angles.size) * 180.0 / Math.PI\n}\n\nfun main(args: Array<String>) {\n    val angles1 = doubleArrayOf(350.0, 10.0)\n    val angles2 = doubleArrayOf(90.0, 180.0, 270.0, 360.0)\n    val angles3 = doubleArrayOf(10.0, 20.0, 30.0)\n    val fmt  = \"%.2f degrees\" // format results to 2 decimal places\n    println(\"Mean for angles 1 is ${fmt.format(meanAngle(angles1))}\")\n    println(\"Mean for angles 2 is ${fmt.format(meanAngle(angles2))}\")\n    println(\"Mean for angles 3 is ${fmt.format(meanAngle(angles3))}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nfun meanAngle(angles: DoubleArray): Double {\n    val sinSum = angles.sumByDouble {  Math.sin(it * Math.PI / 180.0) }\n    val cosSum = angles.sumByDouble {  Math.cos(it * Math.PI / 180.0) }\n    return Math.atan2(sinSum / angles.size, cosSum / angles.size) * 180.0 / Math.PI\n}\n\n/* time string assumed to be in format \"hh:mm:ss\" */\nfun timeToSecs(t: String): Int {\n    val hours = t.slice(0..1).toInt()\n    val mins  = t.slice(3..4).toInt()\n    val secs  = t.slice(6..7).toInt()\n    return 3600 * hours + 60 * mins + secs\n}\n\n/* 1 second of time = 360/(24 * 3600) = 1/240th degree */\nfun timeToDegrees(t: String): Double = timeToSecs(t) / 240.0\n\nfun degreesToTime(d: Double): String {\n    var dd = d\n    if (dd < 0.0) dd += 360.0\n    var secs  = (dd * 240.0).toInt()\n    val hours = secs / 3600\n    var mins  = secs % 3600\n    secs  = mins % 60\n    mins /= 60\n    return String.format(\"%2d:%2d:%2d\", hours, mins, secs)\n}\n\nfun main(args: Array<String>) {\n    val tm = arrayOf(\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\")\n    val angles = DoubleArray(4) { timeToDegrees(tm[it]) }\n    val mean = meanAngle(angles)\n    println(\"Average time is : ${degreesToTime(mean)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun median(l: List<Double>) = l.sorted().let { (it[it.size / 2] + it[(it.size - 1) / 2]) / 2 }\n\nfun main(args: Array<String>) {\n    median(listOf(5.0, 3.0, 4.0)).let { println(it) }  // 4\n    median(listOf(5.0, 4.0, 2.0, 3.0)).let { println(it) }  // 3.5\n    median(listOf(3.0, 4.0, 1.0, -8.4, 7.2, 4.0, 1.0, 1.2)).let { println(it) }  // 2.1\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun <T> modeOf(a: Array<T>) {\n    val sortedByFreq = a.groupBy { it }.entries.sortedByDescending { it.value.size }\n    val maxFreq = sortedByFreq.first().value.size\n    val modes = sortedByFreq.takeWhile { it.value.size == maxFreq }\n    if (modes.size == 1)\n       println(\"The mode of the collection is ${modes.first().key} which has a frequency of $maxFreq\")\n    else {\n       print(\"There are ${modes.size} modes with a frequency of $maxFreq, namely : \")\n       println(modes.map { it.key }.joinToString(\", \"))\n    }\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(7, 1, 1, 6, 2, 4, 2, 4, 2, 1, 5)\n    println(\"[\" + a.joinToString(\", \") + \"]\")\n    modeOf(a)\n    println()\n    val b = arrayOf(true, false, true, false, true, true)\n    println(\"[\" + b.joinToString(\", \") + \"]\")\n    modeOf(b)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun Collection<Double>.geometricMean() =\n    if (isEmpty()) Double.NaN\n    else Math.pow(reduce { n1, n2 -> n1 * n2 }, 1.0 / size)\n\nfun Collection<Double>.harmonicMean() =\n    if (isEmpty() || contains(0.0)) Double.NaN\n    else size / reduce { n1, n2 -> n1 + 1.0 / n2 }\n\nfun main(args: Array<String>) {\n    val list = listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)\n    val a = list.average()  // arithmetic mean\n    val g = list.geometricMean()\n    val h = list.harmonicMean()\n    println(\"A = %f  G = %f  H = %f\".format(a, g, h))\n    println(\"A >= G is %b, G >= H is %b\".format(a >= g, g >= h))\n    require(g in h..a)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun quadraticMean(vector: Array<Double>) : Double {\n    val sum = vector.sumByDouble { it * it }\n    return Math.sqrt(sum / vector.size)\n}\n\nfun main(args: Array<String>) {\n    val vector = Array(10, { (it + 1).toDouble() })\n    print(\"Quadratic mean of numbers 1 to 10 is ${quadraticMean(vector)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nfun initMovingAverage(p: Int): (Double) -> Double {\n    if (p < 1) throw IllegalArgumentException(\"Period must be a positive integer\")\n    val list = mutableListOf<Double>()\n    return {\n        list.add(it)\n        if (list.size > p) list.removeAt(0)\n        list.average()\n    }\n}\n\nfun main(args: Array<String>) {\n    val sma4 = initMovingAverage(4)\n    val sma5 = initMovingAverage(5)\n    val numbers = listOf(1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 4.0, 3.0, 2.0, 1.0)\n    println(\"num\\tsma4\\tsma5\\n\")\n    for (number in numbers) println(\"${number}\\t${sma4(number)}\\t${sma5(number)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\n\nfun isBalanced(s: String): Boolean {\n    if (s.isEmpty()) return true\n    var countLeft = 0  // number of left brackets so far unmatched\n    for (c in s) {\n        if (c == '[') countLeft++\n        else if (countLeft > 0) countLeft--\n        else return false\n    }\n    return countLeft == 0\n}\n\nfun main(args: Array<String>) {\n    println(\"Checking examples in task description:\")\n    val brackets = arrayOf(\"\", \"[]\", \"][\", \"[][]\", \"][][\", \"[[][]]\", \"[]][[]\")\n    for (b in brackets) {\n        print(if (b != \"\") b else \"(empty)\")\n        println(\"\\t  \" + if (isBalanced(b)) \"OK\" else \"NOT OK\")\n    }\n    println()\n\n    println(\"Checking 7 random strings of brackets of length 8:\")\n    val r = Random()\n    (1..7).forEach {\n        var s = \"\"\n        for (j in 1..8) {\n            s += if (r.nextInt(2) == 0) '[' else ']'\n        }\n        println(\"$s  \" + if (isBalanced(s)) \"OK\" else \"NOT OK\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\nimport java.math.BigInteger\n\nval bigZero = BigInteger.ZERO\nval bigOne = BigInteger.ONE\nval bigThree = BigInteger.valueOf(3L)\n\ndata class BTernary(private var value: String) : Comparable<BTernary> {\n\n    init {\n        require(value.all { it in \"0+-\" })\n        value = value.trimStart('0')\n    }\n\n    constructor(v: Int) : this(BigInteger.valueOf(v.toLong()))\n\n    constructor(v: BigInteger) : this(\"\") {\n        value = toBT(v)\n    }\n\n    private fun toBT(v: BigInteger): String {\n        if (v < bigZero) return flip(toBT(-v))\n        if (v == bigZero) return \"\"\n        val rem = mod3(v)\n        return when (rem) {\n            bigZero -> toBT(v / bigThree) + \"0\"\n            bigOne  -> toBT(v / bigThree) + \"+\"\n            else    -> toBT((v + bigOne) / bigThree) + \"-\"\n        }\n    }\n\n    private fun flip(s: String): String {\n        val sb = StringBuilder()\n        for (c in s) {\n            sb.append(when (c) {\n                '+'  -> \"-\"\n                '-'  -> \"+\"\n                else -> \"0\"\n            })\n        }\n        return sb.toString()\n    }\n\n    private fun mod3(v: BigInteger): BigInteger {\n        if (v > bigZero) return v % bigThree\n        return ((v % bigThree) + bigThree) % bigThree\n    }\n\n    fun toBigInteger(): BigInteger {\n        val len = value.length\n        var sum = bigZero\n        var pow = bigOne\n        for (i in 0 until len) {\n            val c = value[len - i - 1]\n            val dig = when (c) {\n                '+'  -> bigOne\n                '-'  -> -bigOne\n                else -> bigZero\n            }\n            if (dig != bigZero) sum += dig * pow\n            pow *= bigThree\n        }\n        return sum\n    }\n\n    private fun addDigits(a: Char, b: Char, carry: Char): String {\n        val sum1 = addDigits(a, b)\n        val sum2 = addDigits(sum1.last(), carry)\n        return when {\n            sum1.length == 1 -> sum2\n            sum2.length == 1 -> sum1.take(1) + sum2\n            else             -> sum1.take(1)\n        }\n    }\n\n    private fun addDigits(a: Char, b: Char): String =\n        when {\n            a == '0' -> b.toString()\n            b == '0' -> a.toString()\n            a == '+' -> if (b == '+') \"+-\" else \"0\"\n            else     -> if (b == '+') \"0\" else \"-+\"\n        }\n\n    operator fun plus(other: BTernary): BTernary {\n        var a = this.value\n        var b = other.value\n        val longer = if (a.length > b.length) a else b\n        var shorter = if (a.length > b.length) b else a\n        while (shorter.length < longer.length) shorter = \"0\" + shorter\n        a = longer\n        b = shorter\n        var carry = '0'\n        var sum = \"\"\n        for (i in 0 until a.length) {\n            val place = a.length - i - 1\n            val digisum = addDigits(a[place], b[place], carry)\n            carry = if (digisum.length != 1) digisum[0] else '0'\n            sum = digisum.takeLast(1) + sum\n        }\n        sum = carry.toString() + sum\n        return BTernary(sum)\n    }\n\n    operator fun unaryMinus() = BTernary(flip(this.value))\n\n    operator fun minus(other: BTernary) = this + (-other)\n\n    operator fun times(other: BTernary): BTernary {\n        var that = other\n        val one = BTernary(1)\n        val zero = BTernary(0)\n        var mul = zero\n        var flipFlag = false\n        if (that < zero) {\n            that = -that\n            flipFlag = true\n        }\n        var i = one\n        while (i <= that) {\n            mul += this\n            i += one\n        }\n        if (flipFlag) mul = -mul\n        return mul\n    }\n\n    override operator fun compareTo(other: BTernary) =\n        this.toBigInteger().compareTo(other.toBigInteger())\n\n    override fun toString() = value\n}\n\nfun main(args: Array<String>) {\n    val a = BTernary(\"+-0++0+\")\n    val b = BTernary(-436)\n    val c = BTernary(\"+-++-\")\n    println(\"a = ${a.toBigInteger()}\")\n    println(\"b = ${b.toBigInteger()}\")\n    println(\"c = ${c.toBigInteger()}\")\n    val bResult = a * (b - c)\n    val iResult = bResult.toBigInteger()\n    println(\"a * (b - c) = $bResult = $iResult\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigInteger\n\ninterface NumberGenerator {\n    val numbers: Array<BigInteger>\n}\n\nclass Benford(ng: NumberGenerator) {\n    override fun toString() = str\n\n    private val firstDigits = IntArray(9)\n    private val count = ng.numbers.size.toDouble()\n    private val str: String\n\n    init {\n        for (n in ng.numbers) {\n            firstDigits[n.toString().substring(0, 1).toInt() - 1]++\n        }\n\n        str = with(StringBuilder()) {\n            for (i in firstDigits.indices) {\n                append(i + 1).append('\\t').append(firstDigits[i] / count)\n                append('\\t').append(Math.log10(1 + 1.0 / (i + 1))).append('\\n')\n            }\n\n            toString()\n        }\n    }\n}\n\nobject FibonacciGenerator : NumberGenerator {\n    override val numbers: Array<BigInteger> by lazy {\n        val fib = Array<BigInteger>(1000, { BigInteger.ONE })\n        for (i in 2 until fib.size)\n            fib[i] = fib[i - 2].add(fib[i - 1])\n        fib\n    }\n}\n\nfun main(a: Array<String>) = println(Benford(FibonacciGenerator))\n"
  },
  {
    "language": "Kotlin",
    "code": "import org.apache.commons.math3.fraction.BigFraction\n\nobject Bernoulli {\n    operator fun invoke(n: Int) : BigFraction {\n        val A = Array(n + 1, init)\n        for (m in 0..n)\n            for (j in m downTo 1)\n                A[j - 1] = A[j - 1].subtract(A[j]).multiply(integers[j])\n        return A.first()\n    }\n\n    val max = 60\n\n    private val init = { m: Int -> BigFraction(1, m + 1) }\n    private val integers = Array(max + 1, { m: Int -> BigFraction(m) } )\n}\n\nfun main(args: Array<String>) {\n    for (n in 0..Bernoulli.max)\n        if (n % 2 == 0 || n == 1)\n            System.out.printf(\"B(%-2d) = %-1s%n\", n, Bernoulli(n))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\n\nobject BestShuffle {\n    operator fun invoke(s1: String) : String {\n        val s2 = s1.toCharArray()\n        s2.shuffle()\n        for (i in s2.indices)\n            if (s2[i] == s1[i])\n                for (j in s2.indices)\n                    if (s2[i] != s2[j] && s2[i] != s1[j] && s2[j] != s1[i]) {\n                        val tmp = s2[i]\n                        s2[i] = s2[j]\n                        s2[j] = tmp\n                        break\n                    }\n        return s1 + ' ' + String(s2) + \" (\" + s2.count(s1) + ')'\n    }\n\n    private fun CharArray.shuffle() {\n        val rand = Random()\n        for (i in size - 1 downTo 1) {\n            val r = rand.nextInt(i + 1)\n            val tmp = this[i]\n            this[i] = this[r]\n            this[r] = tmp\n        }\n    }\n\n    private fun CharArray.count(s1: String) : Int {\n        var count = 0\n        for (i in indices)\n            if (s1[i] == this[i]) count++\n        return count\n    }\n}\n\nfun main(words: Array<String>) = words.forEach { println(BestShuffle(it)) }\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun main(args: Array<String>) {\n    val numbers = intArrayOf(5, 50, 9000)\n    for (number in numbers) println(\"%4d\".format(number) + \" -> \" + Integer.toBinaryString(number))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun <T : Comparable<T>> Array<T>.iterativeBinarySearch(target: T): Int {\n    var hi = size - 1\n    var lo = 0\n    while (hi >= lo) {\n        val guess = lo + (hi - lo) / 2\n        if (this[guess] > target) hi = guess - 1\n        else if (this[guess] < target) lo = guess + 1\n        else return guess\n    }\n    return -1\n}\n\nfun <T : Comparable<T>> Array<T>.recursiveBinarySearch(target: T, lo: Int, hi: Int): Int {\n    if (hi < lo) return -1\n\n    val guess = (hi + lo) / 2\n\n    return if (this[guess] > target) recursiveBinarySearch(target, lo, guess - 1)\n    else if (this[guess] < target) recursiveBinarySearch(target, guess + 1, hi)\n    else guess\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(1, 3, 4, 5, 6, 7, 8, 9, 10)\n    var target = 6\n    var r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n\n    target = 6\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class ByteString(private val bytes: ByteArray) : Comparable<ByteString> {\n    val length get() = bytes.size\n\n    fun isEmpty() = bytes.isEmpty()\n\n    operator fun plus(other: ByteString): ByteString = ByteString(bytes + other.bytes)\n\n    operator fun plus(byte: Byte) = ByteString(bytes + byte)\n\n    operator fun get(index: Int): Byte {\n        require (index in 0 until length)\n        return bytes[index]\n    }\n\n    fun toByteArray() = bytes\n\n    fun copy() = ByteString(bytes.copyOf())\n\n    override fun compareTo(other: ByteString) = this.toString().compareTo(other.toString())\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is ByteString) return false\n        return compareTo(other) == 0\n    }\n\n    override fun hashCode() = this.toString().hashCode()\n\n    fun substring(startIndex: Int) = ByteString(bytes.sliceArray(startIndex until length))\n\n    fun substring(startIndex: Int, endIndex: Int) =\n        ByteString(bytes.sliceArray(startIndex until endIndex))\n\n    fun replace(oldByte: Byte, newByte: Byte): ByteString {\n        val ba = ByteArray(length) { if (bytes[it] == oldByte) newByte else bytes[it] }\n        return ByteString(ba)\n    }\n\n    fun replace(oldValue: ByteString, newValue: ByteString) =\n        this.toString().replace(oldValue.toString(), newValue.toString()).toByteString()\n\n    override fun toString(): String {\n        val chars = CharArray(length)\n        for (i in 0 until length) {\n            chars[i] = when (bytes[i]) {\n                in 0..127  -> bytes[i].toChar()\n                else       -> (256 + bytes[i]).toChar()\n            }\n        }\n        return chars.joinToString(\"\")\n    }\n}\n\nfun String.toByteString(): ByteString {\n    val bytes = ByteArray(this.length)\n    for (i in 0 until this.length) {\n        bytes[i] = when (this[i].toInt()) {\n            in 0..127   -> this[i].toByte()\n            in 128..255 -> (this[i] - 256).toByte()\n            else        -> '?'.toByte()  // say\n        }\n    }\n    return ByteString(bytes)\n}\n\n/* property to be used as an abbreviation for String.toByteString() */\nval String.bs get() = this.toByteString()\n\nfun main(args: Array<String>) {\n    val ba  = byteArrayOf(65, 66, 67)\n    val ba2 = byteArrayOf(68, 69, 70)\n    val bs  = ByteString(ba)\n    val bs2 = ByteString(ba2)\n    val bs3 = bs + bs2\n    val bs4 = \"GHI\u00a3\u20ac\".toByteString()\n    println(\"The length of $bs is ${bs.length}\")\n    println(\"$bs + $bs2 = $bs3\")\n    println(\"$bs + D = ${bs + 68}\")\n    println(\"$bs == ABC is ${bs == bs.copy()}\")\n    println(\"$bs != ABC is ${bs != bs.copy()}\")\n    println(\"$bs >= $bs2 is ${bs > bs2}\")\n    println(\"$bs <= $bs2 is ${bs < bs2}\")\n    println(\"$bs is ${if (bs.isEmpty()) \"empty\" else \"not empty\"}\")\n    println(\"ABC[1] = ${bs[1].toChar()}\")\n    println(\"ABC as a byte array is ${bs.toByteArray().contentToString()}\")\n    println(\"ABCDEF(1..5) = ${bs3.substring(1)}\")\n    println(\"ABCDEF(2..4) = ${bs3.substring(2,5)}\")\n    println(\"ABCDEF with C replaced by G is ${bs3.replace(67, 71)}\")\n    println(\"ABCDEF with CD replaced by GH is ${bs3.replace(\"CD\".bs, \"GH\".bs)}\")\n    println(\"GHI\u00a3\u20ac as a ByteString is $bs4\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.security.MessageDigest\n\nobject Bitcoin {\n    private const val ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\n    private fun ByteArray.contentEquals(other: ByteArray): Boolean {\n        if (this.size != other.size) return false\n        return (0 until this.size).none { this[it] != other[it] }\n    }\n\n    private fun decodeBase58(input: String): ByteArray? {\n        val output = ByteArray(25)\n        for (c in input) {\n            var p = ALPHABET.indexOf(c)\n            if (p == -1) return null\n            for (j in 24 downTo 1) {\n                p += 58 * (output[j].toInt() and 0xff)\n                output[j] = (p % 256).toByte()\n                p = p shr 8\n            }\n            if (p != 0) return null\n        }\n        return output\n    }\n\n    private fun sha256(data: ByteArray, start: Int, len: Int, recursion: Int): ByteArray {\n        if (recursion == 0) return data\n        val md = MessageDigest.getInstance(\"SHA-256\")\n        md.update(data.sliceArray(start until start + len))\n        return sha256(md.digest(), 0, 32, recursion - 1)\n    }\n\n    fun validateAddress(address: String): Boolean {\n        if (address.length !in 26..35) return false\n        val decoded = decodeBase58(address)\n        if (decoded == null) return false\n        val hash = sha256(decoded, 0, 21, 2)\n        return hash.sliceArray(0..3).contentEquals(decoded.sliceArray(21..24))\n    }\n}\n\nfun main(args: Array<String>) {\n    val addresses = arrayOf(\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\",\n        \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\",\n        \"1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n        \"1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n        \"BZbvjr\",\n        \"i55j\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62!\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62iz\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62izz\",\n        \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\",\n        \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\"\n    )\n    for (address in addresses)\n        println(\"${address.padEnd(36)} -> ${if (Bitcoin.validateAddress(address)) \"valid\" else \"invalid\"}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport kotlin.math.abs\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass Point(var x: Int, var y: Int)\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun drawLine(x0: Int, y0: Int, x1: Int, y1: Int, c: Color) {\n        val dx = abs(x1 - x0)\n        val dy = abs(y1 - y0)\n        val sx = if (x0 < x1) 1 else -1\n        val sy = if (y0 < y1) 1 else -1\n        var xx = x0\n        var yy = y0\n        var e1 = (if (dx > dy) dx else -dy) / 2\n        var e2: Int\n        while (true) {\n            setPixel(xx, yy, c)\n            if (xx == x1 && yy == y1) break\n            e2 = e1\n            if (e2 > -dx) { e1 -= dy; xx += sx }\n            if (e2 <  dy) { e1 += dx; yy += sy }\n        }\n    }\n\n    fun cubicBezier(p1: Point, p2: Point, p3: Point, p4: Point, clr: Color, n: Int) {\n        val pts = List(n + 1) { Point(0, 0) }\n        for (i in 0..n) {\n            val t = i.toDouble() / n\n            val u = 1.0 - t\n            val a = u * u * u\n            val b = 3.0 * t * u * u\n            val c = 3.0 * t * t * u\n            val d = t * t * t\n            pts[i].x = (a * p1.x + b * p2.x + c * p3.x + d * p4.x).toInt()\n            pts[i].y = (a * p1.y + b * p2.y + c * p3.y + d * p4.y).toInt()\n            setPixel(pts[i].x, pts[i].y, clr)\n        }\n        for (i in 0 until n) {\n            val j = i + 1\n            drawLine(pts[i].x, pts[i].y, pts[j].x, pts[j].y, clr)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val width = 200\n    val height = 200\n    val bbs = BasicBitmapStorage(width, height)\n    with (bbs) {\n        fill(Color.cyan)\n        val p1 = Point(0, 149)\n        val p2 = Point(30, 50)\n        val p3 = Point(120, 130)\n        val p4 = Point(160, 30)\n        cubicBezier(p1, p2, p3, p4, Color.black, 20)\n        val cbFile = File(\"cubic_bezier.jpg\")\n        ImageIO.write(image, \"jpg\", cbFile)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport kotlin.math.abs\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass Point(var x: Int, var y: Int)\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun drawLine(x0: Int, y0: Int, x1: Int, y1: Int, c: Color) {\n        val dx = abs(x1 - x0)\n        val dy = abs(y1 - y0)\n        val sx = if (x0 < x1) 1 else -1\n        val sy = if (y0 < y1) 1 else -1\n        var xx = x0\n        var yy = y0\n        var e1 = (if (dx > dy) dx else -dy) / 2\n        var e2: Int\n        while (true) {\n            setPixel(xx, yy, c)\n            if (xx == x1 && yy == y1) break\n            e2 = e1\n            if (e2 > -dx) { e1 -= dy; xx += sx }\n            if (e2 <  dy) { e1 += dx; yy += sy }\n        }\n    }\n\n    fun quadraticBezier(p1: Point, p2: Point, p3: Point, clr: Color, n: Int) {\n        val pts = List(n + 1) { Point(0, 0) }\n        for (i in 0..n) {\n            val t = i.toDouble() / n\n            val u = 1.0 - t\n            val a = u * u\n            val b = 2.0 * t * u\n            val c = t * t\n            pts[i].x = (a * p1.x + b * p2.x + c * p3.x).toInt()\n            pts[i].y = (a * p1.y + b * p2.y + c * p3.y).toInt()\n            setPixel(pts[i].x, pts[i].y, clr)\n        }\n        for (i in 0 until n) {\n            val j = i + 1\n            drawLine(pts[i].x, pts[i].y, pts[j].x, pts[j].y, clr)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val width = 320\n    val height = 320\n    val bbs = BasicBitmapStorage(width, height)\n    with (bbs) {\n        fill(Color.cyan)\n        val p1 = Point(10, 100)\n        val p2 = Point(250, 270)\n        val p3 = Point(150, 20)\n        quadraticBezier(p1, p2, p3, Color.black, 20)\n        val qbFile = File(\"quadratic_bezier.jpg\")\n        ImageIO.write(image, \"jpg\", qbFile)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nimport java.awt.*\nimport javax.swing.*\n\nclass Bresenham(w: Int, h: Int) : JPanel() {\n    private val centerX = w / 2\n    private val centerY = h / 2\n\n    init {\n        preferredSize = Dimension(w, h)\n        background = Color.blue\n    }\n\n    override fun paintComponent(g: Graphics) {\n        super.paintComponent(g)\n        drawLine(g, 0, 0, 8, 19)   // NNE\n        drawLine(g, 0, 0, 19, 8)   // ENE\n        drawLine(g, 0, 0, 19, -8)  // ESE\n        drawLine(g, 0, 0, 8, -19)  // SSE\n        drawLine(g, 0, 0, -8, -19) // SSW\n        drawLine(g, 0, 0, -19, -8) // WSW\n        drawLine(g, 0, 0, -19, 8)  // WNW\n        drawLine(g, 0, 0, -8, 19)  // NNW\n    }\n\n    private fun plot(g: Graphics, x: Int, y: Int) {\n        g.color = Color.white\n        g.drawOval(centerX + x * 10, centerY -y * 10, 10, 10)\n    }\n\n    private fun drawLine(g: Graphics, x1: Int, y1: Int, x2: Int, y2: Int) {\n        var d = 0\n        val dy = Math.abs(y2 - y1)\n        val dx = Math.abs(x2 - x1)\n        val dy2 = dy shl 1\n        val dx2 = dx shl 1\n        val ix = if (x1 < x2)  1 else -1\n        val iy = if (y1 < y2)  1 else -1\n        var xx = x1\n        var yy = y1\n\n        if (dy <= dx) {\n            while (true) {\n                plot(g, xx, yy)\n                if (xx == x2) break\n                xx += ix\n                d  += dy2\n                if (d > dx) {\n                    yy += iy\n                    d  -= dx2\n                }\n            }\n        }\n        else {\n            while (true) {\n                plot(g, xx, yy)\n                if (yy == y2) break\n                yy += iy\n                d  += dx2\n                if (d > dy) {\n                    xx += ix\n                    d  -= dy2\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    SwingUtilities.invokeLater {\n        val f = JFrame()\n        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        f.isVisible = true\n        f.add(Bresenham(600, 500), BorderLayout.CENTER)\n        f.title = \"Bresenham\"\n        f.isResizable = false\n        f.pack()\n        f.setLocationRelativeTo(null)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.4-3\n\nimport java.awt.Color\nimport java.awt.Point\nimport java.awt.image.BufferedImage\nimport java.util.LinkedList\nimport java.io.File\nimport javax.imageio.ImageIO\nimport javax.swing.JOptionPane\nimport javax.swing.JLabel\nimport javax.swing.ImageIcon\n\nfun floodFill(image: BufferedImage, node: Point, targetColor: Color, replColor: Color) {\n    val target = targetColor.getRGB()\n    val replacement = replColor.getRGB()\n    if (target == replacement) return\n    val width = image.width\n    val height = image.height\n    val queue = LinkedList<Point>()\n    var nnode: Point? = node\n\n    do {\n        var x = nnode!!.x\n        val y = nnode.y\n        while (x > 0 && image.getRGB(x - 1, y) == target) x--\n        var spanUp = false\n        var spanDown = false\n\n        while (x < width && image.getRGB(x, y) == target) {\n            image.setRGB(x, y, replacement)\n\n            if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {\n                queue.add(Point(x, y - 1))\n                spanUp = true\n            }\n            else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {\n                spanUp = false\n            }\n\n            if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {\n                queue.add(Point(x, y + 1))\n                spanDown = true\n            }\n            else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {\n                spanDown = false\n            }\n            x++\n        }\n        nnode = queue.pollFirst()\n    }\n    while (nnode != null)\n}\n\nfun main(args: Array<String>) {\n   val image = ImageIO.read(File(\"Unfilledcirc.png\"))\n   floodFill(image, Point(50, 50), Color.white, Color.yellow)\n   val title = \"Floodfilledcirc.png\"\n   ImageIO.write(image, \"png\", File(title))\n   JOptionPane.showMessageDialog(null, JLabel(ImageIcon(image)), title, JOptionPane.PLAIN_MESSAGE)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.10\n\nimport java.io.File\nimport java.awt.image.BufferedImage\nimport javax.imageio.ImageIO\n\nconst val BLACK = 0xff000000.toInt()\nconst val WHITE = 0xffffffff.toInt()\n\nfun luminance(argb: Int): Int {\n    val red   = (argb shr 16) and 0xFF\n    val green = (argb shr  8) and 0xFF\n    val blue  =  argb and 0xFF\n    return (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n}\n\nval BufferedImage.histogram: IntArray\n    get() {\n        val lumCount = IntArray(256)\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                var argb = getRGB(x, y)\n                lumCount[luminance(argb)]++\n            }\n        }\n        return lumCount\n    }\n\nfun findMedian(histogram: IntArray): Int {\n    var lSum  = 0\n    var rSum  = 0\n    var left  = 0\n    var right = 255\n    do {\n        if (lSum < rSum) lSum += histogram[left++]\n        else             rSum += histogram[right--]\n    }\n    while (left != right)\n    return left\n}\n\nfun BufferedImage.toBlackAndWhite(median: Int) {\n    for (x in 0 until width) {\n        for (y in 0 until height) {\n            val argb = getRGB(x, y)\n            val lum  = luminance(argb)\n            if (lum < median)\n                setRGB(x, y, BLACK)\n            else\n                setRGB(x, y, WHITE)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val image = ImageIO.read(File(\"Lenna100.jpg\"))\n    val median = findMedian(image.histogram)\n    image.toBlackAndWhite(median)\n    val bwFile = File(\"Lenna_bw.jpg\")\n    ImageIO.write(image, \"jpg\", bwFile)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.4-3\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport javax.swing.JOptionPane\nimport javax.swing.JLabel\nimport javax.swing.ImageIcon\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun drawCircle(bbs: BasicBitmapStorage, centerX: Int, centerY: Int, radius: Int, circleColor: Color) {\n    var d = (5 - radius * 4) / 4\n    var x = 0\n    var y = radius\n\n    do {\n        with(bbs) {\n            setPixel(centerX + x, centerY + y, circleColor)\n            setPixel(centerX + x, centerY - y, circleColor)\n            setPixel(centerX - x, centerY + y, circleColor)\n            setPixel(centerX - x, centerY - y, circleColor)\n            setPixel(centerX + y, centerY + x, circleColor)\n            setPixel(centerX + y, centerY - x, circleColor)\n            setPixel(centerX - y, centerY + x, circleColor)\n            setPixel(centerX - y, centerY - x, circleColor)\n        }\n        if (d < 0) {\n            d += 2 * x + 1\n        }\n        else {\n            d += 2 * (x - y) + 1\n            y--\n        }\n        x++\n    }\n    while (x <= y)\n}\n\nfun main(args: Array<String>) {\n    val bbs = BasicBitmapStorage(400, 400)\n    bbs.fill(Color.pink)\n    drawCircle(bbs, 200, 200, 100, Color.black)\n    drawCircle(bbs, 200, 200,  50, Color.white)\n    val label = JLabel(ImageIcon(bbs.image))\n    val title = \"Bresenham's circle algorithm\"\n    JOptionPane.showMessageDialog(null, label, title, JOptionPane.PLAIN_MESSAGE)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    // create BasicBitmapStorage object\n    val width = 640\n    val height = 640\n    val bbs = BasicBitmapStorage(width, height)\n    for (y in 0 until height) {\n        for (x in 0 until width) {\n            val c = Color(x % 256, y % 256, (x * y) % 256)\n            bbs.setPixel(x, y, c)\n        }\n    }\n\n    // now write the object in PPM format to ImageMagick's STDIN via a pipe\n    // so it can be converted to a .jpg file and written to disk\n    val pb = ProcessBuilder(\"convert\", \"-\", \"output_piped.jpg\")\n    pb.directory(null)\n    pb.redirectInput(ProcessBuilder.Redirect.PIPE)\n    val buffer = ByteArray(width * 3) // write one line at a time\n    val proc = pb.start()\n    val pStdIn = proc.outputStream\n    pStdIn.use {\n        val header = \"P6\\n$width $height\\n255\\n\".toByteArray()\n        with (it) {\n            write(header)\n            for (y in 0 until height) {\n                for (x in 0 until width) {\n                    val c = bbs.getPixel(x, y)\n                    buffer[x * 3] = c.red.toByte()\n                    buffer[x * 3 + 1] = c.green.toByte()\n                    buffer[x * 3 + 2] = c.blue.toByte()\n                }\n                write(buffer)\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport java.io.FileInputStream\nimport java.io.PushbackInputStream\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun toGrayScale() {\n        for (x in 0 until image.width) {\n            for (y in 0 until image.height) {\n                var rgb  = image.getRGB(x, y)\n                val red   = (rgb shr 16) and 0xFF\n                val green = (rgb shr  8) and 0xFF\n                val blue  =  rgb and 0xFF\n                val lumin = (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n                rgb = (lumin shl 16) or (lumin shl 8) or lumin\n                image.setRGB(x, y, rgb)\n            }\n        }\n    }\n}\n\nfun PushbackInputStream.skipComment() {\n    while (read().toChar() != '\\n') {}\n}\n\nfun PushbackInputStream.skipComment(buffer: ByteArray) {\n    var nl: Int\n    while (true) {\n        nl = buffer.indexOf(10) // look for newline at end of comment\n        if (nl != -1) break\n        read(buffer)  // read another buffer full if newline not yet found\n    }\n    val len = buffer.size\n    if (nl < len - 1) unread(buffer, nl + 1, len - nl - 1)\n}\n\nfun Byte.toUInt() = if (this < 0) 256 + this else this.toInt()\n\nfun main(args: Array<String>) {\n    // use file, output.ppm, created in the Bitmap/Write a PPM file task\n    val pbis = PushbackInputStream(FileInputStream(\"output.ppm\"), 80)\n    pbis.use {\n        with (it) {\n            val h1 = read().toChar()\n            val h2 = read().toChar()\n            val h3 = read().toChar()\n            if (h1 != 'P' || h2 != '6' || h3 != '\\n') {\n                println(\"Not a P6 PPM file\")\n                System.exit(1)\n            }\n            val sb = StringBuilder()\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == ' ') break  // read until space reached\n                sb.append(r.toChar())\n            }\n            val width = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val height = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val maxCol = sb.toString().toInt()\n            if (maxCol !in 0..255) {\n                println(\"Maximum color value is outside the range 0..255\")\n                System.exit(1)\n            }\n            var buffer = ByteArray(80)\n            // get rid of any more opening comments before reading data\n            while (true) {\n                read(buffer)\n                if (buffer[0].toChar() == '#') {\n                    skipComment(buffer)\n                }\n                else {\n                    unread(buffer)\n                    break\n                }\n            }\n            // read data\n            val bbs = BasicBitmapStorage(width, height)\n            buffer = ByteArray(width * 3)\n            var y = 0\n            while (y < height) {\n                read(buffer)\n                for (x in 0 until width) {\n                    val c = Color(\n                        buffer[x * 3].toUInt(),\n                        buffer[x * 3 + 1].toUInt(),\n                        buffer[x * 3 + 2].toUInt()\n                    )\n                    bbs.setPixel(x, y, c)\n                }\n                y++\n            }\n            // convert to grayscale and save to a file\n            bbs.toGrayScale()\n            val grayFile = File(\"output_gray.jpg\")\n            ImageIO.write(bbs.image, \"jpg\", grayFile)\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport java.io.PushbackInputStream\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n\n    fun toGrayScale() {\n        for (x in 0 until image.width) {\n            for (y in 0 until image.height) {\n                var rgb  = image.getRGB(x, y)\n                val red   = (rgb shr 16) and 0xFF\n                val green = (rgb shr  8) and 0xFF\n                val blue  =  rgb and 0xFF\n                val lumin = (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n                rgb = (lumin shl 16) or (lumin shl 8) or lumin\n                image.setRGB(x, y, rgb)\n            }\n        }\n    }\n}\n\nfun PushbackInputStream.skipComment() {\n    while (read().toChar() != '\\n') {}\n}\n\nfun PushbackInputStream.skipComment(buffer: ByteArray) {\n    var nl: Int\n    while (true) {\n        nl = buffer.indexOf(10) // look for newline at end of comment\n        if (nl != -1) break\n        read(buffer)  // read another buffer full if newline not yet found\n    }\n    val len = buffer.size\n    if (nl < len - 1) unread(buffer, nl + 1, len - nl - 1)\n}\n\nfun Byte.toUInt() = if (this < 0) 256 + this else this.toInt()\n\nfun main(args: Array<String>) {\n    // use file, output_piped.jpg, created in the\n    // Bitmap/PPM conversion through a pipe task\n    val pb = ProcessBuilder(\"convert\", \"output_piped.jpg\", \"ppm:-\")\n    pb.directory(null)\n    pb.redirectOutput(ProcessBuilder.Redirect.PIPE)\n    val proc = pb.start()\n    val pStdOut = proc.inputStream\n    val pbis = PushbackInputStream(pStdOut, 80)\n    pbis.use {\n        with (it) {\n            val h1 = read().toChar()\n            val h2 = read().toChar()\n            val h3 = read().toChar()\n            if (h1 != 'P' || h2 != '6' || h3 != '\\n') {\n                println(\"Not a P6 PPM file\")\n                System.exit(1)\n            }\n            val sb = StringBuilder()\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == ' ') break  // read until space reached\n                sb.append(r.toChar())\n            }\n            val width = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val height = sb.toString().toInt()\n            sb.setLength(0)\n            while (true) {\n                val r = read().toChar()\n                if (r == '#') { skipComment(); continue }\n                if (r == '\\n') break  // read until new line reached\n                sb.append(r.toChar())\n            }\n            val maxCol = sb.toString().toInt()\n            if (maxCol !in 0..255) {\n                println(\"Maximum color value is outside the range 0..255\")\n                System.exit(1)\n            }\n            var buffer = ByteArray(80)\n            // get rid of any more opening comments before reading data\n            while (true) {\n                read(buffer)\n                if (buffer[0].toChar() == '#') {\n                    skipComment(buffer)\n                }\n                else {\n                    unread(buffer)\n                    break\n                }\n            }\n            // read data\n            val bbs = BasicBitmapStorage(width, height)\n            buffer = ByteArray(width * 3)\n            var y = 0\n            while (y < height) {\n                read(buffer)\n                for (x in 0 until width) {\n                    val c = Color(\n                        buffer[x * 3].toUInt(),\n                        buffer[x * 3 + 1].toUInt(),\n                        buffer[x * 3 + 2].toUInt()\n                    )\n                    bbs.setPixel(x, y, c)\n                }\n                y++\n            }\n            // convert to grayscale and save to a file\n            bbs.toGrayScale()\n            val grayFile = File(\"output_piped_gray.jpg\")\n            ImageIO.write(bbs.image, \"jpg\", grayFile)\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.40\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport java.io.FileOutputStream\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    // create BasicBitmapStorage object\n    val width = 640\n    val height = 640\n    val bbs = BasicBitmapStorage(width, height)\n    for (y in 0 until height) {\n        for (x in 0 until width) {\n            val c = Color(x % 256, y % 256, (x * y) % 256)\n            bbs.setPixel(x, y, c)\n        }\n    }\n\n    // now write it to a PPM file\n    val fos = FileOutputStream(\"output.ppm\")\n    val buffer = ByteArray(width * 3)  // write one line at a time\n    fos.use {\n        val header = \"P6\\n$width $height\\n255\\n\".toByteArray()\n        with (it) {\n            write(header)\n            for (y in 0 until height) {\n                for (x in 0 until width) {\n                    val c = bbs.getPixel(x, y)\n                    buffer[x * 3] = c.red.toByte()\n                    buffer[x * 3 + 1] = c.green.toByte()\n                    buffer[x * 3 + 2] = c.blue.toByte()\n                }\n                write(buffer)\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.4-3\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    val width = 640\n    val height = 480\n    val bbs = BasicBitmapStorage(width, height)\n    with (bbs) {\n        fill(Color.cyan)\n        setPixel(width / 2, height / 2, Color.black)\n        val c1 = getPixel(width / 2, height / 2)\n        val c2 = getPixel(20, 20)\n        print(\"The color of the pixel at (${width / 2}, ${height / 2}) is \")\n        println(if (c1 == Color.black) \"black\" else \"unknown\")\n        print(\"The color of the pixel at (120, 120) is \")\n        println(if (c2 == Color.cyan) \"cyan\" else \"unknown\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.31\n\nimport java.io.File\n\nclass BitFilter(val f: File, var accu: Int = 0, var bits: Int = 0) {\n\n    private val bw = f.bufferedWriter()\n    private val br = f.bufferedReader()\n\n    fun write(buf: ByteArray, start: Int, _nBits: Int, _shift: Int) {\n        var nBits = _nBits\n        var index = start + _shift / 8\n        var shift = _shift % 8\n\n        while (nBits != 0 || bits >= 8) {\n            while (bits >= 8) {\n                bits -= 8\n                bw.write(accu ushr bits)\n                accu = accu and ((1 shl bits) - 1)\n            }\n            while (bits < 8 && nBits != 0) {\n                val b = buf[index].toInt()\n                accu = (accu shl 1) or (((128 ushr shift) and b) ushr (7 - shift))\n                nBits--\n                bits++\n                if (++shift == 8) { shift = 0; index++ }\n            }\n        }\n    }\n\n    fun read(buf: ByteArray, start: Int, _nBits: Int, _shift: Int) {\n        var nBits = _nBits\n        var index = start + _shift / 8\n        var shift = _shift % 8\n\n        while (nBits != 0) {\n            while (bits != 0 && nBits != 0) {\n                val mask = 128 ushr shift\n                if ((accu and (1 shl (bits - 1))) != 0)\n                    buf[index] = (buf[index].toInt() or mask).toByte()\n                else\n                    buf[index] = (buf[index].toInt() and mask.inv()).toByte()\n                nBits--\n                bits--\n                if (++shift >= 8) { shift = 0; index++ }\n            }\n            if (nBits == 0) break\n            accu = (accu shl 8) or br.read()\n            bits += 8\n        }\n    }\n\n    fun closeWriter() {\n        if (bits != 0) {\n            accu = (accu shl (8 - bits))\n            bw.write(accu)\n        }\n        bw.close()\n        accu = 0\n        bits = 0\n    }\n\n    fun closeReader() {\n        br.close()\n        accu = 0\n        bits = 0\n    }\n}\n\nfun main(args: Array<String>) {\n    val s = \"abcdefghijk\".toByteArray(Charsets.UTF_8)\n    val f = File(\"test.bin\")\n    val bf = BitFilter(f)\n\n    /* for each byte in s, write 7 bits skipping 1 */\n    for (i in 0 until s.size) bf.write(s, i, 7, 1)\n    bf.closeWriter()\n\n    /* read 7 bits and expand to each byte of s2 skipping 1 bit */\n    val s2 = ByteArray(s.size)\n    for (i in 0 until s2.size) bf.read(s2, i, 7, 1)\n    bf.closeReader()\n    println(String(s2, Charsets.UTF_8))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "/*  for symmetry with Kotlin's other binary bitwise operators\n    we wrap Java's 'rotate' methods as infix functions */\ninfix fun Int.rol(distance: Int): Int = Integer.rotateLeft(this, distance)\ninfix fun Int.ror(distance: Int): Int = Integer.rotateRight(this, distance)\n\nfun main(args: Array<String>) {\n    // inferred type of x and y is Int i.e. 32 bit signed integers\n    val x = 10\n    val y = 2\n    println(\"x       = $x\")\n    println(\"y       = $y\")\n    println(\"NOT x   = ${x.inv()}\")\n    println(\"x AND y = ${x and y}\")\n    println(\"x OR  y = ${x or y}\")\n    println(\"x XOR y = ${x xor y}\")\n    println(\"x SHL y = ${x shl y}\")\n    println(\"x ASR y = ${x shr y}\")   // arithmetic shift right (sign bit filled)\n    println(\"x LSR y = ${x ushr y}\")  // logical shift right    (zero filled)\n    println(\"x ROL y = ${x rol y}\")\n    println(\"x ROR y = ${x ror y}\")\n}\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100;\ntmp=ConstantArray[-1,n];\nDo[tmp[[i;;;;i]]*=-1;,{i,n}];\nDo[Print[\"door \",i,\" is \",If[tmp[[i]]==-1,\"closed\",\"open\"]],{i,1,Length[tmp]}]\n"
  },
  {
    "language": "Mathematica",
    "code": "f[n_] = \"Closed\";\nDo[Do[If[f[n] == \"Closed\", f[n] = \"Open\", f[n] = \"Closed\"], {n, k, 100, k}], {k, 1, 100}];\nTable[f[n], {n, 1, 100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Fold[\n ReplacePart[#1, (i_ /; Mod[i, #2] == 0) :> (-#1[[i]])] &,\n ConstantArray[-1, {100}],\n Range[100]\n] /. {1 -> \"Open\", -1 -> \"Closed\"}\n"
  },
  {
    "language": "Mathematica",
    "code": "Do[Print[\"door \",i,\" is \",If[IntegerQ[Sqrt[i]],\"open\",\"closed\"]],{i,100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100;\na=Range[1,Sqrt[n]]^2\nDo[Print[\"door \",i,\" is \",If[MemberQ[a,i],\"open\",\"closed\"]],{i,100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100\nnn=1\na=0\nFor[i=1,i<=n,i++,\n If[i==nn,\n  Print[\"door \",i,\" is open\"];\n  a++;\n  nn+=2a+1;\n ,\n  Print[\"door \",i,\" is closed\"];\n ];\n]\n"
  },
  {
    "language": "Mathematica",
    "code": "Pick[Range[100], Xor@@@Array[Divisible[#1,#2]&, {100,100}]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Range[Sqrt[100]]^2\n"
  },
  {
    "language": "Mathematica",
    "code": "treeR[n_] := Table[o[trees[a], trees[n - a]], {a, 1, n - 1}]\ntreeR[1] := n\ntree[n_] :=\n Flatten[treeR[n] //. {o[a_List, b_] :> (o[#, b] & /@ a),\n    o[a_, b_List] :> (o[a, #] & /@ b)}]\ngame24play[val_List] :=\n Union[StringReplace[StringTake[ToString[#, InputForm], {10, -2}],\n     \"-1*\" ~~ n_ :> \"-\" <> n] & /@ (HoldForm /@\n      Select[Union@\n        Flatten[Outer[# /. {o[q_Integer] :> #2[[q]],\n             n[q_] :> #3[[q]]} &,\n          Block[{O = 1, N = 1}, # /. {o :> o[O++], n :> n[N++]}] & /@\n           tree[4], Tuples[{Plus, Subtract, Times, Divide}, 3],\n          Permutations[Array[v, 4]], 1]],\n       Quiet[(# /. v[q_] :> val[[q]]) == 24] &] /.\n     Table[v[q] -> val[[q]], {q, 4}])]\n"
  },
  {
    "language": "Mathematica",
    "code": "game24play[RandomInteger[{1, 9}, 4]]\n"
  },
  {
    "language": "Mathematica",
    "code": "evaluate[HoldForm[op_[l_, r_]]] := op[evaluate[l], evaluate[r]];\nevaluate[x_] := x;\ncombine[l_, r_ /; evaluate[r] != 0] := {HoldForm[Plus[l, r]],\n   HoldForm[Subtract[l, r]], HoldForm[Times[l, r]],\n   HoldForm[Divide[l, r]] };\ncombine[l_, r_] := {HoldForm[Plus[l, r]], HoldForm[Subtract[l, r]],\n   HoldForm[Times[l, r]]};\nsplit[items_] :=\n  Table[{items[[1 ;; i]], items[[i + 1 ;; Length[items]]]}, {i, 1,\n    Length[items] - 1}];\nexpressions[{x_}] := {x};\nexpressions[items_] :=\n  Flatten[Table[\n    Flatten[Table[\n      combine[l, r], {l, expressions[sp[[1]]]}, {r,\n       expressions[sp[[2]]]}], 2], {sp, split[items]}]];\n\n(* Must use all atoms in given order. *)\nsolveMaintainOrder[goal_, items_] :=\n  Select[expressions[items], (evaluate[#] == goal) &];\n(* Must use all atoms, but can permute them. *)\nsolveCanPermute[goal_, items_] :=\n  Flatten[Table[\n    solveMaintainOrder[goal, pitems], {pitems,\n     Permutations[items]}]];\n(* Can use any subset of atoms. *)\nsolveSubsets[goal_, items_] :=\n  Flatten[Table[\n    solveCanPermute[goal, is], {is,\n     Subsets[items, {1, Length[items]}]}], 2];\n\n(* Demonstration to find all the ways to create 1/5 from {2, 3, 4, 5}. *)\nsolveMaintainOrder[1/5, Range[2, 5]]\nsolveCanPermute[1/5, Range[2, 5]]\nsolveSubsets[1/5, Range[2, 5]]\n"
  },
  {
    "language": "Mathematica",
    "code": "isLegal[n_List, x_String] :=\n Quiet[Check[\n   With[{h = ToExpression[x, StandardForm, HoldForm]},\n    If[Cases[Level[h, {2, \\[Infinity]}, Hold, Heads -> True],\n        Except[_Integer | Plus | _Plus | Times | _Times | Power |\n          Power[_, -1]]] === {} &&\n      Sort[Level[h /. Power[q_, -1] -> q, {-1}] /.\n         q_Integer -> Abs[q]] === Sort[n], ReleaseHold[h]]], Null]]\nGrid[{{Button[\n    \"new numbers\", {a, b, c, d} = Table[RandomInteger[{1, 9}], {4}]],\n   InputField[Dynamic[x], String]}, {Dynamic[{a, b, c, d}],\n   Dynamic[Switch[isLegal[{a, b, c, d}, x], Null,\n     \"Sorry, that is invalid.\", 24, \"Congrats! That's 24!\", _,\n     \"Sorry, that makes \" <> ToString[ToExpression@x, InputForm] <>\n      \", not 24.\"]]}}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Table[Last /@ Reverse@Tally[First /@ IntegerPartitions[n]], {n, 10}] // Grid\n"
  },
  {
    "language": "Mathematica",
    "code": "PartitionsP /@ {23, 123, 1234, 12345}\n"
  },
  {
    "language": "Mathematica",
    "code": "DiscretePlot[PartitionsP[n], {n, 1, 999}, PlotRange -> All]\n"
  },
  {
    "language": "Mathematica",
    "code": "Bottle[n_] := ToString[n] <> If[n==1,\" bottle\",\" bottles\"] <> \" of beer\"\n\nBottleSong[n_] := Speak[\n  Bottle[n] <> \" on the wall,\" <>\n  Bottle[n] <>\n  \", take one down, pass it around,\" <>\n  Bottle[n-1] <> \" on the wall.\"\n]\n\nBottleSong /@ Range[99,1,-1]\n"
  },
  {
    "language": "Mathematica",
    "code": "Input[] + Input[]\n"
  },
  {
    "language": "Mathematica",
    "code": "blocks=Partition[Characters[ToLowerCase[\"BOXKDQCPNAGTRETGQDFSJWHUVIANOBERFSLYPCZM\"]],2];\nClearAll[DoStep,ABCBlockQ]\nDoStep[chars_List,blcks_List,chosen_List]:=Module[{opts},\n If[chars=!={},\n  opts=Select[blcks,MemberQ[#,First[chars]]&];\n  {Rest[chars],DeleteCases[blcks,#,1,1],Append[chosen,#]}&/@opts\n ,\n  {{chars,blcks,chosen}}\n ]\n]\nDoStep[opts_List]:=Flatten[DoStep@@@opts,1]\nABCBlockQ[str_String]:=(FixedPoint[DoStep,{{Characters[ToLowerCase[str]],blocks,{}}}]=!={})\n"
  },
  {
    "language": "Mathematica",
    "code": "(* Define an interface, Foo, which requires that the functions Foo, Bar, and Baz be defined *)\nInterfaceFooQ[obj_] := ValueQ[Foo[obj]] && ValueQ[Bar[obj]] && ValueQ[Baz[obj]];\nPrintFoo[obj_] := Print[\"Object \", obj, \" does not implement interface Foo.\"];\nPrintFoo[obj_?InterfaceFooQ] := Print[\n   \"Foo: \", Foo[obj], \"\\n\",\n   \"Bar: \", Bar[obj], \"\\n\",\n   \"Baz: \", Baz[obj], \"\\n\"];\n\n(* Extend all integers with Interface Foo *)\nFoo[x_Integer] := Mod[x, 2];\nBar[x_Integer] := Mod[x, 3];\nBaz[x_Integer] := Mod[x, 5];\n\n(* Extend a particular string with Interface Foo *)\nFoo[\"Qux\"] = \"foo\";\nBar[\"Qux\"] = \"bar\";\nBaz[\"Qux\"] = \"baz\";\n\n(* Print a non-interface object *)\nPrintFoo[{\"Some\", \"List\"}];\n(* And for an integer *)\nPrintFoo[8];\n(* And for the specific string *)\nPrintFoo[\"Qux\"];\n(* And finally a non-specific string *)\nPrintFoo[\"foobarbaz\"]\n"
  },
  {
    "language": "Mathematica",
    "code": "classify[n_Integer] := Sign[Total[Most@Divisors@n] - n]\n\nStringJoin[\n Flatten[Tally[\n     Table[classify[n], {n, 20000}]] /. {-1 -> \"deficient: \",\n     0 -> \"  perfect: \", 1 -> \"  abundant: \"}] /.\n  n_Integer :> ToString[n]]\n"
  },
  {
    "language": "Mathematica",
    "code": "accFactory[initial_] :=\n  Module[{total = initial},\n    Function[x, total += x]\n  ]\nx=accFactory[1];\nx[5.0];\naccFactory[3];\nx[2.3]\n"
  },
  {
    "language": "Mathematica",
    "code": "$RecursionLimit=Infinity\nAckermann1[m_,n_]:=\n If[m==0,n+1,\n  If[ n==0,Ackermann1[m-1,1],\n   Ackermann1[m-1,Ackermann1[m,n-1]]\n  ]\n ]\n\n Ackermann2[0,n_]:=n+1;\n Ackermann2[m_,0]:=Ackermann1[m-1,1];\n Ackermann2[m_,n_]:=Ackermann1[m-1,Ackermann1[m,n-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Flatten[#,1]&@Table[{\"Ackermann2[\"<>ToString[i]<>\",\"<>ToString[j]<>\"] =\",Ackermann2[i,j]},{i,3},{j,8}]//Grid\n"
  },
  {
    "language": "Mathematica",
    "code": "Ackermann2[1,1] =\t3\nAckermann2[1,2] =\t4\nAckermann2[1,3] =\t5\nAckermann2[1,4] =\t6\nAckermann2[1,5] =\t7\nAckermann2[1,6] =\t8\nAckermann2[1,7] =\t9\nAckermann2[1,8] =\t10\nAckermann2[2,1] =\t5\nAckermann2[2,2] =\t7\nAckermann2[2,3] =\t9\nAckermann2[2,4] =\t11\nAckermann2[2,5] =\t13\nAckermann2[2,6] =\t15\nAckermann2[2,7] =\t17\nAckermann2[2,8] =\t19\nAckermann2[3,1] =\t13\nAckermann2[3,2] =\t29\nAckermann2[3,3] =\t61\nAckermann2[3,4] =\t125\nAckermann2[3,5] =\t253\nAckermann2[3,6] =\t509\nAckermann2[3,7] =\t1021\nAckermann2[3,8] =\t2045\n"
  },
  {
    "language": "Mathematica",
    "code": "Clear[Ackermann3]\n$RecursionLimit=Infinity;\nAckermann3[0,n_]:=n+1;\nAckermann3[1,n_]:=n+2;\nAckermann3[2,n_]:=3+2n;\nAckermann3[3,n_]:=5+8 (2^n-1);\nAckermann3[m_,0]:=Ackermann3[m-1,1];\nAckermann3[m_,n_]:=Ackermann3[m-1,Ackermann3[m,n-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Ackermann3[4, 1]\nAckermann3[4, 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "65533\n2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880........699146577530041384717124577965048175856395072895337539755822087777506072339445587895905719156733\n"
  },
  {
    "language": "Mathematica",
    "code": "Block[{start = SessionTime[], K, t0 = 0, t1, kt0, S = 0},\n K[t_] = Sin[2 Pi f t] /. f -> 0.5; kt0 = K[t0];\n While[True, t1 = SessionTime[] - start;\n  S += (kt0 + (kt0 = K[t1])) (t1 - t0)/2; t0 = t1;\n  If[t1 > 2, K[t_] = 0; If[t1 > 2.5, Break[]]]]; S]\n"
  },
  {
    "language": "Mathematica",
    "code": "f[a]=1;\nf[b]=2;\nf[a]=3;\n? f\n"
  },
  {
    "language": "Mathematica",
    "code": "Print[\"powers of (x-1)\"]\n(x - 1)^( Range[0, 7]) // Expand // TableForm\nPrint[\"primes under 50\"]\npoly[p_] := (x - 1)^p - (x^p - 1) // Expand;\ncoefflist[p_Integer] := Coefficient[poly[p], x, #] & /@ Range[0, p - 1];\nAKSPrimeQ[p_Integer] := (Mod[coefflist[p] , p] // Union) == {0};\nSelect[Range[1, 50], AKSPrimeQ]\n"
  },
  {
    "language": "Mathematica",
    "code": "TableForm[StringSplit[StringSplit[a,\"\\n\"],\"$\"],TableAlignments -> Center]\n"
  },
  {
    "language": "Mathematica",
    "code": "seq[n_] :=\n  NestList[If[# == 0, 0,\n     DivisorSum[#, # &, Function[div, div != #]]] &, n, 16];\nclass[seq_] :=\n  Which[Length[seq] < 2, \"Non-terminating\", MemberQ[seq, 0],\n   \"Terminating\", seq[[1]] == seq[[2]], \"Perfect\",\n   Length[seq] > 2 && seq[[1]] == seq[[3]], \"Amicable\",\n   Length[seq] > 3 && MemberQ[seq[[4 ;;]], seq[[1]]], \"Sociable\",\n   MatchQ[class[Rest[seq]], \"Perfect\" | \"Aspiring\"], \"Aspiring\",\n   MatchQ[class[Rest[seq]], \"Amicable\" | \"Sociable\" | \"Cyclic\"],\n   \"Cyclic\", True, \"Non-terminating\"];\nnotate[seq_] :=\n  Which[seq == {}, {},\n   MemberQ[Rest[seq],\n    seq[[1]]], {Prepend[TakeWhile[Rest[seq], # != seq[[1]] &],\n     seq[[1]]]}, True, Prepend[notate[Rest[seq]], seq[[1]]]];\nPrint[{#, class[seq[#]], notate[seq[#]] /. {0} -> 0}] & /@ {1, 2, 3, 4, 5, 6, 7,\n   8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909,\n   562, 1064, 1488, 15355717786080};\n"
  },
  {
    "language": "Mathematica",
    "code": "kprimes[k_,n_] :=\n  (* generates a list of the n smallest k-almost-primes *)\n  Module[{firstnprimes, runningkprimes = {}},\n  firstnprimes = Prime[Range[n]];\n  runningkprimes = firstnprimes;\n  Do[\n   runningkprimes =\n     Outer[Times, firstnprimes , runningkprimes ] // Flatten // Union  // Take[#, n] & ;\n   (* only keep lowest n numbers in our running list *)\n   , {i, 1, k - 1}];\n  runningkprimes\n  ]\n(* now to create table with n=10 and k ranging from 1 to 5 *)\nTable[Flatten[{\"k = \" <> ToString[i] <> \": \", kprimes[i, 10]}], {i,1,5}] // TableForm\n"
  },
  {
    "language": "Mathematica",
    "code": " CheckValid[i_List]:=If[Length[i]<=1,True,And@@(StringTake[#[[1]],-1]==StringTake[#[[2]],1]&/@Partition[i,2,1])]\n sets={{\"the\",\"that\",\"a\"},{\"frog\",\"elephant\",\"thing\"},{\"walked\",\"treaded\",\"grows\"},{\"slowly\",\"quickly\"}};\n Select[Tuples[sets],CheckValid]\n"
  },
  {
    "language": "Mathematica",
    "code": "{{\"that\", \"thing\", \"grows\", \"slowly\"}}\n"
  },
  {
    "language": "Mathematica",
    "code": "CheckValid2[i_List] := StringFreeQ[StringJoin[Riffle[i, \",\"]], a_ ~~ \",\" ~~ b_ /; a =!= b]\n"
  },
  {
    "language": "Mathematica",
    "code": "amicableQ[n_] :=\n Module[{sum = Total[Most@Divisors@n]},\n  sum != n && n == Total[Most@Divisors@sum]]\n\nGrid@Partition[Cases[Range[4, 20000], _?(amicableQ@# &)], 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "list=Import[\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\ntext={#,StringJoin@@Sort[Characters[#]]}&/@list;\ntext=SortBy[text,#[[2]]&];\nsplits=Split[text,#1[[2]]==#2[[2]]&][[All,All,1]];\nmaxlen=Max[Length/@splits];\nSelect[splits,Length[#]==maxlen&]\n"
  },
  {
    "language": "Mathematica",
    "code": "{{abel,able,bale,bela,elba},{caret,carte,cater,crate,trace},{angel,angle,galen,glean,lange},{alger,glare,lager,large,regal},{elan,lane,lean,lena,neal},{evil,levi,live,veil,vile}}\n"
  },
  {
    "language": "Mathematica",
    "code": "splits = Gather[list, Sort[Characters[#]] == Sort[Characters[#2]] &];\nmaxlen = Max[Length /@ splits];\nSelect[splits, Length[#] == maxlen &]\n"
  },
  {
    "language": "Mathematica",
    "code": "anagramGroups = GatherBy[SortBy[GatherBy[list,Sort[Characters[#]] &],Length],Length];\nanagramGroups[[-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "list=Import[\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\nMaximalBy[GatherBy[list, Sort@*Characters], Length]\n"
  },
  {
    "language": "Mathematica",
    "code": "words=First/@Import[\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\",\"Table\"];\nanagramDegrangement=Function[{w1,w2},\n\tModule[{c1=ToCharacterCode@w1,c2=ToCharacterCode@w2},\n\tSort@c1==Sort@c2&&Select[c1-c2,#==0&,1]==={}]];\ngs=Select[GatherBy[words,{StringLength@#,Union@ToCharacterCode@#}&],Length@#>=2&];\nFirst@Flatten[Function[ws,Select[Join@@Outer[List,ws,ws,1],anagramDegrangement@@#&]]/@SortBy[gs,-StringLength@First@#&],1]\n"
  },
  {
    "language": "Mathematica",
    "code": "list = Import[\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\nMaximalBy[\n Select[GatherBy[list, Sort@*Characters],\n  Length@# > 1 && And @@ MapThread[UnsameQ, Characters /@ #] &],\n StringLength@*First]\n"
  },
  {
    "language": "Mathematica",
    "code": "freq = 8; length = freq^(-1/2);\nAnimate[Graphics[\n  List[{Line[{{0, 0}, length {Sin[T], -Cos[T]}} /. {T -> (Pi/6) Cos[2 Pi freq t]}], PointSize[Large],\n               Point[{length {Sin[T], -Cos[T]}} /. {T -> (Pi/6) Cos[2 Pi freq t]}]}],\n  PlotRange -> {{-0.3, 0.3}, {-0.5, 0}}], {t, 0, 1}, AnimationRate -> 0.07]\n"
  },
  {
    "language": "Mathematica",
    "code": "mystring = \"Hello World! \";\nScroll[str_, dir_] := StringJoin @@ RotateLeft[str // Characters, dir];\nGiveString[dir_] := (mystring = Scroll[mystring, dir]);\nCreateDialog[{\n   DynamicModule[{direction = -1},\n    EventHandler[\n     Dynamic[TextCell[\n       Refresh[GiveString[direction], UpdateInterval -> 1/8]],\n      TrackedSymbols -> {}], {\"MouseClicked\" :> (direction *= -1)}]]\n   }];\n"
  },
  {
    "language": "Mathematica",
    "code": "check := #<0&\nfib := If[check[#],Throw[\"Negative Argument\"],If[#<=1,1,#0[#-2]+#0[#-1]]&[#]]&\nfib /@ Range[0,10]\n\n{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89}\n"
  },
  {
    "language": "Mathematica",
    "code": "check := (Print[#];#<0)&\nfib /@ Range[0,4]\n0\n1\n2\n3\n4\n\n{1, 1, 2, 3, 5}\n"
  },
  {
    "language": "Mathematica",
    "code": "data = <|\"account\" -> \"xyz\", \"password\" -> \"x\", \"UID\" -> 1003,\n   \"GID\" -> 1000, \"fullname\" -> \"X Yz\", \"office\" -> \"Room 1003\",\n   \"extension\" -> \"(234)555-8913\", \"homephone\" -> \"(234)555-0033\",\n   \"email\" -> \"xyz@rosettacode.org\", \"directory\" -> \"/home/xyz\",\n   \"shell\" -> \"/bin/bash\"|>;\nasString[data_] :=\n  StringRiffle[\n   ToString /@\n    Insert[data /@ {\"account\", \"password\", \"UID\", \"GID\", \"directory\",\n       \"shell\"},\n     StringRiffle[\n      data /@ {\"fullname\", \"office\", \"extension\", \"homephone\",\n        \"email\"}, \",\"], 5], \":\"];\nfname = FileNameJoin[{$TemporaryDirectory, \"testfile\"}];\nstr = OpenWrite[fname]; (* Use OpenAppend if file exists *)\nClose[str];\nPrint[\"Appended record: \" <> asString[data]];\n"
  },
  {
    "language": "Mathematica",
    "code": "(#*#)& /@ {1, 2, 3, 4}\n\nMap[Function[#*#], {1, 2, 3, 4}]\n\nMap[((#*#)&,{1,2,3,4}]\n\nMap[Function[w,w*w],{1,2,3,4}]\n"
  },
  {
    "language": "Mathematica",
    "code": "s:=ToString[5^4^3^2];\nPrint[StringTake[s,20]<>\"...\"<>StringTake[s,-20]<>\" (\"<>ToString@StringLength@s<>\" digits)\"];\n"
  },
  {
    "language": "Mathematica",
    "code": "f[x_] := x^2\n"
  },
  {
    "language": "Mathematica",
    "code": "x=1+2I\ny=3+4I\n\nx+y  =>  4 + 6 I\nx-y  =>  -2 - 2 I\ny x  =>  -5 + 10 I\ny/x  => 11/5 - (2 I)/5\nx^3  =>  -11 - 2 I\ny^4  =>  -527 - 336 I\nx^y  =>  (1 + 2 I)^(3 + 4 I)\nN[x^y]  =>  0.12901 + 0.0339241 I\n"
  },
  {
    "language": "Mathematica",
    "code": "Exp  Log\nSin  Cos  Tan  Csc  Sec  Cot\nArcSin  ArcCos  ArcTan  ArcCsc  ArcSec  ArcCot\nSinh  Cosh  Tanh  Csch  Sech  Coth\nArcSinh  ArcCosh  ArcTanh  ArcCsch  ArcSech  ArcCoth\nSinc\nHaversine  InverseHaversine\nFactorial  Gamma  PolyGamma  LogGamma\nErf  BarnesG  Hyperfactorial  Zeta  ProductLog  RamanujanTauL\n"
  },
  {
    "language": "Mathematica",
    "code": "(*parsing:*)\nparse[string_] :=\n Module[{e},\n  StringCases[string,\n     \"+\" | \"-\" | \"*\" | \"/\" | \"(\" | \")\" |\n      DigitCharacter ..] //. {a_String?DigitQ :>\n      e[ToExpression@a], {x___, PatternSequence[\"(\", a_e, \")\"],\n       y___} :> {x, a,\n       y}, {x :\n        PatternSequence[] |\n         PatternSequence[___, \"(\" | \"+\" | \"-\" | \"*\" | \"/\"],\n       PatternSequence[op : \"+\" | \"-\", a_e], y___} :> {x, e[op, a],\n       y}, {x :\n        PatternSequence[] | PatternSequence[___, \"(\" | \"+\" | \"-\"],\n       PatternSequence[a_e, op : \"*\" | \"/\", b_e], y___} :> {x,\n       e[op, a, b],\n       y}, {x :\n        PatternSequence[] | PatternSequence[___, \"(\" | \"+\" | \"-\"],\n       PatternSequence[a_e, b_e], y___} :> {x, e[\"*\", a, b],\n       y}, {x : PatternSequence[] | PatternSequence[___, \"(\"],\n       PatternSequence[a_e, op : \"+\" | \"-\", b_e],\n       y : PatternSequence[] |\n         PatternSequence[\")\" | \"+\" | \"-\", ___]} :> {x, e[op, a, b],\n       y}} //. {e -> List, {a_Integer} :> a, {a_List} :> a}]\n\n(*evaluation*)\nevaluate[a_Integer] := a;\nevaluate[{\"+\", a_}] := evaluate[a];\nevaluate[{\"-\", a_}] := -evaluate[a];\nevaluate[{\"+\", a_, b_}] := evaluate[a] + evaluate[b];\nevaluate[{\"-\", a_, b_}] := evaluate[a] - evaluate[b];\nevaluate[{\"*\", a_, b_}] := evaluate[a]*evaluate[b];\nevaluate[{\"/\", a_, b_}] := evaluate[a]/evaluate[b];\nevaluate[string_String] := evaluate[parse[string]]\n"
  },
  {
    "language": "Mathematica",
    "code": "parse[\"-1+2(3+4*-5/6)\"]\nevaluate[\"-1+2(3+4*-5/6)\"]\n"
  },
  {
    "language": "Mathematica",
    "code": "pi[n_, prec_] :=\n Module[{a = 1, g = N[1/Sqrt[2], prec], k, s = 0, p = 4},\n  For[k = 1, k < n, k++,\n   {a, g} = {N[(a + g)/2, prec], N[Sqrt[a g], prec]};\n   s += p (a^2 - g^2); p += p]; N[4 a^2/(1 - s), prec]]\n\n\npi[7, 100] - N[Pi, 100]\n1.2026886537*10^-86\n\npi[7, 100]\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628046852228654\n"
  },
  {
    "language": "Mathematica",
    "code": "PrecisionDigits = 85;\nAGMean[a_, b_] := FixedPoint[{ Tr@#/2, Sqrt[Times@@#] }&, N[{a,b}, PrecisionDigits]]\u301a1\u301b\n"
  },
  {
    "language": "Mathematica",
    "code": "a = Input[\"Give me an integer please!\"];\nb = Input[\"Give me another integer please!\"];\nPrint[\"You gave me \", a, \" and \", b];\nPrint[\"sum: \", a + b];\nPrint[\"difference: \", a - b];\nPrint[\"product: \", a b];\nPrint[\"integer quotient: \", IntegerPart[a/b]];\nPrint[\"remainder: \", Mod[a, b]];\nPrint[\"exponentiation: \", a^b];\n"
  },
  {
    "language": "Mathematica",
    "code": "4/16\n3/8\n8/4\n4Pi/2\n16!/10!\nSqrt[9/16]\nSqrt[3/4]\n(23/12)^5\n2 + 1/(1 + 1/(3 + 1/4))\n\n1/2+1/3+1/5\n8/Pi+Pi/8 //Together\n13/17 + 7/31\nSum[1/n,{n,1,100}]      (*summation of 1/1 + 1/2 + 1/3 + 1/4+ .........+ 1/99 + 1/100*)\n\n1/2-1/3\na=1/3;a+=1/7\n\n1/4==2/8\n1/4>3/8\nPi/E >23/20\n1/3!=123/370\nSin[3]/Sin[2]>3/20\n\nNumerator[6/9]\nDenominator[6/9]\n"
  },
  {
    "language": "Mathematica",
    "code": "c/(2 c)\n(b^2 - c^2)/(b - c)  // Cancel\n1/2 + b/c // Together\n"
  },
  {
    "language": "Mathematica",
    "code": "1/2\nb+c\n(2 b+c) / (2 c)\n"
  },
  {
    "language": "Mathematica",
    "code": "1+2*{1,2,3}^3\n"
  },
  {
    "language": "Mathematica",
    "code": "{3, 17, 55}\n"
  },
  {
    "language": "Mathematica",
    "code": "found={};\nCheckPerfect[num_Integer]:=If[Total[1/Divisors[num]]==2,AppendTo[found,num]];\nDo[CheckPerfect[i],{i,1,2^25}];\nfound\n"
  },
  {
    "language": "Mathematica",
    "code": "{6, 28, 496, 8128, 33550336}\n"
  },
  {
    "language": "Mathematica",
    "code": "Join[{1,2,3}, {4,5,6}]\n\n-> {1, 2, 3, 4, 5, 6}\n"
  },
  {
    "language": "Mathematica",
    "code": "a = Array[Sin, 10]\na[[1]]\nDelete[a, 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "Assert[var===42]\n"
  },
  {
    "language": "Mathematica",
    "code": "a[2] = \"string\"; a[\"sometext\"] = 23;\n"
  },
  {
    "language": "Mathematica",
    "code": "keys=DownValues[#,Sort->False][[All,1,1,1]]&;\nhashes=#/@keys[#]&;\n\na[2]=\"string\";a[\"sometext\"]=23;\nkeys[a]\n->{2,sometext}\nhashes[a]\n->{string,23}\n"
  },
  {
    "language": "Mathematica",
    "code": "transfer[bucks_, src_, dest_, n_] :=\n  ReplacePart[\n   bucks, {src -> Max[bucks[[src]] - n, 0],\n    dest -> bucks[[dest]] + Min[bucks[[src]], n]}];\nDistributeDefinitions[transfer];\nSetSharedVariable[bucks, comp];\nbucks = RandomInteger[10, 20];\ncomp = True;\nPrint[\"Original sum: \" <> IntegerString[Plus @@ bucks]];\nPrint[Dynamic[\"Current sum: \" <> IntegerString[Plus @@ bucks]]];\nWaitAll[{ParallelSubmit[\n    While[True, While[! comp, Null]; comp = False;\n     Module[{a = RandomInteger[{1, 20}], b = RandomInteger[{1, 20}]},\n      bucks = transfer[bucks, Max[a, b], Min[a, b],\n        Floor[Abs[bucks[[a]] - bucks[[b]]]/2]]]; comp = True]],\n   ParallelSubmit[\n    While[True, While[! comp, Null]; comp = False;\n     Module[{src = RandomInteger[{1, 20}],\n       dest = RandomInteger[{1, 20}]},\n      bucks = transfer[bucks, src, dest,\n        RandomInteger[{1, bucks[[src]]}]]]; comp = True]]}];\n"
  },
  {
    "language": "Mathematica",
    "code": "Grid@Prepend[\n  Table[{n, #[[1]], #[[2]],\n      Row[{Round[10000 Abs[#[[1]] - #[[2]]]/#[[2]]]/100., \"%\"}]} &@\n    N[{Mean[Array[\n        Length@NestWhileList[#, 1, UnsameQ[##] &, All] - 1 &[# /.\n            MapIndexed[#2[[1]] -> #1 &,\n             RandomInteger[{1, n}, n]] &] &, 10000]],\n      Sum[n! n^(n - k - 1)/(n - k)!, {k, n}]/n^(n - 1)}, 5], {n, 1,\n    20}], {\"N\", \"average\", \"analytical\", \"error\"}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Unprotect[Mean];\nMean[{}] := 0\n"
  },
  {
    "language": "Mathematica",
    "code": "Mean[{3,4,5}]\nMean[{3.2,4.5,5.9}]\nMean[{-4, 1.233}]\nMean[{}]\nMean[{1/2,1/3,1/4,1/5}]\nMean[{a,c,Pi,-3,a}]\n"
  },
  {
    "language": "MATLAB",
    "code": "a = false(1,100);\nfor b=1:100\n  for i = b:b:100\n    a(i) = ~a(i);\n  end\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "for x=1:100;\n  if sqrt(x) == floor(sqrt(x))\n    a(i)=1;\n  end\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "a = zeros(100,1);\nfor counter = 1:sqrt(100);\n  a(counter^2) = 1;\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "function [doors,opened,closed] = hundredDoors()\n\n    %Initialize the doors, make them booleans for easy vectorization\n    doors = logical( (1:1:100) );\n\n    %Go through the flipping process, ignore the 1 case because the doors\n    %array is already initialized to all open\n    for initialPosition = (2:100)\n        doors(initialPosition:initialPosition:100) = not( doors(initialPosition:initialPosition:100) );\n    end\n\n    opened = find(doors); %Stores the numbers of the open doors\n    closed = find( not(doors) ); %Stores the numbers of the closed doors\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "doors((1:10).^2) = 1;\n\ndoors\n"
  },
  {
    "language": "MATLAB",
    "code": "  function twentyfour()\n  N = 4;\n  n = ceil(rand(1,N)*9);\n  printf('Generate a equation with the numbers %i, %i, %i, %i and +, -, *, /, () operators ! \\n',n);\n  s = input(': ','s');\n  t = s;\n  for k = 1:N,\n    [x,t] = strtok(t,'+-*/() \\t');\n     if length(x)~=1,\n       error('invalid sign %s\\n',x);\n     end;\n     y = x-'0';\n     if ~(0 < y & y < 10)\n       error('invalid sign %s\\n',x);\n     end;\n     z(1,k) = y;  \t\n  end;\n  if any(sort(z)-sort(n))\n    error('numbers do not match.\\n');\t\n  end;\n\n  val =  eval(s);\n  if val==24,\n    fprintf('expression \"%s\" results in %i.\\n',s,val);\t\n  else\n    fprintf('expression \"%s\" does not result in 24 but %i.\\n',s,val);\n  end; \t\n"
  },
  {
    "language": "MATLAB",
    "code": "function ninetyNineBottlesOfBeer()\n\n    disp( [ sprintf(['%d bottles of beer on the wall, %d bottles of beer.\\n'...\n        'Take one down, pass it around...\\n'],[(99:-1:2);(99:-1:2)])...\n        sprintf(['1 bottle of beer on the wall, 1 bottle of beer.\\nTake'...\n        'one down, pass it around;\\nNo more bottles of beer on the wall.']) ] );\n\n    %The end of this song makes me sad. The shelf should always have more\n    %beer...like college.\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function sumOfInputs = APlusB()\n    inputStream = input('Enter two numbers, separated by a space: ', 's');\n    numbers = str2num(inputStream);                         %#ok<ST2NM>\n    if any(numbers < -1000 | numbers > 1000)\n        warning('APlusB:OutOfRange', 'Some numbers are outside the range');\n    end\n    sumOfInputs = sum(numbers);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function testABC\n    combos = ['BO' ; 'XK' ; 'DQ' ; 'CP' ; 'NA' ; 'GT' ; 'RE' ; 'TG' ; 'QD' ; ...\n        'FS' ; 'JW' ; 'HU' ; 'VI' ; 'AN' ; 'OB' ; 'ER' ; 'FS' ; 'LY' ; ...\n        'PC' ; 'ZM'];\n    words = {'A' 'BARK' 'BOOK' 'TREAT' 'COMMON' 'SQUAD' 'CONFUSE'};\n    for k = 1:length(words)\n        possible = canMakeWord(words{k}, combos);\n        fprintf('Can%s make word %s.\\n', char(~possible.*'NOT'), words{k})\n    end\nend\n\nfunction isPossible = canMakeWord(word, combos)\n    word = lower(word);\n    combos = lower(combos);\n    isPossible = true;\n    k = 1;\n    while isPossible && k <= length(word)\n        [r, c] = find(combos == word(k), 1);\n        if ~isempty(r)\n            combos(r, :) = '';\n        else\n            isPossible = false;\n        end\n        k = k+1;\n    end\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "classdef (Abstract) AbsClass\n   ...\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "methods (Abstract)\n   abstMethod(obj)\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "properties (Abstract)\n   AbsProp\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function A = ackermannFunction(m,n)\n    if m == 0\n        A = n+1;\n    elseif (m > 0) && (n == 0)\n        A = ackermannFunction(m-1,1);\n    else\n        A = ackermannFunction( m-1,ackermannFunction(m,n-1) );\n    end\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function amicable\n    tic\n    N=2:1:20000; aN=[];\n    N(isprime(N))=[]; %erase prime numbers\n    I=1;\n    a=N(1); b=sum(pd(a));\n    while length(N)>1\n        if a==b %erase perfect numbers;\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        elseif b<a %the first member of an amicable pair is abundant not defective\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        elseif ~ismember(b,N) %the other member was previously erased\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        else\n            c=sum(pd(b));\n            if a==c\n                aN(I,:)=[I a b]; I=I+1;\n                N(N==b)=[];\n            else\n                if ~ismember(c,N) %the other member was previously erased\n                    N(N==b)=[];\n                end\n            end\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n            clear c\n        end\n    end\n    disp(array2table(aN,'Variablenames',{'N','Amicable1','Amicable2'}))\n    toc\nend\n\nfunction D=pd(x)\n    K=1:ceil(x/2);\n    D=K(~(rem(x, K)));\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "%This is a numerical simulation of a pendulum with a massless pivot arm.\n\n%% User Defined Parameters\n%Define external parameters\ng = -9.8;\ndeltaTime = 1/50; %Decreasing this will increase simulation accuracy\nendTime = 16;\n\n%Define pendulum\nrodPivotPoint = [2 2]; %rectangular coordinates\nrodLength = 1;\nmass = 1; %of the bob\nradius = .2; %of the bob\ntheta = 45; %degrees, defines initial position of the bob\nvelocity = [0 0]; %cylindrical coordinates; first entry is radial velocity,\n                  %second entry is angular velocity\n\n%% Simulation\nassert(radius < rodLength,'Pendulum bob radius must be less than the length of the rod.');\n\nposition = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]); %in rectangular coordinates\n\n%Generate graphics, render pendulum\nfigure;\naxesHandle = gca;\nxlim(axesHandle, [(rodPivotPoint(1) - rodLength - radius) (rodPivotPoint(1) + rodLength + radius)] );\nylim(axesHandle, [(rodPivotPoint(2) - rodLength - radius) (rodPivotPoint(2) + rodLength + radius)] );\n\nrectHandle = rectangle('Position',[(position - radius/2) radius radius],...\n    'Curvature',[1,1],'FaceColor','g'); %Pendulum bob\nhold on\nplot(rodPivotPoint(1),rodPivotPoint(2),'^'); %pendulum pivot\nlineHandle = line([rodPivotPoint(1) position(1)],...\n    [rodPivotPoint(2) position(2)]); %pendulum rod\nhold off\n\n%Run simulation, all calculations are performed in cylindrical coordinates\nfor time = (deltaTime:deltaTime:endTime)\n\n    drawnow; %Forces MATLAB to render the pendulum\n\n    %Find total force\n    gravitationalForceCylindrical = [mass*g*cosd(theta) mass*g*sind(theta)];\n\n    %This code is just incase you want to add more forces,e.g friction\n    totalForce = gravitationalForceCylindrical;\n\n    %If the rod isn't massless or is a spring, etc., modify this line\n    %accordingly\n    rodForce = [-totalForce(1) 0]; %cylindrical coordinates\n\n    totalForce = totalForce + rodForce;\n\n    acceleration = totalForce / mass; %F = ma\n    velocity = velocity + acceleration * deltaTime;\n    rodLength = rodLength + velocity(1) * deltaTime;\n    theta = theta + velocity(2) * deltaTime; % Attention!! Mistake here.\n    % Velocity needs to be divided by pendulum length and scaled to degrees:\n    % theta = theta + velocity(2) * deltaTime/rodLength/pi*180;\n\n    position = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]);\n\n    %Update figure with new position info\n    set(rectHandle,'Position',[(position - radius/2) radius radius]);\n    set(lineHandle,'XData',[rodPivotPoint(1) position(1)],'YData',...\n        [rodPivotPoint(2) position(2)]);\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "  DS{1}.account='jsmith';\n  DS{1}.password='x';\n  DS{1}.UID=1001;\n  DS{1}.GID=1000;\n  DS{1}.fullname='Joe Smith';\n  DS{1}.office='Room 1007';\n  DS{1}.extension='(234)555-8917';\n  DS{1}.homephone='(234)555-0077';\n  DS{1}.email='jsmith@rosettacode.org';\n  DS{1}.directory='/home/jsmith';\n  DS{1}.shell='/bin/bash';\n\n  DS{2}.account='jdoe';\n  DS{2}.password='x';\n  DS{2}.UID=1002;\n  DS{2}.GID=1000;\n  DS{2}.fullname='Jane Doe';\n  DS{2}.office='Room 1004';\n  DS{2}.extension='(234)555-8914';\n  DS{2}.homephone='(234)555-0044';\n  DS{2}.email='jdoe@rosettacode.org';\n  DS{2}.directory='/home/jdoe';\n  DS{2}.shell='/bin/bash';\n\n  function WriteRecord(fid, rec)\n     fprintf(fid,\"%s:%s:%i:%i:%s,%s,%s,%s,%s:%s%s\\n\", rec.account, rec.password, rec.UID, rec.GID, rec.fullname, rec.office, rec.extension, rec.homephone, rec.email, rec.directory, rec.shell);\n     return;\n  end\n\n  %% write\n  fid = fopen('passwd.txt','w');\n  WriteRecord(fid,DS{1});\n  WriteRecord(fid,DS{2});\n  fclose(fid);\n\n  new.account='xyz';\n  new.password='x';\n  new.UID=1003;\n  new.GID=1000;\n  new.fullname='X Yz';\n  new.office='Room 1003';\n  new.extension='(234)555-8913';\n  new.homephone='(234)555-0033';\n  new.email='xyz@rosettacode.org';\n  new.directory='/home/xyz';\n  new.shell='/bin/bash';\n\n  %% append\n  fid = fopen('passwd.txt','a+');\n  WriteRecord(fid,new);\n  fclose(fid);\n\n  % read password file\n  fid = fopen('passwd.txt','r');\n  while ~feof(fid)\n\tprintf('%s\\n',fgetl(fid));\n  end;\n  fclose(fid);\n"
  },
  {
    "language": "MATLAB",
    "code": ">> array = [1 2 3 4 5]\n\narray =\n\n     1     2     3     4     5\n\n>> arrayfun(@sin,array)\n\nans =\n\n  Columns 1 through 4\n\n   0.841470984807897   0.909297426825682   0.141120008059867  -0.756802495307928\n\n  Column 5\n\n  -0.958924274663138\n\n>> cellarray = {1,2,3,4,5}\n\ncellarray =\n\n    [1]    [2]    [3]    [4]    [5]\n\n>> cellfun(@tan,cellarray)\n\nans =\n\n  Columns 1 through 4\n\n   1.557407724654902  -2.185039863261519  -0.142546543074278   1.157821282349578\n\n  Column 5\n\n  -3.380515006246586\n"
  },
  {
    "language": "MATLAB",
    "code": ">> answer = vpi(5)^(vpi(4)^(vpi(3)^vpi(2)));\n>> numDigits = order(answer) + 1\n\nnumDigits =\n\n      183231\n\n>> [sprintf('%d',leadingdigit(answer,20)) '...' sprintf('%d',trailingdigit(answer,20))]\n%First and Last 20 Digits\n\nans =\n\n62060698786608744707...92256259918212890625\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = 1+i\n\na =\n\n  1.000000000000000 + 1.000000000000000i\n\n>> b = 3+7i\n\nb =\n\n  3.000000000000000 + 7.000000000000000i\n\n>> a+b\n\nans =\n\n  4.000000000000000 + 8.000000000000000i\n\n>> a-b\n\nans =\n\n -2.000000000000000 - 6.000000000000000i\n\n>> a*b\n\nans =\n\n -4.000000000000000 +10.000000000000000i\n\n>> a/b\n\nans =\n\n  0.172413793103448 - 0.068965517241379i\n\n>> -a\n\nans =\n\n -1.000000000000000 - 1.000000000000000i\n\n>> a'\n\nans =\n\n  1.000000000000000 - 1.000000000000000i\n\n>> a^b\n\nans =\n\n  0.000808197112874 - 0.011556516327187i\n\n>> norm(a)\n\nans =\n\n   1.414213562373095\n"
  },
  {
    "language": "MATLAB",
    "code": "function [a,g]=agm(a,g)\n%%arithmetic_geometric_mean(a,g)\n\twhile (1)\n\t\ta0=a;\n\t\ta=(a0+g)/2;\n\t\tg=sqrt(a0*g);\n\tif (abs(a0-a) < a*eps) break; end;\n\tend;\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "disp(\"integer a: \"); a = scanf(\"%d\", 1);\ndisp(\"integer b: \"); b = scanf(\"%d\", 1);\na+b\na-b\na*b\nfloor(a/b)\nmod(a,b)\na^b\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = [1 2 3]\n\na =\n\n     1     2     3\n\n>> b = [4 5 6]\n\nb =\n\n     4     5     6\n\n>> concat = [a b]\n\nconcat =\n\n     1     2     3     4     5     6\n\n>> concat = [a;b]\n\nconcat =\n\n     1     2     3\n     4     5     6\n"
  },
  {
    "language": "MATLAB",
    "code": ">> c = randn([3,4,5]);\n>> d = randn([3,4,7]);\n>> e = cat(3,c,d);\n>> size(e)\n   ans =\n\n    3    4   12\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = [1 2 35] %Declaring a vector (i.e. one-dimensional array)\n\na =\n\n     1     2    35\n\n>> a = [1 2 35;5 7 9] % Declaring a matrix (i.e. two-dimensional array)\n\na =\n\n     1     2    35\n     5     7     9\n\n>> a3 = reshape(1:2*3*4,[2,3,4]);   % declaring a three-dimensional array of size 2x3x4\n\na3 =\n\nans(:,:,1) =\n\n   1   3   5\n   2   4   6\n\nans(:,:,2) =\n\n    7    9   11\n    8   10   12\n\nans(:,:,3) =\n\n   13   15   17\n   14   16   18\n\nans(:,:,4) =\n\n   19   21   23\n   20   22   24\n\n\n>> a(2,3) %Retrieving value using row and column indicies\n\n     9\n\n>> a(6) %Retrieving value using array subscript\n\nans =\n\n     9\n\n>> a = [a [10;42]] %Added a column vector to the array\n\na =\n\n     1     2    35    10\n     5     7     9    42\n\n>> a(:,1) = [] %Deleting array elements\n\na =\n\n     2    35    10\n     7     9    42\n"
  },
  {
    "language": "MATLAB",
    "code": "assert(x == 42,'x = %d, not 42.',x);\n"
  },
  {
    "language": "MATLAB",
    "code": "x = 3;\nassert(x == 42,'Assertion Failed: x = %d, not 42.',x);\n??? Assertion Failed: x = 3, not 42.\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash.a = 1;\n   hash.b = 2;\n   hash.C = [3,4,5];\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash = [];\n   hash = setfield(hash,'a',1); \t\n   hash = setfield(hash,'b',2); \t\n   hash = setfield(hash,'C',[3,4,5]);\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash.('a') = 1; \t\n   hash.('b') = 2; \t\n   hash.('C') = [3,4,5];\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map({'a' 'b' 'C'}, [1 2 3]);\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map;\nm('a') = 1;\nm('b') = 2;\nm('C') = 3;\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map([51 72 37], {'fiftyone' 'seventytwo' 'thirtyseven'});\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map('KeyType', 'double', 'ValueType', 'any');\nm(51) = 'fiftyone';\nm(72) = 'seventytwo';\nm(37) = 'thirtyseven';\n"
  },
  {
    "language": "MATLAB",
    "code": "   keys = fieldnames(hash);\n   for k=1:length(keys),\n        key = keys{k};\n\tvalue = getfield(hash,key);        % get value of key\n\thash = setfield(hash,key,-value);  % set value of key\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "   keys = fieldnames(hash);\n   for k=1:length(keys),\n        key = keys{k};\n        value = hash.(key);     % get value of key\n        hash.(key) = -value;    % set value of key\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "function meanValue = findmean(setOfValues)\n   meanValue = mean(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function u = mean_angle(phi)\n\tu = angle(mean(exp(i*pi*phi/180)))*180/pi;\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function t = mean_time_of_day(t)\n    c = pi/(12*60*60);\n    for k=1:length(t)\n\ta = sscanf(t{k},'%d:%d:%d');\n\tphi(k) = (a(1)*3600+a(2)*60+a(3));\n    end;\n    d = angle(mean(exp(i*phi*c)))/(2*pi); % days\n    if (d<0) d += 1;\n    t = datestr(d,\"HH:MM:SS\");\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "function medianValue = findmedian(setOfValues)\n   medianValue = median(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function modeValue = findmode(setOfValues)\n   modeValue = mode(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function [A,G,H] = pythagoreanMeans(list)\n\n    A = mean(list);\n    G = geomean(list);\n    H = harmmean(list);\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function [A,G,H] = pythagoreanMeans(list)\n    A = mean(list);           % arithmetic mean\n    G = exp(mean(log(list))); % geometric mean\n    H = 1./mean(1./list);     % harmonic mean\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> [A,G,H]=pythagoreanMeans((1:10))\n\nA =\n\n   5.500000000000000\n\n\nG =\n\n   4.528728688116765\n\n\nH =\n\n   3.414171521474055\n"
  },
  {
    "language": "MATLAB",
    "code": "function rms = quadraticMean(list)\n    rms = sqrt(mean(list.^2));\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> quadraticMean((1:10))\n\nans =\n\n   6.204836822995429\n"
  },
  {
    "language": "MATLAB",
    "code": " [m,z] = filter(ones(1,P),P,x);\n"
  },
  {
    "language": "MATLAB",
    "code": " [m,z] = filter(ones(1,P),P,x,z);\n"
  },
  {
    "language": "MATLAB",
    "code": "function x = isbb(s)\n   t = cumsum((s=='[') - (s==']'));\n   x = all(t>=0) && (t(end)==0);\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "  dec2bin(5)\n  dec2bin(50)\n  dec2bin(9000)\n"
  },
  {
    "language": "MATLAB",
    "code": "function mid = binarySearchRec(list,value,low,high)\n\n    if( high < low )\n        mid = [];\n        return\n    end\n\n    mid = floor((low + high)/2);\n\n    if( list(mid) > value )\n        mid = binarySearchRec(list,value,low,mid-1);\n        return\n    elseif( list(mid) < value )\n        mid = binarySearchRec(list,value,mid+1,high);\n        return\n    else\n        return\n    end\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> binarySearchRec([1 2 3 4 5 6 6.5 7 8 9 11 18],6.5,1,numel([1 2 3 4 5 6 6.5 7 8 9 11 18]))\n\nans =\n\n     7\n"
  },
  {
    "language": "MATLAB",
    "code": "function mid = binarySearchIter(list,value)\n\n    low = 1;\n    high = numel(list) - 1;\n\n    while( low <= high )\n        mid = floor((low + high)/2);\n\n        if( list(mid) > value )\n            high = mid - 1;\n        elseif( list(mid) < value )\n        \tlow = mid + 1;\n        else\n            return\n        end\n    end\n\n    mid = [];\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> binarySearchIter([1 2 3 4 5 6 6.5 7 8 9 11 18],6.5)\n\nans =\n\n     7\n"
  },
  {
    "language": "MATLAB",
    "code": "\ta=['123',0,' abc '];\n\tb=['456',9];\n\tc='789';\n\tdisp(a);\n\tdisp(b);\n\tdisp(c);\n\n\t% string comparison\n\tprintf('(a==b) is %i\\n',strcmp(a,b));\n\n\t% string copying\n\tA = a;\n\tB = b;\n\tC = c;\n\tdisp(A);\n\tdisp(B);\n\tdisp(C);\n\n\t% check if string is empty\n\tif (length(a)==0)\n\t\tprintf('\\nstring a is empty\\n');\n\telse\n\t\tprintf('\\nstring a is not empty\\n');\n\tend\n\n\t% append a byte to a string\n\ta=[a,64];\n        disp(a);\n\n\t% substring\n\te = a(1:6);\n        disp(e);\n\n\t% join strings\n\td=[a,b,c];\n\tdisp(d);\n"
  },
  {
    "language": "MATLAB",
    "code": "%Bitmap class\n%\n%Implements a class to manage bitmap images without the need for the\n%various conversion and display functions\n%\n%Available functions:\n%\n%fill(obj,color)\n%setPixel(obj,pixel,color)\n%getPixel(obj,pixel,[optional: color channel])\n%display(obj)\n%disp(obj)\n%plot(obj)\n%image(obj)\n%save(obj)\n%open(obj)\n\nclassdef Bitmap\n\n    %% Public Properties\n    properties\n\n        %Channel arrays\n        red;\n        green;\n        blue;\n\n    end\n\n    %% Public Methods\n    methods\n\n        %Creates image and defaults it to black\n        function obj = Bitmap(width,height)\n            obj.red   = zeros(height,width,'uint8');\n            obj.green = zeros(height,width,'uint8');\n            obj.blue  = zeros(height,width,'uint8');\n        end % End Bitmap Constructor\n\n        %Fill the image with a specified color\n        %color = [red green blue] max for each is 255\n        function fill(obj,color)\n            obj.red(:,:)   = color(1);\n            obj.green(:,:) = color(2);\n            obj.blue(:,:)  = color(3);\n            assignin('caller',inputname(1),obj); %saves the changes to the object\n        end\n\n        %Set a pixel to a specified color\n        %pixel = [x y]\n        %color = [red green blue]\n        function setPixel(obj,pixel,color)\n            obj.red(pixel(2),pixel(1))   = color(1);\n            obj.green(pixel(2),pixel(1)) = color(2);\n            obj.blue(pixel(2),pixel(1))  = color(3);\n            assignin('caller',inputname(1),obj); %saves the changes to the object\n        end\n\n        %Get pixel color\n        %pixel = [x y]\n        %varargin can be:\n        %  no input for all channels\n        %  'r' or 'red' for red channel\n        %  'g' or 'green' for green channel\n        %  'b' or 'blue' for blue channel\n        function color = getPixel(obj,pixel,varargin)\n\n            if( ~isempty(varargin) )\n                switch (varargin{1})\n                    case {'r','red'}\n                        color = obj.red(pixel(2),pixel(1));\n                    case {'g','green'}\n                        color = obj.red(pixel(2),pixel(1));\n                    case {'b','blue'}\n                        color = obj.red(pixel(2),pixel(1));\n                end\n            else\n                color = [obj.red(pixel(2),pixel(1)) obj.green(pixel(2),pixel(1)) obj.blue(pixel(2),pixel(1))];\n            end\n\n        end\n\n        %Display the image\n        %varargin can be:\n        %  no input for all channels\n        %  'r' or 'red' for red channel\n        %  'g' or 'green' for green channel\n        %  'b' or 'blue' for blue channel\n        function display(obj,varargin)\n\n            if( ~isempty(varargin) )\n                switch (varargin{1})\n                    case {'r','red'}\n                        image(obj.red)\n                    case {'g','green'}\n                        image(obj.green)\n                    case {'b','blue'}\n                        image(obj.blue)\n                end\n\n                colormap bone;\n            else\n                bitmap = cat(3,obj.red,obj.green,obj.blue);\n                image(bitmap);\n            end\n        end\n\n        %Overload several commonly used display functions\n        function disp(obj,varargin)\n            display(obj,varargin{:});\n        end\n\n        function plot(obj,varargin)\n            display(obj,varargin{:});\n        end\n\n        function image(obj,varargin)\n            display(obj,varargin{:});\n        end\n\n        %Saves the image\n        function save(obj)\n\n            %Open file dialogue\n            [fileName,pathName,success] = uiputfile({'*.bmp','Bitmap Image (*.bmp)'},'Save Bitmap As');\n\n            if( not(success == 0) )\n                imwrite(cat(3,obj.red,obj.green,obj.blue),[pathName fileName],'bmp'); %Write image file to disk\n                disp('Save Complete');\n            end\n        end\n\n        %Opens an image and overwrites what is currently stored\n        function success = open(obj)\n\n            %Open file dialogue\n            [fileName,pathName,success] = uigetfile({'*.bmp','Bitmap Image (*.bmp)'},'Open Bitmap ');\n\n            if( not(success == 0) )\n\n                channels = imread([pathName fileName], 'bmp'); %returns color indexed data\n\n                %Store each channel\n                obj.red   = channels(:,:,1);\n                obj.green = channels(:,:,2);\n                obj.blue  = channels(:,:,3);\n\n                assignin('caller',inputname(1),obj); %saves the changes to the object\n                success = true;\n                return\n            else\n                success = false;\n                return\n            end\n        end\n\n\n    end %methods\nend %classdef\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(20,30);\n>> img.fill([30 30 150]);\n>> img.setPixel([10 15],[20 130 66]);\n>> disp(img)\n>> img.getPixel([10 15])\n\nans =\n\n   20  130   66\n\n>> img.getPixel([10 15],'red')\n\nans =\n\n   20\n\n>> img.save()\nSave Complete\n"
  },
  {
    "language": "MATLAB",
    "code": "function bezierCubic(obj,pixel_0,pixel_1,pixel_2,pixel_3,color,varargin)\n\n    if( isempty(varargin) )\n        resolution = 20;\n    else\n        resolution = varargin{1};\n    end\n\n    %Calculate time axis\n    time = (0:1/resolution:1)';\n    timeMinus = 1-time;\n\n    %The formula for the curve is expanded for clarity, the lack of\n    %loops is because its calculation has been vectorized\n    curve = (timeMinus).^3*pixel_0; %First term of polynomial\n    curve = curve + (3.*time.*timeMinus.^2)*pixel_1; %second term of polynomial\n    curve = curve + (3.*timeMinus.*time.^2)*pixel_2; %third term of polynomial\n    curve = curve + time.^3*pixel_3; %Fourth term of polynomial\n\n    curve = round(curve); %round each of the points to the nearest integer\n\n    %connect each of the points in the curve with a line using the\n    %Bresenham Line algorithm\n    for i = (1:length(curve)-1)\n        obj.bresenhamLine(curve(i,:),curve(i+1,:),color);\n    end\n\n    assignin('caller',inputname(1),obj); %saves the changes to the object\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(200,200);\n>> img.fill([255 255 255]);\n>> img.bezierCubic([160 10],[10 40],[30 160],[150 110],[255 0 0],110);\n>> disp(img)\n"
  },
  {
    "language": "MATLAB",
    "code": "function bezierQuad(obj,pixel_0,pixel_1,pixel_2,color,varargin)\n\n    if( isempty(varargin) )\n        resolution = 20;\n    else\n        resolution = varargin{1};\n    end\n\n    %Calculate time axis\n    time = (0:1/resolution:1)';\n    timeMinus = 1-time;\n\n    %The formula for the curve is expanded for clarity, the lack of\n    %loops is because its calculation has been vectorized\n    curve = (timeMinus.^2)*pixel_0; %First term of polynomial\n    curve = curve + (2.*time.*timeMinus)*pixel_1; %second term of polynomial\n    curve = curve + (time.^2)*pixel_2; %third term of polynomial\n\n    curve = round(curve); %round each of the points to the nearest integer\n\n    %connect each of the points in the curve with a line using the\n    %Bresenham Line algorithm\n    for i = (1:length(curve)-1)\n        obj.bresenhamLine(curve(i,:),curve(i+1,:),color);\n    end\n\n    assignin('caller',inputname(1),obj); %saves the changes to the object\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(400,300);\n>> img.fill([223 255 239]);\n>> img.bezierQuad([20 150],[500 -100],[300 280],[63 143 239],21);\n>> disp(img)\n"
  },
  {
    "language": "MATLAB",
    "code": "%screen     = Bitmap object\n%startPoint = [x0,y0]\n%endPoint   = [x1,y1]\n%color      = [red,green,blue]\n\nfunction bresenhamLine(screen,startPoint,endPoint,color)\n\n  if( any(color > 255) )\n      error 'RGB colors must be between 0 and 255';\n  end\n\n  %Check for vertical line, x0 == x1\n  if( startPoint(1) == endPoint(1) )\n      %Draw vertical line\n      for i = (startPoint(2):endPoint(2))\n          setPixel(screen,[startPoint(1) i],color);\n      end\n  end\n\n  %Simplified Bresenham algorithm\n  dx = abs(endPoint(1) - startPoint(1));\n  dy = abs(endPoint(2) - startPoint(2));\n\n  if(startPoint(1) < endPoint(1))\n      sx = 1;\n  else\n      sx = -1;\n  end\n\n  if(startPoint(2) < endPoint(2))\n      sy = 1;\n  else\n      sy = -1;\n  end\n\n  err = dx - dy;\n  pixel = startPoint;\n\n  while(true)\n\n      screen.setPixel(pixel,color); %setPixel(x0,y0)\n\n      if( pixel == endPoint )\n          break;\n      end\n\n      e2 = 2*err;\n\n      if( e2 > -dy )\n          err = err - dy;\n          pixel(1) = pixel(1) + sx;\n      end\n\n      if( e2 < dx )\n          err = err + dx;\n          pixel(2) = pixel(2) + sy;\n      end\n  end\n\n  assignin('caller',inputname(1),screen); %saves the changes to the object\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> img = Bitmap(800,600);\n>> img.bresenhamLine([400 550],[200 400],[255 255 255]);\n>> img.bresenhamLine([400 550],[600 400],[255 255 255]);\n>> img.bresenhamLine([200 400],[350 150],[255 255 255]);\n>> img.bresenhamLine([600 400],[450 150],[255 255 255]);\n>> img.bresenhamLine([350 150],[450 150],[255 255 255]);\n>> img.bresenhamLine([400 550],[400 150],[255 255 255]);\n>> disp(img)\n"
  },
  {
    "language": "MATLAB",
    "code": "R=[255,0,0;255,255,0];\nG=[0,255,0;255,255,0];\nB=[0,0,255;0,0,0];\n\n\nr = R'; r(:);\ng = R'; g(:);\nb = R'; b(:);\nfid=fopen('p6.ppm','w');\nfprintf(fid,'P6\\n%i %i\\n255\\n',size(R));\nfwrite(fid,[r,g,b]','uint8');\nfclose(fid);\n"
  },
  {
    "language": "MATLAB",
    "code": "function bitwiseOps(a,b)\n\n    disp(sprintf('%d and %d = %d', [a b bitand(a,b)]));\n    disp(sprintf('%d or %d = %d', [a b bitor(a,b)]));\n    disp(sprintf('%d xor %d = %d', [a b bitxor(a,b)]));\n    disp(sprintf('%d << %d = %d', [a b bitshift(a,b)]));\n    disp(sprintf('%d >> %d = %d', [a b bitshift(a,-b)]));\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> bitwiseOps(255,2)\n255 and 2 = 2\n255 or 2 = 255\n255 xor 2 = 253\n255 << 2 = 1020\n255 >> 2 = 63\n"
  },
  {
    "language": "MATLAB",
    "code": ">> islogical(true)\n\nans =\n\n     1\n\n>> islogical(false)\n\nans =\n\n     1\n\n>> islogical(logical(1))\n\nans =\n\n     1\n\n>> islogical(logical(0))\n\nans =\n\n     1\n\n>> islogical(1)\n\nans =\n\n     0\n\n>> islogical(0)\n\nans =\n\n     0\n"
  },
  {
    "language": "MATLAB",
    "code": "function b = compassbox(d)\n    b = ceil(mod(d+360/64,360)*32/360);\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "function BullsAndCowsPlayer\n% Plays the game Bulls and Cows as the player\n\n    % Generate list of all possible numbers\n    nDigits = 4;\n    lowVal = 1;\n    highVal = 9;\n    combs = nchoosek(lowVal:highVal, nDigits);\n    nCombs = size(combs, 1);\n    nPermsPerComb = factorial(nDigits);\n    gList = zeros(nCombs.*nPermsPerComb, nDigits);\n    for k = 1:nCombs\n        gList(nPermsPerComb*(k-1)+1:nPermsPerComb*k, :) = perms(combs(k, :));\n    end\n\n    % Prompt user\n    fprintf('Think of a number with:\\n')\n    fprintf('  %d digits\\n', nDigits)\n    fprintf('  Each digit between %d and %d inclusive\\n', lowVal, highVal)\n    fprintf('  No repeated digits\\n')\n    fprintf('I''ll try to guess that number and you score me:\\n')\n    fprintf('  1 Bull per correct digit in the correct place\\n')\n    fprintf('  1 Cow per correct digit in the wrong place\\n')\n    fprintf('Think of your number and press Enter when ready\\n')\n    pause\n\n    % Play game until all digits are correct\n    nBulls = 0;\n    nGuesses = 0;\n    while nBulls < 4 && ~isempty(gList)\n        nList = size(gList, 1);\n        g = gList(randi(nList), :);     % Random guess from list\n        fprintf('My guess: %s?\\n', sprintf('%d', g))\n        nBulls = input('How many bulls? ');\n        if nBulls < 4\n            nCows = input('How many cows? ');\n            del = false(nList, 1);\n            for k = 1:nList\n                del(k) = any([nBulls nCows] ~= CountBullsCows(g, gList(k, :)));\n            end\n            gList(del, :) = [];\n        end\n        nGuesses = nGuesses+1;\n    end\n    if isempty(gList)\n        fprintf('That''s bull! You messed up your scoring.\\n')\n    else\n        fprintf('Yay, I won! Only took %d guesses.\\n', nGuesses)\n    end\nend\n\nfunction score = CountBullsCows(guess, correct)\n% Checks the guessed array of digits against the correct array to find the score\n% Assumes arrays of same length and valid numbers\n    bulls = guess == correct;\n    cows = ismember(guess(~bulls), correct);\n    score = [sum(bulls) sum(cows)];\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function BullsAndCows\n% Plays the game Bulls and Cows as the \"game master\"\n\n    % Create a secret number\n    nDigits = 4;\n    lowVal = 1;\n    highVal = 9;\n    digitList = lowVal:highVal;\n    secret = zeros(1, 4);\n    for k = 1:nDigits\n        idx = randi(length(digitList));\n        secret(k) = digitList(idx);\n        digitList(idx) = [];\n    end\n\n    % Give game information\n    fprintf('Welcome to Bulls and Cows!\\n')\n    fprintf('Try to guess the %d-digit number (no repeated digits).\\n', nDigits)\n    fprintf('Digits are between %d and %d (inclusive).\\n', lowVal, highVal)\n    fprintf('Score: 1 Bull per correct digit in correct place.\\n')\n    fprintf('       1 Cow per correct digit in incorrect place.\\n')\n    fprintf('The number has been chosen. Now it''s your moooooove!\\n')\n    gs = input('Guess: ', 's');\n\n    % Loop until user guesses right or quits (no guess)\n    nGuesses = 1;\n    while gs\n        gn = str2double(gs);\n        if isnan(gn) || length(gn) > 1  % Not a scalar\n            fprintf('Malformed guess. Keep to valid scalars.\\n')\n            gs = input('Try again: ', 's');\n        else\n            g = sprintf('%d', gn) - '0';\n            if length(g) ~= nDigits || any(g < lowVal) || any(g > highVal) || ...\n                    length(unique(g)) ~= nDigits    % Invalid number for game\n                fprintf('Malformed guess. Remember:\\n')\n                fprintf('  %d digits\\n', nDigits)\n                fprintf('  Between %d and %d inclusive\\n', lowVal, highVal)\n                fprintf('  No repeated digits\\n')\n                gs = input('Try again: ', 's');\n            else\n                score = CountBullsCows(g, secret);\n                if score(1) == nDigits\n                    fprintf('You win! Bully for you! Only %d guesses.\\n', nGuesses)\n                    gs = '';\n                else\n                    fprintf('Score: %d Bulls, %d Cows\\n', score)\n                    gs = input('Guess: ', 's');\n                end\n            end\n        end\n        nGuesses = nGuesses+1;  % Counts malformed guesses\n    end\nend\n\nfunction score = CountBullsCows(guess, correct)\n% Checks the guessed array of digits against the correct array to find the score\n% Assumes arrays of same length and valid numbers\n    bulls = guess == correct;\n    cows = ismember(guess(~bulls), correct);\n    score = [sum(bulls) sum(cows)];\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "   function s = cipherCaesar(s, key)\n          s = char( mod(s - 'A' + key, 25 ) + 'A');\n   end; \t\n   function s = decipherCaesar(s, key)\n          s = char( mod(s - 'A' - key, 25 ) + 'A');\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "   decipherCaesar(cipherCaesar('ABC',4),4)\n   ans = ABC\n"
  },
  {
    "language": "MATLAB",
    "code": "    % Calling a function that requires no arguments\n       function a=foo();\n         a=4;\n       end;\n       x = foo();\n    % Calling a function with a fixed number of arguments\n       function foo(a,b,c);\n         %% function definition;\n       end;\n       foo(x,y,z);\n    % Calling a function with optional arguments\n       function foo(a,b,c);\n\tif nargin<2, b=0; end;\n\tif nargin<3, c=0; end;\n         %% function definition;\n       end;\n       foo(x,y);\n    % Calling a function with a variable number of arguments\n       function foo(varargin);\n\t  for k=1:length(varargin)\n            arg{k} = varargin{k};\t\n       end;\n       foo(x,y);\n    % Calling a function with named arguments\n\t%% does not apply\n    % Using a function in statement context\n\t%% does not apply\n    % Using a function in first-class context within an expression\n    % Obtaining the return value of a function\n       function [a,b]=foo();\n         a=4;\n         b='result string';\n       end;\n       [x,y] = foo();\n    % Distinguishing built-in functions and user-defined functions\n\tfun = 'foo';\t\n\tif (exist(fun,'builtin'))\n \t\tprintf('function %s is a builtin\\n');\n        elseif (exist(fun,'file'))\n \t\tprintf('function %s is user-defined\\n');\n        elseif (exist(fun,'var'))\n \t\tprintf('function %s is a variable\\n');\n        else\n \t\tprintf('%s is not a function or variable.\\n');\n        end\n    % Distinguishing subroutines and functions\n        % there are only scripts and functions, any function declaration starts with the keyword function, otherwise it is a script that runs in the workspace\n    % Stating whether arguments are passed by value or by reference\n      % arguments are passed by value, however Matlab has delayed evaluation, such that a copy of large data structures are done only when an element is written to.\n"
  },
  {
    "language": "MATLAB",
    "code": "BWImage = edge(GrayscaleImage,'canny');\n"
  },
  {
    "language": "MATLAB",
    "code": "  dog = 'Benjamin';\n  Dog = 'Samba';\n  DOG = 'Bernie';\n\n  printf('There are three dogs %s, %s, %s.\\n',dog, Dog, DOG);\n"
  },
  {
    "language": "MATLAB",
    "code": "function n = catalanNumber(n)\n    for i = (1:length(n))\n        n(i) = (1/(n(i)+1))*nchoosek(2*n(i),n(i));\n    end\nend\n"
  },
  {
    "language": "Perl",
    "code": "my @doors;\nfor my $pass (1 .. 100) {\n    for (1 .. 100) {\n        if (0 == $_ % $pass) {\n            $doors[$_] = not $doors[$_];\n        };\n    };\n};\n\nprint \"Door $_ is \", $doors[$_] ? \"open\" : \"closed\", \"\\n\" for 1 .. 100;\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\nuse strict;\nuse warnings;\n\nmy @doors = (1) x 100;\nfor my $N (1 .. 100) {\n   $doors[$_]=1-$doors[$_] for map { $_*$N - 1 } 1 .. int(100/$N);\n}\nprint join(\"\\n\", map { \"Door $_ is Open\" } grep { ! $doors[$_-1] } 1 .. 100), \"\\n\";\nprint \"The rest are closed\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "print \"Door $_ is open\\n\" for map $_**2, 1 .. 10;\n"
  },
  {
    "language": "Perl",
    "code": "print \"Door $_ is \", qw\"closed open\"[int sqrt == sqrt], \"\\n\" for 1..100;\n"
  },
  {
    "language": "Perl",
    "code": "while( ++$i <= 100 )\n{\n    $root = sqrt($i);\n    if ( int( $root ) == $root )\n    {\n        print \"Door $i is open\\n\";\n    }\n    else\n    {\n        print \"Door $i is closed\\n\";\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "# Fischer-Krause ordered permutation generator\n# http://faq.perl.org/perlfaq4.html#How_do_I_permute_N_e\nsub permute (&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$#_;\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $#idx;\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n# generate all possible combinations of operators\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/env perl\nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q')\n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  # remove all white space\n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  # not correct digits\n      $entry =~ /\\d\\d/ ||                # combined digits\n      $entry =~ m|[-+*/]{2}| ||          # combined operators\n      $entry =~ tr|-0-9()+*/||c)         # Invalid characters\n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/:all/;\n\nsub triangle_row {\n  my($n,@row) = (shift);\n  # Tally by first element of the unrestricted integer partitions.\n  forpart { $row[ $_[0] - 1 ]++ } $n;\n  @row;\n}\n\nprintf \"%2d: %s\\n\", $_, join(\" \",triangle_row($_)) for 1..25;\nprint \"\\n\";\nsay \"P($_) = \", partitions($_) for (23, 123, 1234, 12345);\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\n# Where perl6 uses arbitrary precision integers everywhere\n# that you don't tell it not to do so, perl5 will only use\n# them where you *do* tell it do so.\nuse Math::BigInt;\nuse constant zero => Math::BigInt->bzero;\nuse constant one  => Math::BigInt->bone;\n\nmy @todo = [one];\nmy @sums = (zero);\nsub nextrow {\n   my $n = shift;\n   for my $l (@todo .. $n) {\n      $sums[$l] = zero;\n      #print \"$l\\r\" if $l < $n;\n      my @r;\n      for my $x (reverse 0 .. $l-1) {\n         my $todo = $todo[$x];\n         $sums[$x] += shift @$todo if @$todo;\n         push @r, $sums[$x];\n      }\n      push @todo, \\@r;\n   }\n   @{ $todo[$n] };\n}\n\nprint \"rows:\\n\";\nfor(1..25) {\n   printf(\"%2d: \", $_);\n   print join(' ', nextrow($_)), \"\\n\";\n}\nprint \"\\nsums:\\n\";\nfor (23, 123, 1234, 12345) {\n   print $_, \".\" x (8 - length);\n   my $i = 0;\n   $i += $_ for nextrow($_);\n   print $i, \"\\n\";\n}\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl -w\n\nmy $verse = <<\"VERSE\";\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\nVERSE\n\n{\n    $verse =~ s/(\\d+)/$1-1/ge;\n    $verse =~ s/\\b1 bottles/1 bottle/g;\n    my $done = $verse =~ s/\\b0 bottle/No bottles/g; # if we make this replacement, we're also done.\n\n    print $verse;\n    redo unless $done;\n}\n"
  },
  {
    "language": "Perl",
    "code": "for $n (reverse(0..99))\n{\n    $bottles = sprintf(\"%s bottle%s of beer on the wall\\n\",(($n==0)?\"No\":$n), (($n==1)?\"\":\"s\"));\n    print( (($n==99)?\"\":\"$bottles\\n\") .\n\t   (($n==0)?\"\":(substr(${bottles}x2,0,-12) . \"\\nTake one down, pass it around\\n\")) );\n}\n"
  },
  {
    "language": "Perl",
    "code": "use 5.10.0;\n\n$num = 99;\nwhile ($num > 0) {\n    my $s = \"s\" unless ($num == 1);\n    say \"$num bottle$s of beer on the wall, $num bottle$s of beer\";\n    $num--;\n    my $s = \"s\" unless ($num == 1);\n    $num = \"No more\" if ($num == 0);\n    say \"Take one down, pass it around, $num bottle$s of beer on the wall\\n\"\n}\n\nsay \"No more bottles of beer on the wall, no more bottles of beer.\";\nsay \"Go to the store and buy some more, 99 bottles of beer on the wall.\";\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/env perl\nuse strict;\nuse warnings;\n\nsub bottles() { sprintf qq{%s bottle%s of beer}\n               , $_ || 'No'\n               , $_==1 ? '' : 's';\n               }\nsub store() { $_=99; qq{Go to the store, buy some more...\\n}; }\nsub wall() { qq{ on the wall\\n} }\nsub take() { $_-- ? qq{Take one down, pass it around\\n} : store }\ndo { print bottles, wall\n         , bottles, qq{\\n}\n         , take\n         , bottles, qq{\\n\\n}\n   } for reverse 0..99;\n"
  },
  {
    "language": "Perl",
    "code": "my ($a,$b) = split(' ', scalar(<STDIN>));\nprint \"$a $b \" . ($a + $b) . \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "say sum split /\\s+/,  scalar <STDIN>;\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\nuse warnings;\nuse strict;\n\n\nsub can_make_word {\n    my ($word, @blocks) = @_;\n    $_ = uc join q(), sort split // for @blocks;\n    my %blocks;\n    $blocks{$_}++ for @blocks;\n    return _can_make_word(uc $word, %blocks)\n}\n\n\nsub _can_make_word {\n    my ($word, %blocks) = @_;\n    my $char = substr $word, 0, 1, q();\n\n    my @candidates = grep 0 <= index($_, $char), keys %blocks;\n    for my $candidate (@candidates) {\n        next if $blocks{$candidate} <= 0;\n        local $blocks{$candidate} = $blocks{$candidate} - 1;\n        return 1 if q() eq $word or _can_make_word($word, %blocks);\n    }\n    return\n}\n"
  },
  {
    "language": "Perl",
    "code": "use Test::More tests => 8;\n\nmy @blocks1 = qw(BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM);\nis(can_make_word(\"A\",       @blocks1), 1);\nis(can_make_word(\"BARK\",    @blocks1), 1);\nis(can_make_word(\"BOOK\",    @blocks1), undef);\nis(can_make_word(\"TREAT\",   @blocks1), 1);\nis(can_make_word(\"COMMON\",  @blocks1), undef);\nis(can_make_word(\"SQUAD\",   @blocks1), 1);\nis(can_make_word(\"CONFUSE\", @blocks1), 1);\n\nmy @blocks2 = qw(US TZ AO QA);\nis(can_make_word('auto', @blocks2), 1);\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse strict;\n\nsub frob { die \"abstract\" }\nsub baz { die \"abstract\" }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse strict;\n\nsub frob { ... }\nsub baz { ... }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse Moose::Role;\n\nrequires qw/frob baz/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse Role::Tiny;\n\nrequires qw/frob baz/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\nmy @type = <Perfect Abundant Deficient>;\nsay join \"\\n\", map { sprintf \"%2d %s\", $_, $type[divisor_sum($_)-$_ <=> $_] } 1..12;\nmy %h;\n$h{divisor_sum($_)-$_ <=> $_}++ for 1..20000;\nsay \"Perfect: $h{0}    Deficient: $h{-1}    Abundant: $h{1}\";\n"
  },
  {
    "language": "Perl",
    "code": "sub div_sum {\n    my($n) = @_;\n    my $sum = 0;\n    map { $sum += $_ unless $n % $_ } 1 .. $n-1;\n    $sum;\n}\n\nmy @type = <Perfect Abundant Deficient>;\nsay join \"\\n\", map { sprintf \"%2d %s\", $_, $type[div_sum($_) <=> $_] } 1..12;\nmy %h;\n$h{div_sum($_) <=> $_}++ for 1..20000;\nsay \"Perfect: $h{0}    Deficient: $h{-1}    Abundant: $h{1}\";\n"
  },
  {
    "language": "Perl",
    "code": "sub accumulator {\n  my $sum = shift;\n  sub { $sum += shift }\n}\n\nmy $x = accumulator(1);\n$x->(5);\naccumulator(3);\nprint $x->(2.3), \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "{\n    my @memo;\n    sub A {\n        my( $m, $n ) = @_;\n        $memo[ $m ][ $n ] and return $memo[ $m ][ $n ];\n        $m or return $n + 1;\n        return $memo[ $m ][ $n ] = (\n            $n\n               ? A( $m - 1, A( $m, $n - 1 ) )\n               : A( $m - 1, 1 )\n        );\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub A {\n    my ($m, $n) = @_;\n    if    ($m == 0) { $n + 1 }\n    elsif ($n == 0) { A($m - 1, 1) }\n    else            { A($m - 1, A($m, $n - 1)) }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub A {\n  my ($m, $n) = @_;\n  $m == 0 ? $n + 1 :\n  $n == 0 ? A($m - 1, 1) :\n            A($m - 1, A($m, $n - 1))\n}\n"
  },
  {
    "language": "Perl",
    "code": "use Memoize;  memoize('ack2');\nuse bigint try=>\"GMP\";\n\nsub ack2 {\n   my ($m, $n) = @_;\n   $m == 0 ? $n + 1 :\n   $m == 1 ? $n + 2 :\n   $m == 2 ? 2*$n + 3 :\n   $m == 3 ? 8 * (2**$n - 1) + 5 :\n   $n == 0 ? ack2($m-1, 1)\n           : ack2($m-1, ack2($m, $n-1));\n}\nprint \"ack2(3,4) is \", ack2(3,4), \"\\n\";\nprint \"ack2(4,1) is \", ack2(4,1), \"\\n\";\nprint \"ack2(4,2) has \", length(ack2(4,2)), \" digits\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Math::BigInt;\n\nuse constant two => Math::BigInt->new(2);\n\nsub ack {\n\tmy $n = pop;\n\twhile( @_ ) {\n\t\tmy $m = pop;\n\t\tif( $m > 3 ) {\n\t\t\tpush @_, (--$m) x $n;\n\t\t\tpush @_, reverse 3 .. --$m;\n\t\t\t$n = 13;\n\t\t} elsif( $m == 3 ) {\n\t\t\tif( $n < 29 ) {\n\t\t\t\t$n = ( 1 << ( $n + 3 ) ) - 3;\n\t\t\t} else {\n\t\t\t\t$n = two ** ( $n + 3 ) - 3;\n\t\t\t}\n\t\t} elsif( $m == 2 ) {\n\t\t\t$n = 2 * $n + 3;\n\t\t} elsif( $m >= 0 ) {\n\t\t\t$n = $n + $m + 1;\n\t\t} else {\n\t\t\tdie \"negative m!\";\n\t\t}\n\t}\n\t$n;\n}\n\nprint \"ack(3,4) is \", ack(3,4), \"\\n\";\nprint \"ack(4,1) is \", ack(4,1), \"\\n\";\nprint \"ack(4,2) has \", length(ack(4,2)), \" digits\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use Net::LDAP;\n\nmy $ldap = Net::LDAP->new('ldap://ldap.example.com') or die $@;\nmy $mesg = $ldap->bind( $bind_dn, password => $bind_pass );\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\n\nuse strict;\nuse 5.10.0;\n\npackage Integrator;\nuse threads;\nuse threads::shared;\n\nsub new {\n\tmy $cls = shift;\n\tmy $obj = bless {\tt\t=> 0,\n\t\t\t\tsum\t=> 0,\n\t\t\t\tref $cls ? %$cls : (),\n\t\t\t\tstop\t=> 0,\n\t\t\t\ttid\t=> 0,\n\t\t\t\tfunc\t=> shift,\n\t\t\t}, ref $cls || $cls;\n\n\tshare($obj->{sum});\n\tshare($obj->{stop});\n\n\t$obj->{tid} = async {\n\t\tmy $upd = 0.1; # update every 0.1 second\n\t\twhile (!$obj->{stop}) {\n\t\t\t{\n\t\t\t\tmy $f = $obj->{func};\n\t\t\t\tmy $t = $obj->{t};\n\n\t\t\t\t$obj->{sum} += ($f->($t) + $f->($t + $upd))* $upd/ 2;\n\t\t\t\t$obj->{t} += $upd;\n\t\t\t}\n\t\t\tselect(undef, undef, undef, $upd);\n\t\t}\n\t#\tsay \"stopping $obj\";\n\t};\n\t$obj\n}\n\nsub output { shift->{sum} }\n\nsub delete {\n\tmy $obj = shift;\n\t$obj->{stop} = 1;\n\t$obj->{tid}->join;\n}\n\nsub setinput {\n\t# This is surprisingly difficult because of the perl sharing model.\n\t# Func refs can't be shared, thus can't be replaced by another thread.\n\t# Have to create a whole new object... there must be a better way.\n\tmy $obj = shift;\n\t$obj->delete;\n\t$obj->new(shift);\n}\n\npackage main;\n\nmy $x = Integrator->new(sub { sin(atan2(1, 1) * 8 * .5 * shift) });\n\nsleep(2);\nsay \"sin after 2 seconds: \", $x->output;\n\n$x = $x->setinput(sub {0});\n\nselect(undef, undef, undef, .5);\nsay \"0 after .5 seconds: \", $x->output;\n\n$x->delete;\n"
  },
  {
    "language": "Perl",
    "code": "package Empty;\n\n# Constructor. Object is hash.\nsub new { return bless {}, shift; }\n\npackage main;\n\n# Object.\nmy $o = Empty->new;\n\n# Set runtime variable (key => value).\n$o->{'foo'} = 1;\n"
  },
  {
    "language": "Perl",
    "code": "use Scalar::Util qw(refaddr);\nprint refaddr(\\my $v), \"\\n\";  # 140502490125712\n"
  },
  {
    "language": "Perl",
    "code": "printf \"%p\", $v; # 7fc949039590\n"
  },
  {
    "language": "Perl",
    "code": "my $a = 12;\nmy $b = \\$a; # get reference\n$$b = $$b + 30; # access referenced value\nprint $a; # prints 42\n"
  },
  {
    "language": "Perl",
    "code": "my $a = 12;\nour $b; # you can overlay only global variables (this line is only for strictness)\n*b = \\$a;\nprint $b; # prints 12\n$b++;\nprint $a; # prints 13\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n# Select one of these lines.  Math::BigInt is in core, but quite slow.\nuse Math::BigInt;  sub binomial { Math::BigInt->new(shift)->bnok(shift) }\n# use Math::Pari \"binomial\";\n# use ntheory \"binomial\";\n\nsub binprime {\n  my $p = shift;\n  return 0 unless $p >= 2;\n  # binomial is symmetric, so only test half the terms\n  for (1 .. ($p>>1)) { return 0 if binomial($p,$_) % $p }\n  1;\n}\nsub coef {                   # For prettier printing\n  my($n,$e) = @_;\n  return $n unless $e;\n  $n = \"\" if $n==1;\n  $e==1 ? \"${n}x\" : \"${n}x^$e\";\n}\nsub binpoly {\n  my $p = shift;\n  join(\" \", coef(1,$p),\n            map { join(\"\",(\"+\",\"-\")[($p-$_)&1],\" \",coef(binomial($p,$_),$_)) }\n            reverse 0..$p-1 );\n}\nprint \"expansions of (x-1)^p:\\n\";\nprint binpoly($_),\"\\n\" for 0..9;\nprint \"Primes to 80: [\", join(\",\", grep { binprime($_) } 2..80), \"]\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory \":all\";\n# Uncomment next line to see the r and s values used.  Set to 2 for more detail.\n# prime_set_config(verbose => 1);\nsay join(\" \", grep { is_aks_prime($_) } 1_000_000_000 .. 1_000_000_100);\n"
  },
  {
    "language": "Perl",
    "code": "#/usr/bin/perl -w\nuse strict ;\n\ndie \"Call : perl columnaligner.pl <inputfile> <printorientation>!\\n\" unless\n   @ARGV == 2 ; #$ARGV[ 0 ] contains example file , $ARGV[1] any of 'left' , 'right' or 'center'\ndie \"last argument must be one of center, left or right!\\n\" unless\n   $ARGV[ 1 ] =~ /center|left|right/ ;\nsub printLines( $$$ ) ;\nopen INFILE , \"<\" , \"$ARGV[ 0 ]\" or die \"Can't open $ARGV[ 0 ]!\\n\" ;\nmy @lines = <INFILE> ;\nclose INFILE ;\nchomp @lines ;\nmy @fieldwidths = map length, split /\\$/ , $lines[ 0 ] ;\nforeach my $i ( 1..$#lines ) {\n   my @words = split /\\$/ , $lines[ $i ] ;\n   foreach my $j ( 0..$#words ) {\n      if ( $j <= $#fieldwidths ) {\n         if ( length $words[ $j ] > $fieldwidths[ $j ] ) {\n               $fieldwidths[ $j ] = length $words[ $j ] ;\n         }\n      }\n      else {\n         push @fieldwidths, length $words[ $j ] ;\n      }\n   }\n}\nprintLine( $_ , $ARGV[ 1 ] , \\@fieldwidths ) foreach @lines ;\n##################################################################    ####\nsub printLine {\n   my $line = shift ;\n   my $orientation = shift ;\n   my $widthref = shift ;\n   my @words = split /\\$/, $line ;\n   foreach my $k ( 0..$#words ) {\n      my $printwidth = $widthref->[ $k ] + 1 ;\n      if ( $orientation eq 'center' ) {\n         $printwidth++ ;\n      }\n      if ( $orientation eq 'left' ) {\n         print $words[ $k ] ;\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n      }\n      elsif ( $orientation eq 'right' ) {\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n         print $words[ $k ] ;\n      }\n      elsif ( $orientation eq 'center' ) {\n         my $left = int( ( $printwidth - length $words[ $k ] )     / 2 ) ;\n         my $right = $printwidth - length( $words[ $k ] ) - $left      ;\n         print \" \" x $left ;\n         print $words[ $k ] ;\n         print \" \" x $right ;\n      }\n   }\n   print \"\\n\" ;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use List::Util qw(max);\n\nsub columns {\n    my @lines = map [split /\\$/] => split /\\n/ => shift;\n    my $pos = {qw/left 0 center 1 right 2/}->{+shift};\n    for my $col (0 .. max map {$#$_} @lines) {\n        my $max = max my @widths = map {length $_->[$col]} @lines;\n        for my $row (0 .. $#lines) {\n            my @pad = map {' ' x $_, ' ' x ($_ + 0.5)} ($max - $widths[$row]) / 2;\n            for ($lines[$row][$col])\n                {$_ = join '' => @pad[0 .. $pos-1], $_, @pad[$pos .. $#pad]}\n        }\n    }\n    join '' => map {\"@$_\\n\"} @lines\n}\n\nprint columns <<'END', $_ for qw(left right center);\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    # push onto allterms here if we want the cyclic term to display\n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/factor/;\nsub almost {\n  my($k,$n) = @_;\n  my $i = 1;\n  map { $i++ while scalar factor($i) != $k; $i++ } 1..$n;\n}\nsay \"$_ : \", join(\" \", almost($_,10)) for 1..5;\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nsub k_almost_prime;\n\nfor my $k ( 1 .. 5 ) {\n\tmy $almost = 0;\n\tprint join(\", \", map {\n\t\t1 until k_almost_prime ++$almost, $k;\n\t\t\"$almost\";\n\t} 1 .. 10), \"\\n\";\n}\n\nsub nth_prime;\n\nsub k_almost_prime {\n\tmy ($n, $k) = @_;\n\treturn if $n <= 1 or $k < 1;\n\tmy $which_prime = 0;\n\tfor my $count ( 1 .. $k ) {\n\t\twhile( $n % nth_prime $which_prime ) {\n\t\t\t++$which_prime;\n\t\t}\n\t\t$n /= nth_prime $which_prime;\n\t\treturn if $n == 1 and $count != $k;\n\t}\n\t($n == 1) ? 1 : ();\n}\n\nBEGIN {\n\t# This is loosely based on one of the python solutions\n\t# to the RC Sieve of Eratosthenes task.\n\tmy @primes = (2, 3, 5, 7);\n\tmy $p_iter = 1;\n\tmy $p = $primes[$p_iter];\n\tmy $q = $p*$p;\n\tmy %sieve;\n\tmy $candidate = $primes[-1] + 2;\n\tsub nth_prime {\n\t\tmy $n = shift;\n\t\treturn if $n < 0;\n\t\tOUTER: while( $#primes < $n ) {\n\t\t\twhile( my $s = delete $sieve{$candidate} ) {\n\t\t\t\tmy $next = $s + $candidate;\n\t\t\t\t$next += $s while exists $sieve{$next};\n\t\t\t\t$sieve{$next} = $s;\n\t\t\t\t$candidate += 2;\n\t\t\t}\n\t\t\twhile( $candidate < $q ) {\n\t\t\t\tpush @primes, $candidate;\n\t\t\t\t$candidate += 2;\n\t\t\t\tnext OUTER if exists $sieve{$candidate};\n\t\t\t}\n\t\t\tmy $twop = 2 * $p;\n\t\t\tmy $next = $q + $twop;\n\t\t\t$next += $twop while exists $sieve{$next};\n\t\t\t$sieve{$next} = $twop;\n\t\t\t$p = $primes[++$p_iter];\n\t\t\t$q = $p * $p;\t\n\t\t\t$candidate += 2;\n\t\t}\n\t\treturn $primes[$n];\n\t}\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nuse constant EXIT_FAILURE => 1;\nuse constant EXIT_SUCCESS => 0;\n\nsub amb {\n   exit(EXIT_FAILURE) if !@_;\n   for my $word (@_) {\n      my $pid = fork;\n      die $! unless defined $pid;\n      return $word if !$pid;\n      my $wpid = waitpid $pid, 0;\n      die $! unless $wpid == $pid;\n      exit(EXIT_SUCCESS) if $? == EXIT_SUCCESS;\n   }\n   exit(EXIT_FAILURE);\n}\n\nsub joined {\n   my ($join_a, $join_b) = @_;\n   substr($join_a, -1) eq substr($join_b, 0, 1);\n}\n\nmy $w1 = amb(qw(the that a));\nmy $w2 = amb(qw(frog elephant thing));\nmy $w3 = amb(qw(walked treaded grows));\nmy $w4 = amb(qw(slowly quickly));\n\namb() unless joined $w1, $w2;\namb() unless joined $w2, $w3;\namb() unless joined $w3, $w4;\n\nprint \"$w1 $w2 $w3 $w4\\n\";\nexit(EXIT_SUCCESS);\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse feature 'say';\nuse re 'eval';\n\nsub amb ($@) {\n    my $var = shift;\n    join ' || ', map { \"(?{ $var = '$_' })\" } @_;\n}\n\nsub joins {\n    substr(shift,-1,1) eq substr(shift,0,1)\n}\n\nmy ($a,$b,$c,$d);\n'' =~ m/\n    (??{  amb '$a', qw[the that a]           })\n    (??{  amb '$b', qw[frog elephant thing]  })\n    (??{  amb '$c', qw[walked treaded grows] })\n    (??{  amb '$d', qw[slowly quickly]       })\n    (?(?{ joins($b, $c)                      })|(*FAIL))\n    (?(?{ joins($a, $b)                      })|(*FAIL))\n    (?(?{ joins($c, $d)                      })|(*FAIL))\n    (?{   say \"$a $b $c $d\"                  })\n/x;\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nsub amb {\n   if( @_ == 0 ) {\n      no warnings 'exiting';\n      next AMB;\n   }\n   my $code = pop;\n   my @words = @_;\n   my @index = (0) x @words;\n   AMB: while( 1 ) {\n      my @w = map $words[$_][$index[$_]], 0 .. $#_;\n      return $code->( @w );\n   } continue {\n      my $i = 0;\n      while( ++$index[$i] == @{$words[$i]} ) {\n         $index[$i] = 0;\n         return if ++$i == @index;\n      }\n   }\n}\n\nmy @w1 = qw(the that a);\nmy @w2 = qw(frog elephant thing);\nmy @w3 = qw(walked treaded grows);\nmy @w4 = qw(slowly quickly);\n\nsub joined {\n   my ($join_a, $join_b) = @_;\n   substr($join_a, -1) eq substr($join_b, 0, 1);\n}\n\namb( \\(@w1, @w2, @w3, @w4), sub {\n   my ($w1, $w2, $w3, $w4) = @_;\n   amb() unless joined($w1, $w2);\n   amb() unless joined($w2, $w3);\n   amb() unless joined($w3, $w4);\n   print \"$w1 $w2 $w3 $w4\\n\";\n});\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\nfor my $x (1..20000) {\n  my $y = divisor_sum($x)-$x;\n  say \"$x $y\" if $y > $x && $x == divisor_sum($y)-$y;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use List::Util 'max';\n\nmy @words = split \"\\n\", do { local( @ARGV, $/ ) = ( 'unixdict.txt' ); <> };\nmy %anagram;\nfor my $word (@words) {\n    push @{ $anagram{join '', sort split '', $word} }, $word;\n}\n\nmy $count = max(map {scalar @$_} values %anagram);\nfor my $ana (values %anagram) {\n    print \"@$ana\\n\" if @$ana == $count;\n}\n"
  },
  {
    "language": "Perl",
    "code": "push @{$anagram{ join '' => sort split '' }}, $_ for @words;\n$max > @$_  or  $max = @$_    for values %anagram;\n@$_ == $max and print \"@$_\\n\" for values %anagram;\n"
  },
  {
    "language": "Perl",
    "code": "sub deranged {                          # only anagrams ever get here\n        my @a = split('', shift);       # split word into letters\n        my @b = split('', shift);\n        for (0 .. $#a) {\n                $a[$_] eq $b[$_] and return;\n        }\n        return 1\n}\n\nsub find_deranged {\n        for my $i ( 0 .. $#_ ) {\n                for my $j ( $i+1 .. $#_ ) {\n                        next unless deranged $_[$i], $_[$j];\n\n                        print \"length \", length($_[$i]), \": $_[$i] => $_[$j]\\n\";\n                        return 1;\n                }\n        }\n}\n\nmy %letter_list;\nopen my $in, 'unixdict.txt';\n\nlocal $/ = undef;\n\nfor (split(' ', <$in>)) {\n        # store anagrams in hash table by letters they contain\n        push @{ $letter_list{ join('', sort split('', $_)) } }, $_\n}\n\nfor (   sort { length($b) <=> length($a) }      # sort by length, descending\n        grep { @{ $letter_list{$_} } > 1 }      # take only ones with anagrams\n        keys %letter_list               )\n{\n        # if we find a pair, they are the longested due to the sort before\n        last if find_deranged(@{ $letter_list{$_} });\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Tk;\nuse Math::Trig qw/:pi/;\n\nmy $root =  new MainWindow( -title => 'Pendulum Animation' );\nmy $canvas = $root->Canvas(-width => 320, -height => 200);\nmy $after_id;\n\nfor ($canvas) {\n\t$_->createLine(   0,  25, 320,  25, -tags => [qw/plate/], -width => 2, -fill => 'grey50' );\n\t$_->createOval( 155,  20, 165,  30, -tags => [qw/pivot outline/], -fill => 'grey50' );\n\t$_->createLine(   1,   1,    1,  1, -tags => [qw/rod width/], -width => 3, -fill => 'black' );\n\t$_->createOval(   1,   1,    2,  2, -tags => [qw/bob outline/], -fill => 'yellow' );\n}\n\n$canvas->raise('pivot');\n$canvas->pack(-fill => 'both', -expand => 1);\nmy ($Theta, $dTheta, $length, $homeX, $homeY) =\n\t(45, 0, 150, 160, 25);\n\nsub show_pendulum {\n  my $angle = $Theta * pi() / 180;\n  my $x = $homeX + $length * sin($angle);\n  my $y = $homeY + $length * cos($angle);\n  $canvas->coords('rod', $homeX, $homeY, $x, $y);\n  $canvas->coords('bob', $x-15, $y-15, $x+15, $y+15);\n}\n\n\n\nsub recompute_angle {\n  my $scaling = 3000.0 / ($length ** 2);\n  # first estimate\n  my $firstDDTheta = -sin($Theta * pi / 180) * $scaling;\n  my $midDTheta = $dTheta + $firstDDTheta;\n  my $midTheta = $Theta + ($dTheta + $midDTheta)/2;\n  # second estimate\n  my $midDDTheta = -sin($midTheta * pi/ 180) * $scaling;\n  $midDTheta = $dTheta + ($firstDDTheta + $midDDTheta)/2;\n  $midTheta = $Theta + ($dTheta + $midDTheta)/2;\n  # again, first\n  $midDDTheta = -sin($midTheta * pi/ 180) * $scaling;\n  my $lastDTheta = $midDTheta + $midDDTheta;\n  my $lastTheta = $midTheta + ($midDTheta + $lastDTheta)/2;\n  # again, second\n  my $lastDDTheta = -sin($lastTheta * pi/180) * $scaling;\n  $lastDTheta = $midDTheta + ($midDDTheta + $lastDDTheta)/2;\n  $lastTheta = $midTheta + ($midDTheta + $lastDTheta)/2;\n  # Now put the values back in our globals\n  $dTheta  = $lastDTheta;\n  $Theta = $lastTheta;\n}\n\n\nsub animate {\n  recompute_angle;\n  show_pendulum;\n  $after_id = $root->after(15 => sub {animate() });\n}\n\nshow_pendulum;\n$after_id = $root->after(500 => sub {animate});\n\n$canvas->bind('<Destroy>' => sub {$after_id->cancel});\nMainLoop;\n"
  },
  {
    "language": "Perl",
    "code": "use Tk;\nuse Time::HiRes qw(sleep);\n\nmy $msg    = 'Hello World! ';\nmy $first  = '.+';\nmy $second = '.';\n\nmy $mw = Tk::MainWindow->new(-title => 'Animated side-scroller',-bg=>\"white\");\n$mw->geometry (\"400x150+0+0\");\n\n$mw->optionAdd('*Label.font', 'Courier 24 bold' );\n\nmy $scroller = $mw->Label(-text => \"$msg\")->grid(-row=>0,-column=>0);\n$mw->bind('all'=> '<Key-Escape>' => sub {exit;});\n$mw->bind(\"<Button>\" => sub { ($second,$first) = ($first,$second) });\n\n$scroller->after(1, \\&display );\nMainLoop;\n\nsub display {\n    while () {\n        sleep 0.25;\n        $msg =~ s/($first)($second)/$2$1/;\n        $scroller->configure(-text=>\"$msg\");\n        $mw->update();\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub recur (&@) {\n    my $f = shift;\n    local *recurse = $f;\n    $f->(@_);\n}\n\nsub fibo {\n    my $n = shift;\n    $n < 0 and die 'Negative argument';\n    recur {\n        my $m = shift;\n        $m < 3 ? 1 : recurse($m - 1) + recurse($m - 2);\n    } $n;\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub fib {\n\tmy ($n) = @_;\n\tdie \"negative arg $n\" if $n < 0;\n\t# put anon sub on stack and do a magic goto to it\n\t@_ = ($n, sub {\n\t\tmy ($n, $f) = @_;\n\t\t# anon sub recurs with the sub ref on stack\n\t\t$n < 2 ? $n : $f->($n - 1, $f) + $f->($n - 2, $f)\n\t});\n\tgoto $_[1];\n}\n\nprint(fib($_), \" \") for (0 .. 10);\n"
  },
  {
    "language": "Perl",
    "code": "sub fibo {\n    my $n = shift;\n    $n < 0 and die 'Negative argument';\n    no strict 'refs';\n    $n < 3 ? 1 : (caller(0))[3]->($n - 1) + (caller(0))[3]->($n - 2);\n}\n"
  },
  {
    "language": "Perl",
    "code": "use v5.16;\nsay sub {\n  my $n = shift;\n  $n < 2 ? $n : __SUB__->($n-2) + __SUB__->($n-1)\n}->($_) for 0..10\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nuse Fcntl qw( :flock SEEK_END );\n\nuse constant {\n    RECORD_FIELDS => [qw( account password UID GID GECOS directory shell )],\n    GECOS_FIELDS  => [qw( fullname office extension homephone email )],\n    RECORD_SEP    => ':',\n    GECOS_SEP     => ',',\n    PASSWD_FILE   => 'passwd.txt',\n};\n\n# here's our three records\nmy $records_to_write = [\n    {\n        account  => 'jsmith',\n        password => 'x',\n        UID      => 1001,\n        GID      => 1000,\n        GECOS    => {\n            fullname  => 'John Smith',\n            office    => 'Room 1007',\n            extension => '(234)555-8917',\n            homephone => '(234)555-0077',\n            email     => 'jsmith@rosettacode.org',\n        },\n        directory => '/home/jsmith',\n        shell     => '/bin/bash',\n    },\n    {\n        account  => 'jdoe',\n        password => 'x',\n        UID      => 1002,\n        GID      => 1000,\n        GECOS    => {\n            fullname  => 'Jane Doe',\n            office    => 'Room 1004',\n            extension => '(234)555-8914',\n            homephone => '(234)555-0044',\n            email     => 'jdoe@rosettacode.org',\n        },\n        directory => '/home/jdoe',\n        shell     => '/bin/bash',\n    },\n];\nmy $record_to_append = {\n    account  => 'xyz',\n    password => 'x',\n    UID      => 1003,\n    GID      => 1000,\n    GECOS    => {\n        fullname  => 'X Yz',\n        office    => 'Room 1003',\n        extension => '(234)555-8913',\n        homephone => '(234)555-0033',\n        email     => 'xyz@rosettacode.org',\n    },\n    directory => '/home/xyz',\n    shell     => '/bin/bash',\n};\n\nsub record_to_string {\n    my $rec    = shift;\n    my $sep    = shift // RECORD_SEP;\n    my $fields = shift // RECORD_FIELDS;\n    my @ary;\n    for my $field (@$fields) {\n        my $r = $rec->{$field};\n        die \"Field '$field' not found\" unless defined $r;    # simple sanity check\n        push @ary, ( $field eq 'GECOS' ? record_to_string( $r, GECOS_SEP, GECOS_FIELDS ) : $r );\n    }\n    return join $sep, @ary;\n}\n\nsub write_records_to_file {\n    my $records  = shift;\n    my $filename = shift // PASSWD_FILE;\n    open my $fh, '>>', $filename or die \"Can't open $filename: $!\";\n    flock( $fh, LOCK_EX ) or die \"Can't lock $filename: $!\";\n    # if someone appended while we were waiting...\n    seek( $fh, 0, SEEK_END ) or die \"Can't seek $filename: $!\" ;\n    print $fh record_to_string($_), \"\\n\" for @$records;\n    flock( $fh, LOCK_UN ) or die \"Can't unlock $filename: $!\";\n    # note: the file is closed automatically when function returns (and refcount of $fh becomes 0)\n}\n\n# write two records to file\nwrite_records_to_file( $records_to_write );\n\n# append one more record to file\nwrite_records_to_file( [$record_to_append] );\n\n# test\n{\n    use Test::Simple tests => 1;\n\n    open my $fh, '<', PASSWD_FILE or die \"Can't open \", PASSWD_FILE, \": $!\";\n    my @lines = <$fh>;\n    chomp @lines;\n    ok(\n        $lines[-1] eq\n'xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash',\n        \"Appended record: $lines[-1]\"\n    );\n}\n"
  },
  {
    "language": "Perl",
    "code": "# create array\nmy @a = (1, 2, 3, 4, 5);\n\n# create callback function\nsub mycallback {\n  return 2 * shift;\n}\n\n# use array indexing\nfor (my $i = 0; $i < scalar @a; $i++) {\n  print \"mycallback($a[$i]) = \", mycallback($a[$i]), \"\\n\";\n}\n\n# using foreach\nforeach my $x (@a) {\n  print \"mycallback($x) = \", mycallback($x), \"\\n\";\n}\n\n# using map (useful for transforming an array)\nmy @b = map mycallback($_), @a;                # @b is now (2, 4, 6, 8, 10)\n\n# and the same using an anonymous function\nmy @c = map { $_ * 2 } @a;                     # @c is now (2, 4, 6, 8, 10)\n\n# use a callback stored in a variable\nmy $func = \\&mycallback;\nmy @d = map $func->($_), @a;                  # @d is now (2, 4, 6, 8, 10)\n\n# filter an array\nmy @e = grep { $_ % 2 == 0 } @a;               # @e is now (2, 4)\n"
  },
  {
    "language": "Perl",
    "code": "use Math::BigInt;\nmy $x = Math::BigInt->new('5') ** Math::BigInt->new('4') ** Math::BigInt->new('3') ** Math::BigInt->new('2');\nmy $y = \"$x\";\nprintf(\"5**4**3**2 = %s...%s and has %i digits\\n\", substr($y,0,20), substr($y,-20), length($y));\n"
  },
  {
    "language": "Perl",
    "code": "use bigint;\nmy $x = 5**4**3**2;\nmy $y = \"$x\";\nprintf(\"5**4**3**2 = %s...%s and has %i digits\\n\", substr($y,0,20), substr($y,-20), length($y));\n"
  },
  {
    "language": "Perl",
    "code": "$ time perl transparent-bigint.pl\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n    1m4.28s real     1m4.30s user     0m0.00s system\n"
  },
  {
    "language": "Perl",
    "code": "use Math::Complex;\nmy $a = 1 + 1*i;\nmy $b = 3.14159 + 1.25*i;\n\nprint \"$_\\n\" foreach\n    $a + $b,    # addition\n    $a * $b,    # multiplication\n    -$a,        # negation\n    1 / $a,     # multiplicative inverse\n    ~$a;        # complex conjugate\n"
  },
  {
    "language": "Perl",
    "code": "sub ev\n# Evaluates an arithmetic expression like \"(1+3)*7\" and returns\n# its value.\n {my $exp = shift;\n  # Delete all meaningless characters. (Scientific notation,\n  # infinity, and not-a-number aren't supported.)\n  $exp =~ tr {0-9.+-/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  # ??{ ... } interpolates lazily (only when necessary),\n  # permitting recursion to arbitrary depths.\n\n  sub astize\n  # Constructs an abstract syntax tree by recursively\n  # transforming textual arithmetic expressions into array\n  # references of the form [operator, left oprand, right oprand].\n   {my $exp = shift;\n    # If $exp is just a number, return it as-is.\n    $exp =~ /[^0-9.]/ or return $exp;\n    # If parentheses surround the entire expression, get rid of\n    # them.\n    $exp = substr($exp, 1, -1)\n        while $exp =~ /\\A($balanced_paren_regex)\\z/;\n    # Replace stuff in parentheses with placeholders.\n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$#paren_contents]\"}eg;\n    # Scan for operators in order of increasing precedence,\n    # preferring the rightmost.\n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*/]) (.+)}x or\n        # The expression must've been malformed somehow.\n        # (Note that unary minus isn't supported.)\n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    # Restore the parenthetical expressions.\n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    # And recurse.\n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '/' => sub {$_[0] / $_[1]});\n\n  sub ev_ast\n  # Evaluates an abstract syntax tree of the form returned by\n  # &astize.\n   {my $ast = shift;\n    # If $ast is just a number, return it as-is.\n    ref $ast or return $ast;\n    # Otherwise, recurse.\n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}\n"
  },
  {
    "language": "Perl",
    "code": "use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   # Get number of digits from command line\nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Math::BigFloat;\n\nMath::BigFloat->div_scale(100);\n\nmy $a = my $n = 1;\nmy $g = 1 / sqrt(Math::BigFloat->new(2));\nmy $z = 0.25;\nfor( 0 .. 17 ) {\n\tmy $x = [ ($a + $g) * 0.5, sqrt($a * $g) ];\n\tmy $var = $x->[0] - $a;\n\t$z -= $var * $var * $n;\n\t$n += $n;\n\t($a, $g) = @$x;\n}\nprint $a * $a / $z, \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl -w\n\nmy ($a0, $g0, $a1, $g1);\n\nsub agm($$) {\n    $a0 = shift;\n    $g0 = shift;\n    do {\n        $a1 = ($a0 + $g0)/2;\n        $g1 = sqrt($a0 * $g0);\n        $a0 = ($a1 + $g1)/2;\n        $g0 = sqrt($a1 * $g1);\n    } while ($a0 != $a1);\n    return $a0;\n}\n\nprint agm(1, 1/sqrt(2)).\"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "my $a = <>;\nmy $b = <>;\n\nprint\n    \"sum:              \", $a + $b, \"\\n\",\n    \"difference:       \", $a - $b, \"\\n\",\n    \"product:          \", $a * $b, \"\\n\",\n    \"integer quotient: \", int($a / $b), \"\\n\",\n    \"remainder:        \", $a % $b, \"\\n\",\n    \"exponent:         \", $a ** $b, \"\\n\"\n    ;\n"
  },
  {
    "language": "Perl",
    "code": "use bigrat;\n\nforeach my $candidate (2 .. 2**19) {\n    my $sum = 1 / $candidate;\n    foreach my $factor (2 .. sqrt($candidate)+1) {\n        if ($candidate % $factor == 0) {\n            $sum += 1 / $factor + 1 / ($candidate / $factor);\n        }\n    }\n    if ($sum->denominator() == 1) {\n        print \"Sum of recipr. factors of $candidate = $sum exactly \", ($sum == 1 ? \"perfect!\" : \"\"), \"\\n\";\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "my @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\nmy @arr3 = (@arr1, @arr2);\n"
  },
  {
    "language": "Perl",
    "code": "my @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\npush @arr1, @arr2;\nprint \"@arr1\\n\"; # prints \"1 2 3 4 5 6\"\n"
  },
  {
    "language": "Perl",
    "code": " my @empty;\n my @empty_too = ();\n\n my @populated   = ('This', 'That', 'And', 'The', 'Other');\n print $populated[2];  # And\n\n my $aref = ['This', 'That', 'And', 'The', 'Other'];\n print $aref->[2];  # And\n"
  },
  {
    "language": "Perl",
    "code": "my @arr;\n\npush @arr, 1;\npush @arr, 3;\n\n$arr[0] = 2;\n\nprint $arr[0];\n"
  },
  {
    "language": "Perl",
    "code": " my @multi_dimensional = (\n     [0, 1, 2, 3],\n     [qw(a b c d e f g)],\n     [qw(! $ % & *)],\n );\n"
  },
  {
    "language": "Perl",
    "code": "print \"Give me a number: \";\nchomp(my $a = <>);\n\n$a == 42 or die \"Error message\\n\";\n\n# Alternatives\ndie \"Error message\\n\" unless $a == 42;\ndie \"Error message\\n\" if not $a == 42;\ndie \"Error message\\n\" if $a != 42;\n"
  },
  {
    "language": "Perl",
    "code": "open my $fh, '<', 'file'\n    or die \"Cannot open file: $!\\n\"; # $! contains the error message from the last error\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfor ($i = 1; $i <= 100; $i++) {\n\t$root = sqrt($i);\n\t$state = ($root == ceil($root)) ? 'open' : 'closed';\n\techo \"Door {$i}: {$state}\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$doors = array_fill(1, 100, false);\nfor ($pass = 1; $pass <= 100; ++$pass) {\n\tfor ($nr = 1; $nr <= 100; ++$nr) {\n\t\tif ($nr % $pass == 0) {\n\t\t\t$doors[$nr] = !$doors[$nr];\n\t\t}\n\t}\n}\nfor ($nr = 1; $nr <= 100; ++$nr)\n\tprintf(\"Door %d: %s\\n\", $nr, ($doors[$nr])?'open':'closed');\n?>\n"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/env php\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n<?php\n\nwhile (true) {\n    $numbers = make_numbers();\n\n    for ($iteration_num = 1; ; $iteration_num++) {\n        echo \"Expresion $iteration_num: \";\n\n        $entry = rtrim(fgets(STDIN));\n\n        if ($entry === '!') break;\n        if ($entry === 'q') exit;\n\n        $result = play($numbers, $entry);\n\n        if ($result === null) {\n            echo \"That's not valid\\n\";\n            continue;\n        }\n        elseif ($result != 24) {\n            echo \"Sorry, that's $result\\n\";\n            continue;\n        }\n        else {\n            echo \"That's right! 24!!\\n\";\n            exit;\n        }\n    }\n}\n\nfunction make_numbers() {\n    $numbers = array();\n\n    echo \"Your four digits: \";\n\n    for ($i = 0; $i < 4; $i++) {\n        $number = rand(1, 9);\n        // The check is needed to avoid E_NOTICE from PHP\n        if (!isset($numbers[$number])) {\n            $numbers[$number] = 0;\n        }\n        $numbers[$number]++;\n        print \"$number \";\n    }\n\n    print \"\\n\";\n\n    return $numbers;\n}\n\nfunction play($numbers, $expression) {\n    $operator = true;\n    for ($i = 0, $length = strlen($expression); $i < $length; $i++) {\n        $character = $expression[$i];\n\n        if (in_array($character, array('(', ')', ' ', \"\\t\"))) continue;\n\n        $operator = !$operator;\n\n        if (!$operator) {\n            if (!empty($numbers[$character])) {\n                $numbers[$character]--;\n                continue;\n            }\n            return;\n        }\n        elseif (!in_array($character, array('+', '-', '*', '/'))) {\n            return;\n        }\n    }\n\n    foreach ($numbers as $remaining) {\n        if ($remaining > 0) {\n            return;\n        }\n    }\n\n    return eval(\"return $expression;\");\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$plural = 's';\nforeach (range(99, 1) as $i) {\n    echo \"$i bottle$plural of beer on the wall,\\n\";\n    echo \"$i bottle$plural of beer!\\n\";\n    echo \"Take one down, pass it around!\\n\";\n    if ($i - 1 == 1)\n        $plural = '';\n\n    if ($i > 1)\n        echo ($i - 1) . \" bottle$plural of beer on the wall!\\n\\n\";\n    else\n        echo \"No more bottles of beer on the wall!\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nforeach(range(99,1) as $i) {\n    $p = ($i>1)?\"s\":\"\";\n    echo <<< EOV\n$i bottle$p of beer on the wall\n$i bottle$p of beer\nTake one down, pass it around\n\n\nEOV;\n}\necho \"No more Bottles of beer on the wall\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$verse = <<<VERSE\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\n\nVERSE;\n\nforeach (range(1,99) as $i) { // loop 99 times\n    $verse = preg_replace('/\\d+/e', '$0 - 1', $verse);\n    $verse = preg_replace('/\\b1 bottles/', '1 bottle', $verse);\n    $verse = preg_replace('/\\b0 bottle/', 'No bottles', $verse);\n\n    echo $verse;\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  for($i=100;$i>0;$i--){\n    $p2=$i.\" bottle\".(($i>1)?\"s\":\"\").\" of beer\";\n    $p1=$p2.\" on the wall\\n\";\n    $p3=\"Take one down, pass it around\\n\";\n    echo (($i<100)?$p1.\"\\n\":\"\").$p1.$p2.\"\\n\".$p3.(($i<2)?($i-1).substr($p1,1,28):\"\");\n  }\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$bottles = 99;\n\nwhile ($bottles > 0) {\n\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer on the wall\\n\", $bottles);\t\t//X bottles of beer on the wall\n\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer\\n\", $bottles);\t\t\t\t//X bottles of beer\n\tprintf(\"Take one down, pass it around\\n\");\t\t\t\t\t\t\t\t\t\t//Take one down, pass it around\n\n\t$bottles--;\n\n\tif ($bottles > 0) {\n\t\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer on the wall\\n\\n\", $bottles);\t//X bottles of beer on the wall\n\t}\n}\nprintf('No more bottles of beer on the wall');\t\t\t\t\t\t\t\t\t\t\t//No more bottles of beer on the wall\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$lyrics = <<<ENDVERSE\n%2\\$d bottle%1\\$s of beer on the wall\n%2\\$d bottle%1\\$s of beer\nTake one down, pass it around\n%4\\$s bottle%3\\$s of beer on the wall\n\n\nENDVERSE;\n\n$x = 99;\nwhile ( $x > 0 ) {\n   printf( $lyrics, $x != 1 ? 's' : '', $x--, $x != 1 ? 's' : '', $x > 0 ? $x : 'No more' );\n}\n"
  },
  {
    "language": "PHP",
    "code": "fscanf(STDIN, \"%d %d\\n\", $a, $b); //Reads 2 numbers from STDIN\necho ($a + $b) . \"\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "$in = fopen(\"input.dat\", \"r\");\nfscanf($in, \"%d %d\\n\", $a, $b); //Reads 2 numbers from file $in\nfclose($in);\n\n$out = fopen(\"output.dat\", \"w\");\nfwrite($out, ($a + $b) . \"\\n\");\nfclose($out);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = array(\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\");\n\nfunction canMakeWord($word) {\n    $word = strtoupper($word);\n    $blocks = array(\n            \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n            \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n            \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n            \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n    );\n\n    foreach (str_split($word) as $char) {\n        foreach ($blocks as $k => $block) {\n            if (strpos($block, $char) !== FALSE) {\n                unset($blocks[$k]);\n                continue(2);\n            }\n        }\n        return false;\n    }\n    return true;\n}\n\nforeach ($words as $word) {\n    echo $word.': ';\n    echo canMakeWord($word) ? \"True\" : \"False\";\n    echo \"\\r\\n\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "abstract class Abs {\n\tabstract public function method1($value);\n\tabstract protected function method2($name);\n\tfunction add($a, $b){\n\t\treturn a + b;\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "interface Inter {\n\tpublic function method1($value);\n\tpublic function method2($name);\n\tpublic function add($a, $b);\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction accumulator($start){\n return create_function('$x','static $v='.$start.';return $v+=$x;');\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; //prints 10\necho $acc(10), \"\\n\"; //prints 20\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction accumulator($sum){\n return function ($x) use (&$sum) { return $sum += $x; };\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; //prints 10\necho $acc(10), \"\\n\"; //prints 20\n?>\n"
  },
  {
    "language": "PHP",
    "code": "function ackermann( $m , $n )\n{\n    if ( $m==0 )\n    {\n        return $n + 1;\n    }\n    elseif ( $n==0 )\n    {\n        return ackermann( $m-1 , 1 );\n    }\n    return ackermann( $m-1, ackermann( $m , $n-1 ) );\n}\n\necho ackermann( 3, 4 );\n// prints 125\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$ldap = ldap_connect($hostname, $port);\n$success = ldap_bind($ldap, $username, $password);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$l = ldap_connect('ldap.example.com');\nldap_set_option($l, LDAP_OPT_PROTOCOL_VERSION, 3);\nldap_set_option($l, LDAP_OPT_REFERRALS, false);\n\n$bind = ldap_bind($l, 'me@example.com', 'password');\n\n$base = 'dc=example, dc=com';\n$criteria = '(&(objectClass=user)(sAMAccountName=username))';\n$attributes = array('displayName', 'company');\n\n$search = ldap_search($l, $base, $criteria, $attributes);\n$entries = ldap_get_entries($l, $search);\n\nvar_dump($entries);\n"
  },
  {
    "language": "PHP",
    "code": "class E {};\n\n$e=new E();\n\n$e->foo=1;\n\n$e->{\"foo\"} = 1; // using a runtime name\n$x = \"foo\";\n$e->$x = 1; // using a runtime name in a variable\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$j2justtype = array('L' => STR_PAD_RIGHT,\n                    'R' => STR_PAD_LEFT,\n                    'C' => STR_PAD_BOTH);\n\n/**\n Justify columns of textual tabular input where the record separator is the newline\n and the field separator is a 'dollar' character.\n justification can be L, R, or C; (Left, Right, or Centered).\n\n Return the justified output as a string\n*/\nfunction aligner($str, $justification = 'L') {\n  global $j2justtype;\n  assert(array_key_exists($justification, $j2justtype));\n  $justtype = $j2justtype[$justification];\n\n  $fieldsbyrow = array();\n  foreach (explode(\"\\n\", $str) as $line)\n    $fieldsbyrow[] = explode('$', $line);\n  $maxfields = max(array_map('count', $fieldsbyrow));\n\n  foreach (range(0, $maxfields-1) as $col) {\n    $maxwidth = 0;\n    foreach ($fieldsbyrow as $fields)\n      $maxwidth = max($maxwidth, strlen($fields[$col]));\n    foreach ($fieldsbyrow as &$fields)\n      $fields[$col] = str_pad($fields[$col], $maxwidth, ' ', $justtype);\n    unset($fields); // see http://bugs.php.net/29992\n  }\n  $result = '';\n  foreach ($fieldsbyrow as $fields)\n    $result .= implode(' ', $fields) . \"\\n\";\n  return $result;\n}\n\n$textinfile = 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$\\'dollar\\'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.';\n\nforeach (array('L', 'R', 'C') as $j)\n  echo aligner($textinfile, $j);\n\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = file(\n    'http://www.puzzlers.org/pub/wordlists/unixdict.txt',\n    FILE_IGNORE_NEW_LINES\n);\n$length = 0;\n\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $chars = implode(\"\", $chars);\n    $length = strlen($chars);\n    $anagrams[$length][$chars][] = $word;\n}\n\nkrsort($anagrams);\n\nforeach ($anagrams as $anagram) {\n    $final_words = array();\n    foreach ($anagram as $words) {\n        if (count($words) >= 2) {\n            $counts = array();\n            foreach ($words as $word) {\n                $counts[$word] = array($word);\n                foreach ($words as $second_word) {\n                    for ($i = 0, $length = strlen($word); $i < $length; $i++) {\n                        if ($word[$i] === $second_word[$i]) continue 2;\n                    }\n                    $counts[$word][] = $second_word;\n                }\n            }\n            $max = 0;\n            $max_key = '';\n            foreach ($counts as $name => $count) {\n                if (count($count) > $max) {\n                    $max = count($count);\n                    $max_key = $name;\n                }\n            }\n            if ($max > 1) {\n                $final_words[] = $counts[$max_key];\n            }\n        }\n    }\n    if ($final_words) break;\n}\n\nforeach ($final_words as $final_word) {\n    echo implode(\" \", $final_word), \"\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = explode(\"\\n\", file_get_contents('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'));\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $anagram[implode($chars)][] = $word;\n}\n\n$best = max(array_map('count', $anagram));\nforeach ($anagram as $ana)\n    if (count($ana) == $best)\n        print_r($ana);\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) { // This function must be called using call_user_func() only\n        if ($n < 2)\n            return 1;\n        else {\n            $g = debug_backtrace()[1]['args'][0];\n            return call_user_func($g, $n-1) + call_user_func($g, $n-2);\n        }\n    };\n    return call_user_func($f, $n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) use (&$f) {\n        if ($n < 2)\n            return 1;\n        else\n            return $f($n-1) + $f($n-2);\n    };\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass fib_helper {\n    function __invoke($n) {\n        if ($n < 2)\n            return 1;\n        else\n            return $this($n-1) + $this($n-2);\n    }\n}\n\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = new fib_helper();\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$filename = '/tmp/passwd';\n\n$data = array(\n    'account:password:UID:GID:fullname,office,extension,homephone,email:directory:shell' . PHP_EOL,\n    'jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash' . PHP_EOL,\n    'jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jdoe:/bin/bash' . PHP_EOL,\n);\nfile_put_contents($filename, $data, LOCK_EX);\n\necho 'File contents before new record added:', PHP_EOL, file_get_contents($filename), PHP_EOL;\n\n$data = array(\n    'xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash' . PHP_EOL\n);\nfile_put_contents($filename, $data, FILE_APPEND | LOCK_EX);\n\necho 'File contents after new record added:', PHP_EOL, file_get_contents($filename), PHP_EOL;\n"
  },
  {
    "language": "PHP",
    "code": "function cube($n)\n{\n   return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$y = bcpow('5', bcpow('4', bcpow('3', '2')));\nprintf(\"5**4**3**2 = %s...%s and has %d digits\\n\", substr($y,0,20), substr($y,-20), strlen($y));\n?>\n"
  },
  {
    "language": "PHP",
    "code": "define('PRECISION', 13);\n\nfunction agm($a0, $g0, $tolerance = 1e-10)\n{\n    // the bc extension deals in strings and cannot convert\n    // floats in scientific notation by itself - hence\n    // this manual conversion to a string\n    $limit = number_format($tolerance, PRECISION, '.', '');\n    $an    = $a0;\n    $gn    = $g0;\n    do {\n        list($an, $gn) = array(\n            bcdiv(bcadd($an, $gn), 2),\n            bcsqrt(bcmul($an, $gn)),\n        );\n    } while (bccomp(bcsub($an, $gn), $limit) > 0);\n\n    return $an;\n}\n\nbcscale(PRECISION);\necho agm(1, 1 / bcsqrt(2));\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$a = fgets(STDIN);\n$b = fgets(STDIN);\n\necho\n    \"sum:                 \", $a + $b, \"\\n\",\n    \"difference:          \", $a - $b, \"\\n\",\n    \"product:             \", $a * $b, \"\\n\",\n    \"truncating quotient: \", (int)($a / $b), \"\\n\",\n    \"flooring quotient:   \", floor($a / $b), \"\\n\",\n    \"remainder:           \", $a % $b, \"\\n\",\n    \"power:               \", $a ** $b, \"\\n\"; // PHP 5.6+ only\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$arr1 = array(1, 2, 3);\n$arr2 = array(4, 5, 6);\n$arr3 = array_merge($arr1, $arr2);\n"
  },
  {
    "language": "PHP",
    "code": "$NumberArray = array(0, 1, 2, 3, 4, 5, 6);\n$LetterArray = array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n$simpleForm = ['apple', 'orange'];\n"
  },
  {
    "language": "PHP",
    "code": "echo $CustomKeyArray[\"b\"]; // Returns C\n"
  },
  {
    "language": "PHP",
    "code": "$BlankArray = array();\n"
  },
  {
    "language": "PHP",
    "code": "$BlankArray[] = \"Not Blank Anymore\";\n"
  },
  {
    "language": "PHP",
    "code": "$AssignArray[\"CertainKey\"] = \"Value\";\n"
  },
  {
    "language": "PHP",
    "code": "$MultiArray = array(\n                array(0, 0, 0, 0, 0, 0),\n                array(1, 1, 1, 1, 1, 1),\n                array(2, 2, 2, 2, 2, 2),\n                array(3, 3, 3, 3, 3, 3)\n          );\n"
  },
  {
    "language": "PHP",
    "code": "$arr = ['apple', 'orange'];\narray_push($arr, 'pear');\nprint implode(',', $arr); // Returns apple,orange,pear\n"
  },
  {
    "language": "PHP",
    "code": "echo $NumberArray[5]; // Returns 5\necho $LetterArray[5]; // Returns f\n"
  },
  {
    "language": "PHP",
    "code": "echo $MultiArray[1][5]; // 2\n"
  },
  {
    "language": "PHP",
    "code": "print_r($MultiArray);\n"
  },
  {
    "language": "PHP",
    "code": "Array(\n    0 => array(\n            0 => 0\n            1 => 0\n            2 => 0\n            3 => 0\n            4 => 0\n            5 => 0\n         )\n    1 => array(\n            0 => 1\n            1 => 1\n            2 => 1\n            3 => 1\n            4 => 1\n            5 => 1\n         )\n    2 => array(\n            0 => 2\n            1 => 2\n            2 => 2\n            3 => 2\n            4 => 2\n            5 => 2\n         )\n    3 => array(\n            0 => 3\n            1 => 3\n            2 => 3\n            3 => 3\n            4 => 3\n            5 => 3\n         )\n)\n"
  },
  {
    "language": "PHP",
    "code": "$StartIndexAtOne = array(1 => \"A\", \"B\", \"C\", \"D\");\n"
  },
  {
    "language": "PHP",
    "code": "$CustomKeyArray = array(\"d\" => \"A\", \"c\" => \"B\", \"b\" =>\"C\", \"a\" =>\"D\");\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$a = 5\n#...input or change $a here\nassert($a == 42) # when $a is not 42, take appropriate actions,\n                 # which is set by assert_options()\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$array = array();\n$array = []; // Simpler form of array initialization\n$array['foo'] = 'bar';\n$array['bar'] = 'foo';\n\necho($array['foo']); // bar\necho($array['moo']); // Undefined index\n\n// Alternative (inline) way\n$array2 = array('fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green');\n\n// Another alternative (simpler) way\n$array2 = ['fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green'];\n\n// Check if key exists in the associative array\necho(isset($array['foo'])); // Faster, but returns false if the value of the element is set to null\necho(array_key_exists('foo', $array)); // Slower, but returns true if the value of the element is null\n"
  },
  {
    "language": "PHP",
    "code": "foreach($array as $key => $value)\n{\n   echo \"Key: $key Value: $value\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$pairs = array( \"hello\" => 1,\n\t\t\"world\" => 2,\n\t\t\"!\"     => 3 );\n\n// iterate over key-value pairs\nforeach($pairs as $k => $v) {\n  echo \"(k,v) = ($k, $v)\\n\";\n}\n\n// iterate over keys\nforeach(array_keys($pairs) as $key) {\n  echo \"key = $key, value = $pairs[$key]\\n\";\n}\n\n// iterate over values\nforeach($pairs as $value) {\n  echo \"values = $value\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$nums = array(3, 1, 4, 1, 5, 9);\nif ($nums)\n    echo array_sum($nums) / count($nums), \"\\n\";\nelse\n    echo \"0\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$samples = array(\n\t'1st' => array(350, 10),\n\t'2nd' => array(90, 180, 270, 360),\n\t'3rd' => array(10, 20, 30)\n);\n\nforeach($samples as $key => $sample){\n\techo 'Mean angle for ' . $key . ' sample: ' . meanAngle($sample) . ' degrees.' . PHP_EOL;\n}\n\nfunction meanAngle ($angles){\n\t$y_part = $x_part = 0;\n\t$size = count($angles);\n\tfor ($i = 0; $i < $size; $i++){\n\t\t$x_part += cos(deg2rad($angles[$i]));\n\t\t$y_part += sin(deg2rad($angles[$i]));\n\t}\n\t$x_part /= $size;\n\t$y_part /= $size;\n\treturn rad2deg(atan2($y_part, $x_part));\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction time2ang($tim) {\n        if (!is_string($tim)) return $tim;\n        $parts = explode(':',$tim);\n        if (count($parts)!=3) return $tim;\n        $sec = ($parts[0]*3600)+($parts[1]*60)+$parts[2];\n        $ang = 360.0 * ($sec/86400.0);\n        return $ang;\n}\nfunction ang2time($ang) {\n        if (!is_numeric($ang)) return $ang;\n        $sec = 86400.0 * $ang / 360.0;\n        $parts = array(floor($sec/3600),floor(($sec % 3600)/60),$sec % 60);\n        $tim = sprintf('%02d:%02d:%02d',$parts[0],$parts[1],$parts[2]);\n        return $tim;\n}\nfunction meanang($ang) {\n        if (!is_array($ang)) return $ang;\n        $sins = 0.0;\n        $coss = 0.0;\n        foreach($ang as $a) {\n                $sins += sin(deg2rad($a));\n                $coss += cos(deg2rad($a));\n        }\n        $avgsin = $sins / (0.0+count($ang));\n        $avgcos = $coss / (0.0+count($ang));\n        $avgang = rad2deg(atan2($avgsin,$avgcos));\n        while ($avgang < 0.0) $avgang += 360.0;\n        return $avgang;\n}\n$bats = array('23:00:17','23:40:20','00:12:45','00:17:19');\n$angs = array();\nforeach ($bats as $t) $angs[] = time2ang($t);\n$ma = meanang($angs);\n$result = ang2time($ma);\nprint \"The mean time of day is $result (angle $ma).\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "function median($arr)\n{\n    sort($arr);\n    $count = count($arr); //count the number of values in array\n    $middleval = floor(($count-1)/2); // find the middle value, or the lowest middle value\n    if ($count % 2) { // odd number, middle is the median\n        $median = $arr[$middleval];\n    } else { // even number, calculate avg of 2 medians\n        $low = $arr[$middleval];\n        $high = $arr[$middleval+1];\n        $median = (($low+$high)/2);\n    }\n    return $median;\n}\n\necho median(array(4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)) . \"\\n\";  // 4.4\necho median(array(4.1, 7.2, 1.7, 9.3, 4.4, 3.2)) . \"\\n\";       // 4.25\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction mode($arr) {\n    $count = array_count_values($arr);\n    $best = max($count);\n    return array_keys($count, $best);\n}\n\nprint_r(mode(array(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17)));\nprint_r(mode(array(1, 1, 2, 4, 4)));\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n// Created with PHP 7.0\n\nfunction ArithmeticMean(array $values)\n{\n    return array_sum($values) / count($values);\n}\n\nfunction GeometricMean(array $values)\n{\n    return array_product($values) ** (1 / count($values));\n}\n\nfunction HarmonicMean(array $values)\n{\n    $sum = 0;\n\n    foreach ($values as $value) {\n        $sum += 1 / $value;\n    }\n\n    return count($values) / $sum;\n}\n\n$values = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\necho \"Arithmetic: \" . ArithmeticMean($values) . \"\\n\";\necho \"Geometric: \" . GeometricMean($values) . \"\\n\";\necho \"Harmonic: \" . HarmonicMean($values) . \"\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n// Created with PHP 7.0\n\nfunction rms(array $numbers)\n{\n    $sum = 0;\n\n    foreach ($numbers as $number) {\n        $sum += $number**2;\n    }\n\n    return sqrt($sum / count($numbers));\n}\n\necho rms(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\n\n# brackets generator\nfunction bgenerate ($n) {\n    if ($n==0) return '';\n    $s = str_repeat('[', $n) . str_repeat(']', $n);\n    return str_shuffle($s);\n}\n\nfunction printbool($b) {return ($b) ? 'OK' : 'NOT OK';}\n\nfunction isbalanced($s) {\n    $bal = 0;\n    for ($i=0; $i < strlen($s); $i++) {\n        $ch = substr($s, $i, 1);\n        if ($ch == '[') {\n            $bal++;\n        } else {\n            $bal--;\n        }\n        if ($bal < 0) return false;\n    }\n    return ($bal == 0);\n}\n\n# test parameters are N (see spec)\n$tests = array(0, 2,2,2, 3,3,3, 4,4,4,4);\n\nforeach ($tests as $v) {\n    $s = bgenerate($v);\n    printf(\"%s\\t%s%s\", $s, printbool(isbalanced($s)), PHP_EOL);\n}\n"
  },
  {
    "language": "PHP",
    "code": "foreach (split(' ', 'abracadabra seesaw pop grrrrrr up a') as $w)\n    echo bestShuffle($w) . '<br>';\n\nfunction bestShuffle($s1) {\n    $s2 = str_shuffle($s1);\n    for ($i = 0; $i < strlen($s2); $i++) {\n        if ($s2[$i] != $s1[$i]) continue;\n        for ($j = 0; $j < strlen($s2); $j++)\n            if ($i != $j && $s2[$i] != $s1[$j] && $s2[$j] != $s1[$i]) {\n                $t = $s2[$i];\n                $s2[$i] = $s2[$j];\n                $s2[$j] = $t;\n                break;\n            }\n    }\n    return \"$s1 $s2 \" . countSame($s1, $s2);\n}\n\nfunction countSame($s1, $s2) {\n    $cnt = 0;\n    for ($i = 0; $i < strlen($s2); $i++)\n        if ($s1[$i] == $s2[$i])\n            $cnt++;\n    return \"($cnt)\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\necho decbin(5);\necho decbin(50);\necho decbin(9000);\n"
  },
  {
    "language": "PHP",
    "code": "function binary_search( $array, $secret, $start, $end )\n{\n        do\n        {\n                $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n                if ( $array[$guess] > $secret )\n                        $end = $guess;\n\n                if ( $array[$guess] < $secret )\n                        $start = $guess;\n\n                if ( $end < $start)\n                        return -1;\n\n        } while ( $array[$guess] != $secret );\n\n        return $guess;\n}\n"
  },
  {
    "language": "PHP",
    "code": "function binary_search( $array, $secret, $start, $end )\n{\n        $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n        if ( $end < $start)\n                return -1;\n\n        if ( $array[$guess] > $secret )\n                return (binary_search( $array, $secret, $start, $guess ));\n\n        if ( $array[$guess] < $secret )\n                return (binary_search( $array, $secret, $guess, $end ) );\n\n        return $guess;\n}\n"
  },
  {
    "language": "PHP",
    "code": "function validate($address){\n        $decoded = decodeBase58($address);\n\n        $d1 = hash(\"sha256\", substr($decoded,0,21), true);\n        $d2 = hash(\"sha256\", $d1, true);\n\n        if(substr_compare($decoded, $d2, 21, 4)){\n                throw new \\Exception(\"bad digest\");\n        }\n        return true;\n}\nfunction decodeBase58($input) {\n        $alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        $out = array_fill(0, 25, 0);\n        for($i=0;$i<strlen($input);$i++){\n                if(($p=strpos($alphabet, $input[$i]))===false){\n                        throw new \\Exception(\"invalid character found\");\n                }\n                $c = $p;\n                for ($j = 25; $j--; ) {\n                        $c += (int)(58 * $out[$j]);\n                        $out[$j] = (int)($c % 256);\n                        $c /= 256;\n                        $c = (int)$c;\n                }\n                if($c != 0){\n                    throw new \\Exception(\"address too long\");\n                }\n        }\n\n        $result = \"\";\n        foreach($out as $val){\n                $result .= chr($val);\n        }\n\n        return $result;\n}\n\nfunction main () {\n  $s = array(\n                \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\",\n                \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\",\n                \"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\",\n                \"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\",\n        );\n  foreach($s as $btc){\n    $message = \"OK\";\n    try{\n        validate($btc);\n    }catch(\\Exception $e){ $message = $e->getMessage(); }\n    echo \"$btc: $message\\n\";\n  }\n}\n\nmain();\n"
  },
  {
    "language": "PHP",
    "code": "<?\n\n$image = imagecreate(200, 200);\n// The first allocated color will be the background color:\nimagecolorallocate($image, 255, 255, 255);\n$color = imagecolorallocate($image, 255, 0, 0);\ncubicbezier($image, $color, 160, 10, 10, 40, 30, 160, 150, 110);\nimagepng($image);\n\nfunction cubicbezier($img, $col, $x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3, $n = 20) {\n\t$pts = array();\n\n\tfor($i = 0; $i <= $n; $i++) {\n\t\t$t = $i / $n;\n\t\t$t1 = 1 - $t;\n\t\t$a = pow($t1, 3);\n\t\t$b = 3 * $t * pow($t1, 2);\n\t\t$c = 3 * pow($t, 2) * $t1;\n\t\t$d = pow($t, 3);\n\n\t\t$x = round($a * $x0 + $b * $x1 + $c * $x2 + $d * $x3);\n\t\t$y = round($a * $y0 + $b * $y1 + $c * $y2 + $d * $y3);\n\t\t$pts[$i] = array($x, $y);\n\t}\n\n\tfor($i = 0; $i < $n; $i++) {\n\t\timageline($img, $pts[$i][0], $pts[$i][1], $pts[$i+1][0], $pts[$i+1][1], $col);\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "define('src_name', 'input.jpg');\t// source image\ndefine('dest_name', 'output.jpg');\t// destination image\n\n$img = imagecreatefromjpeg(src_name);\t// read image\n\nif(empty($img)){\n\techo 'Image could not be loaded!';\n\texit;\n}\n\n$black = imagecolorallocate($img, 0, 0, 0);\n$white = imagecolorallocate($img, 255, 255, 255);\n$width = imagesx($img);\n$height = imagesy($img);\n\n$array_lum = array(); \t// for storage of luminosity of each pixel\n$sum_lum = 0;\t\t// total sum of luminosity\n$average_lum = 0;\t// average luminosity of whole image\n\nfor($x = 0; $x < $width; $x++){\t\n\tfor($y = 0; $y < $height; $y++){\n\t\t// read pixel value\n\t\t$color = imagecolorat($img, $x, $y);\n\t\t$r = ($color >> 16) & 0xFF;\n\t\t$g = ($color >> 8) & 0xFF;\n\t\t$b = $color & 0xFF;\n\t\t// save pixel luminosity in temporary array\n\t\t$array_lum[$x][$y] = ($r + $g + $b);\n\t\t// add pixel luminosity to sum\n\t\t$sum_lum += $array_lum[$x][$y];\n\t}\n}\n\n// calculate average luminosity\n$average_lum = $sum_lum / ($width * $height);\n\nfor($x = 0; $x < $width; $x++){\t\n\tfor($y = 0; $y < $height; $y++){\n\t\t// pixel is brighter than average -> set white\n\t\t// else -> set black\n\t\tif($array_lum[$x][$y] > $average_lum){\n\t\t\timagesetpixel($img, $x, $y, $white);\n\t\t}\n\t\telse{\n\t\t\timagesetpixel($img, $x, $y, $black);\n\t\t}\n\t}\n}\n// save black and white image to dest_name\nimagejpeg($img, dest_name);\n\nif(!file_exists(dest_name)){\n\techo 'Image not saved! Check permission!';\n}\n"
  },
  {
    "language": "PHP",
    "code": "class Bitmap {\n  public $data;\n  public $w;\n  public $h;\n  public function __construct($w = 16, $h = 16){\n    $white = array_fill(0, $w, array(255,255,255));\n    $this->data = array_fill(0, $h, $white);\n    $this->w = $w;\n    $this->h = $h;\n  }\n  //Fills a rectangle, or the whole image with black by default\n  public function fill($x = 0, $y = 0, $w = null, $h = null, $color = array(0,0,0)){\n    if (is_null($w)) $w = $this->w;\n    if (is_null($h)) $h = $this->h;\n    $w += $x;\n    $h += $y;\n    for ($i = $y; $i < $h; $i++){\n      for ($j = $x; $j < $w; $j++){\n        $this->setPixel($j, $i, $color);\n      }\n    }\n  }\n  public function setPixel($x, $y, $color = array(0,0,0)){\n    if ($x >= $this->w) return false;\n    if ($x < 0) return false;\n    if ($y >= $this->h) return false;\n    if ($y < 0) return false;\n    $this->data[$y][$x] = $color;\n  }\n  public function getPixel($x, $y){\n    return $this->data[$y][$x];\n  }\n  public function writeP6($filename){\n    $fh = fopen($filename, 'w');\n    if (!$fh) return false;\n    fputs($fh, \"P6 {$this->w} {$this->h} 255\\n\");\n    foreach ($this->data as $row){\n      foreach($row as $pixel){\n        fputs($fh, pack('C', $pixel[0]));\n        fputs($fh, pack('C', $pixel[1]));\n        fputs($fh, pack('C', $pixel[2]));\n      }\n    }\n    fclose($fh);\n  }\n}\n\n$b = new Bitmap(16,16);\n$b->fill();\n$b->fill(2, 2, 18, 18, array(240,240,240));\n$b->setPixel(0, 15, array(255,0,0));\n$b->writeP6('p6.ppm');\n"
  },
  {
    "language": "PHP",
    "code": "class Bitmap {\n  public $data;\n  public $w;\n  public $h;\n  public function __construct($w = 16, $h = 16){\n    $white = array_fill(0, $w, array(255,255,255));\n    $this->data = array_fill(0, $h, $white);\n    $this->w = $w;\n    $this->h = $h;\n  }\n  //Fills a rectangle, or the whole image with black by default\n  public function fill($x = 0, $y = 0, $w = null, $h = null, $color = array(0,0,0)){\n    if (is_null($w)) $w = $this->w;\n    if (is_null($h)) $h = $this->h;\n    $w += $x;\n    $h += $y;\n    for ($i = $y; $i < $h; $i++){\n      for ($j = $x; $j < $w; $j++){\n        $this->setPixel($j, $i, $color);\n      }\n    }\n  }\n  public function setPixel($x, $y, $color = array(0,0,0)){\n    if ($x >= $this->w) return false;\n    if ($x < 0) return false;\n    if ($y >= $this->h) return false;\n    if ($y < 0) return false;\n    $this->data[$y][$x] = $color;\n  }\n  public function getPixel($x, $y){\n    return $this->data[$y][$x];\n  }\n}\n\n$b = new Bitmap(16,16);\n$b->fill();\n$b->fill(2, 2, 18, 18, array(240,240,240));\n$b->setPixel(0, 15, array(255,0,0));\nprint_r($b->getPixel(3,3)); //(240,240,240)\n"
  },
  {
    "language": "PHP",
    "code": "function bitwise($a, $b)\n{\n    function zerofill($a,$b) {\n        if($a>=0) return $a>>$b;\n        if($b==0) return (($a>>1)&0x7fffffff)*2+(($a>>$b)&1); // this line shifts a 0 into the sign bit for compatibility, replace with \"if($b==0) return $a;\" if you need $b=0 to mean that nothing happens\n        return ((~$a)>>$b)^(0x7fffffff>>($b-1));\n\n    echo '$a AND $b: ' . $a & $b . '\\n';\n    echo '$a OR $b: ' . $a | $b . '\\n';\n    echo '$a XOR $b: ' . $a ^ $b . '\\n';\n    echo 'NOT $a: ' . ~$a . '\\n';\n    echo '$a << $b: ' . $a << $b . '\\n'; // left shift\n    echo '$a >> $b: ' . $a >> $b . '\\n'; // arithmetic right shift\n    echo 'zerofill($a, $b): ' . zerofill($a, $b) . '\\n'; // logical right shift\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass SimpleClass {\n    private $answer = \"hello\\\"world\\nforever :)\";\n}\n\n$class = new SimpleClass;\nob_start();\n\n// var_export() expects class to contain __set_state() method which would import\n// data from array. But let's ignore this and remove from result the method which\n// sets state and just leave data which can be used everywhere...\nvar_export($class);\n$class_content = ob_get_clean();\n\n$class_content = preg_replace('\"^SimpleClass::__set_state\\(\"', 'return ', $class_content);\n$class_content = preg_replace('\"\\)$\"', ';', $class_content);\n\n$new_class = eval($class_content);\necho $new_class['answer'];\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass SimpleClass {\n    private $answer = 42;\n}\n\n$class = new SimpleClass;\n$classvars = (array)$class;\necho $classvars[\"\\0SimpleClass\\0answer\"];\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass fragile {\n    private $foo = 'bar';\n}\n$fragile = new fragile;\n$ro = new ReflectionObject($fragile);\n$rp = $ro->getProperty('foo');\n$rp->setAccessible(true);\nvar_dump($rp->getValue($fragile));\n$rp->setValue($fragile, 'haxxorz!');\nvar_dump($rp->getValue($fragile));\nvar_dump($fragile);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$size = 4;\n\n$chosen = implode(array_rand(array_flip(range(1,9)), $size));\n\necho \"I've chosen a number from $size unique digits from 1 to 9; you need\nto input $size unique digits to guess my number\\n\";\n\nfor ($guesses = 1; ; $guesses++) {\n    while (true) {\n        echo \"\\nNext guess [$guesses]: \";\n        $guess = rtrim(fgets(STDIN));\n        if (!checkguess($guess))\n            echo \"$size digits, no repetition, no 0... retry\\n\";\n        else\n            break;\n    }\n    if ($guess == $chosen) {\n        echo \"You did it in $guesses attempts!\\n\";\n        break;\n    } else {\n        $bulls = 0;\n        $cows = 0;\n        foreach (range(0, $size-1) as $i) {\n            if ($guess[$i] == $chosen[$i])\n                $bulls++;\n            else if (strpos($chosen, $guess[$i]) !== FALSE)\n                $cows++;\n        }\n        echo \"$cows cows, $bulls bulls\\n\";\n    }\n}\n\nfunction checkguess($g)\n{\n  global $size;\n  return count(array_unique(str_split($g))) == $size &&\n    preg_match(\"/^[1-9]{{$size}}$/\", $g);\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction caesarEncode( $message, $key ){\n    $plaintext = strtolower( $message );\n    $ciphertext = \"\";\n    $ascii_a = ord( 'a' );\n    $ascii_z = ord( 'z' );\n    while( strlen( $plaintext ) ){\n        $char = ord( $plaintext );\n        if( $char >= $ascii_a && $char <= $ascii_z ){\n            $char = ( ( $key + $char - $ascii_a ) % 26 ) + $ascii_a;\n        }\n        $plaintext = substr( $plaintext, 1 );\n        $ciphertext .= chr( $char );\n    }\n    return $ciphertext;\n}\n\necho caesarEncode( \"The quick brown fox Jumped over the lazy Dog\", 12 ), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction caesarEncode($message, $key) {\n    $from = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    $to   = substr($from, $key) . substr($from, 0, $key);\n    return strtr($message, $from, $to);\n}\n\necho caesarEncode('THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG', 12), PHP_EOL;\n"
  },
  {
    "language": "PHP",
    "code": "<?PHP\nECHO <<<REALPROGRAMMERSTHINKINUPPERCASEANDCHEATBYUSINGPRINT\n       JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE\n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n        1  2  3  4  5                  1  2                  1  2      1  2  3  4  5  6            1  2  3  4                     1\n  6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8\n 13 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15\n 20 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22\n 27 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29\n                                             31                                                                30\n\n         JULY                 AUGUST               SEPTEMBER              OCTOBER              NOVEMBER              DECEMBER\n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n     1  2  3  4  5  6               1  2  3   1  2  3  4  5  6  7         1  2  3  4  5                  1  2   1  2  3  4  5  6  7\n  7  8  9 10 11 12 13   4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9   8  9 10 11 12 13 14\n 14 15 16 17 18 19 20  11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16  15 16 17 18 19 20 21\n 21 22 23 24 25 26 27  18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23  22 23 24 25 26 27 28\n 28 29 30 31           25 26 27 28 29 30 31  29 30                 27 28 29 30 31        24 25 26 27 28 29 30  29 30 31\nREALPROGRAMMERSTHINKINUPPERCASEANDCHEATBYUSINGPRINT\n                                                                                                             ; // MAGICAL SEMICOLON\n"
  },
  {
    "language": "PHP",
    "code": "// Static method\nMyClass::method($someParameter);\n// In PHP 5.3+, static method can be called on a string of the class name\n$foo = 'MyClass';\n$foo::method($someParameter);\n\n\n// Instance method\n$myInstance->method($someParameter);\n"
  },
  {
    "language": "PowerShell",
    "code": "$doors = @(0..99)\nfor($i=0; $i -lt 100; $i++) {\n  $doors[$i] = 0  # start with all doors closed\n}\nfor($i=0; $i -lt 100; $i++) {\n  $step = $i + 1\n  for($j=$i; $j -lt 100; $j = $j + $step) {\n    $doors[$j] = $doors[$j] -bxor 1\n  }\n}\nforeach($doornum in 1..100) {\n  if($doors[($doornum-1)] -eq $true) {\"$doornum open\"}\n  else {\"$doornum closed\"}\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-DoorState($NumberOfDoors)\n{\n   begin\n   {\n      $Doors = @()\n      $Multiple = 1\n   }\n\n   process\n   {\n      for ($i = 1; $i -le $NumberOfDoors; $i++)\n      {\n         $Door = [pscustomobject]@{\n                    Name = $i\n                    Open = $false\n                 }\n\n         $Doors += $Door\n      }\n\n      While ($Multiple -le $NumberOfDoors)\n      {\n\t Foreach ($Door in $Doors)\n\t {\n\t    if ($Door.name % $Multiple -eq 0)\n               {\n\t          If ($Door.open -eq $False){$Door.open = $True}\n\t          Else {$Door.open = $False}\n\t       }\n\t }\n\t\t\t\n         $Multiple++\n      }\n    }\n\n    end {$Doors}\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$doors = 1..100 | ForEach-Object {0}\n1..100 | ForEach-Object { $a=$_;1..100 | Where-Object { -not ( $_ % $a )  } | ForEach-Object { $doors[$_-1] = $doors[$_-1] -bxor 1 }; if ( $doors[$a-1] ) { \"door opened\" } else { \"door closed\" } }\n"
  },
  {
    "language": "PowerShell",
    "code": "$doors = 1..100 | ForEach-Object {0}\n$visited = 1..100\n1..100 | ForEach-Object { $a=$_;$visited[0..([math]::floor(100/$a)-1)] | Where-Object { -not ( $_ % $a )  } | ForEach-Object { $doors[$_-1] = $doors[$_-1] -bxor 1;$visited[$_/$a-1]+=($_/$a) }; if ( $doors[$a-1] ) { \"door opened\" } else { \"door closed\" } }\n"
  },
  {
    "language": "PowerShell",
    "code": "1..100|foreach-object {$pipe += \"toggle $_ |\"} -begin {$pipe=\"\"}\nfilter toggle($pass) {$_.door = $_.door -xor !($_.index % $pass);$_}\ninvoke-expression \"1..100| foreach-object {@{index=`$_;door=`$false}} | $pipe  out-host\"\n"
  },
  {
    "language": "PowerShell",
    "code": "Workflow Calc-Doors {\n    Foreach \u2013parallel ($number in 1..100) {\n        \"Door \" + $number.ToString(\"0000\") + \": \" + @{$true=\"Closed\";$false=\"Open\"}[([Math]::pow($number, 0.5)%1) -ne 0]\n    }\n}\nCalc-Doors | sort\n"
  },
  {
    "language": "PowerShell",
    "code": "1..10|%{\"Door \"+ $_*$_ + \" is open\"}\n"
  },
  {
    "language": "PowerShell",
    "code": "CLS\n\nFunction isNumeric ($x)\n{\n    $x2 = 0\n    $isNum = [System.Int32]::TryParse($x,[ref]$x2)\nReturn $isNum\n}\n\n$NumberArray = @()\nWhile( $NumberArray.Count -lt 4 ){\n    $NumberArray += Random -Minimum 1 -Maximum 10\n}\n\nWrite-Host @\"\nWelcome to the 24 game!\n\nHere are your numbers: $($NumberArray -join \",\").\nUse division, multiplication, subtraction and addition to get 24 as a result with these 4 numbers.\n\"@\n\nDo\n{\n$Wrong = 0\n$EndResult = $null\n$TempChar = $null\n$TempChar2 = $null\n$Count = $null\n\n$AllowableCharacters = $NumberArray + \"+-*/()\".ToCharArray()\n    $Result = Read-Host\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If( $AllowableCharacters -notcontains $Char ){ $Wrong = 1 }\n        }\n\n        If($Wrong -eq 1)\n        {\n            Write-Warning \"Wrong input! Please use only the given numbers.\"\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If((IsNumeric $TempChar) -AND (IsNumeric $Char))\n            {\n                Write-Warning \"Wrong input! Combining two or more numbers together is not allowed!\"\n            }\n            $TempChar = $Char\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If(IsNumeric $Char)\n            {\n                $Count++\n            }\n        }\n        If($Count -eq 4)\n        {\n            $EndResult = Invoke-Expression $Result\n                If($EndResult -eq 24)\n                {\n                    Write-Host \"`nYou've won the game!\"\n                }\n                Else\n                {\n                    Write-Host \"`n$EndResult is not 24! Too bad.\"\n                }\n        }\n        Else\n        {\n            Write-Warning \"Wrong input! You did not supply four numbers.\"\n        }\n}\nWhile($EndResult -ne 24)\n"
  },
  {
    "language": "PowerShell",
    "code": "$a,$b = -split \"$input\"\n[int]$a + [int]$b\n"
  },
  {
    "language": "PowerShell",
    "code": "$a,$b = -split (Read-Host)\n[int]$a + [int]$b\n"
  },
  {
    "language": "PowerShell",
    "code": "filter add {\n    return [int]$args[0] + [int]$args[1]\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "add 2 3\n"
  },
  {
    "language": "PowerShell",
    "code": "<#\n.Synopsis\n  ABC Problem\n.DESCRIPTION\n   You are given a collection of ABC blocks. Just like the ones you had when you were a kid.\n   There are twenty blocks with two letters on each block. You are guaranteed to have a\n   complete alphabet amongst all sides of the blocks\n   blocks = \"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"\n   The goal of this task is to write a function that takes a string and can determine whether\n   you can spell the word with the given collection of blocks.\n\n   The rules are simple:\n        1.Once a letter on a block is used that block cannot be used again\n        2.The function should be case-insensitive\n        3. Show your output on this page for the following words:\n        >>> can_make_word(\"A\")\n        True\n        >>> can_make_word(\"BARK\")\n        True\n        >>> can_make_word(\"BOOK\")\n        False\n        >>> can_make_word(\"TREAT\")\n        True\n        >>> can_make_word(\"COMMON\")\n        False\n        >>> can_make_word(\"SQUAD\")\n        True\n        >>> can_make_word(\"CONFUSE\")\n        True\n\n   Using the examples below  you can either see just the value or\n   status and the values using the verbose switch\n\n.EXAMPLE\n   test-blocks -testword confuse\n\n.EXAMPLE\n   test-blocks -testword confuse -verbose\n\n#>\n\nfunction test-blocks\n{\n\t[CmdletBinding()]\n\t#  [OutputType([int])]\n\tParam\n\t(\n\t\t# word to test against blocks\n\t\t[Parameter(Mandatory = $true,\n\t\t\t\t   ValueFromPipelineByPropertyName = $true)]\n\t\t$testword\n\t\t\n\t)\n\n\t$word = $testword\n\t\n\t#define array of blocks\n\t[System.Collections.ArrayList]$blockarray = \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t\n\t#send word to chararray\n\t$chararray = $word.ToCharArray()\n\t$chars = $chararray\n\t\n\t#get the character count\n\t$charscount = $chars.count\n\t\n\t#get the initial count of the blocks\n\t$blockcount = $blockarray.Count\n\t\n\t#find out how many blocks should be left from the difference\n\t#of the blocks and characters in the word - 1 letter/1 block\n\t$correctblockcount = $blockcount - $charscount\n\t\n\t#loop through the characters in the word\n\tforeach ($char in $chars)\n\t{\n\t\t\n\t\t#loop through the blocks\n\t\tforeach ($block in $blockarray)\n\t\t{\n\t\t\t\n\t\t\t#check the current character against each letter on the current block\n\t\t\t#and break if found so the array can reload\n\t\t\tif ($char -in $block[0] -or $char -in $block[1])\n\t\t\t{\n\t\t\t\t\n\t\t\t\twrite-verbose \"match for letter - $char - removing block $block\"\n\t\t\t\t$blockarray.Remove($block)\n\t\t\t\tbreak\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t#get final count of blocks left in array to determine if the word was\n\t#correctly made\n\t$finalblockcount = $blockarray.count\n\tif ($finalblockcount -ne $correctblockcount)\n\t{\n\t\twrite-verbose \"$word : $false \"\n\t\treturn $false\n\t}\n\telse\n\t{\n\t\twrite-verbose \"$word : $true \"\n\t\treturn $true\n\t}\n\t\n}\n\n#loop all the words and pass them to the function\n$wordlist = \"a\", \"bark\", \"book\", \"treat\", \"common\", \"squad\", \"confuse\"\nforeach ($word in $wordlist)\n{\n\ttest-blocks -testword $word -Verbose\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "#Requires -Version 5.0\n\nClass Player\n{\n  <#\n    Properties: Name, Team, Position and Number\n  #>\n    [string]$Name\n\n    [ValidateSet(\"Baltimore Ravens\",\"Cincinnati Bengals\",\"Cleveland Browns\",\"Pittsburgh Steelers\",\n                 \"Chicago Bears\",\"Detroit Lions\",\"Green Bay Packers\",\"Minnesota Vikings\",\n                 \"Houston Texans\",\"Indianapolis Colts\",\"Jacksonville Jaguars\",\"Tennessee Titans\",\n                 \"Atlanta Falcons\",\"Carolina Panthers\",\"New Orleans Saints\",\"Tampa Bay Buccaneers\",\n                 \"Buffalo Bills\",\"Miami Dolphins\",\"New England Patriots\",\"New York Jets\",\n                 \"Dallas Cowboys\",\"New York Giants\",\"Philadelphia Eagles\",\"Washington Redskins\",\n                 \"Denver Broncos\",\"Kansas City Chiefs\",\"Oakland Raiders\",\"San Diego Chargers\",\n                 \"Arizona Cardinals\",\"Los Angeles Rams\",\"San Francisco 49ers\",\"Seattle Seahawks\")]\n    [string]$Team\n\n    [ValidateSet(\"C\",\"G\",\"T\",\"QB\",\"RB\",\"WR\",\"TE\",\"DT\",\"DE\",\"ILB\",\"OLB\",\"CB\",\"S\",\"K\",\"H\",\"LS\",\"P\",\"KOS\",\"R\")]\n    [string]$Position\n\n    [ValidateRange(0,99)]\n    [int]$Number\n\n  <#\n    Constructor: Creates a new Player object, with the specified Name, Team, Position and Number.\n  #>\n    Player([string]$Name, [string]$Team, [string]$Position, [int]$Number)\n    {\n        $this.Name     = (Get-Culture).TextInfo.ToTitleCase(\"$Name\")\n        $this.Team     = (Get-Culture).TextInfo.ToTitleCase(\"$Team\")\n        $this.Position = $Position.ToUpper()\n        $this.Number   = $Number\n    }\n\n  <#\n    Methods: Trade the player to a different team (optional parameters for methods in PowerShell 5 classes are not available.  Boo!!)\n             An overloaded method is a method with the same name as another method but in a different context,\n             in this case with different parameters.\n  #>\n    Trade([string]$NewTeam)\n    {\n        [string[]]$league = \"Baltimore Ravens\",\"Cincinnati Bengals\",\"Cleveland Browns\",\"Pittsburgh Steelers\",\n                            \"Chicago Bears\",\"Detroit Lions\",\"Green Bay Packers\",\"Minnesota Vikings\",\n                            \"Houston Texans\",\"Indianapolis Colts\",\"Jacksonville Jaguars\",\"Tennessee Titans\",\n                            \"Atlanta Falcons\",\"Carolina Panthers\",\"New Orleans Saints\",\"Tampa Bay Buccaneers\",\n                            \"Buffalo Bills\",\"Miami Dolphins\",\"New England Patriots\",\"New York Jets\",\n                            \"Dallas Cowboys\",\"New York Giants\",\"Philadelphia Eagles\",\"Washington Redskins\",\n                            \"Denver Broncos\",\"Kansas City Chiefs\",\"Oakland Raiders\",\"San Diego Chargers\",\n                            \"Arizona Cardinals\",\"Los Angeles Rams\",\"San Francisco 49ers\",\"Seattle Seahawks\"\n\n        if ($NewTeam -in $league | Where-Object {$_ -notmatch $this.Team})\n        {\n            $this.Team = (Get-Culture).TextInfo.ToTitleCase(\"$NewTeam\")\n        }\n        else\n        {\n            throw \"Invalid Team\"\n        }\n    }\n\n    Trade([string]$NewTeam, [int]$NewNumber)\n    {\n        [string[]]$league = \"Baltimore Ravens\",\"Cincinnati Bengals\",\"Cleveland Browns\",\"Pittsburgh Steelers\",\n                            \"Chicago Bears\",\"Detroit Lions\",\"Green Bay Packers\",\"Minnesota Vikings\",\n                            \"Houston Texans\",\"Indianapolis Colts\",\"Jacksonville Jaguars\",\"Tennessee Titans\",\n                            \"Atlanta Falcons\",\"Carolina Panthers\",\"New Orleans Saints\",\"Tampa Bay Buccaneers\",\n                            \"Buffalo Bills\",\"Miami Dolphins\",\"New England Patriots\",\"New York Jets\",\n                            \"Dallas Cowboys\",\"New York Giants\",\"Philadelphia Eagles\",\"Washington Redskins\",\n                            \"Denver Broncos\",\"Kansas City Chiefs\",\"Oakland Raiders\",\"San Diego Chargers\",\n                            \"Arizona Cardinals\",\"Los Angeles Rams\",\"San Francisco 49ers\",\"Seattle Seahawks\"\n\n        if ($NewTeam -in $league | Where-Object {$_ -notmatch $this.Team})\n        {\n            $this.Team = (Get-Culture).TextInfo.ToTitleCase(\"$NewTeam\")\n        }\n        else\n        {\n            throw \"Invalid Team\"\n        }\n\n        if ($NewNumber -in 0..99)\n        {\n            $this.Number = $NewNumber\n        }\n        else\n        {\n            throw \"Invalid Number\"\n        }\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$player1 = [Player]::new(\"sam bradford\", \"philadelphia eagles\", \"qb\", 7)\n$player1\n"
  },
  {
    "language": "PowerShell",
    "code": "$player1.Trade(\"minnesota vikings\", 8)\n$player1\n"
  },
  {
    "language": "PowerShell",
    "code": "$player2 = [Player]::new(\"demarco murray\", \"philadelphia eagles\", \"rb\", 29)\n$player2\n"
  },
  {
    "language": "PowerShell",
    "code": "$player2.Trade(\"tennessee titans\")\n$player2\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-ProperDivisorSum ( [int]$N )\n    {\n    If ( $N -lt 2 ) { return 0 }\n\n    $Sum = 1\n    If ( $N -gt 3 )\n        {\n        $SqrtN = [math]::Sqrt( $N )\n        ForEach ( $Divisor in 2..$SqrtN )\n            {\n            If ( $N % $Divisor -eq 0 ) { $Sum += $Divisor + $N / $Divisor }\n            }\n        If ( $N % $SqrtN -eq 0 ) { $Sum -= $SqrtN }\n        }\n    return $Sum\n    }\n\n\n$Deficient = $Perfect = $Abundant = 0\n\nForEach ( $N in 1..20000 )\n    {\n    Switch ( [math]::Sign( ( Get-ProperDivisorSum $N ) - $N ) )\n        {\n        -1 { $Deficient++ }\n         0 { $Perfect++   }\n         1 { $Abundant++  }\n        }\n    }\n\n\"Deficient: $Deficient\"\n\"Perfect  : $Perfect\"\n\"Abundant : $Abundant\"\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-NumberClassification\n{\n    [CmdletBinding()]\n    [OutputType([PSCustomObject])]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true,\n                   Position=0)]\n        [int]\n        $Number\n    )\n\n    Begin\n    {\n        function Get-ProperDivisorSum ([int]$Number)\n        {\n            if ($Number -lt 2) {return 0}\n\n            $sum = 1\n\n            if ($Number -gt 3)\n            {\n                $sqrtNumber = [Math]::Sqrt($Number)\n\n                foreach ($divisor in 2..$sqrtNumber)\n                {\n                    if ($Number % $divisor -eq 0) {$sum += $divisor + $Number / $divisor}\n                }\n\n                if ($Number % $sqrtNumber -eq 0) {$sum -= $sqrtNumber}\n            }\n\n            $sum\n        }\n\n        [System.Collections.ArrayList]$numbers = @()\n    }\n    Process\n    {\n        switch ([Math]::Sign((Get-ProperDivisorSum $Number) - $Number))\n        {\n            -1 { [void]$numbers.Add([PSCustomObject]@{Class=\"Deficient\"; Number=$Number}) }\n             0 { [void]$numbers.Add([PSCustomObject]@{Class=\"Perfect\"  ; Number=$Number}) }\n             1 { [void]$numbers.Add([PSCustomObject]@{Class=\"Abundant\" ; Number=$Number}) }\n        }\n    }\n    End\n    {\n        $numbers | Group-Object  -Property Class |\n                   Select-Object -Property Count,\n                                           @{Name='Class' ; Expression={$_.Name}},\n                                           @{Name='Number'; Expression={$_.Group.Number}}\n    }\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "1..20000 | Get-NumberClassification\n"
  },
  {
    "language": "PowerShell",
    "code": "function Get-Accumulator ([double]$Start)\n{\n    {param([double]$Plus) return $script:Start += $Plus}.GetNewClosure()\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "$total = Get-Accumulator -Start 1\n& $total -Plus 5.0 | Out-Null\n& $total -Plus 2.3\n"
  },
  {
    "language": "PowerShell",
    "code": "function ackermann ([long] $m, [long] $n) {\n    if ($m -eq 0) {\n        return $n + 1\n    }\n\n    if ($n -eq 0) {\n        return (ackermann ($m - 1) 1)\n    }\n\n    return (ackermann ($m - 1) (ackermann $m ($n - 1)))\n}\n"
  },
  {
    "language": "PowerShell",
    "code": "foreach ($m in 0..3) {\n    foreach ($n in 0..6) {\n        Write-Host -NoNewline (\"{0,5}\" -f (ackermann $m $n))\n    }\n    Write-Host\n}\n"
  },
  {
    "language": "Python",
    "code": "doors = [False] * 100\nfor i in range(100):\n   for j in range(i, 100, i+1):\n       doors[j] = not doors[j]\n   print(\"Door %d:\" % (i+1), 'open' if doors[i] else 'close')\n"
  },
  {
    "language": "Python",
    "code": "for i in xrange(1, 101):\n    root = i ** 0.5\n    print \"Door %d:\" % i, 'open' if root == int(root) else 'close'\n"
  },
  {
    "language": "Python",
    "code": "print '\\n'.join(['Door %s is %s' % (i, ('closed', 'open')[(i**0.5).is_integer()]) for i in xrange(1, 101)])\n"
  },
  {
    "language": "Python",
    "code": "print '\\n'.join('Door %s is %s' % (i, 'closed' if i**0.5 % 1 else 'open') for i in range(1, 101))\n"
  },
  {
    "language": "Python",
    "code": "for i in range(1, 101):\n    if i**0.5 % 1:\n        state='open'\n    else:\n        state='close'\n    print(\"Door {}:{}\".format(i, state))\n"
  },
  {
    "language": "Python",
    "code": "for i in range(1,11): print(\"Door %s is open\" % i**2)\n"
  },
  {
    "language": "Python",
    "code": "'''\n The 24 Game Player\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n\n\n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets\n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))\n    return '!'\n\ndef main():\n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport operator\nfrom itertools import product, permutations\n\ndef mydiv(n, d):\n    return n / d if d != 0 else 9999999\n\nsyms = [operator.add, operator.sub, operator.mul, mydiv]\nop = {sym: ch for sym, ch in zip(syms, '+-*/')}\n\ndef solve24(nums):\n    for x, y, z in product(syms, repeat=3):\n        for a, b, c, d in permutations(nums):\n            if round(x(y(a,b),z(c,d)),5) == 24:\n                return f\"({a} {op[y]} {b}) {op[x]} ({c} {op[z]} {d})\"\n            elif round(x(a,y(b,z(c,d))),5) == 24:\n                return f\"{a} {op[x]} ({b} {op[y]} ({c} {op[z]} {d}))\"\n            elif round(x(y(z(c,d),b),a),5) == 24:\n                return f\"(({c} {op[z]} {d}) {op[y]} {b}) {op[x]} {a}\"\n            elif round(x(y(b,z(c,d)),a),5) == 24:\n                return f\"({b} {op[y]} ({c} {op[z]} {d})) {op[x]} {a}\"\n    return '--Not Found--'\n\nif __name__ == '__main__':\n    #nums = eval(input('Four integers in the range 1:9 inclusive, separated by commas: '))\n    for nums in [\n        [9,4,4,5],\n        [1,7,2,7],\n        [5,7,5,4],\n        [1,4,6,6],\n        [2,3,7,3],\n        [8,7,9,7],\n        [1,6,2,6],\n        [7,9,4,1],\n        [6,4,2,2],\n        [5,7,9,7],\n        [3,3,8,8],  # Difficult case requiring precise division\n            ]:\n        print(f\"solve24({nums}) -> {solve24(nums)}\")\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# Python 3\nfrom operator import mul, sub, add\n\n\ndef div(a, b):\n    if b == 0:\n        return 999999.0\n    return a / b\n\nops = {mul: '*', div: '/', sub: '-', add: '+'}\n\ndef solve24(num, how, target):\n    if len(num) == 1:\n        if round(num[0], 5) == round(target, 5):\n            yield str(how[0]).replace(',', '').replace(\"'\", '')\n    else:\n        for i, n1 in enumerate(num):\n            for j, n2 in enumerate(num):\n                if i != j:\n                    for op in ops:\n                        new_num = [n for k, n in enumerate(num) if k != i and k != j] + [op(n1, n2)]\n                        new_how = [h for k, h in enumerate(how) if k != i and k != j] + [(how[i], ops[op], how[j])]\n                        yield from solve24(new_num, new_how, target)\n\ntests = [\n         [1, 7, 2, 7],\n         [5, 7, 5, 4],\n         [1, 4, 6, 6],\n         [2, 3, 7, 3],\n         [1, 6, 2, 6],\n         [7, 9, 4, 1],\n         [6, 4, 2, 2],\n         [5, 7, 9, 7],\n         [3, 3, 8, 8],  # Difficult case requiring precise division\n         [8, 7, 9, 7],  # No solution\n         [9, 4, 4, 5],  # No solution\n            ]\nfor nums in tests:\n    print(nums, end=' : ')\n    try:\n        print(next(solve24(nums, nums, 24)))\n    except StopIteration:\n        print(\"No solution found\")\n"
  },
  {
    "language": "Python",
    "code": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n"
  },
  {
    "language": "Python",
    "code": "def partitions(N):\n    diffs,k,s = [],1,1\n    while k * (3*k-1) < 2*N:\n        diffs.extend([(2*k - 1, s), (k, s)])\n\tk,s = k+1,-s\n\n    out = [1] + [0]*N\n    for p in range(0, N+1):\n        x = out[p]\n\tfor (o,s) in diffs:\n           p += o\n           if p > N: break\n           out[p] += x*s\n\n    return out\n\np = partitions(12345)\nfor x in [23,123,1234,12345]: print x, p[x]\n"
  },
  {
    "language": "Python",
    "code": "def partitions(n):\n    partitions.p.append(0)\n\n    for k in xrange(1, n + 1):\n        d = n - k * (3 * k - 1) // 2\n        if d < 0:\n            break\n\n        if k & 1:\n            partitions.p[n] += partitions.p[d]\n        else:\n            partitions.p[n] -= partitions.p[d]\n\n        d -= k\n        if d < 0:\n            break\n\n        if k & 1:\n            partitions.p[n] += partitions.p[d]\n        else:\n            partitions.p[n] -= partitions.p[d]\n\n    return partitions.p[-1]\n\npartitions.p = [1]\n\ndef main():\n    ns = set([23, 123, 1234, 12345])\n    max_ns = max(ns)\n\n    for i in xrange(1, max_ns + 1):\n        if i > max_ns:\n            break\n        p = partitions(i)\n        if i in ns:\n            print \"%6d: %s\" % (i, p)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "catchphrase = \"%d bottles of beer on the wall\"\n\nstrofas = (\"\\n\".join((\n    catchphrase % n,\n    catchphrase[:18] % n,\n    \"Take one down and pass it around\",\n    catchphrase % (n-1)\n)) for n in range(99, 0, -1))\n\nprint(\"\\n\\n\".join(strofas))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"Pythonic 99 beer song (maybe the simplest naive implementation in Python 3).\"\"\"\n\n\nREGULAR_VERSE = '''\\\n{n} bottles of beer on the wall, {n} bottles of beer\nTake one down and pass it around, {n_minus_1} bottles of beer on the wall.\n\n'''\n\nENDING_VERSES = '''\\\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\n\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n\n'''\n\n\nfor n in range(99, 2, -1):\n    print(REGULAR_VERSE.format(n=n, n_minus_1=n - 1))\nprint(ENDING_VERSES)\n"
  },
  {
    "language": "Python",
    "code": "'''99 Units of Disposable Asset'''\n\n\nfrom itertools import chain\n\n\n# main :: IO ()\ndef main():\n    '''Modalised asset dispersal procedure.'''\n\n    # localisation :: (String, String, String)\n    localisation = (\n        'on the wall',\n        'Take one down, pass it around',\n        'Better go to the store to buy some more'\n    )\n\n    print(unlines(map(\n        incantation(localisation),\n        enumFromThenTo(99)(98)(0)\n    )))\n\n\n# incantation :: (String, String, String) -> Int -> String\ndef incantation(localisation):\n    '''Versification of asset disposal\n       and inventory update.'''\n\n    location, distribution, solution = localisation\n\n    def inventory(n):\n        return unwords([asset(n), location])\n    return lambda n: solution if 0 == n else (\n        unlines([\n            inventory(n),\n            asset(n),\n            distribution,\n            inventory(pred(n))\n        ])\n    )\n\n\n# asset :: Int -> String\ndef asset(n):\n    '''Quantified asset.'''\n    def suffix(n):\n        return [] if 1 == n else 's'\n    return unwords([\n        str(n),\n        concat(reversed(concat(cons(suffix(n))([\"elttob\"]))))\n    ])\n\n\n# GENERIC -------------------------------------------------\n\n# concat :: [[a]] -> [a]\n# concat :: [String] -> String\ndef concat(xxs):\n    '''The concatenation of all the elements in a list.'''\n    xs = list(chain.from_iterable(xxs))\n    unit = '' if isinstance(xs, str) else []\n    return unit if not xs else (\n        ''.join(xs) if isinstance(xs[0], str) else xs\n    )\n\n\n# cons :: a -> [a] -> [a]\ndef cons(x):\n    '''Construction of a list from x as head,\n       and xs as tail.'''\n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else chain([x], xs)\n\n\n# enumFromThenTo :: Int -> Int -> Int -> [Int]\ndef enumFromThenTo(m):\n    '''Integer values enumerated from m to n\n       with a step defined by nxt-m.'''\n    def go(nxt, n):\n        d = nxt - m\n        return list(range(m, d + n, d))\n    return lambda nxt: lambda n: (\n        go(nxt, n)\n    )\n\n\n# pred ::  Enum a => a -> a\ndef pred(x):\n    '''The predecessor of a value. For numeric types, (- 1).'''\n    return x - 1 if isinstance(x, int) else (\n        chr(ord(x) - 1)\n    )\n\n\n# unlines :: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.'''\n    return '\\n'.join(xs)\n\n\n# unwords :: [String] -> String\ndef unwords(xs):\n    '''A space-separated string derived from\n       a list of words.'''\n    return ' '.join(xs)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\n    99 Bottles of Beer on the Wall made functional\n\n    Main function accepts a number of parameters, so you can specify a name of\n    the drink, its container and other things. English only.\n\"\"\"\n\nfrom functools import partial\nfrom typing import Callable\n\n\ndef regular_plural(noun: str) -> str:\n    \"\"\"English rule to get the plural form of a word\"\"\"\n    if noun[-1] == \"s\":\n        return noun + \"es\"\n\n    return noun + \"s\"\n\n\ndef beer_song(\n    *,\n    location: str = 'on the wall',\n    distribution: str = 'Take one down, pass it around',\n    solution: str = 'Better go to the store to buy some more!',\n    container: str = 'bottle',\n    plurifier: Callable[[str], str] = regular_plural,\n    liquid: str = \"beer\",\n    initial_count: int = 99,\n) -> str:\n    \"\"\"\n    Return the lyrics of the beer song\n    :param location: initial location of the drink\n    :param distribution: specifies the process of its distribution\n    :param solution: what happens when we run out of drinks\n    :param container: bottle/barrel/flask or other containers\n    :param plurifier: function converting a word to its plural form\n    :param liquid: the name of the drink in the given container\n    :param initial_count: how many containers available initially\n    \"\"\"\n\n    verse = partial(\n        get_verse,\n        initial_count = initial_count,\n        location = location,\n        distribution = distribution,\n        solution = solution,\n        container = container,\n        plurifier = plurifier,\n        liquid = liquid,\n    )\n\n    verses = map(verse, range(initial_count, -1, -1))\n    return '\\n\\n'.join(verses)\n\n\ndef get_verse(\n    count: int,\n    *,\n    initial_count: str,\n    location: str,\n    distribution: str,\n    solution: str,\n    container: str,\n    plurifier: Callable[[str], str],\n    liquid: str,\n) -> str:\n    \"\"\"Returns the verse for the given amount of drinks\"\"\"\n\n    asset = partial(\n        get_asset,\n        container = container,\n        plurifier = plurifier,\n        liquid = liquid,\n    )\n\n    current_asset = asset(count)\n    next_number = count - 1 if count else initial_count\n    next_asset = asset(next_number)\n    action = distribution if count else solution\n\n    inventory = partial(\n        get_inventory,\n        location = location,\n    )\n\n    return '\\n'.join((\n        inventory(current_asset),\n        current_asset,\n        action,\n        inventory(next_asset),\n    ))\n\n\ndef get_inventory(\n    asset: str,\n    *,\n    location: str,\n) -> str:\n    \"\"\"\n    Used to return the first or the fourth line of the verse\n\n    >>> get_inventory(\"10 bottles of beer\", location=\"on the wall\")\n    \"10 bottles of beer on the wall\"\n    \"\"\"\n    return ' '.join((asset, location))\n\n\ndef get_asset(\n    count: int,\n    *,\n    container: str,\n    plurifier: Callable[[str], str],\n    liquid: str,\n) -> str:\n    \"\"\"\n    Quantified asset\n\n    >>> get_asset(0, container=\"jar\", plurifier=regular_plural, liquid='milk')\n    \"No more jars of milk\"\n    \"\"\"\n\n    containers = plurifier(container) if count != 1 else container\n    spelled_out_quantity = str(count) if count else \"No more\"\n    return ' '.join((spelled_out_quantity, containers, \"of\", liquid))\n\n\nif __name__ == '__main__':\n    print(beer_song())\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nExcercise of style. An overkill for the task :-D\n\n1. OOP, with abstract class and implementation with much common magic methods\n2. you can customize:\n    a. the initial number\n    b. the name of the item and its plural\n    c. the string to display when there's no more items\n    d. the normal action\n    e. the final action\n    f. the template used, for foreign languages\n3. strofas of the song are created with multiprocessing\n4. when you launch it as a script, you can specify an optional parameter for\n   the number of initial items\n\"\"\"\n\nfrom string import Template\nfrom abc import ABC, abstractmethod\nfrom multiprocessing.pool import Pool as ProcPool\nfrom functools import partial\nimport sys\n\nclass Song(ABC):\n    @abstractmethod\n    def sing(self):\n        \"\"\"\n        it must return the song as a text-like object\n        \"\"\"\n\n        pass\n\nclass MuchItemsSomewhere(Song):\n    eq_attrs = (\n        \"initial_number\",\n        \"zero_items\",\n        \"action1\",\n        \"action2\",\n        \"item\",\n        \"items\",\n        \"strofa_tpl\"\n    )\n\n    hash_attrs = eq_attrs\n    repr_attrs = eq_attrs\n\n    __slots__ = eq_attrs + (\"_repr\", \"_hash\")\n\n    def __init__(\n        self,\n        items = \"bottles of beer\",\n        item = \"bottle of beer\",\n        where = \"on the wall\",\n        initial_number = None,\n        zero_items = \"No more\",\n        action1 = \"Take one down, pass it around\",\n        action2 = \"Go to the store, buy some more\",\n        template = None,\n    ):\n        initial_number_true = 99 if initial_number is None else initial_number\n\n        try:\n            is_initial_number_int = (initial_number_true % 1) == 0\n        except Exception:\n            is_initial_number_int = False\n\n        if not is_initial_number_int:\n            raise ValueError(\"`initial_number` parameter must be None or a int-like object\")\n\n        if initial_number_true < 0:\n            raise ValueError(\"`initial_number` parameter must be >=0\")\n\n\n        true_tpl = template or \"\"\"\\\n$i $items1 $where\n$i $items1\n$action\n$j $items2 $where\"\"\"\n\n        strofa_tpl_tmp = Template(true_tpl)\n        strofa_tpl = Template(strofa_tpl_tmp.safe_substitute(where=where))\n\n        self.zero_items = zero_items\n        self.action1 = action1\n        self.action2 = action2\n        self.initial_number = initial_number_true\n        self.item = item\n        self.items = items\n        self.strofa_tpl = strofa_tpl\n        self._hash = None\n        self._repr = None\n\n    def strofa(self, number):\n        zero_items = self.zero_items\n        item = self.item\n        items = self.items\n\n        if number == 0:\n            i = zero_items\n            action = self.action2\n            j = self.initial_number\n        else:\n            i = number\n            action = self.action1\n            j = i - 1\n\n        if i == 1:\n            items1 = item\n            j = zero_items\n        else:\n            items1 = items\n\n        if j == 1:\n            items2 = item\n        else:\n            items2 = items\n\n        return self.strofa_tpl.substitute(\n            i = i,\n            j = j,\n            action = action,\n            items1 = items1,\n            items2 = items2\n        )\n\n    def sing(self):\n        with ProcPool() as proc_pool:\n            strofa = self.strofa\n            initial_number = self.initial_number\n            args = range(initial_number, -1, -1)\n            return \"\\n\\n\".join(proc_pool.map(strofa, args))\n\n    def __copy__(self, *args, **kwargs):\n        return self\n\n    def __deepcopy__(self, *args, **kwargs):\n        return self\n\n    def __eq__(self, other, *args, **kwargs):\n        if self is other:\n            return True\n\n        getmyattr = partial(getattr, self)\n        getotherattr = partial(getattr, other)\n        eq_attrs = self.eq_attrs\n\n        for attr in eq_attrs:\n            val = getmyattr(attr)\n\n            try:\n                val2 = getotherattr(attr)\n            except Exception:\n                return False\n\n            if attr == \"strofa_tpl\":\n                val_true = val.safe_substitute()\n                val2_true = val.safe_substitute()\n            else:\n                val_true = val\n                val2_true = val\n\n            if val_true != val2_true:\n                return False\n\n        return True\n\n    def __hash__(self, *args, **kwargs):\n        _hash = self._hash\n\n        if _hash is None:\n            getmyattr = partial(getattr, self)\n            attrs = self.hash_attrs\n            hash_true = self._hash = hash(tuple(map(getmyattr, attrs)))\n        else:\n            hash_true = _hash\n\n        return hash_true\n\n    def __repr__(self, *args, **kwargs):\n        _repr = self._repr\n\n        if _repr is None:\n            repr_attrs = self.repr_attrs\n            getmyattr = partial(getattr, self)\n\n            attrs = []\n\n            for attr in repr_attrs:\n                val = getmyattr(attr)\n\n                if attr == \"strofa_tpl\":\n                    val_true = val.safe_substitute()\n                else:\n                    val_true = val\n\n                attrs.append(f\"{attr}={repr(val_true)}\")\n\n            repr_true = self._repr = f\"{self.__class__.__name__}({', '.join(attrs)})\"\n        else:\n            repr_true = _repr\n\n        return repr_true\n\ndef muchBeersOnTheWall(num):\n    song = MuchItemsSomewhere(initial_number=num)\n\n    return song.sing()\n\ndef balladOfProgrammer(num):\n    \"\"\"\n    Prints\n    \"99 Subtle Bugs in Production\"\n    or\n    \"The Ballad of Programmer\"\n    \"\"\"\n\n    song = MuchItemsSomewhere(\n        initial_number = num,\n        items = \"subtle bugs\",\n        item = \"subtle bug\",\n        where = \"in Production\",\n        action1 = \"Debug and catch, commit a patch\",\n        action2 = \"Release the fixes, wait for some tickets\",\n        zero_items = \"Zarro\",\n    )\n\n    return song.sing()\n\ndef main(num):\n    print(f\"### {num} Bottles of Beers on the Wall ###\")\n    print()\n    print(muchBeersOnTheWall(num))\n    print()\n    print()\n    print('### \"The Ballad of Programmer\", by Marco Sulla')\n    print()\n    print(balladOfProgrammer(num))\n\nif __name__ == \"__main__\":\n    # Ok, argparse is **really** too much\n    argv = sys.argv\n\n    if len(argv) == 1:\n        num = None\n    elif len(argv) == 2:\n        try:\n            num = int(argv[1])\n        except Exception:\n            raise ValueError(\n                f\"{__file__} parameter must be an integer, or can be omitted\"\n            )\n    else:\n        raise RuntimeError(f\"{__file__} takes one parameter at max\")\n\n    main(num)\n\n__all__ = (Song.__name__, MuchItemsSomewhere.__name__, muchBeersOnTheWall.__name__, balladOfProgrammer.__name__)\n"
  },
  {
    "language": "Python",
    "code": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfor line in sys.stdin:\n    print(sum(map(int, line.split())))\n"
  },
  {
    "language": "Python",
    "code": "'''\nNote that this code is broken, e.g., it won't work when\nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\",\n                     \"COMMON\", \"squad\", \"Confused\"]))\n"
  },
  {
    "language": "Python",
    "code": "BLOCKS = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\n\ndef _abc(word, blocks):\n    for i, ch in enumerate(word):\n        for blk in (b for b in blocks if ch in b):\n            whatsleft = word[i + 1:]\n            blksleft = blocks[:]\n            blksleft.remove(blk)\n            if not whatsleft:\n                return True, blksleft\n            if not blksleft:\n                return False, blksleft\n            ans, blksleft = _abc(whatsleft, blksleft)\n            if ans:\n                return ans, blksleft\n        else:\n            break\n    return False, blocks\n\ndef abc(word, blocks=BLOCKS):\n    return _abc(word.upper(), blocks)[0]\n\nif __name__ == '__main__':\n    for word in [''] + 'A BARK BoOK TrEAT COmMoN SQUAD conFUsE'.split():\n        print('Can we spell %9r? %r' % (word, abc(word)))\n"
  },
  {
    "language": "Python",
    "code": "def mkword(w, b):\n    if not w: return []\n\n    c,w = w[0],w[1:]\n    for i in range(len(b)):\n        if c in b[i]:\n            m = mkword(w, b[0:i] + b[i+1:])\n            if m != None: return [b[i]] + m\n\ndef abc(w, blk):\n    return mkword(w.upper(), [a.upper() for a in blk])\n\nblocks = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\n\nfor w in \", A, bark, book, treat, common, SQUAD, conFUsEd\".split(', '):\n    print '\\'' + w + '\\'' + ' ->', abc(w, blocks)\n"
  },
  {
    "language": "Python",
    "code": "class BaseQueue(object):\n    \"\"\"Abstract/Virtual Class\n    \"\"\"\n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"
  },
  {
    "language": "Python",
    "code": "from abc import ABCMeta, abstractmethod\n\nclass BaseQueue():\n    \"\"\"Abstract Class\n    \"\"\"\n    __metaclass__ = ABCMeta\n\n    def __init__(self):\n        self.contents = list()\n\n    @abstractmethod\n    def Enqueue(self, item):\n        pass\n\n    @abstractmethod\n    def Dequeue(self):\n        pass\n\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"
  },
  {
    "language": "Python",
    "code": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>>\n>>> rangemax = 20000\n>>>\n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n...\n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n...\n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"
  },
  {
    "language": "Ruby",
    "code": "doors = Array.new(101,0)\nprint \"Open doors \"\n(1..100).step(){ |i|\n(i..100).step(i) { |d|\n    doors[d] = doors[d]^= 1\n    if i == d and doors[d] == 1 then\n      print \"#{i} \"\n    end\n  }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class Door\n  attr_reader :state\n\n  def initialize\n    @state = :closed\n  end\n\n  def close\n    @state = :closed\n  end\n\n  def open\n    @state = :open\n  end\n\n  def closed?\n    @state == :closed\n  end\n\n  def open?\n    @state == :open\n  end\n\n  def toggle\n    if closed? then open else close end\n  end\n\n  def to_s\n    @state.to_s\n  end\nend\n\ndoors = Array.new(100) { Door.new }\n1.upto(100) do |multiplier|\n  doors.each_with_index do |door, i|\n    door.toggle if (i + 1) % multiplier == 0\n  end\nend\n\ndoors.each_with_index { |door, i| puts \"Door #{i+1} is #{door}.\" }\n"
  },
  {
    "language": "Ruby",
    "code": "n = 100\nOpen = \"open\"\nClosed = \"closed\"\ndef Open.toggle\n  Closed\nend\ndef Closed.toggle\n  Open\nend\ndoors = [Closed] * (n + 1)\nfor mul in 1..n\n  for x in (mul..n).step(mul)\n    doors[x] = doors[x].toggle\n  end\nend\ndoors.each_with_index do |b, i|\n  puts \"Door #{i} is #{b}\" if i > 0\nend\n"
  },
  {
    "language": "Ruby",
    "code": "n = 100\n(1..n).each do |i|\n  puts \"Door #{i} is #{i**0.5 == (i**0.5).round ? \"open\" : \"closed\"}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "doors = [false] * 100\n100.times do |i|\n  (i ... doors.length).step(i + 1) do |j|\n    doors[j] = !doors[j]\n  end\nend\nputs doors.map.with_index(1){|d,i| \"Door #{i} is #{d ? 'open' : 'closed'}.\"}\n"
  },
  {
    "language": "Ruby",
    "code": "class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n\n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n\n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      # evaluate using rational arithmetic\n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 # catch division by zero\n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n# validate user input\ndigits = ARGV.map do |arg|\n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '#{arg}'\"\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have #{digits.size}\"\n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found #{solutions.size} solutions, including #{solutions.first}\"\n  puts solutions.sort\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives #{result}!\"\n    end\n    puts \"You win!\"\n  end\n\n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using #{nums}: \"\n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n\n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n\n    error ? puts(\"Invalid input of a(n) #{name.to_s.tr('_',' ')}!\") : true\n  end\n\n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        # r : Rational suffix\n    eval \"(#{as_rat}).to_f\"\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n"
  },
  {
    "language": "Ruby",
    "code": "# Generate IPF triangle\n# Nigel_Galloway: May 1st., 2013.\ndef g(n,g)\n  return 1 unless 1 < g and g < n-1\n  (2..g).inject(1){|res,q| res + (q > n-g ? 0 : g(n-g,q))}\nend\n\n(1..25).each {|n|\n  puts (1..n).map {|g| \"%4s\" % g(n,g)}.join\n}\n"
  },
  {
    "language": "Ruby",
    "code": "# Find large values of IPF\n# Nigel_Galloway: May 1st., 2013.\nN = 12345\n@ng = []\n@ipn1 = []\n@ipn2 = []\ndef g(n,g)\n  t = n-g-2\n  return 1 if n<4 or t<0\n  return @ng[g-2][n-4] unless n/2<g\n  return @ipn1[t]\nend\n@ng[0] = []\n(4..N).each {|q| @ng[0][q-4] = 1 + g(q-2,2)}\n@ipn1[0] = @ng[0][0]\n@ipn2[0] = @ng[0][N-4]\n(1...(N/2-1)).each {|n|\n  @ng[n] = []\n  (n*2+4..N).each {|q| @ng[n][q-4] = g(q-1,n+1) + g(q-n-2,n+2)}\n  @ipn1[n] = @ng[n][n*2]\n  @ipn2[n] = @ng[n][N-4]\n  @ng[n-1] = nil\n}\n@ipn2.pop if N.even?\n\nputs \"G(23) = #{@ipn1[21]}\"\nputs \"G(123) = #{@ipn1[121]}\"\nputs \"G(1234) = #{@ipn1[1232]}\"\nn = 3 + @ipn1.inject(:+) + @ipn2.inject(:+)\nputs \"G(12345) = #{n}\"\n"
  },
  {
    "language": "Ruby",
    "code": "plural = 's'\n99.downto(1) do |i|\n  puts \"#{i} bottle#{plural} of beer on the wall,\"\n  puts \"#{i} bottle#{plural} of beer\"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"#{i-1} bottle#{plural} of beer on the wall!\"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "trace_var :$bottle_num do |val|\n  $bottles = %Q{#{val == 0 ? 'No more' : val.to_s} bottle#{val == 1 ? '' : 's'}}\nend\n\n($bottle_num = 99).times do\n  puts \"#{$bottles} of beer on the wall\"\n  puts \"#{$bottles} of beer\"\n  puts \"Take one down, pass it around\"\n  $bottle_num -= 1\n  puts \"#{$bottles} of beer on the wall\"\n  puts \"\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def bottles(of_beer, ending)\n  puts \"#{of_beer} bottle#{ending} of beer on the wall,\"\n  puts \"#{of_beer} bottle#{ending} of beer\"\n  puts \"Take one down, pass it around!\"\nend\n\n99.downto(0) do |left|\n  if left > 1\n    bottles(left, \"s\")\n  elsif left == 1\n    bottles(left, \"\")\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def bottles(beer, wall = false)\n  \"#{beer>0 ? beer : \"no more\"} bottle#{\"s\" if beer!=1} of beer#{\" on the wall\" if wall}\"\nend\n\n99.downto(0) do |remaining|\n  puts \"#{bottles(remaining,true).capitalize}, #{bottles(remaining)}.\"\n  if remaining==0\n    print \"Go to the store and buy some more\"\n    remaining=100\n  else\n    print \"Take one down, pass it around\"\n  end\n  puts \", #{bottles(remaining-1,true)}.\\n\\n\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "99.downto(1) do |bottles|\n  puts \"#{bottles} bottle#{\"s\" if bottles != 1} of beer on the wall.\",\n       \"#{bottles} bottle#{\"s\" if bottles != 1} of beer.\",\n       \"Take one down, pass it around.\",\n       \"#{bottles - 1} bottle#{\"s\" if bottles - 1 != 1} of beer on the wall.\\n\\n\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "puts gets.split.sum(&:to_i)\n"
  },
  {
    "language": "Ruby",
    "code": "words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?#{c}\\w?/i, \"\")}  #regexps can be interpolated like strings\n  puts \"#{word.inspect}: #{res}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'abstraction'\n\nclass AbstractQueue\n  abstract\n  def enqueue(object)\n    raise NotImplementedError\n  end\n  def dequeue\n    raise NotImplementedError\n  end\nend\n\nclass ConcreteQueue < AbstractQueue\n  def enqueue(object)\n    puts \"enqueue #{object.inspect}\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "res = Hash.new(0)\n(1 .. 20_000).each{|n| res[n.proper_divisors.sum <=> n] += 1}\nputs \"Deficient: #{res[-1]}   Perfect: #{res[0]}   Abundant: #{res[1]}\"\n"
  },
  {
    "language": "Ruby",
    "code": "def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n# mixing Integer and Float\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  # prints 8.3\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rational'\nrequire 'complex'\ny = accumulator(Rational(2, 3))\nputs y[Rational(1, 2)]  # 7/6\nputs y[4]               # 31/6\nputs y[Complex(0, 1)]   # 31/6+1i\n\nt = accumulator(Time.utc(1999, 8, 7, 6, 5))\n                       # (Ruby 1.8.6)                  (Ruby 1.9.2)\nputs t[4]              # Sat Aug 07 06:05:04 UTC 1999  1999-08-07 06:05:04 UTC\nputs t[-12 * 60 * 60]  # Fri Aug 06 18:05:04 UTC 1999  1999-08-06 18:05:04 UTC\n\nrequire 'matrix'\nm = accumulator(Matrix[[1, 2], [3, 4]])\nputs m[Matrix[[5, 6], [7, 8]]]  # Matrix[[6, 8], [10, 12]]\n"
  },
  {
    "language": "Ruby",
    "code": "def accumulator(sum)\n  lambda {|n| sum += n}\nend\nclass << self\n  define_method :x, &accumulator(1)\nend\nx(5)\naccumulator(3)\nputs x(2.3)  # prints 8.3\n"
  },
  {
    "language": "Ruby",
    "code": "def ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rubygems'\nrequire 'net/ldap'\nldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')\nldap.authenticate('bind_dn', 'bind_pass')\n"
  },
  {
    "language": "Ruby",
    "code": "require 'rubygems'\nrequire 'net/ldap'\n\nldap = Net::LDAP.new(:host => 'hostname', :base => 'base')\nldap.authenticate('bind_dn', 'bind_pass')\n\nfilter = Net::LDAP::Filter.pres('objectclass')\nfilter &= Net::LDAP::Filter.eq('sn','Jackman')\n# or\nfilter = Net::LDAP::Filter.construct('(&(objectclass=*)(sn=Jackman))')\n\nresults = ldap.search(:filter => filter)  # returns an array of Net::LDAP::Entry objects\n\nputs results[0][:sn]  # ==> \"Jackman\"\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let mut door_open = [false; 100];\n    for pass in 1..100 {\n        let mut door = pass;\n        while door <= 100 {\n            door_open[door - 1] = !door_open[door - 1];\n            door += pass;\n        }\n    }\n    for (i, &is_open) in door_open.iter().enumerate() {\n        println!(\"Door {} is {}.\", i + 1, if is_open {\"open\"} else {\"closed\"});\n    }\n}\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let doors = vec![false; 100].iter_mut().enumerate()\n                                .map(|(door, door_state)| (1..100).into_iter()\n                                                                   .filter(|pass| door % pass == 0)\n                                                                   .map(|_| { *door_state = !*door_state; *door_state })\n                                                                   .last().unwrap()).collect::<Vec<_>>();\n\n    println!(\"{:?}\", doors);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let squares: Vec<_> = (1..10).map(|n| n*n).collect();\n    let is_square = |num| squares.binary_search(&num).is_ok();\n\n    for i in 1..100 {\n        let state = if is_square(i) {\"open\"} else {\"closed\"};\n        println!(\"Door {} is {}\", i, state);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    for i in 1u32..10u32{\n        println!(\"Door {} is open\", i.pow(2));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone, Copy, Debug)]\nenum Operator {\n    Sub,\n    Plus,\n    Mul,\n    Div,\n}\n\n#[derive(Clone, Debug)]\nstruct Factor {\n    content: String,\n    value: i32,\n}\n\nfn apply(op: Operator, left: &[Factor], right: &[Factor]) -> Vec<Factor> {\n    let mut ret = Vec::new();\n    for l in left.iter() {\n        for r in right.iter() {\n            use Operator::*;\n            ret.push(match op {\n                Sub if l.value > r.value => Factor {\n                    content: format!(\"({} - {})\", l.content, r.content),\n                    value: l.value - r.value,\n                },\n                Plus => Factor {\n                    content: format!(\"({} + {})\", l.content, r.content),\n                    value: l.value + r.value,\n                },\n                Mul => Factor {\n                    content: format!(\"({} x {})\", l.content, r.content),\n                    value: l.value * r.value,\n                },\n                Div if l.value >= r.value && r.value > 0 && l.value % r.value == 0 => Factor {\n                    content: format!(\"({} / {})\", l.content, r.content),\n                    value: l.value / r.value,\n                },\n                _ => continue,\n            })\n        }\n    }\n    ret\n}\n\nfn calc(op: [Operator; 3], numbers: [i32; 4]) -> Vec<Factor> {\n    fn calc(op: &[Operator], numbers: &[i32], acc: &[Factor]) -> Vec<Factor> {\n        use Operator::*;\n        if op.is_empty() {\n            return Vec::from(acc)\n        }\n        let mut ret = Vec::new();\n        let mono_factor = [Factor {\n            content: numbers[0].to_string(),\n            value: numbers[0],\n        }];\n        match op[0] {\n            Mul => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n            Div => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Sub => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Plus => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n        }\n        calc(&op[1..], &numbers[1..], &ret)\n    }\n    calc(&op, &numbers[1..], &[Factor { content: numbers[0].to_string(), value: numbers[0] }])\n}\n\nfn solutions(numbers: [i32; 4]) -> Vec<Factor> {\n    use std::collections::hash_set::HashSet;\n    let mut ret = Vec::new();\n    let mut hash_set = HashSet::new();\n\n    for ops in OpIter(0) {\n        for o in orders().iter() {\n            let numbers = apply_order(numbers, o);\n            let r = calc(ops, numbers);\n            ret.extend(r.into_iter().filter(|&Factor { value, ref content }| value == 24 && hash_set.insert(content.to_owned())))\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut numbers = Vec::new();\n    if let Some(input) = std::env::args().skip(1).next() {\n        for c in input.chars() {\n            if let Ok(n) = c.to_string().parse() {\n                numbers.push(n)\n            }\n            if numbers.len() == 4 {\n                let numbers = [numbers[0], numbers[1], numbers[2], numbers[3]];\n                let solutions = solutions(numbers);\n                let len = solutions.len();\n                if len == 0 {\n                    println!(\"no solution for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                    return\n                }\n                println!(\"solutions for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                for s in solutions {\n                    println!(\"{}\", s.content)\n                }\n                println!(\"{} solutions found\", len);\n                return\n            }\n        }\n    } else {\n        println!(\"empty input\")\n    }\n}\n\n\nstruct OpIter (usize);\n\nimpl Iterator for OpIter {\n    type Item = [Operator; 3];\n    fn next(&mut self) -> Option<[Operator; 3]> {\n        use Operator::*;\n        const OPTIONS: [Operator; 4] = [Mul, Sub, Plus, Div];\n        if self.0 >= 1 << 6 {\n            return None\n        }\n        let f1 = OPTIONS[(self.0 & (3 << 4)) >> 4];\n        let f2 = OPTIONS[(self.0 & (3 << 2)) >> 2];\n        let f3 = OPTIONS[(self.0 & (3 << 0)) >> 0];\n        self.0 += 1;\n        Some([f1, f2, f3])\n    }\n}\n\nfn orders() -> [[usize; 4]; 24] {\n    [\n        [0, 1, 2, 3],\n        [0, 1, 3, 2],\n        [0, 2, 1, 3],\n        [0, 2, 3, 1],\n        [0, 3, 1, 2],\n        [0, 3, 2, 1],\n        [1, 0, 2, 3],\n        [1, 0, 3, 2],\n        [1, 2, 0, 3],\n        [1, 2, 3, 0],\n        [1, 3, 0, 2],\n        [1, 3, 2, 0],\n        [2, 0, 1, 3],\n        [2, 0, 3, 1],\n        [2, 1, 0, 3],\n        [2, 1, 3, 0],\n        [2, 3, 0, 1],\n        [2, 3, 1, 0],\n        [3, 0, 1, 2],\n        [3, 0, 2, 1],\n        [3, 1, 0, 2],\n        [3, 1, 2, 0],\n        [3, 2, 0, 1],\n        [3, 2, 1, 0]\n    ]\n}\n\nfn apply_order(numbers: [i32; 4], order: &[usize; 4]) -> [i32; 4] {\n    [numbers[order[0]], numbers[order[1]], numbers[order[2]], numbers[order[3]]]\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self,BufRead};\nextern crate rand;\nuse rand::Rng;\n\nfn op_type(x: char) -> i32{\n    match x {\n        '-' | '+' => return 1,\n        '/' | '*' => return 2,\n        '(' | ')' => return -1,\n        _   => return 0,\n    }\n}\n\nfn to_rpn(input: &mut String){\n\n    let mut rpn_string : String = String::new();\n    let mut rpn_stack : String = String::new();\n    let mut last_token = '#';\n    for token in input.chars(){\n        if token.is_digit(10) {\n            rpn_string.push(token);\n        }\n        else if op_type(token) == 0 {\n            continue;\n        }\n        else if op_type(token) > op_type(last_token) || token == '(' {\n                rpn_stack.push(token);\n                last_token=token;\n        }\n        else {\n            while let Some(top) = rpn_stack.pop() {\n                if top=='(' {\n                    break;\n                }\n                rpn_string.push(top);\n            }\n            if token != ')'{\n                rpn_stack.push(token);\n            }\n        }\n    }\n    while let Some(top) = rpn_stack.pop() {\n        rpn_string.push(top);\n    }\n\n    println!(\"you formula results in {}\", rpn_string);\n\n    *input=rpn_string;\n}\n\nfn calculate(input: &String, list : &mut [u32;4]) -> f32{\n    let mut stack : Vec<f32> = Vec::new();\n    let mut accumulator : f32 = 0.0;\n\n    for token in input.chars(){\n        if token.is_digit(10) {\n            let test = token.to_digit(10).unwrap() as u32;\n            match list.iter().position(|&x| x == test){\n                Some(idx) => list[idx]=10 ,\n                _         => println!(\" invalid digit: {} \",test),\n            }\n            stack.push(accumulator);\n            accumulator = test as f32;\n        }else{\n            let a = stack.pop().unwrap();\n            accumulator = match token {\n                '-' => a-accumulator,\n                '+' => a+accumulator,\n                '/' => a/accumulator,\n                '*' => a*accumulator,\n                _ => {accumulator},//NOP\n            };\n        }\n    }\n    println!(\"you formula results in {}\",accumulator);\n    accumulator\n}\n\nfn main() {\n\n    let mut rng = rand::thread_rng();\n    let mut list :[u32;4]=[rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10];\n\n    println!(\"form 24 with using + - / * {:?}\",list);\n    //get user input\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    //convert to rpn\n    to_rpn(&mut input);\n    let result = calculate(&input, &mut list);\n\n    if list.iter().any(|&list| list !=10){\n        println!(\"and you used all numbers\");\n        match result {\n            24.0 => println!(\"you won\"),\n            _ => println!(\"but your formulla doesn't result in 24\"),\n        }\n    }else{\n        println!(\"you didn't use all the numbers\");\n    }\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate num;\n\nuse std::cmp;\nuse num::bigint::BigUint;\n\nfn cumu(n: usize, cache: &mut Vec<Vec<BigUint>>) {\n    for l in cache.len()..n+1 {\n        let mut r = vec![BigUint::from(0u32)];\n        for x in 1..l+1 {\n            let prev = r[r.len() - 1].clone();\n            r.push(prev + cache[l-x][cmp::min(x, l-x)].clone());\n        }\n        cache.push(r);\n    }\n}\n\nfn row(n: usize, cache: &mut Vec<Vec<BigUint>>) -> Vec<BigUint> {\n    cumu(n, cache);\n    let r = &cache[n];\n    let mut v: Vec<BigUint> = Vec::new();\n\n    for i in 0..n {\n        v.push(&r[i+1] - &r[i]);\n    }\n    v\n}\n\nfn main() {\n    let mut cache = vec![vec![BigUint::from(1u32)]];\n\n    println!(\"rows:\");\n    for x in 1..26 {\n        let v: Vec<String> = row(x, &mut cache).iter().map(|e| e.to_string()).collect();\n        let s: String = v.join(\" \");\n        println!(\"{}: {}\", x, s);\n    }\n\n    println!(\"sums:\");\n    for x in vec![23, 123, 1234, 12345] {\n        cumu(x, &mut cache);\n        let v = &cache[x];\n        let s = v[v.len() - 1].to_string();\n        println!(\"{}: {}\", x, s);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n\tfor n in (0..100).rev() {\n\t\tmatch n {\n\t\t\t0 => {\n\t\t\t\tprintln!(\"No more bottles of beer on the wall, no more bottles of beer.\");\n\t\t\t\tprintln!(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n\t\t\t},\n\t\t\t1 => {\n\t\t\t\tprintln!(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n\t\t\t\tprintln!(\"Take one down and pass it around, no more bottles of beer on the wall.\\n\");\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\tprintln!(\"{0:?} bottles of beer on the wall, {0:?} bottles of beer.\", n);\n\t\t\t\tprintln!(\"Take one down and pass it around, {} bottles of beer on the wall.\\n\", n-1);\n\t\t\t},\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "trait Bottles {\n\tfn bottles_of_beer(&self) -> Self;\n\tfn on_the_wall(&self);\n}\n\nimpl Bottles for u32 {\n\tfn bottles_of_beer(&self) -> u32 {\n\t\tmatch *self {\n\t\t\t0 => print!(\"No bottles of beer\"),\n\t\t\t1 => print!(\"{} bottle of beer\", self),\n\t\t\t_ => print!(\"{} bottles of beer\", self)\n\t\t}\n\t\t*self   // return a number for chaining\n\t}\n\n\tfn on_the_wall(&self) {\n\t\tprintln!(\" on the wall!\");\n\t}\n}\n\nfn main() {\n\tfor i in (1..100).rev() {\n\t\ti.bottles_of_beer().on_the_wall();\n\t\ti.bottles_of_beer();\n\t\tprintln!(\"\\nTake one down, pass it around...\");\n\t\t(i - 1).bottles_of_beer().on_the_wall();\n\t\tprintln!(\"-----------------------------------\");\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).expect(\"reading stdin\");\n\n    let mut i: i64 = 0;\n    for word in line.split_whitespace() {\n        i += word.parse::<i64>().expect(\"trying to interpret your input as numbers\");\n    }\n    println!(\"{}\", i);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).expect(\"reading stdin\");\n\n    let sum: i64 = line.split_whitespace()\n                       .map(|x| x.parse::<i64>().expect(\"Not an integer\"))\n                       .sum();\n    println!(\"{}\", sum);\n}\n"
  },
  {
    "language": "Rust",
    "code": "trait Shape {\n    fn area(self) -> i32;\n}\n"
  },
  {
    "language": "Rust",
    "code": "struct Square {\n    side_length: i32\n}\n\nimpl Shape for Square {\n    fn area(self) -> i32 {\n        self.side_length * self.side_length\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "trait Shape {\n    fn area(self) -> i32;\n\n    fn is_shape(self) -> bool {\n        true\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    // deficient starts at 1 because 1 is deficient but proper_divisors returns\n    // and empty Vec\n    let (mut abundant, mut deficient, mut perfect) = (0u32, 1u32, 0u32);\n    for i in 1..20_001 {\n        if let Some(divisors) = i.proper_divisors() {\n            let sum: u64 = divisors.iter().sum();\n            if sum < i {\n                deficient += 1\n            } else if sum > i {\n                abundant += 1\n            } else {\n                perfect += 1\n            }\n        }\n    }\n    println!(\"deficient:\\t{:5}\\nperfect:\\t{:5}\\nabundant:\\t{:5}\",\n             deficient, perfect, abundant);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// rustc -V\n// rustc 1.2.0-nightly (0cc99f9cc 2015-05-17) (built 2015-05-18)\n\nuse std::ops::Add;\n\nfn foo<Num>(n: Num) -> Box<FnMut(Num) -> Num>\n        where Num: Add<Output=Num> + Copy + 'static {\n    let mut acc = n;\n    Box::new(move |i: Num| {\n        acc = acc + i;\n        acc\n    })\n}\n\nfn main() {\n    let mut x = foo(1.);\n    x(5.);\n    foo(3.);\n    println!(\"{}\", x(2.3));\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a); // 125\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn ack(m: u64, n: u64) -> u64 {\n\tmatch (m, n) {\n\t\t(0, n) => n + 1,\n\t\t(m, 0) => ack(m - 1, 1),\n\t\t(m, n) => ack(m - 1, ack(m, n - 1)),\n\t}\n}\n"
  },
  {
    "language": "Rust",
    "code": "let conn = ldap3::LdapConn::new(\"ldap://ldap.example.com\")?;\nconn.simple_bind(\"bind_dn\", \"bind_pass\")?.success()?;\n"
  },
  {
    "language": "Rust",
    "code": "#![feature(mpsc_select)]\n\nextern crate num;\nextern crate schedule_recv;\n\nuse num::traits::Zero;\nuse num::Float;\nuse schedule_recv::periodic_ms;\nuse std::f64::consts::PI;\nuse std::ops::Mul;\nuse std::sync::mpsc::{self, SendError, Sender};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\npub type Actor<S> = Sender<Box<Fn(u32) -> S + Send>>;\npub type ActorResult<S> = Result<(), SendError<Box<Fn(u32) -> S + Send>>>;\n\n/// Rust supports both shared-memory and actor models of concurrency, and the `Integrator` utilizes\n/// both.  We use an `Actor` to send the `Integrator` new functions, while we use a `Mutex`\n/// (shared-memory concurrency) to hold the result of the integration.\n///\n/// Note that these are not the only options here--there are many, many ways you can deal with\n/// concurrent access.  But when in doubt, a plain old `Mutex` is often a good bet.  For example,\n/// this might look like a good situation for a `RwLock`--after all, there's no reason for a read\n/// in the main task to block writes.  Unfortunately, unless you have significantly more reads than\n/// writes (which is certainly not the case here), a `Mutex` will usually outperform a `RwLock`.\npub struct Integrator<S: 'static, T: Send> {\n    input: Actor<S>,\n    output: Arc<Mutex<T>>,\n}\n\n/// In Rust, time durations are strongly typed.  This is usually exactly what you want, but for a\n/// problem like this--where the integrated value has unusual (unspecified?) units--it can actually\n/// be a bit tricky.  Right now, `Duration`s can only be multiplied or divided by `i32`s, so in\n/// order to be able to actually do math with them we say that the type parameter `S` (the result\n/// of the function being integrated) must yield `T` (the type of the integrated value) when\n/// multiplied by `f64`.  We could possibly replace `f64` with a generic as well, but it would make\n/// things a bit more complex.\nimpl<S, T> Integrator<S, T>\nwhere\n    S: Mul<f64, Output = T> + Float + Zero,\n    T: 'static + Clone + Send + Float,\n{\n    pub fn new(frequency: u32) -> Integrator<S, T> {\n        // We create a pipe allowing functions to be sent from tx (the sending end) to input (the\n        // receiving end).  In order to change the function we are integrating from the task in\n        // which the Integrator lives, we simply send the function through tx.\n        let (tx, input) = mpsc::channel();\n        // The easiest way to do shared-memory concurrency in Rust is to use atomic reference\n        // counting, or Arc, around a synchronized type (like Mutex<T>).  Arc gives you a guarantee\n        // that memory will not be freed as long as there is at least one reference to it.\n        // It is similar to C++'s shared_ptr, but it is guaranteed to be safe and is never\n        // incremented unless explicitly cloned (by default, it is moved).\n        let s: Arc<Mutex<T>> = Arc::new(Mutex::new(Zero::zero()));\n        let integrator = Integrator {\n            input: tx,\n            // Here is the aforementioned clone.  We have to do it before s enters the closure,\n            // because once that happens it is moved into the closure (and later, the new task) and\n            // becomes inaccessible to the outside world.\n            output: Arc::clone(&s),\n        };\n        thread::spawn(move || -> () {\n            // The frequency is how often we want to \"tick\" as we update our integrated total.  In\n            // Rust, timers can yield Receivers that are periodically notified with an empty\n            // message (where the period is the frequency).  This is useful because it lets us wait\n            // on either a tick or another type of message (in this case, a request to change the\n            // function we are integrating).\n            let periodic = periodic_ms(frequency);\n            let mut t = 0;\n            let mut k: Box<Fn(u32) -> S + Send> = Box::new(|_| Zero::zero());\n            let mut k_0: S = Zero::zero();\n            loop {\n                // Here's the selection we talked about above.  Note that we are careful to call\n                // the *non*-failing function, recv(), here.  The reason we do this is because\n                // recv() will return Err when the sending end of a channel is dropped.  While\n                // this is unlikely to happen for the timer (so again, you could argue for failure\n                // there), it's normal behavior for the sending end of input to be dropped, since\n                // it just happens when the Integrator falls out of scope.  So we handle it cleanly\n                // and break out of the loop, rather than failing.\n                select! {\n                    res = periodic.recv() => match res {\n                        Ok(_) => {\n                            t += frequency;\n                            let k_1: S = k(t);\n                            // Rust Mutexes are a bit different from Mutexes in many other\n                            // languages, in that the protected data is actually encapsulated by\n                            // the Mutex.  The reason for this is that Rust is actually capable of\n                            // enforcing (via its borrow checker) the invariant that the contents\n                            // of a Mutex may only be read when you have acquired its lock.  This\n                            // is enforced by way of a MutexGuard, the return value of lock(),\n                            // which implements some special traits (Deref and DerefMut) that allow\n                            // access to the inner element \"through\" the guard.  The element so\n                            // acquired has a lifetime bounded by that of the MutexGuard, the\n                            // MutexGuard can only be acquired by taking a lock, and the only way\n                            // to release the lock is by letting the MutexGuard fall out of scope,\n                            // so it's impossible to access the data incorrectly.  There are some\n                            // additional subtleties around the actual implementation, but that's\n                            // the basic idea.\n                            let mut s = s.lock().unwrap();\n                            *s = *s + (k_1 + k_0) * (f64::from(frequency) / 2.);\n                            k_0 = k_1;\n                        }\n                        Err(_) => break,\n                    },\n                    res = input.recv() => match res {\n                        Ok(k_new) => k = k_new,\n                        Err(_) => break,\n                    }\n                }\n            }\n        });\n        integrator\n    }\n\n    pub fn input(&self, k: Box<Fn(u32) -> S + Send>) -> ActorResult<S> {\n        // The meat of the work is done in the other thread, so to set the\n        // input we just send along the Sender we set earlier...\n        self.input.send(k)\n    }\n\n    pub fn output(&self) -> T {\n        // ...and to read the input, we simply acquire a lock on the output Mutex and return a\n        // copy. Why do we have to copy it?  Because, as mentioned above, Rust won't let us\n        // retain access to the interior of the Mutex unless we have possession of its lock.  There\n        // are ways and circumstances in which one can avoid this (e.g. by using atomic types) but\n        // a copy is a perfectly reasonable solution as well, and a lot easier to reason about :)\n        *self.output.lock().unwrap()\n    }\n}\n\n/// This function is fairly straightforward.  We create the integrator, set its input function k(t)\n/// to 2pi * f * t, and then wait as described in the Rosetta stone problem.\nfn integrate() -> f64 {\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / f64::from(two_seconds_ms);\n            (2. * PI * f * f64::from(t)).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_secs(2));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(500));\n    object.output()\n}\n\nfn main() {\n    println!(\"{}\", integrate());\n}\n\n/// Will fail on a heavily loaded machine\n#[test]\n#[ignore]\nfn solution() {\n    // We should just be able to call integrate, but can't represent the closure properly due to\n    // rust-lang/rust issue #17060 if we make frequency or period a variable.\n    // FIXME(pythonesque): When unboxed closures are fixed, fix integrate() to take two arguments.\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / (two_seconds_ms / 10) as f64;\n            (2. * PI * f * t as f64).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(200));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(100));\n    assert_eq!(object.output() as u32, 0)\n}\n"
  },
  {
    "language": "Rust",
    "code": "let v1 = vec![vec![1,2,3]; 10];\nprintln!(\"Original address: {:p}\", &v1);\nlet mut v2;\n// Override rust protections on reading from uninitialized memory\nunsafe {v2 = mem::uninitialized();}\nlet addr = &mut v2 as *mut _;\n\n// ptr::write() though it takes v1 by value, v1s destructor is not run when it goes out of\n// scope, which is good since then we'd have a vector of free'd vectors\nunsafe {ptr::write(addr, v1)}\nprintln!(\"New address: {:p}\", &v2);\n"
  },
  {
    "language": "Rust",
    "code": "let var = 1;\nprintln!(\"address of var: {:p}\", &var);\n"
  },
  {
    "language": "Rust",
    "code": "let address: usize = 0x7ffc8f303130;\nunsafe {\n    let val = *(address as *const usize);\n    println!(\"value at {}: {:?}\", address, val);\n}\n"
  },
  {
    "language": "Rust",
    "code": "unsafe {\n    *(0x7ffc8f303130 as *mut usize) = 1;\n    // Note that this invokes undefined behavior if 0x7ffc8f303130 is uninitialized. In that case, std::ptr::write should be used.\n    std::ptr::write(0x7ffc8f303130 as *mut usize, 1);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn aks_coefficients(k: usize) -> Vec<i64> {\n    let mut coefficients = vec![0i64; k + 1];\n    coefficients[0] = 1;\n    for i in 1..(k + 1) {\n        coefficients[i] = -(1..i).fold(coefficients[0], |prev, j|{\n            let old = coefficients[j];\n            coefficients[j] = old - prev;\n            old\n        });\n    }\n    coefficients\n}\n\nfn is_prime(p: usize) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let c = aks_coefficients(p);\n        (1..p / 2 + 1).all(|i| c[i] % p as i64 == 0)\n    }\n}\n\nfn main() {\n    for i in 0..8 {\n        println!(\"{}: {:?}\", i, aks_coefficients(i));\n    }\n    for i in (1..=50).filter(|&i| is_prime(i)) {\n        print!(\"{} \", i);\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* do the 100 passes */\nfor i in 1...100 {\n    /* map on a strideTo instance to only visit the needed doors on each iteration */\n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* set i^2 doors to opened */\nvar i = 1\ndo {\n    doorsStateList[(i*i)-1] = DoorState.Opened\n    ++i\n} while (i*i) <= doorsStateList.count\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits : \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n// check value of expression provided by the operator\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n\n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n\n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n\n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n\n\n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n\n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n\n        for oper in opr {\n          expression += oper\n        }\n\n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n// n=4, total=64, npow=16\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n\n  var solution = \"\"\n\n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n\n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits : \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n// check value of expression provided by the operator\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet input = FileHandle.standardInput\n\nlet data = input.availableData\nlet str = String(data: data, encoding: .utf8)!\nlet nums = str.split(separator: \" \")\n    .map { String($0.unicodeScalars\n        .filter { CharacterSet.decimalDigits.contains($0) }) }\n\nlet a = Int(nums[0])!\nlet b = Int(nums[1])!\n\nprint(\" \\(a + b)\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Swift\n\nfunc canMake(word: String) -> Bool {\n\tvar blocks = [\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t]\n\t\n\tfor letter in word.uppercased().characters {\n\t\tguard let index = blocks.index(where: { $0.characters.contains(letter) }) else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tblocks.remove(at: index)\n\t}\n\t\n\treturn true\n}\n\nlet words = [\"a\", \"bARK\", \"boOK\", \"TreAt\", \"CoMmon\", \"SquAd\", \"CONFUse\"]\n\nwords.forEach { print($0, canMake(word: $0)) }\n"
  },
  {
    "language": "Swift",
    "code": "var deficients = 0 // sumPd < n\nvar perfects = 0 // sumPd = n\nvar abundants = 0 // sumPd > n\n\n// 1 is deficient (no proper divisor)\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 // 1 is a proper divisor of all integer above 1\n\n    var maxPdToTest = i/2 // the max divisor to test\n\n    for var j = 2; j < maxPdToTest; j++ {\n\n        if (i%j) == 0 {\n            // j is a proper divisor\n            sumPd += j\n\n            // New maximum for divisibility check\n            maxPdToTest = i / j\n\n            // To add to sum of proper divisors unless already done\n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n\n    // Select type according to sum of Proper divisors\n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n"
  },
  {
    "language": "Swift",
    "code": "func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n"
  },
  {
    "language": "Swift",
    "code": "func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "// For NSObject, NSTimeInterval and NSThread\nimport Foundation\n// For PI and sin\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n\n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n\n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n\n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n\n    func Output() -> Double {\n        return S\n    }\n\n}\n\n// main\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n\n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet fooKey = UnsafeMutablePointer<UInt8>.alloc(1)\n\nclass MyClass { }\nlet e = MyClass()\n\n// set\nobjc_setAssociatedObject(e, fooKey, 1, .OBJC_ASSOCIATION_RETAIN)\n\n// get\nif let associatedObject = objc_getAssociatedObject(e, fooKey) {\n  print(\"associated object: \\(associatedObject)\")\n} else {\n  print(\"no associated object\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "class MyClass { }\n\nfunc printAddress<T>(of pointer: UnsafePointer<T>) {\n    print(pointer)\n}\n\nfunc test() {\n    var x = 42\n    var y = 3.14\n    var z = \"foo\"\n    var obj = MyClass()\n\n    // Use a pointer to a variable on the stack and print its address.\n    withUnsafePointer(to: &x)   { print($0) }\n    withUnsafePointer(to: &y)   { print($0) }\n    withUnsafePointer(to: &z)   { print($0) }\n    withUnsafePointer(to: &obj) { print($0) }\n\n    // Alternately:\n    printAddress(of: &x)\n    printAddress(of: &y)\n    printAddress(of: &z)\n    printAddress(of: &obj)\n\n    // Printing the address of an object that an object reference points to.\n    print(Unmanaged.passUnretained(obj).toOpaque())\n}\n\ntest()\n"
  },
  {
    "language": "Swift",
    "code": "func polynomialCoeffs(n: Int) -> [Int] {\n    var result = [Int](count : n+1, repeatedValue : 0)\n\n    result[0]=1\n    for i in 1 ..< n/2+1 { //Progress up, until reaching the middle value\n        result[i] = result[i-1] * (n-i+1)/i;\n    }\n    for i in n/2+1 ..< n+1 { //Copy the inverse of the first part\n        result[i] = result[n-i];\n    }\n    // Take into account the sign\n    for i in stride(from: 1, through: n, by: 2) {\n        result[i] = -result[i]\n    }\n\n    return result\n}\n\nfunc isPrime(n: Int) -> Bool {\n\n    var coeffs = polynomialCoeffs(n)\n\n    coeffs[0]--\n    coeffs[n]++\n\n    for i in 1 ... n {\n        if coeffs[i]%n != 0 {\n            return false\n        }\n    }\n\n    return true\n}\n\nfor i in 0...10 {\n\n    let coeffs = polynomialCoeffs(i)\n\n    print(\"(x-1)^\\(i) = \")\n    if i == 0 {\n        print(\"1\")\n    } else {\n        if i == 1 {\n            print(\"x\")\n        } else {\n            print(\"x^\\(i)\")\n            if i == 2 {\n                print(\"\\(coeffs[i-1])x\")\n            } else {\n                for j in 1...(i - 2) {\n                    if j%2 == 0 {\n                        print(\"+\\(coeffs[j])x^\\(i-j)\")\n                    } else {\n                        print(\"\\(coeffs[j])x^\\(i-j)\")\n                    }\n                }\n                if (i-1)%2 == 0 {\n                    print(\"+\\(coeffs[i-1])x\")\n                } else {\n                    print(\"\\(coeffs[i-1])x\")\n                }\n            }\n        }\n        if i%2 == 0 {\n            print(\"+\\(coeffs[i])\")\n        } else {\n            print(\"\\(coeffs[i])\")\n        }\n    }\n    println()\n}\n\nprintln()\nprint(\"Primes under 50 : \")\n\nfor i in 1...50 {\n    if isPrime(i) {\n        print(\"\\(i) \")\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n\n    if n == 1 { return [] }\n\n    var result = [Int]()\n\n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n\n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n\n    return sorted(result)\n\n}\n\n\nfunc sumDivs(n:Int) -> Int {\n\n    struct Cache { static var sum = [Int:Int]() }\n\n    if let sum = Cache.sum[n] { return sum }\n\n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n\n    Cache.sum[n] = sum\n\n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n\n    if n == m { return false }\n\n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n\n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc sigma(n: Int) -> Int {\n\n    if n == 1 { return 0 }          // definition of aliquot sum\n\n    var result = 1\n    let root = sqrt(n)\n\n    for var div = 2; div <= root; ++div {\n        if n % div == 0 {\n            result += div + n/div\n        }\n\n    }\n    if root*root == n { result -= root }\n\n    return (result)\n}\n\nfunc amicables (upTo: Int) -> () {\n\n    var aliquot = Array(count: upTo+1, repeatedValue: 0)\n\n    for i in 1 ... upTo {           // fill lookup array\n        aliquot[i] = sigma(i)\n    }\n\n for i in 1 ... upTo {\n        let a = aliquot[i]\n        if a > upTo {continue}      //second part of pair out-of-bounds\n\n        if a == i {continue}        //skip perfect numbers\n\n        if i == aliquot[a] {\n            print(\"\\(i, a)\")\n            aliquot[a] = upTo+1     //prevent second display of pair\n        }\n    }\n}\n\namicables(20_000)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet wordsURL = NSURL(string: \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")!\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords//[0..<100] // used to limit the size while testing\n\nextension String {\n    var charactersAscending : String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n\n    var knownwords = charsToWords[chars] ?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let fib: Int -> Int = {\n  func f(n: Int) -> Int {\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprint(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "let fib: Int -> Int = {\n  var f: (Int -> Int)!\n  f = { n in\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprintln(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nfunc fib(n: Int) -> Int {\n  assert(n >= 0, \"fib: no negative numbers\")\n  return y {f in {n in n < 2 ? 1 : f(n-1) + f(n-2)}} (n)\n}\n\nprintln(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "func square(n: Int) -> Int {\n    return n * n\n}\n\nlet numbers = [1, 3, 5, 7]\n\nlet squares1a = numbers.map(square)         // map method on array\n\nlet squares1b = numbers.map {x in x*x}      // map method on array with anonymous function\n\nlet squares1b = numbers.map { $0 * $0 }      // map method on array with anonymous function and unnamed parameters\n\nlet isquares1 = numbers.lazy.map(square)   // lazy sequence\n"
  },
  {
    "language": "Swift",
    "code": "public struct Complex {\n\n    public let real : Double\n    public let imaginary : Double\n\n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n\n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n\n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n\n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n\n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n\n}\npublic func + (left: Complex, right: Complex) -> Complex {\n\n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n\n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n// Checking equality is almost necessary for a struct of this type  to be useful\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n"
  },
  {
    "language": "Swift",
    "code": "extension Complex : CustomStringConvertible {\n\n    public var description : String {\n\n        guard real != 0 || imaginary != 0 else { return \"0\" }\n\n        let rs : String = real != 0 ? \"\\(real)\" : \"\"\n        let iS : String\n        let sign : String\n        let iSpace = real != 0 ? \" \" : \"\"\n        switch imaginary {\n        case let i where i < 0:\n            sign = \"-\"\n            iS = i == -1 ? \"i\" : \"\\(-i)i\"\n        case let i where i > 0:\n            sign = real != 0 ? \"+\" : \"\"\n            iS = i == 1 ? \"i\" : \"\\(i)i\"\n        default:\n            sign = \"\"\n            iS = \"\"\n        }\n        return \"\\(rs)\\(iSpace)\\(sign)\\(iSpace)\\(iS)\"\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "public func - (left:Complex, right:Complex) -> Complex {\n    return left + -right\n}\n\npublic func / (divident:Complex, divisor:Complex) -> Complex {\n    let rc = divisor.conjugate\n    let num = divident * rc\n    let den = divisor * rc\n    return Complex(real: num.real/den.real, imaginary: num.imaginary/den.real)\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let a = 6\nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func gcd(with other: Self) -> Self {\n    var gcd = self\n    var b = other\n\n    while b != 0 {\n      (gcd, b) = (b, gcd % b)\n    }\n\n    return gcd\n  }\n\n  @inlinable\n  public func lcm(with other: Self) -> Self {\n    let g = gcd(with: other)\n\n    return self / g * other\n  }\n}\n\npublic struct Frac<NumType: BinaryInteger & SignedNumeric>: Equatable {\n  @usableFromInline\n  var _num: NumType\n\n  @usableFromInline\n  var _dom: NumType\n\n  @usableFromInline\n  init(_num: NumType, _dom: NumType) {\n    self._num = _num\n    self._dom = _dom\n  }\n\n  @inlinable\n  public init(numerator: NumType, denominator: NumType) {\n    let divisor = numerator.gcd(with: denominator)\n\n    self._num = numerator / divisor\n    self._dom = denominator / divisor\n  }\n\n  @inlinable\n  public static func + (lhs: Frac, rhs: Frac) -> Frac {\n    let multiplier = lhs._dom.lcm(with: rhs.denominator)\n\n    return Frac(\n      numerator: lhs._num * multiplier / lhs._dom + rhs._num * multiplier / rhs._dom,\n      denominator: multiplier\n    )\n  }\n\n  @inlinable\n  public static func += (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + rhs\n  }\n\n  @inlinable\n  public static func - (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs + -rhs\n  }\n\n  @inlinable\n  public static func -= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + -rhs\n  }\n\n  @inlinable\n  public static func * (lhs: Frac, rhs: Frac) -> Frac {\n    return Frac(numerator: lhs._num * rhs._num, denominator: lhs._dom * rhs._dom)\n  }\n\n  @inlinable\n  public static func *= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs * rhs\n  }\n\n  @inlinable\n  public static func / (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs * Frac(_num: rhs._dom, _dom: rhs._num)\n  }\n\n  @inlinable\n  public static func /= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs / rhs\n  }\n\n  @inlinable\n  prefix static func - (rhs: Frac) -> Frac {\n    return Frac(_num: -rhs._num, _dom: rhs._dom)\n  }\n}\n\nextension Frac {\n  @inlinable\n  public var numerator: NumType {\n    get { _num }\n    set {\n      let divisor = newValue.gcd(with: denominator)\n\n      _num = newValue / divisor\n      _dom = denominator / divisor\n    }\n  }\n\n  @inlinable\n  public var denominator: NumType {\n    get { _dom }\n    set {\n      let divisor = newValue.gcd(with: numerator)\n\n      _num = numerator / divisor\n      _dom = newValue / divisor\n    }\n  }\n}\n\nextension Frac: CustomStringConvertible {\n  public var description: String {\n    let neg = numerator < 0 || denominator < 0\n\n    return \"Frac(\\(neg ? \"-\" : \"\")\\(abs(numerator)) / \\(abs(denominator)))\"\n  }\n}\n\nextension Frac: Comparable {\n  @inlinable\n  public static func <(lhs: Frac, rhs: Frac) -> Bool {\n    return lhs._num * rhs._dom < lhs._dom * rhs._num\n  }\n}\n\nextension Frac: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) {\n    self._num = NumType(value)\n    self._dom = 1\n  }\n}\n\n\nfor candidate in 2..<1<<19 {\n  var sum = Frac(numerator: 1, denominator: candidate)\n\n  let m = Int(ceil(Double(candidate).squareRoot()))\n\n  for factor in 2..<m where candidate % factor == 0 {\n    sum += Frac(numerator: 1, denominator: factor)\n    sum += Frac(numerator: 1, denominator: candidate / factor)\n  }\n\n  if sum == 1 {\n    print(\"\\(candidate) is perfect\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n"
  },
  {
    "language": "Swift",
    "code": "// Arrays are typed in Swift, however, using the Any object we can add any type. Swift does not support fixed length arrays\nvar anyArray = [Any]()\nanyArray.append(\"foo\") // Adding to an Array\nanyArray.append(1) // [\"foo\", 1]\nanyArray.removeAtIndex(1) // Remove object\nanyArray[0] = \"bar\" // [\"bar\"]\n"
  },
  {
    "language": "Swift",
    "code": "var a = 5\n//...input or change a here\nassert(a == 42) // aborts program when a is not 42\nassert(a == 42, \"Error message\") // aborts program\n       // when a is not 42 with \"Error message\" for the message\n       // the error message must be a static string\n"
  },
  {
    "language": "Swift",
    "code": "// make an empty map\nvar a = [String: Int]()\n// or\nvar b: [String: Int] = [:]\n\n// make an empty map with an initial capacity\nvar c = [String: Int](minimumCapacity: 42)\n\n// set a value\nc[\"foo\"] = 3\n\n// make a map with a literal\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n"
  },
  {
    "language": "Swift",
    "code": "let myMap = [\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 ]\n\n// iterating over key-value pairs:\nfor (key, value) in myMap {\n    println(\"key = \\(key), value = \\(value)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfinal class AtomicBuckets: CustomStringConvertible {\n  var count: Int {\n    return buckets.count\n  }\n\n  var description: String {\n    return withBucketsLocked { \"\\(buckets)\" }\n  }\n\n  var total: Int {\n    return withBucketsLocked { buckets.reduce(0, +) }\n  }\n\n  private let lock = DispatchSemaphore(value: 1)\n\n  private var buckets: [Int]\n\n  subscript(n: Int) -> Int {\n    return withBucketsLocked { buckets[n] }\n  }\n\n  init(with buckets: [Int]) {\n    self.buckets = buckets\n  }\n\n  func transfer(amount: Int, from: Int, to: Int) {\n    withBucketsLocked {\n      let transferAmount = buckets[from] >= amount ? amount : buckets[from]\n\n      buckets[from] -= transferAmount\n      buckets[to] += transferAmount\n    }\n  }\n\n  private func withBucketsLocked<T>(do: () -> T) -> T {\n    let ret: T\n\n    lock.wait()\n    ret = `do`()\n    lock.signal()\n\n    return ret\n  }\n}\n\nlet bucks = AtomicBuckets(with: [21, 39, 40, 20])\nlet order = DispatchSource.makeTimerSource()\nlet chaos = DispatchSource.makeTimerSource()\nlet printer = DispatchSource.makeTimerSource()\n\nprinter.setEventHandler {\n  print(\"\\(bucks) = \\(bucks.total)\")\n}\n\nprinter.schedule(deadline: .now(), repeating: .seconds(1))\nprinter.activate()\n\norder.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n  let (v1, v2) = (bucks[b1], bucks[b2])\n\n  guard v1 != v2 else {\n    return\n  }\n\n  if v1 > v2 {\n    bucks.transfer(amount: (v1 - v2) / 2, from: b1, to: b2)\n  } else {\n    bucks.transfer(amount: (v2 - v1) / 2, from: b2, to: b1)\n  }\n}\n\norder.schedule(deadline: .now(), repeating: .milliseconds(5))\norder.activate()\n\nchaos.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n\n  bucks.transfer(amount: Int.random(in: 0..<(bucks[b1] + 1)), from: b1, to: b2)\n}\n\nchaos.schedule(deadline: .now(), repeating: .milliseconds(5))\nchaos.activate()\n\ndispatchMain()\n"
  },
  {
    "language": "Swift",
    "code": "func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n"
  },
  {
    "language": "Swift",
    "code": "// Extend the Collection protocol. Any type that conforms to extension where its Element type conforms to Hashable will automatically gain this method.\nextension Collection where Element: Hashable {\n\n    /// Return a Mode of the function, or nil if none exist.\n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        // Standard for loop. Can also use the forEach(_:) or reduce(into:) methods on self.\n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        // The max(by:) method used here to find one of the elements with the highest associated count.\n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() // returns \"a\"\n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() // returns 3\n\nlet emptyArray: [Int] = []\nemptyArray.mode() // returns nil\n"
  },
  {
    "language": "Swift",
    "code": "extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n"
  },
  {
    "language": "Swift",
    "code": "struct SimpleMovingAverage {\n  var period: Int\n  var numbers = [Double]()\n\n  mutating func addNumber(_ n: Double) -> Double {\n    numbers.append(n)\n\n    if numbers.count > period {\n      numbers.removeFirst()\n    }\n\n    guard !numbers.isEmpty else {\n      return 0\n    }\n\n    return numbers.reduce(0, +) / Double(numbers.count)\n  }\n}\n\nfor period in [3, 5] {\n  print(\"Moving average with period \\(period)\")\n\n  var averager = SimpleMovingAverage(period: period)\n\n  for n in [1.0, 2, 3, 4, 5, 5, 4, 3, 2, 1] {\n    print(\"n: \\(n); average \\(averager.addNumber(n))\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc isBal(str: String) -> Bool {\n\n  var count = 0\n\n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n\n}\n"
  },
  {
    "language": "Swift",
    "code": "isBal(\"[[[]]]\") // true\n\nisBal(\"[]][[]\") // false\n"
  },
  {
    "language": "Swift",
    "code": "func randBrack(n: Int) -> String {\n\n  var bracks: [Character] = Array(Repeat(count: n, repeatedValue: \"[\"))\n\n  for i in UInt32(n+1)...UInt32(n + n) {\n\n    bracks.insert(\"]\", atIndex: Int(arc4random_uniform(i)))\n\n  }\n\n  return String(bracks)\n\n}\n"
  },
  {
    "language": "Swift",
    "code": "randBrack(2) // \"]][[\"\n"
  },
  {
    "language": "Swift",
    "code": "func randIsBal(n: Int) {\n\n  let (bal, un) = (\"\", \"un\")\n\n  for str in (1...n).map(randBrack) {\n\n    print(\"\\(str) is \\(isBal(str) ? bal : un)balanced\\n\")\n\n  }\n}\n\nrandIsBal(4)\n"
  },
  {
    "language": "Swift",
    "code": "//    ][ is unbalanced\n//\n//    ]][[ is unbalanced\n//\n//    []][[] is unbalanced\n//\n//    [][][[]] is balanced\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n/* Reads from a file and returns the content as a String */\nfunc readFromFile(fileName file:String) -> String{\n\n    var ret:String = \"\"\n\n    let path = Foundation.URL(string: \"file://\"+file)\n\n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n\n    return ret\n}\n\n/* Calculates the probability following Benford's law */\nfunc benford(digit z:Int) -> Double {\n\n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n\n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n// get CLI input\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n// Read from given file and parse into lines\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n// check digits line by line\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n\n}\n\n// print result\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n"
  },
  {
    "language": "Swift",
    "code": "import BigInt\n\npublic func bernoulli<T: BinaryInteger & SignedNumeric>(n: Int) -> Frac<T> {\n  guard n != 0 else {\n    return 1\n  }\n\n  var arr = [Frac<T>]()\n\n  for m in 0...n {\n    arr.append(Frac(numerator: 1, denominator: T(m) + 1))\n\n    for j in stride(from: m, through: 1, by: -1) {\n      arr[j-1] = (arr[j-1] - arr[j]) * Frac(numerator: T(j), denominator: 1)\n    }\n  }\n\n  return arr[0]\n}\n\nfor n in 0...60 {\n  let b = bernoulli(n: n) as Frac<BigInt>\n\n  guard b != 0 else {\n    continue\n  }\n\n  print(\"B(\\(n)) = \\(b)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n"
  },
  {
    "language": "Swift",
    "code": "func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var recurse: ((Int, Int) -> Int?)!\n  recurse = {(low, high) in switch (low + high) / 2 {\n    case _ where high < low: return nil\n    case let mid where xs[mid] > x: return recurse(low, mid - 1)\n    case let mid where xs[mid] < x: return recurse(mid + 1, high)\n    case let mid: return mid\n  }}\n  return recurse(0, xs.count - 1)\n}\n"
  },
  {
    "language": "Swift",
    "code": "func binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var (low, high) = (0, xs.count - 1)\n  while low <= high {\n    switch (low + high) / 2 {\n      case let mid where xs[mid] > x: high = mid - 1\n      case let mid where xs[mid] < x: low = mid + 1\n      case let mid: return mid\n    }\n  }\n  return nil\n}\n"
  },
  {
    "language": "Swift",
    "code": "func testBinarySearch(n: Int) {\n  let odds = Array(stride(from: 1, through: n, by: 2))\n  let result = flatMap(0...n) {binarySearch(odds, $0)}\n  assert(result == Array(0..<odds.count))\n  println(\"\\(odds) are odd natural numbers\")\n  for it in result {\n    println(\"\\(it) is ordinal of \\(odds[it])\")\n  }\n}\n\ntestBinarySearch(12)\n\nfunc flatMap<T, U>(source: [T], transform: (T) -> U?) -> [U] {\n  return source.reduce([]) {(var xs, x) in if let x = transform(x) {xs.append(x)}; return xs}\n}\n"
  },
  {
    "language": "Swift",
    "code": "func bitwise(a: Int, b: Int) {\n  // All bitwise operations (including shifts)\n  // require both operands to be the same type\n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") // left shift\n  // for right shifts, if the operands are unsigned, Swift performs\n  // a logical shift; if signed, an arithmetic shift.\n  println(\"a >> b: \\(a >> b)\") // arithmetic right shift\n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") // logical right shift\n}\n\nbitwise(-15,3)\n"
  },
  {
    "language": "Swift",
    "code": "struct Example {\n    var notSoSecret = \"Hello!\"\n    private var secret = 42\n}\n\nlet e = Example()\nlet mirror = Mirror(reflecting: e)\n\nif let secret = mirror.children.filter({ $0.label == \"secret\" }).first?.value {\n    print(\"Value of the secret is \\(secret)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc generateRandomNumArray(numDigits: Int = 4) -> [Int] {\n  guard numDigits > 0 else {\n    return []\n  }\n\n  let needed =  min(9, numDigits)\n  var nums = Set<Int>()\n\n  repeat {\n    nums.insert(.random(in: 1...9))\n  } while nums.count != needed\n\n  return Array(nums)\n}\n\nfunc parseGuess(_ guess: String) -> [Int]? {\n  guard guess.count == 4 else {\n    return nil\n  }\n\n  let guessArray = guess.map(String.init).map(Int.init).compactMap({ $0 })\n\n  guard Set(guessArray).count == 4 else {\n    return nil\n  }\n\n  return guessArray\n}\n\nwhile true {\n  let num = generateRandomNumArray()\n  var bulls = 0\n  var cows = 0\n\n  print(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  guard let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr) else {\n    print(\"Invalid input\")\n    continue\n  }\n\n  for (guess, actual) in zip(guess, num) {\n    if guess == actual {\n      bulls += 1\n    } else if num.contains(guess) {\n      cows += 1\n    }\n  }\n\n  print(\"Actual number: \\(num.map(String.init).joined())\")\n  print(\"Your score: \\(bulls) bulls and \\(cows) cows\\n\")\n  print(\"Would you like to play again? (y): \")\n\n  guard readLine(strippingNewline: true)!.lowercased() == \"y\" else {\n    exit(0)\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) // '-' = 45\n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  // if '-', set it to 'a'-1\n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } // if larget than 'z', reduce by 27\n  if 96 == cv { cv = 45 }  // restore '-'\n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet hello = \"Hello, World!\"\nlet fromC = strdup(hello)\nlet backToSwiftString = String.fromCString(fromC)\n"
  },
  {
    "language": "Swift",
    "code": "// call a function with no args\nnoArgs()\n\n// call a function with one arg with no external name\noneArgUnnamed(1)\n\n// call a function with one arg with external name\noneArgNamed(arg: 1)\n\n// call a function with two args with no external names\ntwoArgsUnnamed(1, 2)\n\n// call a function with two args and external names\ntwoArgsNamed(arg1: 1, arg2: 2)\n\n// call a function with an optional arg\n// with arg\noptionalArguments(arg: 1)\n// without\noptionalArguments() // defaults to 0\n\n// function that takes another function as arg\nfuncArg(noArgs)\n\n// variadic function\nvariadic(opts: \"foo\", \"bar\")\n\n// getting a return value\nlet foo = returnString()\n\n// getting a bunch of return values\nlet (foo, bar, baz) = returnSomeValues()\n\n// getting a bunch of return values, discarding second returned value\nlet (foo, _, baz) = returnSomeValues()\n"
  },
  {
    "language": "Swift",
    "code": "// Class\nMyClass.method(someParameter)\n// or equivalently:\nlet foo = MyClass.self\nfoo.method(someParameter)\n\n// Instance\nmyInstance.method(someParameter)\n\n// Method with multiple arguments\nmyInstance.method(red:arg1, green:arg2, blue:arg3)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func carmichael<T: BinaryInteger & SignedNumeric>(p1: T) -> [(T, T, T)] {\n  func mod(_ n: T, _ m: T) -> T { (n % m + m) % m }\n\n  var res = [(T, T, T)]()\n\n  guard p1.isPrime else {\n    return res\n  }\n\n  for h3 in stride(from: 2, to: p1, by: 1) {\n    for d in stride(from: 1, to: h3 + p1, by: 1) {\n      if (h3 + p1) * (p1 - 1) % d != 0 || mod(-p1 * p1, h3) != d % h3 {\n        continue\n      }\n\n      let p2 = 1 + (p1 - 1) * (h3 + p1) / d\n\n      guard p2.isPrime else {\n        continue\n      }\n\n      let p3 = 1 + p1 * p2 / h3\n\n      guard p3.isPrime && (p2 * p3) % (p1 - 1) == 1 else {\n        continue\n      }\n\n      res.append((p1, p2, p3))\n    }\n  }\n\n  return res\n}\n\n\nlet res =\n  (1..<62)\n    .lazy\n    .filter({ $0.isPrime })\n    .map(carmichael)\n    .filter({ !$0.isEmpty })\n    .flatMap({ $0 })\n\nfor c in res {\n  print(c)\n}\n"
  },
  {
    "language": "Swift",
    "code": "let dog = \"Benjamin\"\nlet Dog = \"Samba\"\nlet DOG = \"Bernie\"\nprintln(\"The three dogs are named \\(dog), \\(Dog), and \\(DOG).\")\n"
  },
  {
    "language": "Swift",
    "code": "func catalan(_ n: Int) -> Int {\n  switch n {\n  case 0:\n    return 1\n  case _:\n    return catalan(n - 1) * 2 * (2 * n - 1) / (n + 1)\n  }\n}\n\nfor i in 1..<16 {\n  print(\"catalan(\\(i)) => \\(catalan(i))\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(nums.reduce(0, +))\nprint(nums.reduce(1, *))\nprint(nums.reduce(\"\", { $0 + String($1) }))\n"
  },
  {
    "language": "Swift",
    "code": "let c1: UnicodeScalar = \"a\"\nprintln(c1.value) // prints \"97\"\nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) // prints \"960\"\n"
  },
  {
    "language": "Swift",
    "code": "let s1 = \"a\"\nfor c in s1.unicodeScalars {\n  println(c.value) // prints \"97\"\n}\nlet s2 = \"\u03c0\"\nfor c in s2.unicodeScalars {\n  println(c.value) // prints \"960\"\n}\n"
  },
  {
    "language": "Swift",
    "code": "let i1: UInt32 = 97\nprintln(UnicodeScalar(i1)) // prints \"a\"\nlet i2: UInt32 = 960\nprintln(UnicodeScalar(i2)) // prints \"\u03c0\"\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\n\n/*\n * Function: euclid\n * Usage: (r,s) = euclid(m,n)\n * --------------------------\n * The extended Euclidean algorithm subsequently performs\n * Euclidean divisions till the remainder is zero and then\n * returns the B\u00e9zout coefficients r and s.\n */\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n/*\n * Function: gcd\n * Usage: x = gcd(m,n)\n * -------------------\n * The greatest common divisor of two numbers a and b\n * is expressed by ax + by = gcd(a,b) where x and y are\n * the B\u00e9zout coefficients as determined by the extended\n * euclidean algorithm.\n */\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n/*\n * Function: coprime\n * Usage: truth = coprime(m,n)\n * ---------------------------\n * If two values are coprime, their greatest common\n * divisor is 1.\n */\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n//coprime(2,4)\n\n/*\n * Function: crt\n * Usage: x = crt(a,n)\n * -------------------\n * The Chinese Remainder Theorem supposes that given the\n * integers n_1...n_k that are pairwise co-prime, then for\n * any sequence of integers a_1...a_k there exists an integer\n * x that solves the system of linear congruences:\n *\n *   x === a_1 (mod n_1)\n *   ...\n *   x === a_k (mod n_k)\n */\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    // There is no identity operator for elements of [Int].\n    // The offset of the elements of an enumerated sequence\n    // can be used instead, to determine if two elements of the same\n    // array are the same.\n    let divs = n_i.enumerated()\n\n    // Check if elements of n_i are pairwise coprime divs.filter{ $0.0 < n.0 }\n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n\n    // Calculate factor N\n    let N = n_i.map{$0}.reduce(1, *)\n\n    // Euclidean algorithm determines s_i (and r_i)\n    var s:[Int] = []\n\n    // Using euclidean algorithm to calculate r_i, s_i\n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n\n    // Solve for x\n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    // Return minimal solution\n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n"
  },
  {
    "language": "Swift",
    "code": "func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "class MyClass{\n\n  // stored property\n  var variable : Int\n\n  /**\n  * The constructor\n  */\n  init() {\n    self.variable = 42\n  }\n\n  /**\n  * A method\n  */\n  func someMethod() {\n    self.variable = 1\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "MyClass()\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n\n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n\n    return Self.closestPair(xP, xY)?.1\n  }\n\n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n\n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n\n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n\n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n\n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n\n    var (closest, pairClosest) = (dMin, pairMin)\n\n    for i in 0..<ys.count {\n      let p1 = ys[i]\n\n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n\n        guard abs(p2.y - p1.y) < dMin else { break }\n\n        let distance = abs(p1.distance(to: p2))\n\n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n\n    return (closest, pairClosest)\n  }\n\n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n\n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n\n    guard count != 2 else { return (minDistance, closestPoints) }\n\n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n\n        let distance = abs(p1.distance(to: p2))\n\n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n\n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#! /bin/bash\n\ndeclare -a doors\nfor((i=1; i <= 100; i++)); do\n    doors[$i]=0\ndone\n\nfor((i=1; i <= 100; i++)); do\n    for((j=i; j <= 100; j += i)); do\n\techo $i $j\n\tdoors[$j]=$(( doors[j] ^ 1 ))\n    done\ndone\n\nfor((i=1; i <= 100; i++)); do\n    if [[ ${doors[$i]} -eq 0 ]]; then\n\top=\"closed\"\n    else\n\top=\"open\"\n    fi\n    echo $i $op\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nfor i in {1..100}; do\n  door[$i*$i]=1\n  [ -z ${door[$i]} ] && echo \"$i closed\" || echo \"$i open\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "gen_digits() {\n    awk 'BEGIN { srand()\n                 for(i = 1; i <= 4; i++) print 1 + int(9 * rand())\n         }' | sort\n}\n\nsame_digits() {\n    [ \"$(tr -dc 0-9 | sed 's/./&\\n/g' | grep . | sort)\" = \"$*\" ]\n}\n\nguessed() {\n    [ \"$(echo \"$1\" | tr -dc '\\n0-9()*/+-' | bc 2>/dev/null)\" = 24 ]\n}\n\n\nwhile :\ndo\n    digits=$(gen_digits)\n    echo\n    echo Digits: $digits\n    read -r expr\n\n    echo \" $expr\" | same_digits \"$digits\" || \\\n        { echo digits should be: $digits; continue; }\n\n    guessed \"$expr\" && message=correct \\\n                    || message=wrong\n\n    echo $message\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a b || exit\necho `expr \"$a\" + \"$b\"`\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\nread a b || exit\necho $(( a + b ))\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "echo 2 3 | ksh a+b.sh\n5\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "set line=$<\nset input=($line)\n@ sum = $input[1] + $input[2]\necho $sum\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "can_build_word() {\n    if [[ $1 ]]; then\n        can_build_word_rec \"$1\" BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\n    else\n        return 1\n    fi\n}\n\ncan_build_word_rec() {\n    [[ -z $1 ]] && return 0\n\n    local -u word=$1       # uppercase the first parameter\n    shift\n    local blocks=(\"$@\")\n\n    # see if we have a block for the first letter\n    local letter=${word:0:1} indices=() i\n    for (( i=0; i<${#blocks[@]}; i++ )); do\n        if [[ ${blocks[i]} == *$letter* ]]; then\n            indices+=($i)\n        fi\n    done\n    (( ${#indices[@]} == 0 )) && return 1\n\n    local tmp\n    for i in ${indices[@]}; do\n        tmp=( \"${blocks[@]}\" )\n        unset \"tmp[$i]\"\n        can_build_word_rec \"${word:1}\" \"${tmp[@]}\" && return 0\n    done\n\n    return 1\n}\n\nwords=( \"\" A BARK Book treat COMMON Squad confuse )\nfor word in \"${words[@]}\"; do\n    can_build_word \"$word\" \"${blocks[@]}\" && ans=yes || ans=no\n    printf \"%s\\t%s\\n\" \"$word\" $ans\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\naccumulator() {\n\t# Define a global function named $1\n\t# with a global variable named ${1}_sum.\n\teval \"${1}_sum=\\$2\"\n\teval \"$1() {\n\t\t${1}_sum=\\$(echo \\\"(\\$${1}_sum) + (\\$2)\\\" | bc)\n\t\teval \\\"\\$1=\\\\\\$${1}_sum\\\"  # Provide the current sum.\n\t}\"\n}\n\naccumulator x 1\nx r 5\naccumulator y 3\nx r 2.3\necho $r\ny r -3000\necho $r\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "fn accumulator n {\n\tresult @ i {\n\t\tn = `{echo $n + $i | bc}\n\t\tresult $n\n\t}\n}\n\nfn-x = <={accumulator 1}\nx 5\nfn-y = <={accumulator 3}\necho <={x 2.3}\necho <={y -3000}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "ack() {\n  local m=$1\n  local n=$2\n  if [ $m -eq 0 ]; then\n    echo -n $((n+1))\n  elif [ $n -eq 0 ]; then\n    ack $((m-1)) 1\n  else\n    ack $((m-1)) $(ack $m $((n-1)))\n  fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "for ((m=0;m<=3;m++)); do\n  for ((n=0;n<=6;n++)); do\n    ack $m $n\n    echo -n \" \"\n  done\n  echo\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\n\nLDAP_HOST=\"localhost\"\nLDAP_PORT=11389\nLDAP_DN_STR=\"uid=admin,ou=system\"\nLDAP_CREDS=\"********\"\nLDAP_BASE_DN=\"ou=users,o=mojo\"\nLDAP_SCOPE=\"sub\"\nLDAP_FILTER=\"(&(objectClass=person)(&(uid=*mil*)))\"\nLDAP_ATTRIBUTES=\"dn cn sn uid\"\n\nldapsearch \\\n  -s base \\\n  -h $LDAP_HOST \\\n  -p $LDAP_PORT \\\n  -LLL \\\n  -x \\\n  -v \\\n  -s $LDAP_SCOPE \\\n  -D $LDAP_DN_STR \\\n  -w $LDAP_CREDS \\\n  -b $LDAP_BASE_DN \\\n  $LDAP_FILTER \\\n  $LDAP_ATTRIBUTES\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "cat <<EOF_OUTER > just-nocenter.sh\n#!/bin/sh\n\ntd() {\ncat <<'EOF'\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEOF\n}\n\nrows=$( td | wc -l )\n\n# get the number of fields\nfields=$(td | rs -c'$' -g1 -h | awk '{print $2}')\n\n# get the max of the value widths\ncwidth=$(td | rs -c'$' -g1 -w1 2>/dev/null | awk 'BEGIN{w=0}{if(length>w){w=length}}END{print w}')\n\n# compute the minimum line width for the columns\nlwidth=$(( (1 + cwidth) * fields ))\n\n# left adjusted columns\ntd | rs -c'$' -g1 -zn -w$lwidth\n\necho \"\"\n\n# right adjusted columns\ntd | rs -c'$' -g1 -znj -w$lwidth\n\necho \"\"\n\nexit\nEOF_OUTER\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "$ ./just-nocenter.sh\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "function get_words {\n    typeset host=www.puzzlers.org\n    typeset page=/pub/wordlists/unixdict.txt\n    exec 7<>/dev/tcp/$host/80\n    print -e -u7 \"GET $page HTTP/1.1\\r\\nhost: $host\\r\\nConnection: close\\r\\n\\r\\n\"\n    # remove the http header and save the word list\n    sed 's/\\r$//; 1,/^$/d' <&7 >\"$1\"\n    exec 7<&-\n}\n\nfunction is_deranged {\n    typeset -i i\n    for ((i=0; i<${#1}; i++)); do\n        [[ ${1:i:1} == ${2:i:1} ]] && return 1\n    done\n    return 0\n}\n\nfunction word2key {\n    typeset -a chars=( $(\n        for ((i=0; i<${#word}; i++)); do\n            echo \"${word:i:1}\"\n        done | sort\n    ) )\n    typeset IFS=\"\"\n    echo \"${chars[*]}\"\n}\n\n[[ -f word.list ]] || get_words word.list\n\ntypeset -A words\ntypeset -i max=0\n\nwhile IFS= read -r word; do\n    key=$(word2key $word)\n    if [[ -z \"${words[\"$key\"]}\" ]]; then\n        words[\"$key\"]=$word\n    else\n        if (( ${#word} > max )); then\n            if is_deranged \"${words[\"$key\"]}\" \"$word\"; then\n                max_deranged=(\"${words[\"$key\"]}\" \"$word\")\n                max=${#word}\n            fi\n        fi\n    fi\ndone <word.list\necho $max - ${max_deranged[@]}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "http_get_body() {\n    local host=$1\n    local uri=$2\n    exec 5<> /dev/tcp/$host/80\n    printf >&5 \"%s\\r\\n\" \"GET $uri HTTP/1.1\" \"Host: $host\" \"Connection: close\" \"\"\n    mapfile -t -u5\n    local lines=( \"${MAPFILE[@]//$'\\r'}\" )\n    local i=0 found=0\n    for (( ; found == 0; i++ )); do\n        [[ -z ${lines[i]} ]] && (( found++ ))\n    done\n    printf \"%s\\n\" \"${lines[@]:i}\"\n    exec 5>&-\n}\n\ndeclare -A wordlist\n\nwhile read -r word; do\n    uniq_letters=( $(for ((i=0; i<${#word}; i++)); do echo \"${word:i:1}\"; done | sort) )\n    wordlist[\"${uniq_letters[*]}\"]+=\"$word \"\ndone < <( http_get_body wiki.puzzlers.org  /pub/wordlists/unixdict.txt )\n\nmaxlen=0\nmaxwords=()\n\nfor key in \"${!wordlist[@]}\"; do\n    words=( ${wordlist[$key]} )\n    if (( ${#words[@]} > maxlen )); then\n        maxlen=${#words[@]}\n        maxwords=( \"${wordlist[\"$key\"]}\" )\n    elif (( ${#words[@]} == maxlen )); then\n        maxwords+=( \"${wordlist[$key]}\" )\n    fi\ndone\n\nprintf \"%s\\n\" \"${maxwords[@]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "fib() {\n  if test 0 -gt \"$1\"; then\n    echo \"fib: fib of negative\" 1>&2\n    return 1\n  else\n    (\n      fib2() {\n        if test 2 -gt \"$1\"; then\n          echo \"$1\"\n        else\n          echo $(( $(fib2 $(($1 - 1)) ) + $(fib2 $(($1 - 2)) ) ))\n        fi\n      }\n      fib2 \"$1\"\n    )\n  fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "$ for i in -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12; do\n>   fib $i\n> done\nfib: fib of negative\nfib: fib of negative\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "rec1=(\n    jsmith\n    x\n    1001\n    1000\n    \"Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org\"\n    /home/jsmith\n    /bin/bash\n)\n\nrec2=(\n    jdoe\n    x\n    1002\n    1000\n    \"Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org\"\n    /home/jdoe\n    /bin/bash\n)\n\nrec3=(\n    xyz\n    x\n    1003\n    1000\n    \"X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org\"\n    /home/xyz\n    /bin/bash\n)\n\nfilename=./passwd-ish\n\n# use parentheses to run the commands in a subshell, so the\n# current shell's IFS variable is not changed\n(\n    IFS=:\n    echo \"${rec1[*]}\"\n    echo \"${rec2[*]}\"\n) > \"$filename\"\n\necho before appending:\ncat \"$filename\"\n\n# appending, use the \">>\" redirection symbol\nIFS=:\necho \"${rec3[*]}\" >> \"$filename\"\n\necho after appending:\ncat \"$filename\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map() {\n\tmap_command=$1\n\tshift\n\tfor i do \"$map_command\" \"$i\"; done\n}\nlist=1:2:3\n(IFS=:; map echo $list)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map() {\n\ttypeset command=$1\n\tshift\n\tfor i do \"$command\" \"$i\"; done\n}\nset -A ary 1 2 3\nmap print \"${ary[@]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map(){for i ($*[2,-1]) $1 $i}\na=(1 2 3)\nmap print $a\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T Complex_t=(\n    float real=0\n    float imag=0\n\n    function to_s {\n        print -- \"${_.real} + ${_.imag} i\"\n    }\n\n    function dup {\n        nameref other=$1\n        _=( real=${other.real} imag=${other.imag} )\n    }\n\n    function add {\n        typeset varname\n        for varname; do\n            nameref other=$varname\n            (( _.real += other.real ))\n            (( _.imag += other.imag ))\n        done\n    }\n\n    function negate {\n        (( _.real *= -1 ))\n        (( _.imag *= -1 ))\n    }\n\n    function conjugate {\n        (( _.imag *= -1 ))\n    }\n\n    function multiply {\n        typeset varname\n        for varname; do\n            nameref other=$varname\n            float a=${_.real} b=${_.imag} c=${other.real} d=${other.imag}\n            (( _.real = a*c - b*d ))\n            (( _.imag = b*c + a*d ))\n        done\n    }\n\n    function inverse {\n        if (( _.real == 0 && _.imag == 0 )); then\n            print -u2 \"division by zero\"\n            return 1\n        fi\n        float denom=$(( _.real*_.real + _.imag*_.imag ))\n        (( _.real = _.real / denom ))\n        (( _.imag = -1 * _.imag / denom ))\n    }\n)\n\nComplex_t a=(real=1 imag=1)\na.to_s        # 1 + 1 i\n\nComplex_t b=(real=3.14159 imag=1.2)\nb.to_s        # 3.14159 + 1.2 i\n\nComplex_t c\nc.add a b\nc.to_s        # 4.14159 + 2.2 i\n\nc.negate\nc.to_s        # -4.14159 + -2.2 i\n\nc.conjugate\nc.to_s        # -4.14159 + 2.2 i\n\nc.dup a\nc.multiply b\nc.to_s        # 1.94159 + 4.34159 i\n\nComplex_t d=(real=2 imag=1)\nd.inverse\nd.to_s        # 0.4 + -0.2 i\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "function agm {\n    float a=$1 g=$2 eps=${3:-1e-11} tmp\n    while (( abs(a-g) > eps )); do\n        print \"debug: a=$a\\tg=$g\"\n        tmp=$(( (a+g)/2.0 ))\n        g=$(( sqrt(a*g) ))\n        a=$tmp\n    done\n    echo $a\n}\n\nagm $((1/sqrt(2))) 1\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "while (( abs(a-g) > eps ))\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "while [[ $a != $g ]]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a; read b;\necho \"a+b     = \"  `expr $a  +  $b`\necho \"a-b     = \"  `expr $a  -  $b`\necho \"a*b     = \"  `expr $a \\*  $b`\necho \"a/b     = \"  `expr $a  /  $b` # truncates towards 0\necho \"a mod b = \"  `expr $a  %  $b` # same sign as first operand\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a; read b;\necho \"a+b     = $((a+b))\"\necho \"a-b     = $((a-b))\"\necho \"a*b     = $((a*b))\"\necho \"a/b     = $((a/b))\" # truncates towards 0\necho \"a mod b = $((a%b))\" # same sign as first operand\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "array1=( 1 2 3 4 5 )\narray2=( 6 7 8 9 10 )\nbotharrays=( ${array1[@]} ${array2[@]} )\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "array1='1 2 3 4 5'\narray2='6 7 8 9 10'\n\n# Concatenated to a Bash array ...\nbotharrays_a=( $array1 $array2 )\n\n# Concatenated to a string ...\nbotharrays_s=\"$array1 $array2\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "alist=( item1 item2 item3 )  # creates a 3 item array called \"alist\"\ndeclare -a list2        # declare an empty list called \"list2\"\ndeclare -a list3[0]     # empty list called \"list3\"; the subscript is ignored\n\n# create a 4 item list, with a specific order\nlist5=([3]=apple [2]=cherry [1]=banana [0]=strawberry)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "count=${#alist[*]}\necho \"The number of items in alist is ${#alist[*]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "x=0\nwhile [[ $x < ${#alist[*]} ]]; do\n  echo \"Item $x = ${alist[$x]}\"\n  : $((x++))\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "x=${#alist[*]}       # start with the number of items in the array\nwhile [[ $x > 0 ]]; do     # while there are items left\n  : $((x--))               # decrement first, because indexing is zero-based\n  echo \"Item $x = ${alist[$x]}\"   # show the current item\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "alist[${#alist[*]}]=new_item\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# shell function to append values to an array\n# push LIST VALUES ...\npush() {\n  local var=${1:?'Missing variable name!'}\n  shift\n  eval \"\\$$var=( \\\"\\${$var[@]}\\\" \\\"$@\\\" )\"\n}\n\npush alist \"one thing to add\"\npush alist many words to add\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist[0]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# pop ARRAY -- pop the last item on ARRAY and output it\n\npop() {\n  local var=${1:?'Missing array name'}\n  local x ;   eval \"x=\\${#$var[*]}\"\n  if [[ $x > 0 ]]; then\n    local val ; eval \"val=\\\"\\${$var[$((--x))]}\\\"\"\n    unset $var[$x]\n  else\n    echo 1>&2 \"No items in $var\" ; exit 1\n  fi\n  echo \"$val\"\n}\n\nalist=(a b c)\npop alist\na\npop alist\nb\npop alist\nc\npop alist\nNo items in alist\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist[*]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "assert() {\n    if test ! $1; then\n        [[ $2 ]] && echo \"$2\" >&2\n        exit 1\n    fi\n}\nx=42\nassert \"$x -eq 42\" \"that's not the answer\"\n((x--))\nassert \"$x -eq 42\" \"that's not the answer\"\necho \"won't get here\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A hash\nhash=( [key1]=val1 [key2]=val2 )\nhash[key3]=val3\necho \"${hash[key3]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "declare -A hash\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A a=([key1]=value1 [key2]=value2)\n\n# just keys\nprintf '%s\\n' \"${!a[@]}\"\n\n# just values\nprintf '%s\\n' \"${a[@]}\"\n\n# keys and values\nfor key in \"${!a[@]}\"; do\n\tprintf '%s => %s\\n' \"$key\" \"${a[$key]}\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A a\na=(key1 value1 key2 value2)\n\n# just keys\nprint -l -- ${(k)a}\n\n# just values\nprint -l -- ${(v)a}\n\n# keys and values\nprintf '%s => %s\\n' ${(kv)a}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "mean() {\n\tif expr $# >/dev/null; then\n\t\t(count=0\n\t\t sum=0\n\t\t while expr $# \\> 0 >/dev/null; do\n\t\t\tsum=`expr $sum + \"$1\"`\n\t\t\tresult=$?\n\t\t\texpr $result \\> 1 >/dev/null && exit $result\n\n\t\t\tcount=`expr $count + 1`\n\t\t\tshift\n\t\t done\n\t\t expr $sum / $count)\n\telse\n\t\techo 0\n\tfi\n}\n\nprintf \"test 1: \"; mean\t\t\t\t# 0\nprintf \"test 2: \"; mean 300\t\t\t# 300\nprintf \"test 3: \"; mean 300 100 400\t\t# 266\nprintf \"test 4: \"; mean -400 400 -1300 200\t# -275\nprintf \"test 5: \"; mean -\t\t\t# expr: syntax error\nprintf \"test 6: \"; mean 1 2 A 3\t\t\t# expr: non-numeric argument\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nfunction mode {\n    declare -A map\n    max=0\n    for x in \"$@\"; do\n\ttmp=$((${map[$x]} + 1))\n\tmap[$x]=$tmp\n\t((tmp > max)) && max=$tmp\n    done\n    for x in \"${!map[@]}\"; do\n\t[[ ${map[$x]} == $max ]] && echo -n \"$x \"\n    done\n    echo\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "mode 1 2 1 2 a b a b a 2\na 2\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "generate() {\n    local b=()\n    local i j tmp\n    for ((i=1; i<=$1; i++)); do\n        b+=( '[' ']')\n    done\n    for ((i=${#b[@]}-1; i>0; i--)); do\n        j=$(rand $i)\n        tmp=${b[j]}\n        b[j]=${b[i]}\n        b[i]=$tmp\n    done\n    local IFS=\n    echo \"${b[*]}\"\n}\n\n# a random number in the range [0,n)\nrand() {\n    echo $(( $RANDOM % $1 ))\n}\n\nbalanced() {\n    local -i lvl=0\n    local i\n    for ((i=0; i<${#1}; i++)); do\n        case ${1:i:1} in\n            '[') ((lvl++));;\n            ']') (( --lvl < 0 )) && return 1;;\n        esac\n    done\n    (( lvl == 0 )); return $?\n}\n\nfor ((i=0; i<=10; i++)); do\n    test=$(generate $i)\n    balanced \"$test\" && result=OK || result=\"NOT OK\"\n    printf \"%s\\t%s\\n\" \"$test\" \"$result\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# Define a function to output binary digits\ntobinary() {\n  # We use the bench calculator for our conversion\n  echo \"obase=2;$1\"|bc\n}\n\n# Call the function with each of our values\ntobinary 5\ntobinary 50\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/ksh\n# This should work on any clone of Bourne Shell, ksh is the fastest.\n\nvalue=$1; [ -z \"$value\" ] && exit\narray=()\nsize=0\n\nwhile IFS= read -r line; do\n\tsize=$(($size + 1))\n\tarray[${#array[*]}]=$line\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "left=0\nright=$(($size - 1))\nwhile\t[ $left -le $right ] ; do\n\tmid=$((($left + $right) >> 1))\n#\techo \"$left\t$mid(${array[$mid]})\t$right\"\n\tif\t[ $value -eq ${array[$mid]} ] ; then\n\t\techo $mid\n\t\texit\n\telif\t[ $value -lt ${array[$mid]} ]; then\n\t\tright=$(($mid - 1))\n\telse\n\t\tleft=$((mid + 1))\n\tfi\ndone\necho 'ERROR 404 : NOT FOUND'\n"
  },
  {
    "language": "UNIX-Shell",
    "code": " No code yet\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "base58=({1..9} {A..H} {J..N} {P..Z} {a..k} {m..z})\nbitcoinregex=\"^[$(printf \"%s\" \"${base58[@]}\")]{34}$\"\n\ndecodeBase58() {\n    local s=$1\n    for i in {0..57}\n    do s=\"${s//${base58[i]}/ $i}\"\n    done\n    dc <<< \"16o0d${s// /+58*}+f\"\n}\n\nchecksum() {\n    xxd -p -r <<<\"$1\" |\n    openssl dgst -sha256 -binary |\n    openssl dgst -sha256 -binary |\n    xxd -p -c 80 |\n    head -c 8\n}\n\ncheckBitcoinAddress() {\n    if [[ \"$1\" =~ $bitcoinregex ]]\n    then\n        h=$(decodeBase58 \"$1\")\n        checksum \"00${h::${#h}-8}\" |\n        grep -qi \"^${h: -8}$\"\n    else return 2\n    fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "    function setrgb {\n        _.r=$1\n        _.g=$2\n        _.b=$3\n    }\n    function grayscale {\n        integer x=$(( round( 0.2126*_.r + 0.7152*_.g + 0.0722*_.b ) ))\n        _.r=$x\n        _.g=$x\n        _.b=$x\n    }\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "    function grayscale {\n        RGBColor_t c\n        for ((y=0; y<_.height; y++)); do\n            for ((x=0; x<_.width; x++)); do\n                c.setrgb ${_.data[y][x]}\n                c.grayscale\n                _.data[y][x]=$(c.to_s)\n            done\n        done\n    }\n\n    function read {\n        exec 4<\"$1\"\n        typeset filetype\n        read -u4 filetype\n        if [[ $filetype != \"P3\" ]]; then\n            print -u2 \"error: I can only read P3 type PPM files\"\n        else\n            read -u4 _.width _.height\n            integer maxval\n            read -u4 maxval\n            integer x y r g b\n            typeset -a bytes\n            for ((y=0; y<_.height; y++)); do\n                read -u4 -A bytes\n                for ((x=0; x<_.width; x++)); do\n                    r=${bytes[3*x+0]}\n                    g=${bytes[3*x+1]}\n                    b=${bytes[3*x+2]}\n                    if (( r > maxval || g > maxval || b > maxval )); then\n                        print -u2 \"error: invalid color ($r $g $b), max=$maxval\"\n                        return 1\n                    fi\n                    _.data[y][x]=\"$r $g $b\"\n                done\n            done\n        fi\n        exec 4<&-\n    }\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "Bitmap_t c\nc.read \"$HOME/tmp/bitmap.ppm\"\nc.to_s\n\nif [[ $(c.to_s) == $(cat \"$HOME/tmp/bitmap.ppm\") ]]; then\n    echo looks OK\nelse\n    echo something is wrong\nfi\n\nc.grayscale\nc.to_s\nc.write \"$HOME/tmp/bitmap_g.ppm\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "    function write {\n        _.to_s > \"$1\"\n    }\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "Bitmap_t b\n# do stuff to b, and save it:\nb.write '$HOME/tmp/bitmap.ppm'\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T RGBColor_t=(\n    integer r g b\n    function to_s {\n        printf \"%d %d %d\" ${_.r} ${_.g} ${_.b}\n    }\n    function white   { print \"255 255 255\"; }\n    function black   { print \"0 0 0\"; }\n    function red     { print \"255 0 0\"; }\n    function green   { print \"0 255 0\"; }\n    function blue    { print \"0 0 255\"; }\n    function yellow  { print \"255 255 0\"; }\n    function magenta { print \"255 0 255\"; }\n    function cyan    { print \"0 255 255\"; }\n)\n\ntypeset -T Bitmap_t=(\n    integer height\n    integer width\n    typeset -a data\n\n    function fill {\n        typeset color=$1\n        if [[ -z ${color:+set} ]]; then\n            print -u2 \"error: no fill color specified\"\n            return 1\n        fi\n        integer x y\n        for ((y=0; y<_.height; y++)); do\n            for ((x=0; x<_.width; x++)); do\n                _.data[y][x]=\"$color\"\n            done\n        done\n    }\n\n    function setpixel {\n        integer x=$1 y=$2\n        typeset color=$3\n        _.data[y][x]=$color\n    }\n\n    function getpixel {\n        integer x=$1 y=$2\n        print \"${_.data[y][x]}\"\n    }\n\n    function to_s {\n        typeset ppm=\"\"\n        ppm+=\"P3\"$'\\n'\n        ppm+=\"${_.width} ${_.height}\"$'\\n'\n        ppm+=\"255\"$'\\n'\n        typeset sep\n        for ((y=0; y<_.height; y++)); do\n            sep=\"\"\n            for ((x=0; x<_.width; x++)); do\n                ppm+=\"$sep${_.data[y][x]}\"\n                sep=\" \"\n            done\n            ppm+=$'\\n'\n        done\n        print -- \"$ppm\"\n    }\n)\n\nRGBColor_t color\nBitmap_t b=( width=3  height=2 )\nb.fill \"$(color.white)\"\nb.setpixel 0 0 \"$(color.red)\"\nb.setpixel 1 0 \"$(color.green)\"\nb.setpixel 2 0 \"$(color.blue)\"\nb.setpixel 0 1 \"$(color.yellow)\"\nb.setpixel 1 1 \"$(color.white)\"\nb.setpixel 2 1 \"$(color.black)\"\necho \"$(b.getpixel 0 0)\"\nb.to_s\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "if\n  echo 'Looking for file'  # This is the evaluation block\n  test -e foobar.fil       # The exit code from this statement determines whether the branch runs\nthen\n  echo 'The file exists'   # This is the optional branch\n  echo 'I am going to delete it'\n  rm foobar.fil\nfi\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "true && echo \"true\" || echo \"false\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# List of abbreviated compass point labels\ncompass_points=( N NbE N-NE NEbN NE NEbE E-NE EbN\n                 E EbS E-SE SEbE SE SEbS S-SE SbE\n                 S SbW S-SW SWbS SW SWbW W-SW WbS\n                 W WbN W-NW NWbW NW NWbN N-NW NbW )\n\n# List of angles to test\ntest_angles=(  0.00  16.87  16.88  33.75  50.62  50.63  67.50\n              84.37  84.38 101.25 118.12 118.13 135.00 151.87\n             151.88 168.75 185.62 185.63 202.50 219.37 219.38\n             236.25 253.12 253.13 270.00 286.87 286.88 303.75\n             320.62 320.63 337.50 354.37 354.38 )\n\ncapitalize() {\n  printf '%s%s\\n' \"$(tr a-z A-Z <<<\"${1:0:1}\")\" \"${1:1}\"\n}\n\n# convert compass point abbreviation to full text of label\nfunction expand_point {\n  local label=$1\n  set -- N north E east S south W west b \" by \"\n  while (( $# )); do\n    label=${label//$1/$2}\n    shift 2\n  done\n  capitalize \"$label\"\n}\n\n# modulus function that returns 1..N instead of 0..N-1\nfunction amod {\n  echo $(( ($1 - 1) % $2 + 1 ))\n}\n\n# convert a compass angle from degrees into a box index (1..32)\nfunction compass_point {\n  # use bc or dc depending on what's on the system\n  #amod $(dc <<<\"$1 5.625 + 11.25 / 1 + p\") 32\n  amod $(bc <<<\"($1 + 5.625) / 11.25 + 1\") 32\n}\n\n#  Now output the table of test data\nheader_format=\"%-7s | %-18s | %s\\n\"\nrow_format=\"%7.2f | %-18s | %2d\\n\"\nprintf \"$header_format\" \"Degrees\" \"Closest Point\" \"Index\"\nfor angle in ${test_angles[@]}; do\n  let index=$(compass_point $angle)\n  abbr=${compass_points[index-1]}\n  label=\"$(expand_point $abbr)\"\n  printf \"$row_format\" $angle \"$label\" $index\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nrand() {\n  local min=${1:-0}\n  local max=${2:-32767}\n\n  [ ${min} -gt ${max} ] &&\n  min=$(( min ^ max )) &&\n  max=$(( min ^ max )) &&\n  min=$(( min ^ max ))\n\n  echo -n $(( ( $RANDOM % $max ) + $min ))\n}\n\nin_arr() {\n  local quandry=\"${1}\"\n  shift\n  local arr=( $@ )\n  local i=''\n\n  for i in ${arr[*]}\n  do\n    [ \"${quandry}\" == \"${i}\" ] && return 0 && break\n  done\n\n  return 1\n}\n\ndelete_at() {\n  local idx=\"$(( $1 + 1 ))\"\n  shift\n  local arr=( \"sentinel\" $@ )\n\n  echo -n \"${arr[@]:1:$(( idx - 1 ))} ${arr[@]:$((idx + 1)):$(( ${#arr[@]} - idx - 1))}\"\n}\n\ndelete_first() {\n  local meanie=\"${1}\"\n  shift\n  local arr=( $@ )\n  local i=0\n\n  for (( i = 0; i < ${#arr[@]} ; i++ ))\n  do\n    [ \"${arr[${i}]}\" == \"${meanie}\" ] && arr=( $( delete_at ${i} ${arr[*]} ) )\n  done\n\n  echo -n \"${arr[*]}\"\n}\n\nto_arr() {\n  local string=\"${1}\"\n  local arr=()\n\n  while [ \"${#string}\" -gt 0 ]\n  do\n    arr=( ${arr[*]} ${string:0:1} )\n    string=\"${string:1}\"\n  done\n\n  echo -n \"${arr[*]}\"\n}\n\nchoose_idx() {\n  local arr=( $@ )\n\n  echo -n \"$( rand 0 $(( ${#arr[@]} - 1 )) )\"\n}\n\nlocate_bulls() {\n  local secret=( $( to_arr \"${1}\" ) )\n  local guess=( $( to_arr \"${2}\" ) )\n  local hits=()\n  local i=0\n\n  for (( i=0; i<4; i++ ))\n  do\n    [ \"${secret[${i}]}\" -eq \"${guess[${i}]}\" ] && hits=( ${hits[*]} ${i} )\n  done\n\n  echo -n \"${hits[*]}\"\n}\n\nbulls() {\n  local secret=\"${1}\"\n  local guess=\"${2}\"\n  local bulls=( $( locate_bulls \"${secret}\" \"${guess}\" ) )\n\n  echo -n \"${#bulls[@]}\"\n}\n\ncows() {\n  local secret=( $( to_arr \"${1}\" ) )\n  local guess=( $( to_arr \"${2}\" ) )\n  local bulls=( $( locate_bulls \"${1}\" \"${2}\" ) )\n  local hits=0\n  local i=''\n\n  # Avoid double-counting bulls\n  for i in ${bulls[*]}\n  do\n    secret=( $( delete_at ${i} ${secret[*]} ) )\n  done\n\n  # Process the guess against what's left of the secret\n  for i in ${guess[*]}\n  do\n    in_arr \"${i}\" ${secret[*]} &&\n    secret=( $( delete_first \"${i}\" ${secret[*]} ) ) &&\n    (( hits++ ))\n  done\n\n  echo -n ${hits}\n}\n\nmalformed() {\n  local guess=( $( to_arr \"${1}\" ) )\n  local i=''\n\n  [ ${#guess[@]} -ne 4 ] &&\n  return 0\n\n  for i in ${guess[*]}\n  do\n    if ! in_arr ${i} 1 2 3 4 5 6 7 8 9\n    then\n      return 0\n      break\n    fi\n  done\n\n  return 1\n}\n\ncandidates=( 1 2 3 4 5 6 7 8 9 )\nsecret=''\n\nwhile [ \"${#secret}\" -lt 4 ]\ndo\n  cidx=$( choose_idx ${candidates[*]} )\n  secret=\"${secret}${candidates[${cidx}]}\"\n  candidates=( $(delete_at ${cidx} ${candidates[*]} ) )\ndone\n\nwhile read -p \"Enter a four-digit guess:  \" guess\ndo\n  malformed \"${guess}\" && echo \"Malformed guess\" && continue\n  [ \"${guess}\" == \"${secret}\" ] && echo \"You win!\" && exit\n  echo \"Score: $( bulls \"${secret}\" \"${guess}\" ) Bulls, $( cows \"${secret}\" \"${guess}\" ) Cows\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "caesar() {\n    local OPTIND\n    local encrypt n=0\n    while getopts :edn: option; do\n        case $option in\n            e) encrypt=true ;;\n            d) encrypt=false ;;\n            n) n=$OPTARG ;;\n            :) echo \"error: missing argument for -$OPTARG\" >&2\n               return 1 ;;\n            ?) echo \"error: unknown option -$OPTARG\" >&2\n               return 1 ;;\n        esac\n    done\n    shift $((OPTIND-1))\n    if [[ -z $encrypt ]]; then\n        echo \"error: specify one of -e or -d\" >&2\n        return 1\n    fi\n\n    local upper=ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    local lower=abcdefghijklmnopqrstuvwxyz\n    if $encrypt; then\n        tr \"$upper$lower\" \"${upper:n}${upper:0:n}${lower:n}${lower:0:n}\" <<< \"$1\"\n    else\n        tr \"${upper:n}${upper:0:n}${lower:n}${lower:0:n}\" \"$upper$lower\" <<< \"$1\"\n    fi\n}\n\ntr() {\n    local -A charmap\n    local i trans line char\n    for ((i=0; i<${#1}; i++)); do\n        charmap[${1:i:1}]=${2:i:1}\n    done\n    while IFS= read -r line; do\n        trans=\"\"\n        for ((i=0; i<${#line}; i++)); do\n            char=${line:i:1}\n            if [[ -n ${charmap[$char]} ]]; then\n                trans+=${charmap[$char]}\n            else\n                trans+=$char\n            fi\n        done\n        echo \"$trans\"\n    done\n}\n\ntxt=\"The five boxing wizards jump quickly.\"\nenc=$(caesar -e -n 5 \"$txt\")\ndec=$(caesar -d -n 5 \"$enc\")\n\necho \"original:  $txt\"\necho \"encrypted: $enc\"\necho \"decrypted: $dec\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "CAL=CAL\nTR=TR\nA=A\nZ=Z\nLANG=C ${CAL,,} 1969 | ${TR,,} ${A,}-${Z,} A-Z\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\necho \"Snoopy goes here\"\ncal 1969\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "sayhello    # Call a function in statement context with no arguments\nmultiply 3 4    # Call a function in statement context with two arguments\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "dog=\"Benjamin\"\nDog=\"Samba\"\nDOG=\"Bernie\"\necho \"The three dogs are named $dog, $Dog and $DOG.\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "test -f input.txt\ntest -f /input.txt\ntest -d docs\ntest -d /docs\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "for f in input.txt /input.txt; do\n\ttest -f \"$f\" && r=true || r=false\n\techo \"$f is a regular file? $r\"\ndone\nfor d in docs /docs; do\n\ttest -d \"$d\" && r=true || r=false\n\techo \"$d is a directory? $r\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T Summation_t=(\n    integer sum\n\n    # the constructor\n    function create {\n        _.sum=0\n    }\n\n    # a method\n    function add {\n        (( _.sum += $1 ))\n    }\n)\n\nSummation_t s\nfor i in 1 2 3 4 5; do\n    s.add $i\ndone\nprint ${s.sum}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "a_index=(one two three)           # create an array with a few elements\na_index+=(four five)              # append some elements\na_index[9]=ten                   # add a specific index\nfor elem in \"${a_index[@]}\"; do   # interate over the elements\n    echo \"$elem\"\ndone\nfor idx in \"${!a_index[@]}\"; do   # interate over the array indices\n    printf \"%d\\t%s\\n\" $idx \"${a_index[idx]}\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "declare -A a_assoc=([one]=1 [two]=2 [three]=3)    # create an array with a few elements\na_assoc+=([four]=4 [five]=5)                      # add some elements\na_assoc[ten]=10\nfor value in \"${a_assoc[@]}\"; do                  # interate over the values\n    echo \"$value\"\ndone\nfor key in \"${!a_assoc[@]}\"; do                   # interate over the array indices\n    printf \"%s\\t%s\\n\" \"$key\" \"${a_assoc[$key]}\"\ndone\n"
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. HelloWorld. PROCEDURE DIVISION. DISPLAY \"Hello, world!\"."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. AddNumbers. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num1 PIC 9(3) VALUE 123. 01 Num2 PIC 9(3) VALUE 456. 01 Result PIC 9(4). PROCEDURE DIVISION. COMPUTE Result = Num1 + Num2. DISPLAY \"Sum is: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. Factorial. DATA DIVISION. WORKING-STORAGE SECTION. 01 Number PIC 9(2) VALUE 5. 01 Result PIC 9(4). PROCEDURE DIVISION. COMPUTE Result = 1. PERFORM VARYING Number FROM 1 BY 1 UNTIL Number > 5 MULTIPLY Result BY Number. END-PERFORM. DISPLAY \"Factorial of 5 is: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. Fibonacci. DATA DIVISION. WORKING-STORAGE SECTION. 01 n PIC 9(2) VALUE 10. 01 a PIC 9(5) VALUE 0. 01 b PIC 9(5) VALUE 1. 01 c PIC 9(5). PROCEDURE DIVISION. DISPLAY a DISPLAY b PERFORM VARYING n FROM 1 BY 1 UNTIL n > 10   COMPUTE c = a + b   DISPLAY c   COMPUTE a = b   COMPUTE b = c END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram1.\nPROCEDURE DIVISION.\n    DISPLAY 'Hello, world!'.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram2.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 + Num2.\n    DISPLAY 'Sum is ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram3.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Customer-Record.\n    05 Cust-Name PIC X(30).\n    05 Cust-Age PIC 99.\n    05 Cust-Balance PIC 9(6)V99 VALUE 100.50.\nPROCEDURE DIVISION.\n    DISPLAY 'Customer Details: ', Cust-Name, Cust-Age, Cust-Balance.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram4.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Counter PIC 9(2) VALUE 1.\nPROCEDURE DIVISION.\n    PERFORM VARYING Counter FROM 1 BY 1 UNTIL Counter > 10\n        DISPLAY 'Counter is ', Counter\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram12.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Array-Data.\n    05 Array OCCURS 5 TIMES PIC X(5).\nPROCEDURE DIVISION.\n    MOVE 'COBOL' TO Array(1).\n    MOVE 'Fortran' TO Array(2).\n    MOVE 'Java' TO Array(3).\n    MOVE 'Python' TO Array(4).\n    MOVE 'C++' TO Array(5).\n    PERFORM VARYING Array FROM 1 BY 1 UNTIL Array > 5\n        DISPLAY 'Programming Language: ', Array(Array)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram13.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Result PIC 9(5).\nPROCEDURE DIVISION.\n    MOVE 123 TO Result.\n    IF Result > 100\n        DISPLAY 'Result is greater than 100'\n    ELSE\n        DISPLAY 'Result is less than or equal to 100'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram14.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Length PIC 9(2) VALUE 10.\n01 InputStr PIC X(10) VALUE 'Hello'.\n01 OutputStr PIC X(10).\nPROCEDURE DIVISION.\n    MOVE InputStr TO OutputStr(1:Length).\n    DISPLAY 'Output: ', OutputStr\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram15.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 * Num2.\n    DISPLAY 'Multiplication Result: ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram16.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    END-READ.\n    CLOSE InputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram17.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nFD OutputFile.\n01 OutputRecord.\n    05 OutputField1 PIC X(10).\n    05 OutputField2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    OPEN OUTPUT OutputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            MOVE Field1 TO OutputField1\n            MOVE Field2 TO OutputField2\n            WRITE OutputRecord\n            DISPLAY 'Record written'\n    END-READ.\n    CLOSE InputFile.\n    CLOSE OutputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram18.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Item PIC X(10).\n        10 Quantity PIC 9(3).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'Item: ', Item(Table-Entry), ' Quantity: ', Quantity(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram19.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Employee-Data.\n    05 Emp-ID PIC 9(5) VALUE 12345.\n    05 Emp-Name PIC X(20) VALUE 'John Doe'.\n    05 Emp-Salary PIC 9(6)V99 VALUE 2500.75.\nPROCEDURE DIVISION.\n    COMPUTE Emp-Salary = Emp-Salary + 200.\n    DISPLAY 'Updated Salary: ', Emp-Salary.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram20.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Random-Numbers.\n    05 Rand-Num PIC 9(2) OCCURS 5 TIMES.\nPROCEDURE DIVISION.\n    PERFORM VARYING Rand-Num FROM 1 BY 1 UNTIL Rand-Num > 5\n        COMPUTE Rand-Num(Rand-Num) = FUNCTION RANDOM(99)\n        DISPLAY 'Random Number: ', Rand-Num(Rand-Num)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram21.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram22.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Customer-Record.\n    05 Cust-Name PIC X(30).\n    05 Cust-Age PIC 99.\n    05 Cust-Balance PIC 9(6)V99 VALUE 100.50.\nPROCEDURE DIVISION.\n    DISPLAY 'Customer Details: ', Cust-Name, Cust-Age, Cust-Balance.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram23.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Counter PIC 9(2) VALUE 1.\nPROCEDURE DIVISION.\n    PERFORM VARYING Counter FROM 1 BY 1 UNTIL Counter > 10\n        DISPLAY 'Counter is ', Counter\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram24.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Array-Data.\n    05 Array OCCURS 5 TIMES PIC X(5).\nPROCEDURE DIVISION.\n    MOVE 'COBOL' TO Array(1).\n    MOVE 'Fortran' TO Array(2).\n    MOVE 'Java' TO Array(3).\n    MOVE 'Python' TO Array(4).\n    MOVE 'C++' TO Array(5).\n    PERFORM VARYING Array FROM 1 BY 1 UNTIL Array > 5\n        DISPLAY 'Programming Language: ', Array(Array)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram25.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Date-Present PIC 9(8) VALUE 20220107.\nPROCEDURE DIVISION.\n    DISPLAY 'Year: ', Date-Present(1:4)\n    DISPLAY 'Month: ', Date-Present(5:2)\n    DISPLAY 'Day: ', Date-Present(7:2)\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram26.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Result PIC 9(5).\nPROCEDURE DIVISION.\n    MOVE 123 TO Result.\n    IF Result > 100\n        DISPLAY 'Result is greater than 100'\n    ELSE\n        DISPLAY 'Result is less than or equal to 100'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram27.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Length PIC 9(2) VALUE 10.\n01 InputStr PIC X(10) VALUE 'Hello'.\n01 OutputStr PIC X(10).\nPROCEDURE DIVISION.\n    MOVE InputStr TO OutputStr(1:Length).\n    DISPLAY 'Output: ', OutputStr\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram28.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 * Num2.\n    DISPLAY 'Multiplication Result: ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram29.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    DISPLAY 'Enter Field1: '\n    ACCEPT Field1\n    DISPLAY 'Enter Field2: '\n    ACCEPT Field2\n    DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram30.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Item PIC X(10).\n        10 Quantity PIC 9(3).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'Item: ', Item(Table-Entry), ' Quantity: ', Quantity(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram31.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    END-READ.\n    CLOSE InputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram32.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nFD OutputFile.\n01 OutputRecord.\n    05 OutputField1 PIC X(10).\n    05 OutputField2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    OPEN OUTPUT OutputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            MOVE Field1 TO OutputField1\n            MOVE Field2 TO OutputField2\n            WRITE OutputRecord\n            DISPLAY 'Record written'\n    END-READ.\n    CLOSE InputFile.\n    CLOSE OutputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram33.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram34.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Date-Present PIC 9(8) VALUE 20220107.\nPROCEDURE DIVISION.\n    DISPLAY 'Year: ', Date-Present(1:4)\n    DISPLAY 'Month: ', Date-Present(5:2)\n    DISPLAY 'Day: ', Date-Present(7:2)\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram35.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Customer-Record.\n    05 Cust-Name PIC X(30).\n    05 Cust-Age PIC 99.\n    05 Cust-Balance PIC 9(6)V99 VALUE 100.50.\nPROCEDURE DIVISION.\n    DISPLAY 'Customer Details: ', Cust-Name, Cust-Age, Cust-Balance.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram36.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Result PIC 9(5).\nPROCEDURE DIVISION.\n    MOVE 123 TO Result.\n    IF Result > 100\n        DISPLAY 'Result is greater than 100'\n    ELSE\n        DISPLAY 'Result is less than or equal to 100'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram37.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Length PIC 9(2) VALUE 10.\n01 InputStr PIC X(10) VALUE 'Hello'.\n01 OutputStr PIC X(10).\nPROCEDURE DIVISION.\n    MOVE InputStr TO OutputStr(1:Length).\n    DISPLAY 'Output: ', OutputStr\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram38.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 * Num2.\n    DISPLAY 'Multiplication Result: ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram39.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    DISPLAY 'Enter Field1: '\n    ACCEPT Field1\n    DISPLAY 'Enter Field2: '\n    ACCEPT Field2\n    DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram40.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Item PIC X(10).\n        10 Quantity PIC 9(3).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'Item: ', Item(Table-Entry), ' Quantity: ', Quantity(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram41.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Random-Numbers.\n    05 Rand-Num PIC 9(2) OCCURS 5 TIMES.\nPROCEDURE DIVISION.\n    PERFORM VARYING Rand-Num FROM 1 BY 1 UNTIL Rand-Num > 5\n        COMPUTE Rand-Num(Rand-Num) = FUNCTION RANDOM(99)\n        DISPLAY 'Random Number: ', Rand-Num(Rand-Num)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram42.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram43.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Date-Present PIC 9(8) VALUE 20220107.\nPROCEDURE DIVISION.\n    DISPLAY 'Year: ', Date-Present(1:4)\n    DISPLAY 'Month: ', Date-Present(5:2)\n    DISPLAY 'Day: ', Date-Present(7:2)\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram5.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    END-READ.\n    CLOSE InputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram6.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nFD OutputFile.\n01 OutputRecord.\n    05 OutputField1 PIC X(10).\n    05 OutputField2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    OPEN OUTPUT OutputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            MOVE Field1 TO OutputField1\n            MOVE Field2 TO OutputField2\n            WRITE OutputRecord\n            DISPLAY 'Record written'\n    END-READ.\n    CLOSE InputFile.\n    CLOSE OutputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram7.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Employee-ID PIC 9(5).\n        10 Employee-Name PIC X(20).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'ID: ', Employee-ID(Table-Entry), ' Name: ', Employee-Name(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram8.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Employee-Data.\n    05 Emp-ID PIC 9(5) VALUE 12345.\n    05 Emp-Name PIC X(20) VALUE 'John Doe'.\n    05 Emp-Salary PIC 9(6)V99 VALUE 2500.75.\nPROCEDURE DIVISION.\n    COMPUTE Emp-Salary = Emp-Salary + 200.\n    DISPLAY 'Updated Salary: ', Emp-Salary.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram9.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Random-Numbers.\n    05 Rand-Num PIC 9(2) OCCURS 5 TIMES.\nPROCEDURE DIVISION.\n    PERFORM VARYING Rand-Num FROM 1 BY 1 UNTIL Rand-Num > 5\n        COMPUTE Rand-Num(Rand-Num) = FUNCTION RANDOM(99)\n        DISPLAY 'Random Number: ', Rand-Num(Rand-Num)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram10.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ReverseString. DATA DIVISION. WORKING-STORAGE SECTION. 01 Input-String PIC X(20) VALUE 'COBOL'. 01 Output-String PIC X(20). PROCEDURE DIVISION. MOVE Function REVERSE OF Input-String TO Output-String. DISPLAY \"Reversed string: \" Output-String."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MultiplicationTable. DATA DIVISION. WORKING-STORAGE SECTION. 01 i PIC 9(2) VALUE 1. 01 j PIC 9(2) VALUE 1. PROCEDURE DIVISION. PERFORM VARYING i FROM 1 BY 1 UNTIL i > 10   PERFORM VARYING j FROM 1 BY 1 UNTIL j > 10     COMPUTE Result = i * j     DISPLAY i \" * \" j \" = \" Result   END-PERFORM END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. SimpleMath. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num1 PIC 9(2) VALUE 10. 01 Num2 PIC 9(2) VALUE 5. 01 Result PIC 9(3). PROCEDURE DIVISION. ADD Num1 TO Num2 GIVING Result. DISPLAY \"Addition: \" Result. SUBTRACT Num1 FROM Num2 GIVING Result. DISPLAY \"Subtraction: \" Result. MULTIPLY Num1 BY Num2 GIVING Result. DISPLAY \"Multiplication: \" Result. DIVIDE Num1 INTO Num2 GIVING Result. DISPLAY \"Division: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ArrayOperations. DATA DIVISION. WORKING-STORAGE SECTION. 01 Numbers OCCURS 5 TIMES PIC 9(2) VALUE ZEROES. 01 Index PIC 9 VALUE 1. PROCEDURE DIVISION. PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 5   COMPUTE Numbers(Index) = Index * 10   DISPLAY \"Index \" Index \": \" Numbers(Index) END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. BubbleSort. DATA DIVISION. WORKING-STORAGE SECTION. 01 Numbers OCCURS 10 TIMES PIC 9(2) VALUE ZEROES. 01 Index1 PIC 9 VALUE 1. 01 Index2 PIC 9 VALUE 1. 01 Temp PIC 9. PROCEDURE DIVISION. PERFORM VARYING Index1 FROM 1 BY 1 UNTIL Index1 > 10   PERFORM VARYING Index2 FROM 1 BY 1 UNTIL Index2 > 10 - Index1     IF Numbers(Index2) > Numbers(Index2 + 1)       MOVE Numbers(Index2) TO Temp       MOVE Numbers(Index2 + 1) TO Numbers(Index2)       MOVE Temp TO Numbers(Index2 + 1)     END-IF   END-PERFORM END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ConcatenateStrings. DATA DIVISION. WORKING-STORAGE SECTION. 01 String1 PIC X(10) VALUE 'Hello'. 01 String2 PIC X(10) VALUE 'COBOL'. 01 ResultString PIC X(20). PROCEDURE DIVISION. STRING String1 DELIMITED BY SIZE   String2 DELIMITED BY SIZE INTO ResultString. DISPLAY \"Concatenated string: \" ResultString."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. PalindromeCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 InputString PIC X(20) VALUE 'LEVEL'. 01 ReverseString PIC X(20). PROCEDURE DIVISION. MOVE Function REVERSE OF InputString TO ReverseString. IF InputString = ReverseString     DISPLAY \"Palindrome!\" ELSE     DISPLAY \"Not a Palindrome!\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. EvenOddCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Number PIC 9(2) VALUE 11. PROCEDURE DIVISION. IF Number MOD 2 = 0     DISPLAY Number \" is Even.\" ELSE     DISPLAY Number \" is Odd.\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MaxOfThree. DATA DIVISION. WORKING-STORAGE SECTION. 01 A PIC 9(2) VALUE 25. 01 B PIC 9(2) VALUE 37. 01 C PIC 9(2) VALUE 19. 01 MaxNumber PIC 9(2). PROCEDURE DIVISION. IF A > B AND A > C     MOVE A TO MaxNumber ELSE IF B > A AND B > C     MOVE B TO MaxNumber ELSE     MOVE C TO MaxNumber END-IF. DISPLAY \"Maximum Number is: \" MaxNumber."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MergeArrays. DATA DIVISION. WORKING-STORAGE SECTION. 01 Array1 OCCURS 5 TIMES PIC 9(2) VALUE 10, 20, 30, 40, 50. 01 Array2 OCCURS 5 TIMES PIC 9(2) VALUE 60, 70, 80, 90, 100. 01 MergedArray OCCURS 10 TIMES PIC 9(2). PROCEDURE DIVISION. PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 5   MOVE Array1(Index) TO MergedArray(Index)   MOVE Array2(Index) TO MergedArray(Index + 5) END-PERFORM. DISPLAY \"Merged Array: \". PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 10   DISPLAY MergedArray(Index) END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. PrimeNumberCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num PIC 9(2) VALUE 17. 01 PrimeFlag PIC X VALUE 'Y'. 01 Divisor PIC 9(2). PROCEDURE DIVISION. PERFORM VARYING Divisor FROM 2 BY 1 UNTIL Divisor > Num / 2   IF Num MOD Divisor = 0       MOVE 'N' TO PrimeFlag       EXIT PERFORM   END-IF END-PERFORM. IF PrimeFlag = 'Y'   DISPLAY Num \" is a Prime Number.\" ELSE   DISPLAY Num \" is not a Prime Number.\" END-IF"
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. AreaOfCircle. DATA DIVISION. WORKING-STORAGE SECTION. 01 Radius PIC 9(3) VALUE 10. 01 Pi PIC 9V9(6) VALUE 3.14159. 01 Area PIC 9(5)V99. PROCEDURE DIVISION. COMPUTE Area = Pi * Radius * Radius. DISPLAY \"Area of Circle: \" Area."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. FibonacciSeries. DATA DIVISION. WORKING-STORAGE SECTION. 01 FirstNum PIC 9(2) VALUE 0. 01 SecondNum PIC 9(2) VALUE 1. 01 NextNum PIC 9(2). PROCEDURE DIVISION. DISPLAY FirstNum DISPLAY SecondNum PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 8   COMPUTE NextNum = FirstNum + SecondNum   DISPLAY NextNum   COMPUTE FirstNum = SecondNum   COMPUTE SecondNum = NextNum END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. CountWords. DATA DIVISION. WORKING-STORAGE SECTION. 01 Sentence PIC X(50) VALUE 'COBOL programming is fun and structured.'. 01 WordCount PIC 9(3). PROCEDURE DIVISION. STRING LENGTH OF Sentence DELIMITED BY SPACES INTO WordCount. DISPLAY \"Number of Words: \" WordCount."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. StringConcatenation. DATA DIVISION. WORKING-STORAGE SECTION. 01 String1 PIC X(20) VALUE 'Hello'. 01 String2 PIC X(20) VALUE 'COBOL'. 01 ResultString PIC X(40). PROCEDURE DIVISION. MOVE Function CONCATENATE OF String1 AND String2 TO ResultString. DISPLAY \"Concatenated string: \" ResultString."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. LeapYearCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Year PIC 9(4) VALUE 2024. PROCEDURE DIVISION. IF (Year MOD 4 = 0 AND Year MOD 100 <> 0) OR (Year MOD 400 = 0)     DISPLAY Year \" is a Leap Year.\" ELSE     DISPLAY Year \" is not a Leap Year.\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. FILE-HANDLING.\n\nDATA DIVISION.\nFILE SECTION.\n    FD INPUT-FILE.\n    01 INPUT-RECORD.\n        05 NAME    PIC X(20).\n        05 AGE     PIC 99.\n\nWORKING-STORAGE SECTION.\n    01 OUTPUT-RECORD.\n        05 RESULT  PIC X(30).\n\nPROCEDURE DIVISION.\n    OPEN INPUT INPUT-FILE.\n    READ INPUT-FILE INTO INPUT-RECORD\n        AT END DISPLAY 'End of file reached'\n    END-READ.\n\n    PERFORM UNTIL EOF\n        MOVE NAME TO RESULT\n        DISPLAY 'Name: ' RESULT\n        MOVE AGE TO RESULT\n        DISPLAY 'Age: ' RESULT\n        READ INPUT-FILE INTO INPUT-RECORD\n            AT END SET EOF TO TRUE\n        END-READ\n    END-PERFORM.\n\n    CLOSE INPUT-FILE.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MAIN-PROGRAM.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 5.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    PERFORM MULTIPLY-BY-TWO.\n    DISPLAY 'Result: ' RESULT.\n    STOP RUN.\n\nMULTIPLY-BY-TWO.\n    MULTIPLY NUMBER BY 2 GIVING RESULT."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. CONDITIONAL.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUM PIC 99 VALUE 10.\n\nPROCEDURE DIVISION.\n    IF NUM > 5\n        DISPLAY 'Number is greater than 5'\n    ELSE\n        DISPLAY 'Number is less than or equal to 5'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. ADD-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 10.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    ADD 20 TO NUMBER.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after adding 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SUBTRACT-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 50.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    SUBTRACT 20 FROM NUMBER.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after subtracting 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MULTIPLY-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 3.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    MULTIPLY NUMBER BY 20.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after multiplying by 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. DIVIDE-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 999 VALUE 100.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    DIVIDE NUMBER BY 20 GIVING RESULT.\n    DISPLAY 'Result after dividing by 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. DISPLAY-MESSAGE.\n\nPROCEDURE DIVISION.\n    DISPLAY 'This is a sample COBOL program'.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. READ-WRITE-FILE.\n\nDATA DIVISION.\nFILE SECTION.\n    FD MY-FILE.\n    01 RECORD.\n        05 NAME PIC X(30).\n        05 AGE PIC 99.\n\nPROCEDURE DIVISION.\n    OPEN OUTPUT MY-FILE.\n    MOVE 'John' TO NAME.\n    MOVE 25 TO AGE.\n    WRITE RECORD.\n    CLOSE MY-FILE.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SIMPLE-ADD.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 A PIC 99 VALUE 5.\n    01 B PIC 99 VALUE 10.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    ADD A, B GIVING RESULT.\n    DISPLAY 'Result of addition: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "Dart",
    "code": "void main() { print('Hello, World!'); }"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var shoppingList = ['apples', 'bananas', 'oranges'];\n  var prices = {'apples': 1.50, 'bananas': 0.80, 'oranges': 1.20};\n  var total = 0.0;\n\n  for (var item in shoppingList) {\n    total += prices[item] ?? 0;\n  }\n\n  print('Total cost: \\$total');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var fibonacci = [0, 1];\n  for (var i = 2; i < 10; i++) {\n    fibonacci.add(fibonacci[i - 1] + fibonacci[i - 2]);\n  }\n  print('Fibonacci sequence: \\$fibonacci');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var words = ['hello', 'world', 'dart', 'openai', 'programming'];\n  var longestWord = words.reduce((a, b) => a.length > b.length ? a : b);\n  print('Longest word: \\$longestWord');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var colors = {'red', 'green', 'blue', 'yellow', 'orange'};\n  var color = colors.elementAt(2);\n  print('Selected color: \\$color');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var number = 17;\n  var isPrime = true;\n  for (var i = 2; i <= number / 2; ++i) {\n    if (number % i == 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  print('Is \\$number prime? \\$isPrime');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var inputString = 'Hello, Dart!';\n  var vowels = 'aeiouAEIOU';\n  var count = 0;\n\n  for (var i = 0; i < inputString.length; i++) {\n    if (vowels.contains(inputString[i])) {\n      count++;\n    }\n  }\n  print('Number of vowels: \\$count');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var students = {\n    'Alice': 95,\n    'Bob': 72,\n    'Charlie': 85,\n    'David': 90,\n    'Eve': 68\n  };\n\n  var passed = students.entries.where((entry) => entry.value >= 70);\n  print('Number of students passed: \\${passed.length}');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var temperatures = [23, 26, 28, 21, 19, 25, 30];\n  var average = temperatures.reduce((a, b) => a + b) / temperatures.length;\n  print('Average temperature: \\$average');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [2, 4, 6, 8, 10];\n  var squares = numbers.map((num) => num * num).toList();\n  print('Squared numbers: \\$squares');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {  var list1 = [1, 2, 3, 4, 5];  var list2 = [3, 4, 5, 6, 7];  var commonElements = list1.toSet().intersection(list2.toSet());  print('Common elements: \\$commonElements');}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [1, 2, 3, 4, 5];\n  var evenNumbers = numbers.where((number) => number % 2 == 0).toList();\n  print('Even numbers: \\$evenNumbers');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var data = {'name': 'Alice', 'age': 30};\n  var keys = data.keys.toList();\n  var values = data.values.toList();\n  print('Keys: \\$keys');\n  print('Values: \\$values');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var sum = list.reduce((value, element) => value + element);\n  var average = sum / list.length;\n  print('Average: \\$average');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var filteredList = myList.where((fruit) => fruit.length > 5).toList();\n  print('Fruits with length greater than 5: \\\\$filteredList');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [4, 7, 12, 18, 25];\n  var average = myList.reduce((a, b) => a + b) / myList.length;\n  print('Average: \\\\$average');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'Dart is an interesting language';\n  var words = sentence.split(' ');\n  var longestWord = words.reduce((a, b) => a.length > b.length ? a : b);\n  print('Longest word: \\\\$longestWord');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [3, 6, 9, 12, 15];\n  var sum = list.fold(0, (previous, current) => previous + current);\n  print('Sum: \\\\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [10, 20, 30, 40, 50];\n  var result = myList.map((value) => value * 2).toList();\n  print('Doubled list: \\\\$result');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'Learning Dart is fun!';\n  var charCount = sentence.runes.toSet().length;\n  print('Unique characters: \\\\$charCount');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [1, 2, 3, 4, 5];\n  var oddNumbers = myList.where((number) => number % 2 != 0).toList();\n  print('Odd numbers: \\\\$oddNumbers');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var firstThreeLetters = myList.map((fruit) => fruit.substring(0, 3)).toList();\n  print('First three letters: \\\\$firstThreeLetters');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var number = 42;\n  var isEven = number.isEven;\n  print('Is \\\\$number even? \\\\$isEven');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var containsA = myList.any((fruit) => fruit.contains('a'));\n  print('Any fruit contains letter \\'a\\': \\\\$containsA');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [2, 4, 6, 8, 10];\n  var product = myList.reduce((value, element) => value * element);\n  print('Product: \\\\$product');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var reversedList = myList.map((fruit) => fruit.split('').reversed.join()).toList();\n  print('Reversed fruits: \\\\$reversedList');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [10, 20, 30, 40, 50];\n  var result = myList.where((value) => value > 25).toList();\n  print('Values greater than 25: \\\\$result');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var concatenated = myList.reduce((value, element) => value + element);\n  print('Concatenated fruits: \\\\$concatenated');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'This is a sample sentence';\n  var count = sentence.split(' ').length;\n  print('Word count: \\\\$count');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'The quick brown fox jumps over the lazy dog';\n  var words = sentence.split(' ');\n  var wordCount = words.length;\n  print('Word count: \\$wordCount');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [2, 3, 5, 7, 11, 13];\n  var squaredNumbers = numbers.map((num) => num * num).toList();\n  print('Squared numbers: \\$squaredNumbers');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'Hello, world!';\n  var reversed = sentence.split('').reversed.join();\n  print('Reversed: \\$reversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var input = '1, 2, 3, 4, 5';\n  var numbers = input.split(', ').map((str) => int.parse(str)).toList();\n  var sum = numbers.reduce((value, element) => value + element);\n  print('Sum: \\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var squares = list.map((num) => num * num).toList();\n  var filtered = squares.where((num) => num.isEven).toList();\n  print('Filtered: \\$filtered');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var sum = list.fold(0, (acc, current) => acc + current);\n  print('Sum: \\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var names = ['Alice', 'Bob', 'Charlie'];\n  var nameWithL = names.firstWhere((name) => name.startsWith('L'), orElse: () => 'None');\n  print('Name starting with L: \\$nameWithL');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var values = [1, 2, 3, 4, 5];\n  var product = values.reduce((value, element) => value * element);\n  print('Product: \\$product');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var reversedList = list.reversed.toList();\n  print('Reversed list: \\$reversedList');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [3, 7, 12, 18, 22, 30];\n  var multiplesOfThree = numbers.where((number) => number % 3 == 0).toList();\n  print('Multiples of three: \\$multiplesOfThree');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var sum = list.fold(0, (previousValue, element) => previousValue + element);\n  print('Sum: \\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [2, 4, 6, 8, 10];\n  var squares = numbers.map((num) => num * num).toList();\n  print('Squared numbers: \\$squares');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() { int number = 42; String message = 'Hello'; double piValue = 3.14; bool isTrue = true; }"
  },
  {
    "language": "Dart",
    "code": "void main() { bool isTrue = true; if (isTrue) { print('It is true!'); } else { print('It is false!'); } }"
  },
  {
    "language": "Dart",
    "code": "void main() { for (var i = 0; i < 5; i++) { print('Count: $i'); } }"
  },
  {
    "language": "Dart",
    "code": "void main() { int count = 0; while (count < 5) { print('Count: $count'); count++; } }"
  },
  {
    "language": "Dart",
    "code": "void greet(String name) { print('Hello, $name!'); } void main() { greet('Alice'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { List<String> fruits = ['Apple', 'Orange', 'Banana']; print(fruits); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Map<String, int> ages = {'Alice': 25, 'Bob': 30, 'Charlie': 28}; print(ages); }"
  },
  {
    "language": "Dart",
    "code": "class Person { String name; int age; Person(this.name, this.age); } void main() { var person = Person('Alice', 25); print('Name: ${person.name}, Age: ${person.age}'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Future<void> fetchData() async { await Future.delayed(Duration(seconds: 2)); print('Data fetched!'); } fetchData(); print('Fetching data...'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Set<int> numbers = {1, 2, 3, 4, 5}; print(numbers); }"
  },
  {
    "language": "Dart",
    "code": "enum Status { pending, approved, rejected } void main() { var applicationStatus = Status.approved; print('Application Status: $applicationStatus'); }"
  },
  {
    "language": "Dart",
    "code": "import 'dart:math'; void main() { var random = Random(); print('Random number: ${random.nextInt(100)}'); }"
  },
  {
    "language": "Dart",
    "code": "import 'dart:io'; void main() { stdout.write('Enter your name: '); var name = stdin.readLineSync(); print('Hello, $name!'); }"
  },
  {
    "language": "Dart",
    "code": "void greet({String name = 'Anonymous'}) { print('Hello, $name!'); } void main() { greet(name: 'Alice'); greet(); }"
  },
  {
    "language": "Dart",
    "code": "class Bird { void fly() { print('Flying!'); } } class Sparrow extends Bird {} void main() { var sparrow = Sparrow(); sparrow.fly(); }"
  },
  {
    "language": "Dart",
    "code": "extension StringExtension on String { void shout() { print('${this.toUpperCase()}!!!'); } } void main() { var message = 'hello'; message.shout(); }"
  },
  {
    "language": "Dart",
    "code": "Future<void> delayedPrint() { return Future.delayed(Duration(seconds: 2), () { print('Delayed print after 2 seconds'); }); } void main() { delayedPrint(); print('Printed immediately'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { RegExp regex = RegExp(r'\\d+'); String text = 'There are 123 apples'; Iterable<Match> matches = regex.allMatches(text); matches.forEach((match) => print(match.group(0))); }"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  print('Hello, World!');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int result = add(3, 5);\n  print('Result: result');\n}\n\nint add(int a, int b) {\n  return a + b;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  for (int i = 0; i < 5; i++) {\n    print('Value: i');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<String> names = ['Alice', 'Bob', 'Charlie'];\n  for (String name in names) {\n    print('Hello, name!');\n  }}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String message = 'Hello';\n  String name = 'Alice';\n  String result = concatenate(message, name);\n  print(result);\n}\n\nString concatenate(String a, String b) {\n  return ''a', 'b!'';\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  double radius = 7.0;\n  double area = calculateArea(radius);\n  print('Area of the circle: area');\n}\n\ndouble calculateArea(double r) {\n  return 3.14 * r * r;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int num = 10;\n  if (num > 5) {\n    print('Number is greater than 5');\n  } else {\n    print('Number is less than or equal to 5');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int x = 0;\n  while (x < 5) {\n    print('Value: ,'x';\n    x++;\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<int> numbers = [1, 2, 3, 4, 5];\n  numbers.forEach((number) => print('Number: number'));\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String text = 'This is a Dart program';\n  print(text);\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String name = 'Alice';\n  print('Hello, name!');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int number = 7;\n  if (number % 2 == 0) {\n    print('Even');\n  } else {\n    print('Odd');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int n = 5;\n  for (int i = 1; i <= n; i++) {\n    print('*' * i);\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<int> numbers = [1, 2, 3, 4, 5];\n  int sum = numbers.reduce((value, element) => value + element);\n  print('Sum: sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String message = 'Hello';\n  String name = 'Bob';\n  String result = 'message, name!';\n  print(result);\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int x = 10;\n  do {\n    print('Value: x');\n    x -= 2;\n  } while (x > 0);\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String str = 'Dart Programming Language';\n  List<String> parts = str.split(' ');\n  parts.forEach((part) => print(part));\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int a = 10, b = 20;\n  int max = (a > b) ? a : b;\n  print('Maximum: max');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  double tempCelsius = 30.0;\n  double tempFahrenheit = (tempCelsius * 9/5) + 32;\n  print('tempCelsius\u00b0C = tempFahrenheit\u00b0F');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int num = 54321;\n  int reversed = int.parse(num.toString().split('').reversed.join());\n  print('Reversed number: reversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String message = 'Welcome';\n  for (int i = 0; i < message.length; i++) {\n    print(message[i]);\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int num = 5;\n  print('Square of num is: {num * num}');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<int> list = [1, 2, 3, 4, 5];\n  List<int> squares = list.map((number) => number * number).toList();\n  print('Squared values: squares');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String str = 'Dart';\n  String reversed = str.split('').reversed.join();\n  print('Reversed string: eversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  double radius = 7.0;\n  double area = calculateArea(radius);\n  print('Area of the circle: area');\n}\n\ndouble calculateArea(double r) {\n  return 3.14 * r * r;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  List<String> fruits = ['Apple', 'Banana', 'Orange'];\n  for (String fruit in fruits) {\n    print('I like fruit');\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int a = 10, b = 20;\n  int sum = a + b;\n  print('Sum: sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int x = 5;\n  while (x > 0) {\n    print('Value: x');\n    x--;\n  }\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int number = 12345;\n  String reversed = number.toString().split('').reversed.join();\n  print('Reversed number: reversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  String sentence = 'This is a Dart code snippet';\n  List<String> words = sentence.split(' ');\n  words.forEach((word) => print('Word: word'));\n}"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM HelloWorld PRINT *, 'Hello, World!' END PROGRAM HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "program HelloWorld\n  print *, 'Hello, World!'\nend program HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "program SumNumbers\n  integer :: sum\n  sum = 0\n  do i = 1, 10\n     sum = sum + i\n  end do\n  print *, 'Sum: ', sum\nend program SumNumbers"
  },
  {
    "language": "Fortran",
    "code": "program Factorial\n  integer :: n = 5, fact = 1, i\n  do i = 1, n\n     fact = fact * i\n  end do\n  print *, 'Factorial of ', n, ' is ', fact\nend program Factorial"
  },
  {
    "language": "Fortran",
    "code": "program PrimeCheck\n  integer :: number = 17, i, flag = 0\n  do i = 2, number - 1\n     if (mod(number, i) == 0) then\n        flag = 1\n        exit\n     end if\n  end do\n  if (flag == 0) then\n     print *, number, ' is prime'\n  else\n     print *, number, ' is not prime'\n  end if\nend program PrimeCheck"
  },
  {
    "language": "Fortran",
    "code": "program Fibonacci\n  integer :: n = 10, first = 0, second = 1, next, i\n  print *, 'Fibonacci Series: '\n  do i = 0, n\n     if (i <= 1) then\n        next = i\n     else\n        next = first + second\n        first = second\n        second = next\n     end if\n     print *, next\n  end do\nend program Fibonacci"
  },
  {
    "language": "Fortran",
    "code": "program ArraySum\n  integer :: arr(5) = [1, 2, 3, 4, 5], i, sum = 0\n  do i = 1, size(arr)\n     sum = sum + arr(i)\n  end do\n  print *, 'Sum of array elements: ', sum\nend program ArraySum"
  },
  {
    "language": "Fortran",
    "code": "program SphereVolume\n  real :: radius = 5.0, volume\n  volume = (4.0 / 3.0) * 3.14159 * radius**3\n  print *, 'Volume of sphere: ', volume\nend program SphereVolume"
  },
  {
    "language": "Fortran",
    "code": "program LargestNumber\n  integer :: numbers(5) = [5, 12, 9, 3, 18], i, max\n  max = numbers(1)\n  do i = 2, size(numbers)\n     if (numbers(i) > max) then\n        max = numbers(i)\n     end if\n  end do\n  print *, 'Largest number: ', max\nend program LargestNumber"
  },
  {
    "language": "Fortran",
    "code": "program BubbleSort\n  integer :: arr(5) = [64, 34, 25, 12, 22], i, j, temp\n  do i = 1, size(arr) - 1\n     do j = 1, size(arr) - i\n        if (arr(j) > arr(j + 1)) then\n           temp = arr(j)\n           arr(j) = arr(j + 1)\n           arr(j + 1) = temp\n        end if\n     end do\n  end do\n  print *, 'Sorted array: ', arr\nend program BubbleSort"
  },
  {
    "language": "Fortran",
    "code": "program QuadraticEquation\n  real :: a = 2.0, b = -7.0, c = 3.0\n  real :: discriminant, root1, root2\n  discriminant = b**2 - 4 * a * c\n  root1 = (-b + sqrt(discriminant)) / (2 * a)\n  root2 = (-b - sqrt(discriminant)) / (2 * a)\n  print *, 'Roots: ', root1, root2\nend program QuadraticEquation"
  },
  {
    "language": "Fortran",
    "code": "program ArmstrongNumber\n  integer :: number = 153, temp, digit, sum = 0\n  temp = number\n  do while (temp /= 0)\n     digit = mod(temp, 10)\n     sum = sum + digit**3\n     temp = temp / 10\n  end do\n  if (sum == number) then\n     print *, number, ' is an Armstrong number'\n  else\n     print *, number, ' is not an Armstrong number'\n  end if\nend program ArmstrongNumber"
  },
  {
    "language": "Fortran",
    "code": "program GCD\n  integer :: num1 = 45, num2 = 60, temp1, temp2\n  temp1 = num1\n  temp2 = num2\n  do while (temp2 /= 0)\n     if (temp1 > temp2) then\n        temp1 = temp1 - temp2\n     else\n        temp2 = temp2 - temp1\n     end if\n  end do\n  print *, 'GCD: ', temp1\nend program GCD"
  },
  {
    "language": "Fortran",
    "code": "program CountVowels\n  character(len=50) :: sentence = 'Fortran programming language'\n  integer :: i, vowels = 0\n  do i = 1, len_trim(sentence)\n     if (any(sentence(i:i) == ['a', 'e', 'i', 'o', 'u'])) then\n        vowels = vowels + 1\n     end if\n  end do\n  print *, 'Number of vowels: ', vowels\nend program CountVowels"
  },
  {
    "language": "Fortran",
    "code": "program DecimalToBinary\n  integer :: decimal = 19, binary(32), quotient, i = 1\n  quotient = decimal\n  do while (quotient > 0)\n     binary(i) = mod(quotient, 2)\n     quotient = quotient / 2\n     i = i + 1\n  end do\n  print *, 'Binary equivalent of ', decimal, ' is: '\n  do i = i - 1, 1, -1\n     print *, binary(i)\n  end do\nend program DecimalToBinary"
  },
  {
    "language": "Fortran",
    "code": "program ArrayAverage\n  integer :: arr(6) = [10, 15, 20, 25, 30, 35], i, sum = 0\n  real :: average\n  do i = 1, size(arr)\n     sum = sum + arr(i)\n  end do\n  average = real(sum) / size(arr)\n  print *, 'Average of array elements: ', average\nend program ArrayAverage"
  },
  {
    "language": "Fortran",
    "code": "program LeapYear\n  integer :: year = 2024\n  if (mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0)) then\n     print *, year, ' is a leap year'\n  else\n     print *, year, ' is not a leap year'\n  end if\nend program LeapYear"
  },
  {
    "language": "Fortran",
    "code": "program SumOfSeries\n  integer :: n = 10, i\n  real :: sum = 0.0\n  do i = 1, n\n     sum = sum + 1.0 / real(i)\n  end do\n  print *, 'Sum of series: ', sum\nend program SumOfSeries"
  },
  {
    "language": "Fortran",
    "code": "program ReverseString\n  character(len=20) :: str = 'Fortran'\n  integer :: len, i\n  len = len_trim(str)\n  print *, 'Original string: ', str\n  print *, 'Reversed string: '\n  do i = len, 1, -1\n     print *, str(i:i)\n  end do\nend program ReverseString"
  },
  {
    "language": "Fortran",
    "code": "program MatrixMultiplication\n  integer, parameter :: n = 3, m = 2, p = 3\n  integer :: a(n, m) = reshape([1, 2, 3, 4, 5, 6], [n, m])\n  integer :: b(m, p) = reshape([7, 8, 9, 10, 11, 12], [m, p])\n  integer :: c(n, p), i, j, k\n  do i = 1, n\n     do j = 1, p\n        c(i, j) = 0\n        do k = 1, m\n           c(i, j) = c(i, j) + a(i, k) * b(k, j)\n        end do\n     end do\n  end do\n  print *, 'Matrix multiplication result: '\n  do i = 1, n\n     do j = 1, p\n        print *, c(i, j)\n     end do\n  end do\nend program MatrixMultiplication"
  },
  {
    "language": "Fortran",
    "code": "program NewtonRaphson\n  real :: x0 = 2.0, x, epsilon = 0.0001\n  do\n     x = x0 - (x0**3 - 2*x0 - 5) / (3*x0**2 - 2)\n     if (abs(x - x0) < epsilon) exit\n     x0 = x\n  end do\n  print *, 'Root using Newton-Raphson method: ', x\nend program NewtonRaphson"
  },
  {
    "language": "Fortran",
    "code": "program SineSeries\n  real :: x = 1.2, sine = 0.0, term, epsilon = 0.0001\n  integer :: i, sign = 1\n  do i = 1, 1000\n     term = sign * x**((2*i) - 1) / product([(2 * j) - 1, j = 1, i])\n     if (abs(term) < epsilon) exit\n     sine = sine + term\n     sign = -sign\n  end do\n  print *, 'Sine of ', x, ' is ', sine\nend program SineSeries"
  },
  {
    "language": "Fortran",
    "code": "program MatrixTranspose\n  integer, parameter :: n = 3, m = 2\n  integer :: a(n, m) = reshape([1, 2, 3, 4, 5, 6], [n, m]), b(m, n), i, j\n  do i = 1, n\n     do j = 1, m\n        b(j, i) = a(i, j)\n     end do\n  end do\n  print *, 'Original Matrix: '\n  do i = 1, n\n     print *, (a(i, j), j = 1, m)\n  end do\n  print *, 'Transposed Matrix: '\n  do i = 1, m\n     print *, (b(i, j), j = 1, n)\n  end do\nend program MatrixTranspose"
  },
  {
    "language": "Fortran",
    "code": "program SimpsonRule\n  real :: a = 0.0, b = 1.0, integral, h, x\n  integer :: n = 10, i\n  h = (b - a) / real(n)\n  integral = func(a) + func(b)\n  do i = 1, n - 1, 2\n     x = a + real(i) * h\n     integral = integral + 4.0 * func(x)\n  end do\n  do i = 2, n - 2, 2\n     x = a + real(i) * h\n     integral = integral + 2.0 * func(x)\n  end do\n  integral = integral * h / 3.0\n  print *, 'Integral using Simpson's rule: ', integral\ncontains\n  real function func(x)\n    real, intent(in) :: x\n    func = x**2 + 1\n  end function func\nend program SimpsonRule"
  },
  {
    "language": "Fortran",
    "code": "program LagrangeInterpolation\n  real :: xvals(5) = [1.0, 2.0, 3.0, 4.0, 5.0], yvals(5) = [1.0, 8.0, 27.0, 64.0, 125.0], x = 2.5, result = 0.0\n  integer :: n = size(xvals), i, j\n  do i = 1, n\n     product = yvals(i)\n     do j = 1, n\n        if (j /= i) product = product * (x - xvals(j)) / (xvals(i) - xvals(j))\n     end do\n     result = result + product\n  end do\n  print *, 'Interpolated value at ', x, ' is ', result\nend program LagrangeInterpolation"
  },
  {
    "language": "Fortran",
    "code": "program JacobiMethod\n  real :: A(3,3) = reshape([10, 2, 1, 1, 5, 1, 2, 3, 10], [3,3])\n  real :: b(3) = [7, -8, 6], x(3) = [0, 0, 0], x_new(3), tol = 0.0001\n  integer :: max_iter = 1000, iter = 0, i, j\n  do while (iter < max_iter)\n     do i = 1, size(b)\n        x_new(i) = b(i)\n        do j = 1, size(b)\n           if (i /= j) x_new(i) = x_new(i) - A(i, j) * x(j)\n        end do\n        x_new(i) = x_new(i) / A(i, i)\n     end do\n     if (all(abs(x_new - x) < tol)) exit\n     x = x_new\n     iter = iter + 1\n  end do\n  print *, 'Solution using Jacobi method: ', x_new\nend program JacobiMethod"
  },
  {
    "language": "Fortran",
    "code": "program HeapSort\n  integer, parameter :: n = 10\n  integer :: arr(n) = [12, 11, 13, 5, 6, 7, 15, 8, 14, 9]\n  call heapify(arr, n)\n  do i = n, 2, -1\n     call swap(arr(1), arr(i))\n     call heapify(arr, i - 1)\n  end do\n  print *, 'Sorted array: ', arr\ncontains\n  subroutine swap(a, b)\n    integer, intent(inout) :: a, b\n    integer :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap\n  subroutine heapify(arr, size)\n    integer, intent(inout) :: arr(:), size\n    integer :: i, j, parent, left, right, largest\n    do i = size / 2, 1, -1\n       parent = i\n       left = 2 * parent\n       right = 2 * parent + 1\n       if (left <= size .and. arr(left) > arr(parent)) then\n          largest = left\n       else\n          largest = parent\n       end if\n       if (right <= size .and. arr(right) > arr(largest)) largest = right\n       if (largest /= parent) then\n          call swap(arr(parent), arr(largest))\n          call heapify(arr, size)\n       end if\n    end do\n  end subroutine heapify\nend program HeapSort"
  },
  {
    "language": "Fortran",
    "code": "program RungeKutta\n  real :: h = 0.1, t = 0.0, y = 1.0, k1, k2, k3, k4\n  integer :: i\n  do i = 1, 10\n     k1 = h * f(t, y)\n     k2 = h * f(t + h/2, y + k1/2)\n     k3 = h * f(t + h/2, y + k2/2)\n     k4 = h * f(t + h, y + k3)\n     y = y + (k1 + 2*k2 + 2*k3 + k4) / 6\n     t = t + h\n     print *, 't = ', t, ' y = ', y\n  end do\ncontains\n  real function f(t, y)\n    real, intent(in) :: t, y\n    f = t*y + y**2\n  end function f\nend program RungeKutta"
  },
  {
    "language": "Fortran",
    "code": "program FFT\n  integer, parameter :: n = 8\n  complex :: data(n) = [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0), (1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0)]\n  call fft(data, n)\n  print *, 'FFT Result: ', data\ncontains\n  subroutine fft(data, n)\n    complex, intent(inout) :: data(:)\n    integer, intent(in) :: n\n    ! FFT implementation\n    ! ... (omitted for brevity)\n  end subroutine fft\nend program FFT"
  },
  {
    "language": "Fortran",
    "code": "program BesselFunction\n  real :: x = 2.0, j0, j1\n  j0 = bessj0(x)\n  j1 = bessj1(x)\n  print *, 'Bessel function J0(x): ', j0\n  print *, 'Bessel function J1(x): ', j1\ncontains\n  real function bessj0(x)\n    real, intent(in) :: x\n    ! Bessel function calculation for J0(x)\n    ! ... (omitted for brevity)\n  end function bessj0\n  real function bessj1(x)\n    real, intent(in) :: x\n    ! Bessel function calculation for J1(x)\n    ! ... (omitted for brevity)\n  end function bessj1\nend program BesselFunction"
  },
  {
    "language": "Fortran",
    "code": "program MonteCarloPi\n  integer :: n = 1000000, i\n  real :: x, y, pi_approx, count\n  count = 0\n  do i = 1, n\n     x = random_number()\n     y = random_number()\n     if (x**2 + y**2 <= 1.0) count = count + 1\n  end do\n  pi_approx = 4.0 * count / n\n  print *, 'Approximation of Pi using Monte Carlo method: ', pi_approx\nend program MonteCarloPi"
  },
  {
    "language": "Fortran",
    "code": "program NelderMead\n  real :: x0(2) = [0.0, 0.0]\n  real :: simplex(3,2), tol = 0.0001\n  integer :: i\n  ! Initialize simplex\n  simplex = reshape([-1.0, -1.0, 1.0, -1.0, 0.0, 1.0], [3,2])\n  do i = 1, 100\n     call sort_simplex(simplex)\n     ! Perform Nelder-Mead optimization steps\n     ! ... (omitted for brevity)\n  end do\n  print *, 'Optimal solution: ', simplex(1, :)\ncontains\n  subroutine sort_simplex(simplex)\n    real, intent(inout) :: simplex(:,:)\n    ! Sort simplex points based on function evaluation\n    ! ... (omitted for brevity)\n  end subroutine sort_simplex\nend program NelderMead"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Variables INTEGER :: number REAL :: piValue CHARACTER(LEN=5) :: message LOGICAL :: isTrue number = 42 piValue = 3.14 message = 'Hello' isTrue = .TRUE. END PROGRAM Variables"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ConditionalStatements LOGICAL :: isTrue isTrue = .TRUE. IF (isTrue) THEN PRINT *, 'It is true!' ELSE PRINT *, 'It is false!' END IF END PROGRAM ConditionalStatements"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Loops INTEGER :: i DO i = 0, 4 PRINT *, 'Count: ', i END DO END PROGRAM Loops"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM WhileLoop INTEGER :: count count = 0 DO WHILE (count < 5) PRINT *, 'Count: ', count count = count + 1 END DO END PROGRAM WhileLoop"
  },
  {
    "language": "Fortran",
    "code": "SUBROUTINE Greet(name) CHARACTER(LEN=10) :: name PRINT *, 'Hello, ', name, '!' END SUBROUTINE Greet PROGRAM Main CALL Greet('Alice') END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Arrays INTEGER, DIMENSION(3) :: numbers numbers = [1, 2, 3] PRINT *, numbers END PROGRAM Arrays"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Arrays2D INTEGER, DIMENSION(2, 3) :: matrix matrix = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3]) PRINT *, matrix END PROGRAM Arrays2D"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Functions SUBROUTINE AddNumbers(a, b) INTEGER :: a, b PRINT *, 'Sum:', a + b END SUBROUTINE AddNumbers PROGRAM Main CALL AddNumbers(5, 7) END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Modules MODULE MathFunctions CONTAINS FUNCTION Cube(x) REAL :: x Cube = x**3 END FUNCTION Cube END MODULE MathFunctions PROGRAM Main USE MathFunctions REAL :: result result = Cube(3.0) PRINT *, 'Cube:', result END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM IfElseStatements INTEGER :: age age = 18 IF (age < 18) THEN PRINT *, 'You are a minor.' ELSEIF (age >= 18 .AND. age < 65) THEN PRINT *, 'You are an adult.' ELSE PRINT *, 'You are a senior citizen.' END IF END PROGRAM IfElseStatements"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM RandomNumbers INTEGER :: randomNum CALL RANDOM_NUMBER(randomNum) randomNum = randomNum * 100 PRINT *, 'Random number:', randomNum END PROGRAM RandomNumbers"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM UserInput CHARACTER(LEN=20) :: name PRINT *, 'Enter your name: ' READ *, name PRINT *, 'Hello, ', TRIM(name), '!' END PROGRAM UserInput"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM OptionalArguments SUBROUTINE Greet(name) CHARACTER(LEN=10), OPTIONAL :: name IF (PRESENT(name)) THEN PRINT *, 'Hello, ', name, '!' ELSE PRINT *, 'Hello, World!' END IF END SUBROUTINE Greet PROGRAM Main CALL Greet('Alice') CALL Greet() END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM DerivedTypes TYPE Person CHARACTER(LEN=20) :: name INTEGER :: age END TYPE Person TYPE(Person) :: individual individual%name = 'Alice' individual%age = 25 PRINT *, 'Name:', individual%name PRINT *, 'Age:', individual%age END PROGRAM DerivedTypes"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FileIO INTEGER :: num, i OPEN(UNIT=10, FILE='numbers.txt', STATUS='OLD') DO i = 1, 3 READ(10, *) num PRINT *, 'Number:', num END DO CLOSE(10) END PROGRAM FileIO"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM AllocateArray INTEGER, ALLOCATABLE :: arr(:) ALLOCATE(arr(5)) arr = [1, 2, 3, 4, 5] PRINT *, arr DEALLOCATE(arr) END PROGRAM AllocateArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM RegexExample CHARACTER(LEN=50) :: text CHARACTER(LEN=20) :: pattern INTEGER :: i, nmatches INTEGER, ALLOCATABLE :: matches(:) text = 'There are 123 apples' pattern = '(\\d+)' CALL GET_MATCHES(text, pattern, matches, nmatches) DO i = 1, nmatches PRINT *, 'Match: ', TRIM(matches(i)) END DO END PROGRAM RegexExample"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM HelloWorld\n    PRINT *, 'Hello, World!'\nEND PROGRAM HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SimpleCalculation\n    INTEGER :: num1 = 123, num2 = 456, result\n    result = num1 + num2\n    PRINT *, 'Result: ', result\nEND PROGRAM SimpleCalculation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Looping\n    INTEGER :: i\n    DO i = 1, 10\n        PRINT *, 'Value of i: ', i\n    END DO\nEND PROGRAM Looping"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Conditional\n    INTEGER :: num\n    num = 10\n    IF (num > 5) THEN\n        PRINT *, 'Number is greater than 5'\n    ELSE\n        PRINT *, 'Number is less than or equal to 5'\n    END IF\nEND PROGRAM Conditional"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Subroutine\n    INTEGER :: number = 5, result\n    CALL MultiplyByTwo(number, result)\n    PRINT *, 'Result: ', result\nEND PROGRAM Subroutine\n\nSUBROUTINE MultiplyByTwo(num, res)\n    INTEGER, INTENT(IN) :: num\n    INTEGER, INTENT(OUT) :: res\n    res = num * 2\nEND SUBROUTINE MultiplyByTwo"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FileHandling\n    INTEGER :: unit\n    CHARACTER(LEN=100) :: line\n    OPEN (UNIT=unit, FILE='sample.txt', STATUS='OLD')\n    DO WHILE (.NOT. EOF(unit))\n        READ (unit, '(A)') line\n        PRINT *, line\n    END DO\n    CLOSE(unit)\nEND PROGRAM FileHandling"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Factorial\n    INTEGER :: n = 5, factorial = 1, i\n    DO i = 1, n\n        factorial = factorial * i\n    END DO\n    PRINT *, 'Factorial of ', n, ' is ', factorial\nEND PROGRAM Factorial"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ArrayExample\n    REAL :: numbers(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n    INTEGER :: i\n    DO i = 1, SIZE(numbers)\n        PRINT *, 'Number ', i, ': ', numbers(i)\n    END DO\nEND PROGRAM ArrayExample"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM QuadraticEquation\n    REAL :: a = 1.0, b = -3.0, c = 2.0, discriminant, root1, root2\n    discriminant = b**2 - 4 * a * c\n    root1 = (-b + SQRT(discriminant)) / (2 * a)\n    root2 = (-b - SQRT(discriminant)) / (2 * a)\n    PRINT *, 'Root 1: ', root1\n    PRINT *, 'Root 2: ', root2\nEND PROGRAM QuadraticEquation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FibonacciSeries\n    INTEGER :: n = 10, a = 0, b = 1, i, next\n    PRINT *, 'Fibonacci Series:'\n    DO i = 1, n\n        PRINT *, a\n        next = a + b\n        a = b\n        b = next\n    END DO\nEND PROGRAM FibonacciSeries"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM AverageCalculator\n    INTEGER :: n = 5, i\n    REAL :: numbers(n), total = 0.0, average\n    PRINT *, 'Enter ', n, ' numbers:'\n    DO i = 1, n\n        READ *, numbers(i)\n        total = total + numbers(i)\n    END DO\n    average = total / REAL(n)\n    PRINT *, 'Average: ', average\nEND PROGRAM AverageCalculator"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM StringConcatenation\n    CHARACTER(LEN=20) :: str1 = 'Hello', str2 = 'World', result\n    result = str1 // ' ' // str2\n    PRINT *, 'Concatenated String: ', result\nEND PROGRAM StringConcatenation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM PrimeNumberCheck\n    INTEGER :: num = 11, i, flag = 0\n    DO i = 2, num - 1\n        IF (MOD(num, i) == 0) THEN\n            flag = 1\n            EXIT\n        END IF\n    END DO\n    IF (flag == 0) THEN\n        PRINT *, num, ' is a prime number'\n    ELSE\n        PRINT *, num, ' is not a prime number'\n    END IF\nEND PROGRAM PrimeNumberCheck"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ExponentCalculation\n    REAL :: base = 2.0, exponent = 3.0, result\n    result = base ** exponent\n    PRINT *, 'Result: ', result\nEND PROGRAM ExponentCalculation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM LinearSearch\n    INTEGER :: numbers(5) = [4, 7, 2, 9, 5], key = 2, i, position = -1\n    DO i = 1, SIZE(numbers)\n        IF (numbers(i) == key) THEN\n            position = i\n            EXIT\n        END IF\n    END DO\n    IF (position /= -1) THEN\n        PRINT *, 'Element found at position: ', position\n    ELSE\n        PRINT *, 'Element not found'\n    END IF\nEND PROGRAM LinearSearch"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ArraySum\n    INTEGER, DIMENSION(3, 3) :: matrix = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    INTEGER :: i, j, total = 0\n    DO i = 1, 3\n        DO j = 1, 3\n            total = total + matrix(i, j)\n        END DO\n    END DO\n    PRINT *, 'Sum of matrix elements: ', total\nEND PROGRAM ArraySum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM OddEvenCounter\n    INTEGER :: numbers(5) = [1, 2, 3, 4, 5]\n    INTEGER :: i, oddCount = 0, evenCount = 0\n    DO i = 1, SIZE(numbers)\n        IF (MOD(numbers(i), 2) == 0) THEN\n            evenCount = evenCount + 1\n        ELSE\n            oddCount = oddCount + 1\n        END IF\n    END DO\n    PRINT *, 'Number of even numbers: ', evenCount\n    PRINT *, 'Number of odd numbers: ', oddCount\nEND PROGRAM OddEvenCounter"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM TriangleArea\n    REAL :: base = 5.0, height = 8.0, area\n    area = 0.5 * base * height\n    PRINT *, 'Area of the triangle: ', area\nEND PROGRAM TriangleArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM CircleArea\n    REAL :: radius = 7.0, area\n    area = 3.14 * radius * radius\n    PRINT *, 'Area of the circle: ', area\nEND PROGRAM CircleArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ArrayManipulation\n    INTEGER :: numbers(5) = [5, 10, 15, 20, 25], i\n    PRINT *, 'Original Array:'\n    DO i = 1, SIZE(numbers)\n        PRINT *, numbers(i)\n    END DO\n    PRINT *, 'Array after modification:'\n    DO i = 1, SIZE(numbers)\n        numbers(i) = numbers(i) * 2\n        PRINT *, numbers(i)\n    END DO\nEND PROGRAM ArrayManipulation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixMultiplication\n    INTEGER :: A(3,3), B(3,3), C(3,3)\n    INTEGER :: i, j, k, sum\n    A = RESHAPE([2, 3, 4, 5, 6, 7, 8, 9, 1], [3, 3])\n    B = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    DO i = 1, 3\n        DO j = 1, 3\n            sum = 0\n            DO k = 1, 3\n                sum = sum + A(i, k) * B(k, j)\n            END DO\n            C(i, j) = sum\n        END DO\n    END DO\n    PRINT *, 'Resultant Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, C(i, j)\n        END DO\n    END DO\nEND PROGRAM MatrixMultiplication"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SortingArray\n    INTEGER :: numbers(5) = [3, 7, 1, 5, 4]\n    INTEGER :: i, j, temp\n    DO i = 1, SIZE(numbers) - 1\n        DO j = 1, SIZE(numbers) - i\n            IF (numbers(j) > numbers(j+1)) THEN\n                temp = numbers(j)\n                numbers(j) = numbers(j+1)\n                numbers(j+1) = temp\n            END IF\n        END DO\n    END DO\n    PRINT *, 'Sorted Array:'\n    DO i = 1, SIZE(numbers)\n        PRINT *, numbers(i)\n    END DO\nEND PROGRAM SortingArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMaximum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, max\n    max = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) > max) THEN\n            max = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Maximum value: ', max\nEND PROGRAM FindingMaximum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMinimum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, min\n    min = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) < min) THEN\n            min = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Minimum value: ', min\nEND PROGRAM FindingMinimum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FibonacciRecursion\n    INTEGER :: n = 10\n    PRINT *, 'Fibonacci Series:'\n    DO i = 1, n\n        PRINT *, fibonacci(i)\n    END DO\nCONTAINS\n    INTEGER FUNCTION fibonacci(num)\n        INTEGER, INTENT(IN) :: num\n        IF (num <= 1) THEN\n            fibonacci = num\n        ELSE\n            fibonacci = fibonacci(num-1) + fibonacci(num-2)\n        END IF\n    END FUNCTION fibonacci\nEND PROGRAM FibonacciRecursion"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM TriangularArea\n    REAL :: base = 5.0, height = 8.0, area\n    area = 0.5 * base * height\n    PRINT *, 'Area of the triangle: ', area\nEND PROGRAM TriangularArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM CircleCircumference\n    REAL :: radius = 7.0, circumference\n    circumference = 2.0 * 3.14 * radius\n    PRINT *, 'Circumference of the circle: ', circumference\nEND PROGRAM CircleCircumference"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixTranspose\n    INTEGER :: A(3,3), i, j\n    A = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    PRINT *, 'Original Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(i, j)\n        END DO\n    END DO\n    PRINT *, 'Transposed Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(j, i)\n        END DO\n    END DO\nEND PROGRAM MatrixTranspose"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM PalindromeCheck\n    CHARACTER(LEN=50) :: str = 'racecar', reversed\n    INTEGER :: len, i, flag = 0\n    len = LEN_TRIM(str)\n    reversed = ''\n    DO i = len, 1, -1\n        reversed = TRIM(reversed) // str(i:i)\n    END DO\n    IF (TRIM(str) == reversed) THEN\n        PRINT *, 'It is a palindrome'\n    ELSE\n        PRINT *, 'It is not a palindrome'\n    END IF\nEND PROGRAM PalindromeCheck"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM VectorAddition\n    INTEGER :: A(3), B(3), C(3), i\n    A = [1, 2, 3]\n    B = [4, 5, 6]\n    DO i = 1, SIZE(A)\n        C(i) = A(i) + B(i)\n    END DO\n    PRINT *, 'Resultant Vector:'\n    DO i = 1, SIZE(C)\n        PRINT *, C(i)\n    END DO\nEND PROGRAM VectorAddition"
  },
  {
    "language": "Groovy",
    "code": "def greet() { println 'Hello, World!' } greet()"
  },
  {
    "language": "Groovy",
    "code": "def factorial(int n) {\n    if (n <= 1) return 1\n    return n * factorial(n - 1)\n}\nprintln 'Factorial of 5: ' + factorial(5)"
  },
  {
    "language": "Groovy",
    "code": "def ackermann(int m, int n) {\n    if (m == 0) return n + 1\n    else if (n == 0) return ackermann(m - 1, 1)\n    else return ackermann(m - 1, ackermann(m, n - 1))\n}\nprintln 'Ackermann of (3, 4): ' + ackermann(3, 4)"
  },
  {
    "language": "Groovy",
    "code": "def fibonacci(int n) {\n    def fib = [0, 1]\n    (2..n).each { fib << fib[-1] + fib[-2] }\n    return fib[n]\n}\nprintln 'Fibonacci of 8: ' + fibonacci(8)"
  },
  {
    "language": "Groovy",
    "code": "def quicksort(list) {\n    if (list.size() <= 1) return list\n    def pivot = list.removeAt(list.size() / 2)\n    def (less, greater) = list.partition { it < pivot }\n    return (quicksort(less) << pivot << quicksort(greater)).flatten()\n}\ndef numbers = [5, 3, 7, 2, 9, 1]\nprintln 'Sorted list: ' + quicksort(numbers)"
  },
  {
    "language": "Groovy",
    "code": "def binarySearch(list, int target) {\n    def low = 0, high = list.size() - 1\n    while (low <= high) {\n        def mid = (low + high) / 2\n        if (list[mid] == target) return mid\n        else if (list[mid] < target) low = mid + 1\n        else high = mid - 1\n    }\n    return -1\n}\ndef sortedList = [2, 4, 6, 8, 10, 12, 14, 16, 18]\nprintln 'Index of 10 in list: ' + binarySearch(sortedList, 10)"
  },
  {
    "language": "Groovy",
    "code": "def mergeSort(list) {\n    def merge(left, right) {\n        def result = []\n        while (left.size() && right.size()) {\n            if (left[0] <= right[0]) result << left.remove(0)\n            else result << right.remove(0)\n        }\n        return result + left + right\n    }\n    if (list.size() <= 1) return list\n    def mid = list.size() / 2\n    def left = mergeSort(list[0..(mid - 1)])\n    def right = mergeSort(list[mid..-1])\n    return merge(left, right)\n}\ndef numbers = [38, 27, 43, 3, 9, 82, 10]\nprintln 'Sorted list: ' + mergeSort(numbers)"
  },
  {
    "language": "Groovy",
    "code": "def matrixMultiplication(matrixA, matrixB) {\n    def result = []\n    for (int i = 0; i < matrixA.size(); i++) {\n        def row = []\n        for (int j = 0; j < matrixB[0].size(); j++) {\n            def sum = 0\n            for (int k = 0; k < matrixB.size(); k++) {\n                sum += matrixA[i][k] * matrixB[k][j]\n            }\n            row << sum\n        }\n        result << row\n    }\n    return result\n}\ndef matrix1 = [[1, 2, 3], [4, 5, 6]]\ndef matrix2 = [[7, 8], [9, 10], [11, 12]]\nprintln 'Matrix Multiplication: ' + matrixMultiplication(matrix1, matrix2)"
  },
  {
    "language": "Groovy",
    "code": "def sieveOfEratosthenes(int n) {\n    def primes = []\n    def sieve = new boolean[n + 1]\n    for (int i = 2; i <= n; i++) {\n        if (!sieve[i]) {\n            primes << i\n            for (int j = i * i; j <= n; j += i) {\n                sieve[j] = true\n            }\n        }\n    }\n    return primes\n}\nprintln 'Primes up to 50: ' + sieveOfEratosthenes(50)"
  },
  {
    "language": "Groovy",
    "code": "def hanoi(int n, String source, String auxiliary, String destination) {\n    if (n == 1) {\n        println 'Move disk 1 from ' + source + ' to ' + destination\n        return\n    }\n    hanoi(n - 1, source, destination, auxiliary)\n    println 'Move disk ' + n + ' from ' + source + ' to ' + destination\n    hanoi(n - 1, auxiliary, source, destination)\n}\nhanoi(3, 'A', 'B', 'C')"
  },
  {
    "language": "Groovy",
    "code": "def selectionSort(list) {\n    def size = list.size()\n    for (int i = 0; i < size - 1; i++) {\n        def minIndex = i\n        for (int j = i + 1; j < size; j++) {\n            if (list[j] < list[minIndex]) minIndex = j\n        }\n        def temp = list[i]\n        list[i] = list[minIndex]\n        list[minIndex] = temp\n    }\n    return list\n}\ndef numbers = [64, 25, 12, 22, 11]\nprintln 'Sorted list: ' + selectionSort(numbers)"
  },
  {
    "language": "Groovy",
    "code": "def dijkstra(graph, start) {\n    def distances = [:].withDefault { Integer.MAX_VALUE }\n    distances[start] = 0\n    def visited = []\n    def queue = [start]\n    while (queue) {\n        def current = queue.min { distances[it] }\n        queue.remove(current)\n        visited << current\n        graph[current].each { vertex, weight ->\n            def alt = distances[current] + weight\n            if (alt < distances[vertex]) {\n                distances[vertex] = alt\n                queue << vertex\n            }\n        }\n    }\n    return distances\n}\ndef graph = [\n    A: [B: 5, C: 3],\n    B: [D: 7, C: 2],\n    C: [D: 8, E: 6],\n    D: [E: 9],\n    E: [:]\n]\ndef start = 'A'\nprintln 'Shortest distances from ' + start + ': ' + dijkstra(graph, start)"
  },
  {
    "language": "Groovy",
    "code": "class BinarySearchTree {\n    Node root\n    class Node {\n        int value\n        Node left, right\n        Node(int value) { this.value = value }\n    }\n    void insert(int value) { root = insertRec(root, value) }\n    Node insertRec(Node root, int value) {\n        if (root == null) return new Node(value)\n        if (value < root.value) root.left = insertRec(root.left, value)\n        else if (value > root.value) root.right = insertRec(root.right, value)\n        return root\n    }\n    void inOrder() { inOrderRec(root) }\n    void inOrderRec(Node root) {\n        if (root != null) {\n            inOrderRec(root.left)\n            print(root.value + ' ')\n            inOrderRec(root.right)\n        }\n    }\n}\ndef tree = new BinarySearchTree()\ntree.insert(50)\ntree.insert(30)\ntree.insert(20)\ntree.insert(40)\ntree.insert(70)\ntree.insert(60)\ntree.insert(80)\nprint 'Inorder traversal: '\ntree.inOrder()"
  },
  {
    "language": "Groovy",
    "code": "def matrixChainOrder(int p[]) {\n    def n = p.size() - 1\n    def m = new int[n][n], s = new int[n][n]\n    for (int i = 1; i < n; i++) m[i][i] = 0\n    for (int L = 2; L < n; L++) {\n        for (int i = 1; i < n - L + 1; i++) {\n            int j = i + L - 1\n            m[i][j] = Integer.MAX_VALUE\n            for (int k = i; k <= j - 1; k++) {\n                int cost = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]\n                if (cost < m[i][j]) {\n                    m[i][j] = cost\n                    s[i][j] = k\n                }\n            }\n        }\n    }\n    return [m, s]\n}\ndef p = [10, 20, 30, 40, 30]\nprintln 'Minimum number of multiplications: ' + matrixChainOrder(p)[0][1][p.size() - 1]"
  },
  {
    "language": "Groovy",
    "code": "def findLongestCommonSubsequence(String X, String Y) {\n    def m = X.size(), n = Y.size()\n    def L = new int[m + 1][n + 1]\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0) L[i][j] = 0\n            else if (X[i - 1] == Y[j - 1]) L[i][j] = L[i - 1][j - 1] + 1\n            else L[i][j] = Math.max(L[i - 1][j], L[i][j - 1])\n        }\n    }\n    def index = L[m][n], lcs = new char[index]\n    def i = m, j = n\n    while (i > 0 && j > 0) {\n        if (X[i - 1] == Y[j - 1]) {\n            lcs[--index] = X[i - 1]\n            i--\n            j--\n        } else if (L[i - 1][j] > L[i][j - 1]) i--\n        else j--\n    }\n    return new String(lcs)\n}\ndef X = 'AGGTAB'\ndef Y = 'GXTXAYB'\nprintln 'Longest Common Subsequence: ' + findLongestCommonSubsequence(X, Y)"
  },
  {
    "language": "Groovy",
    "code": "def longestIncreasingSubsequence(int arr[]) {\n    def n = arr.size()\n    def lis = new int[n]\n    lis[0] = 1\n    (1..n - 1).each { i ->\n        lis[i] = 1\n        (0..i - 1).each { j ->\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1) lis[i] = lis[j] + 1\n        }\n    }\n    return lis.max()\n}\ndef arr = [10, 22, 9, 33, 21, 50, 41, 60]\nprintln 'Length of Longest Increasing Subsequence: ' + longestIncreasingSubsequence(arr)"
  },
  {
    "language": "Groovy",
    "code": "def editDistance(String str1, String str2) {\n    def m = str1.size(), n = str2.size()\n    def dp = new int[m + 1][n + 1]\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) dp[i][j] = j\n            else if (j == 0) dp[i][j] = i\n            else if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1]\n            else dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1])\n        }\n    }\n    return dp[m][n]\n}\ndef str1 = 'sunday'\ndef str2 = 'saturday'\nprintln 'Edit Distance between strings: ' + editDistance(str1, str2)"
  },
  {
    "language": "Groovy",
    "code": "def knapsack(int W, int wt[], int val[], int n) {\n    def K = new int[n + 1][W + 1]\n    for (int i = 0; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            if (i == 0 || w == 0) K[i][w] = 0\n            else if (wt[i - 1] <= w) K[i][w] = Math.max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else K[i][w] = K[i - 1][w]\n        }\n    }\n    return K[n][W]\n}\ndef val = [60, 100, 120]\ndef wt = [10, 20, 30]\ndef W = 50\nprintln 'Maximum value in Knapsack: ' + knapsack(W, wt, val, val.size())"
  },
  {
    "language": "Groovy",
    "code": "def subsetSum(int arr[], int n, int sum) {\n    def subset = new boolean[n + 1][sum + 1]\n    for (int i = 0; i <= n; i++) subset[i][0] = true\n    for (int i = 1; i <= sum; i++) subset[0][i] = false\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) subset[i][j] = subset[i - 1][j]\n            else subset[i][j] = subset[i - 1][j] || subset[i - 1][j - arr[i - 1]]\n        }\n    }\n    return subset[n][sum]\n}\ndef arr = [3, 34, 4, 12, 5, 2]\nprintln 'Subset with sum 9 exists: ' + subsetSum(arr, arr.size(), 9)"
  },
  {
    "language": "Groovy",
    "code": "def maximumBipartiteMatching(int graph[][], int u, boolean seen[], int matchR[]) {\n    def m = graph.size(), n = graph[0].size()\n    (0..n - 1).each { v ->\n        if (graph[u][v] != 0 && !seen[v]) {\n            seen[v] = true\n            if (matchR[v] < 0 || maximumBipartiteMatching(graph, matchR[v], seen, matchR)) {\n                matchR[v] = u\n                return true\n            }\n        }\n    }\n    return false\n}\ndef maxBPM(int graph[][]) {\n    def m = graph.size(), n = graph[0].size(), result = 0\n    def matchR = new int[n]\n    matchR.fill(-1)\n    (0..m - 1).each { u ->\n        def seen = new boolean[n]\n        if (maximumBipartiteMatching(graph, u, seen, matchR)) result++\n    }\n    return result\n}\ndef graph = [[0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1]]\nprintln 'Maximum matching in Bipartite Graph: ' + maxBPM(graph)"
  },
  {
    "language": "Groovy",
    "code": "def travellingSalesmanProblem(int graph[][], int s) {\n    def V = graph.size()\n    def vertex = []\n    (0..V - 1).each { i ->\n        if (i != s) vertex.add(i)\n    }\n    def min_path = Integer.MAX_VALUE\n    while (true) {\n        def current_pathweight = 0\n        def k = s\n        (0..vertex.size() - 1).each { i ->\n            current_pathweight += graph[k][vertex[i]]\n            k = vertex[i]\n        }\n        current_pathweight += graph[k][s]\n        min_path = Math.min(min_path, current_pathweight)\n        def next_permutation = -1\n        (vertex.size() - 1).downto(0).each { i ->\n            if (i > 0 && vertex[i] > vertex[i - 1]) {\n                next_permutation = i\n                break\n            }\n        }\n        if (next_permutation == -1) break\n        def next_min = next_permutation\n        (vertex.size() - 1).downto(next_permutation).each { i ->\n            if (vertex[i] > vertex[next_permutation - 1] && vertex[i] < vertex[next_min]) next_min = i\n        }\n        def temp = vertex[next_permutation - 1]\n        vertex[next_permutation - 1] = vertex[next_min]\n        vertex[next_min] = temp\n        (next_permutation..(vertex.size() - 1)).sort().each { i ->\n            def temp = vertex[next_permutation]\n            vertex[next_permutation] = vertex[i]\n            vertex[i] = temp\n            next_permutation++\n        }\n    }\n    return min_path\n}\ndef graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ndef s = 0\nprintln 'Minimum Cost Hamiltonian Cycle: ' + travellingSalesmanProblem(graph, s)"
  },
  {
    "language": "Groovy",
    "code": "def variables() { def number = 42 def piValue = 3.14 def message = 'Hello' def isTrue = true } variables()"
  },
  {
    "language": "Groovy",
    "code": "def conditionalStatements() { def isTrue = true if (isTrue) { println 'It is true!' } else { println 'It is false!' } } conditionalStatements()"
  },
  {
    "language": "Groovy",
    "code": "def loops() { for (int i = 0; i < 5; i++) { println \"Count: $i\" } } loops()"
  },
  {
    "language": "Groovy",
    "code": "def whileLoop() { def count = 0 while (count < 5) { println \"Count: $count\" count++ } } whileLoop()"
  },
  {
    "language": "Groovy",
    "code": "def greet(name) { println \"Hello, $name!\" } greet('Alice')"
  },
  {
    "language": "Groovy",
    "code": "def list() { def fruits = ['Apple', 'Orange', 'Banana'] println fruits } list()"
  },
  {
    "language": "Groovy",
    "code": "def map() { def ages = [Alice: 25, Bob: 30, Charlie: 28] println ages } map()"
  },
  {
    "language": "Groovy",
    "code": "class Person { String name int age } def person = new Person(name: 'Alice', age: 25) println \"Name: ${person.name}, Age: ${person.age}\""
  },
  {
    "language": "Groovy",
    "code": "def fetchData() { def result = new groovy.concurrent.Promise() result.future.onComplete { println 'Data fetched!' } result.resolve() } fetchData() println 'Fetching data...'"
  },
  {
    "language": "Groovy",
    "code": "def set() { def numbers = [1, 2, 3, 4, 5] as Set println numbers } set()"
  },
  {
    "language": "Groovy",
    "code": "enum Status { PENDING, APPROVED, REJECTED } def applicationStatus = Status.APPROVED println \"Application Status: $applicationStatus\""
  },
  {
    "language": "Groovy",
    "code": "import java.util.Random def random = new Random() println \"Random number: ${random.nextInt(100)}\""
  },
  {
    "language": "Groovy",
    "code": "def userInput() { print 'Enter your name: ' def name = System.console().readLine() println \"Hello, $name!\" } userInput()"
  },
  {
    "language": "Groovy",
    "code": "def optionalArguments(name = 'Anonymous') { println \"Hello, $name!\" } optionalArguments('Alice') optionalArguments()"
  },
  {
    "language": "Groovy",
    "code": "class Bird { def fly() { println 'Flying!' } } class Sparrow extends Bird {} def sparrow = new Sparrow() sparrow.fly()"
  },
  {
    "language": "Groovy",
    "code": "String.metaClass.shout = { println \"${delegate.toUpperCase()}!!!\" } def message = 'hello' message.shout()"
  },
  {
    "language": "Groovy",
    "code": "def delayedPrint() { groovy.concurrent.Promise.delay { println 'Delayed print after 2 seconds' } } delayedPrint() println 'Printed immediately'"
  },
  {
    "language": "Groovy",
    "code": "def parallelExecution = { List items ->\n    def threads = items.collectParallel { item ->\n        Thread.start {\n            println(\"Processing $item on thread ${Thread.currentThread().name}\")\n            // Perform complex operations\n        }\n    }\n    threads*.join()\n}\nparallelExecution([1, 2, 3, 4, 5])"
  },
  {
    "language": "Groovy",
    "code": "def fibonacciSequence(int n) {\n    def fib = [0, 1]\n    (2..<n).each { fib << fib[-2] + fib[-1] }\n    return fib\n}\nprintln(fibonacciSequence(10))"
  },
  {
    "language": "Groovy",
    "code": "def asyncProcessing = { Closure closure ->\n    def result = null\n    def thread = Thread.start {\n        result = closure.call()\n    }\n    thread.join()\n    return result\n}\nprintln(asyncProcessing({\n    // Simulate time-consuming operation\n    Thread.sleep(3000)\n    return 'Async operation completed'\n}))"
  },
  {
    "language": "Groovy",
    "code": "def memoization = { Closure closure ->\n    def cache = [:].withDefault { key ->\n        def result = closure.call(key)\n        cache[key] = result\n        return result\n    }\n    return cache\n}\n// Usage:\ndef fib = memoization { n ->\n    n < 2 ? n : fib(n - 1) + fib(n - 2)\n}\nprintln(fib(10))"
  },
  {
    "language": "Groovy",
    "code": "def executeWithRetry = { Closure closure, int maxAttempts ->\n    def attempt = 0\n    while (attempt < maxAttempts) {\n        try {\n            return closure.call()\n        } catch (Exception e) {\n            println(\"Attempt $attempt failed: $e\")\n        }\n        attempt++\n    }\n    throw new RuntimeException(\"Max attempts reached\")\n}\n// Usage:\nexecuteWithRetry({\n    // Complex operation that might fail\n    if (Math.random() < 0.5) throw new RuntimeException(\"Failed\")\n    return 'Success'\n}, 3)"
  },
  {
    "language": "Groovy",
    "code": "def asyncParallelExecution = { List tasks ->\n    def results = tasks.collectParallel { task ->\n        Thread.start {\n            // Perform complex async task\n            // Store result in shared list or map\n        }\n    }\n    results*.join()\n    return results.collect { /* retrieve and process results */ }\n}\nasyncParallelExecution(['Task 1', 'Task 2', 'Task 3'])"
  },
  {
    "language": "Groovy",
    "code": "def processBigData = { List data ->\n    def batchSize = 1000\n    def results = []\n    data.each { item ->\n        // Process item and collect result\n        // Add to results list\n    }\n    return results\n}\n// Usage:\ndef bigData = /* load huge data set */\ndef processedData = processBigData(bigData)"
  },
  {
    "language": "Groovy",
    "code": "def complexSorting = { List items ->\n    // Implement a complex sorting algorithm\n    // e.g., Merge Sort, Quick Sort, etc.\n    return items.sort { a, b -> /* custom comparison logic */ }\n}\n// Usage:\ndef unsortedList = [5, 2, 7, 1, 9]\ndef sortedList = complexSorting(unsortedList)"
  },
  {
    "language": "Groovy",
    "code": "def transactionalProcessing = { Closure transaction ->\n    def transactionManager = /* retrieve transaction manager */\n    transactionManager.beginTransaction()\n    try {\n        def result = transaction.call()\n        transactionManager.commitTransaction()\n        return result\n    } catch (Exception e) {\n        transactionManager.rollbackTransaction()\n        throw e\n    }\n}\n// Usage:\ntransactionalProcessing({\n    // Perform a series of transactional operations\n    // Return the result\n})"
  },
  {
    "language": "Groovy",
    "code": "def customDSL = {\n    person {\n        name 'John Doe'\n        age 30\n        address {\n            street '123 Main St'\n            city 'Exampleville'\n        }\n    }\n}\n// Implement a DSL parser to interpret and execute this custom DSL"
  },
  {
    "language": "Groovy",
    "code": "def concurrentStreamProcessing = { List data ->\n    data.parallelStream().forEach { item ->\n        // Perform complex operations on each item concurrently\n    }\n}\n// Usage:\ndef data = ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5']\nconcurrentStreamProcessing(data)"
  },
  {
    "language": "Groovy",
    "code": "def distributedLocking = { Closure operation ->\n    def lock = DistributedLock.acquireLock('lockKey')\n    try {\n        operation()\n    } finally {\n        lock.release()\n    }\n}\n// Usage:\ndistributedLocking({ /* Perform a critical section of code */ })"
  },
  {
    "language": "Groovy",
    "code": "def eventDrivenArchitecture = {\n    def eventBus = new EventBus()\n    def subscriber = new Subscriber()\n    eventBus.subscribe(subscriber)\n    eventBus.publish(new Event())\n}\n// Implement an event-driven system"
  },
  {
    "language": "Groovy",
    "code": "def reactiveDatabaseAccess = {\n    def database = new ReactiveDatabase()\n    database.query('SELECT * FROM table').subscribe({ result ->\n        // Handle and process the query result reactively\n    })\n}\n// Implement reactive database access"
  },
  {
    "language": "Groovy",
    "code": "def machineLearningModel = {\n    def model = new MachineLearningModel()\n    model.train(trainingData)\n    return model.predict(testData)\n}\n// Implement a machine learning model"
  },
  {
    "language": "Groovy",
    "code": "def distributedMessaging = {\n    def messagingSystem = new DistributedMessaging()\n    messagingSystem.send('destination', 'message')\n    messagingSystem.receive('destination', { message ->\n        // Process received messages\n    })\n}\n// Implement distributed messaging"
  },
  {
    "language": "Groovy",
    "code": "def blockchainTransaction = {\n    def transaction = new BlockchainTransaction()\n    transaction.createTransaction(sender, receiver, amount)\n    transaction.mineBlock()\n}\n// Implement blockchain transaction logic"
  },
  {
    "language": "Groovy",
    "code": "def distributedTaskExecution = {\n    def task = new DistributedTask()\n    task.assignToCluster(cluster)\n    task.executeOnCluster()\n}\n// Implement distributed task execution"
  },
  {
    "language": "Groovy",
    "code": "def quantumComputingSimulation = {\n    def quantumComputer = new QuantumComputer()\n    quantumComputer.runSimulation()\n    return quantumComputer.getResults()\n}\n// Simulate quantum computing operations"
  },
  {
    "language": "Groovy",
    "code": "def geneticAlgorithm = {\n    def algorithm = new GeneticAlgorithm()\n    algorithm.initializePopulation()\n    algorithm.evolvePopulation()\n    return algorithm.getFittestIndividual()\n}\n// Implement a genetic algorithm"
  },
  {
    "language": "Groovy",
    "code": "def deepLearningModel = {\n    def model = new DeepLearningModel()\n    model.buildNeuralNetwork()\n    model.train(trainingData)\n    return model.predict(testData)\n}\n// Implement a deep learning model"
  },
  {
    "language": "Groovy",
    "code": "def distributedGraphProcessing = {\n    def graph = new DistributedGraph()\n    graph.loadNodesAndEdges()\n    graph.processWithMapReduce()\n}\n// Implement distributed graph processing"
  },
  {
    "language": "Groovy",
    "code": "def continuousIntegrationPipeline = {\n    def pipeline = new ContinuousIntegrationPipeline()\n    pipeline.runTests()\n    pipeline.buildArtifacts()\n    pipeline.deployToProduction()\n}\n// Create a continuous integration pipeline"
  },
  {
    "language": "Groovy",
    "code": "def evolutionaryStrategy = {\n    def strategy = new EvolutionaryStrategy()\n    strategy.initializePopulation()\n    strategy.evolvePopulation()\n    return strategy.getFittestIndividual()\n}\n// Implement an evolutionary strategy"
  },
  {
    "language": "Groovy",
    "code": "def distributedFileSystem = {\n    def fileSystem = new DistributedFileSystem()\n    fileSystem.readFile('file.txt')\n    fileSystem.writeFile('file.txt', 'content')\n}\n// Implement a distributed file system"
  },
  {
    "language": "Groovy",
    "code": "def quantumCryptography = {\n    def cryptography = new QuantumCryptography()\n    cryptography.generateKeys()\n    cryptography.encryptMessage(message)\n}\n// Implement quantum cryptography operations"
  },
  {
    "language": "Groovy",
    "code": "def naturalLanguageProcessing = {\n    def nlpProcessor = new NLPProcessor()\n    nlpProcessor.analyzeText('text')\n    nlpProcessor.generateSummary('text')\n}\n// Implement natural language processing tasks"
  },
  {
    "language": "Groovy",
    "code": "def realTimeDataProcessing = {\n    def streamProcessor = new RealTimeDataProcessor()\n    streamProcessor.consumeStream('stream')\n    streamProcessor.processData()\n}\n// Implement real-time data processing"
  },
  {
    "language": "Groovy",
    "code": "def autonomousRobotics = {\n    def robot = new AutonomousRobot()\n    robot.navigateEnvironment()\n    robot.performTasks()\n}\n// Implement autonomous robotics functionalities"
  },
  {
    "language": "Groovy",
    "code": "def federatedLearning = {\n    def learningSystem = new FederatedLearningSystem()\n    learningSystem.initializeNodes()\n    learningSystem.trainModelWithFederation()\n}\n// Implement federated learning"
  },
  {
    "language": "Groovy",
    "code": "def chaosEngineeringAutomation = {\n    def automation = new ChaosEngineeringAutomation()\n    automation.injectFaultsRandomly()\n    automation.analyzeSystemBehavior()\n}\n// Automate chaos engineering for system testing"
  },
  {
    "language": "Groovy",
    "code": "def quantumErrorCorrection = {\n    def errorCorrection = new QuantumErrorCorrection()\n    errorCorrection.detectAndCorrectErrors()\n}\n// Implement quantum error correction mechanisms"
  },
  {
    "language": "Groovy",
    "code": "def selfDrivingCarSimulation = {\n    def simulation = new SelfDrivingCarSimulation()\n    simulation.generateVirtualEnvironment()\n    simulation.testAutonomousDrivingAlgorithms()\n}\n// Simulate self-driving car operations"
  },
  {
    "language": "Groovy",
    "code": "def distributedGenomicAnalysis = {\n    def genomicAnalyzer = new DistributedGenomicAnalyzer()\n    genomicAnalyzer.loadGenomicData()\n    genomicAnalyzer.analyzeWithParallelProcessing()\n}\n// Perform distributed analysis of genomic data"
  },
  {
    "language": "Groovy",
    "code": "def augmentedRealityRendering = {\n    def renderer = new AugmentedRealityRenderer()\n    renderer.loadARModels()\n    renderer.renderWithReal-timeTracking()\n}\n// Implement augmented reality rendering"
  },
  {
    "language": "Groovy",
    "code": "def quantumTeleportation = {\n    def teleporter = new QuantumTeleporter()\n    teleporter.prepareEntangledParticles()\n    teleporter.transferQuantumState()\n}\n// Simulate quantum teleportation process"
  },
  {
    "language": "Groovy",
    "code": "def autonomousDroneNavigation = {\n    def drone = new AutonomousDrone()\n    drone.planFlightPath()\n    drone.navigatetoDestination()\n}\n// Implement autonomous drone navigation"
  },
  {
    "language": "Groovy",
    "code": "def medicalImageProcessing = {\n    def imageProcessor = new MedicalImageProcessor()\n    imageProcessor.loadImages()\n    imageProcessor.applyImageAnalysis()\n}\n// Perform processing on medical images"
  },
  {
    "language": "Groovy",
    "code": "def distributedEnergyGrid = {\n    def energyGrid = new DistributedEnergyGrid()\n    energyGrid.monitorAndBalance()\n    energyGrid.optimizeDistribution()\n}\n// Manage and optimize distributed energy grids"
  },
  {
    "language": "Groovy",
    "code": "def chaosEngineering = {\n    def chaosEngine = new ChaosEngine()\n    chaosEngine.injectFaults(system)\n    chaosEngine.monitorAndReport()\n}\n// Implement chaos engineering for system resilience testing"
  },
  {
    "language": "Groovy",
    "code": "def regexExample() { def text = 'There are 123 apples' def pattern = /\\d+/ def matches = (text =~ pattern) matches.each { println \"Match: ${it}\" } } regexExample()"
  },
  {
    "language": "Groovy",
    "code": "def name = 'Alice'\nprintln 'Hello, $name!'"
  },
  {
    "language": "Groovy",
    "code": "int number = 7\nif (number % 2 == 0) {\n    println 'Even'\n} else {\n    println 'Odd'\n}"
  },
  {
    "language": "Groovy",
    "code": "int n = 5\nfor (int i = 1; i <= n; i++) {\n    println '*' * i\n}"
  },
  {
    "language": "Groovy",
    "code": "List<int> numbers = [1, 2, 3, 4, 5]\nList<int> squares = numbers.collect { it * it }\nprintln 'Squared values: $squares'"
  },
  {
    "language": "Groovy",
    "code": "String str = 'Groovy'\nString reversed = str.reverse()\nprintln 'Reversed string: $reversed'"
  },
  {
    "language": "Groovy",
    "code": "def radius = 7.0\ndef area = 3.14 * radius * radius\nprintln 'Area of the circle: $area'"
  },
  {
    "language": "Groovy",
    "code": "int num = 5\nwhile (num > 0) {\n    println 'Value: $num'\n    num--\n}"
  },
  {
    "language": "Groovy",
    "code": "String text = 'Groovy is awesome'\nList<String> parts = text.tokenize()\nparts.each { part ->\n    println 'Part: $part'\n}"
  },
  {
    "language": "Groovy",
    "code": "int a = 10, b = 20\nint max = (a > b) ? a : b\nprintln 'Maximum: $max'"
  },
  {
    "language": "Groovy",
    "code": "double tempCelsius = 30.0\ndouble tempFahrenheit = (tempCelsius * 9/5) + 32\nprintln '$tempCelsius\u00b0C = $tempFahrenheit\u00b0F'"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixMultiplication\n    INTEGER :: A(3,3), B(3,3), C(3,3)\n    INTEGER :: i, j, k, sum\n    A = RESHAPE([2, 3, 4, 5, 6, 7, 8, 9, 1], [3, 3])\n    B = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    DO i = 1, 3\n        DO j = 1, 3\n            sum = 0\n            DO k = 1, 3\n                sum = sum + A(i, k) * B(k, j)\n            END DO\n            C(i, j) = sum\n        END DO\n    END DO\n    PRINT *, 'Resultant Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, C(i, j)\n        END DO\n    END DO\nEND PROGRAM MatrixMultiplication"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SortingArray\n    INTEGER :: numbers(5) = [3, 7, 1, 5, 4]\n    INTEGER :: i, j, temp\n    DO i = 1, SIZE(numbers) - 1\n        DO j = 1, SIZE(numbers) - i\n            IF (numbers(j) > numbers(j+1)) THEN\n                temp = numbers(j)\n                numbers(j) = numbers(j+1)\n                numbers(j+1) = temp\n            END IF\n        END DO\n    END DO\n    PRINT *, 'Sorted Array:'\n    DO i = 1, SIZE(numbers)\n        PRINT *, numbers(i)\n    END DO\nEND PROGRAM SortingArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMaximum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, max\n    max = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) > max) THEN\n            max = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Maximum value: ', max\nEND PROGRAM FindingMaximum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FindingMinimum\n    INTEGER :: numbers(5) = [15, 7, 21, 9, 13]\n    INTEGER :: i, min\n    min = numbers(1)\n    DO i = 2, SIZE(numbers)\n        IF (numbers(i) < min) THEN\n            min = numbers(i)\n        END IF\n    END DO\n    PRINT *, 'Minimum value: ', min\nEND PROGRAM FindingMinimum"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FibonacciRecursion\n    INTEGER :: n = 10\n    PRINT *, 'Fibonacci Series:'\n    DO i = 1, n\n        PRINT *, fibonacci(i)\n    END DO\nCONTAINS\n    INTEGER FUNCTION fibonacci(num)\n        INTEGER, INTENT(IN) :: num\n        IF (num <= 1) THEN\n            fibonacci = num\n        ELSE\n            fibonacci = fibonacci(num-1) + fibonacci(num-2)\n        END IF\n    END FUNCTION fibonacci\nEND PROGRAM FibonacciRecursion"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM TriangularArea\n    REAL :: base = 5.0, height = 8.0, area\n    area = 0.5 * base * height\n    PRINT *, 'Area of the triangle: ', area\nEND PROGRAM TriangularArea"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM CircleCircumference\n    REAL :: radius = 7.0, circumference\n    circumference = 2.0 * 3.14 * radius\n    PRINT *, 'Circumference of the circle: ', circumference\nEND PROGRAM CircleCircumference"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM MatrixTranspose\n    INTEGER :: A(3,3), i, j\n    A = RESHAPE([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n    PRINT *, 'Original Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(i, j)\n        END DO\n    END DO\n    PRINT *, 'Transposed Matrix:'\n    DO i = 1, 3\n        DO j = 1, 3\n            PRINT *, A(j, i)\n        END DO\n    END DO\nEND PROGRAM MatrixTranspose"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM PalindromeCheck\n    CHARACTER(LEN=50) :: str = 'racecar', reversed\n    INTEGER :: len, i, flag = 0\n    len = LEN_TRIM(str)\n    reversed = ''\n    DO i = len, 1, -1\n        reversed = TRIM(reversed) // str(i:i)\n    END DO\n    IF (TRIM(str) == reversed) THEN\n        PRINT *, 'It is a palindrome'\n    ELSE\n        PRINT *, 'It is not a palindrome'\n    END IF\nEND PROGRAM PalindromeCheck"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM VectorAddition\n    INTEGER :: A(3), B(3), C(3), i\n    A = [1, 2, 3]\n    B = [4, 5, 6]\n    DO i = 1, SIZE(A)\n        C(i) = A(i) + B(i)\n    END DO\n    PRINT *, 'Resultant Vector:'\n    DO i = 1, SIZE(C)\n        PRINT *, C(i)\n    END DO\nEND PROGRAM VectorAddition"
  },
  {
    "language": "Haskell",
    "code": "main :: IO () main = putStrLn \"Hello, World!\""
  },
  {
    "language": "Haskell",
    "code": "module ParallelExecution where\nimport Control.Parallel\n\nparallelExecution :: [IO ()] -> IO ()\nparallelExecution tasks = sequence_ tasks `par` return ()"
  },
  {
    "language": "Haskell",
    "code": "module GeneticAlgorithm where\nimport Control.Monad.Random\nimport Data.List\n\ntype Individual = [Bool]\ncrossover :: Individual -> Individual -> IO Individual\nmutation :: Individual -> IO Individual\nselection :: [Individual] -> IO Individual\ngeneticAlgorithm :: Int -> Int -> Int -> IO Individual"
  },
  {
    "language": "Haskell",
    "code": "module QuantumComputing where\nimport Quantum\n\nsimulateQuantumCircuit :: QuantumCircuit -> IO QuantumState\nrunQuantumAlgorithm :: QuantumAlgorithm -> IO QuantumResult"
  },
  {
    "language": "Haskell",
    "code": "module NaturalLanguageProcessing where\nimport Text.Parsec\n\nparseText :: String -> Either ParseError AST\nanalyzeText :: AST -> AnalysisResult"
  },
  {
    "language": "Haskell",
    "code": "module DistributedSystems where\nimport Network.Socket\n\ncreateSocket :: IO Socket\nsendData :: Socket -> String -> IO ()\nreceiveData :: Socket -> IO String"
  },
  {
    "language": "Haskell",
    "code": "module Concurrency where\nimport Control.Concurrent\n\nconcurrentExecution :: [IO ()] -> IO ()\nconcurrentExecution tasks = mapM_ (forkIO . void) tasks"
  },
  {
    "language": "Haskell",
    "code": "module NeuralNetwork where\nimport Numeric.LinearAlgebra\n\ncreateNeuralNetwork :: Int -> Int -> Int -> IO NeuralNetwork\ntrainNeuralNetwork :: NeuralNetwork -> TrainingData -> IO ()\npredictNeuralNetwork :: NeuralNetwork -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module QuantumErrorCorrection where\nimport QuantumError\n\ndetectErrors :: QuantumState -> Error\ncorrectErrors :: QuantumState -> Error -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module ChaosEngineering where\nimport System.Random\n\ninjectFaults :: System -> IO ()\nanalyzeSystemBehavior :: System -> IO SystemBehavior"
  },
  {
    "language": "Haskell",
    "code": "module Blockchain where\nimport Crypto.Hash\n\ncreateTransaction :: Wallet -> Wallet -> Amount -> IO Transaction\nmineBlock :: Blockchain -> IO ()"
  },
  {
    "language": "Haskell",
    "code": "module QuantumCryptography where\nimport Quantum\n\ngenerateKeys :: IO KeyPair\nencryptMessage :: Message -> Key -> IO EncryptedMessage"
  },
  {
    "language": "Haskell",
    "code": "module ReactiveProgramming where\nimport Reactive\n\nsubscribeToStream :: Stream -> (Event -> IO ()) -> IO Subscription\npublishToStream :: Stream -> Event -> IO ()"
  },
  {
    "language": "Haskell",
    "code": "module AutonomousRobotics where\nimport Robotics\n\nnavigateEnvironment :: Environment -> Robot -> IO ()\nperformTasks :: Robot -> [Task] -> IO ()"
  },
  {
    "language": "Haskell",
    "code": "module QuantumTeleportation where\nimport Quantum\n\nprepareEntangledParticles :: IO EntangledParticles\ntransferQuantumState :: EntangledParticles -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module DistributedGenomicAnalysis where\nimport Genomics\n\nloadGenomicData :: FilePath -> IO GenomicData\nanalyzeWithParallelProcessing :: GenomicData -> IO AnalysisResult"
  },
  {
    "language": "Haskell",
    "code": "module DistributedAI where\nimport AI\n\ntrainModel :: Model -> TrainingData -> IO TrainedModel\nloadModel :: FilePath -> IO Model\npredictWithModel :: TrainedModel -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module DistributedComputing where\nimport Network.Socket\n\ncreateSocket :: IO Socket\nsendData :: Socket -> String -> IO ()\nreceiveData :: Socket -> IO String\nperformComputation :: ComputationTask -> IO ComputationResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumAlgorithm where\nimport Quantum\n\nrunAlgorithm :: Algorithm -> IO AlgorithmResult\noptimizeAlgorithm :: Algorithm -> IO OptimizedAlgorithm"
  },
  {
    "language": "Haskell",
    "code": "module MachineLearning where\nimport AI\nimport Data.Matrix\n\ntrainModel :: Model -> TrainingData -> IO TrainedModel\npredictWithModel :: TrainedModel -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module IoTDevices where\nimport Network.Socket\n\ncollectSensorData :: Sensor -> IO SensorData\ntransmitData :: Socket -> SensorData -> IO ()\nreceiveCommand :: Socket -> IO Command"
  },
  {
    "language": "Haskell",
    "code": "module Cryptography where\nimport Crypto\n\nencryptData :: PlainData -> Key -> IO EncryptedData\ndecryptData :: EncryptedData -> Key -> IO PlainData"
  },
  {
    "language": "Haskell",
    "code": "module DataAnalysis where\nimport Statistics\n\nperformAnalysis :: Dataset -> AnalysisType -> IO AnalysisResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumSimulation where\nimport Quantum\n\nsimulateQuantumSystem :: QuantumSystem -> IO SimulatedSystem\nanalyzeSimulatedSystem :: SimulatedSystem -> IO SystemAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module ImageProcessing where\nimport Vision\n\nprocessImage :: Image -> ProcessingOptions -> IO ProcessedData"
  },
  {
    "language": "Haskell",
    "code": "module CompilerDesign where\nimport Compiler\n\ndesignCompiler :: LanguageSpecification -> IO Compiler\ncompileCode :: Compiler -> SourceCode -> IO ExecutableCode"
  },
  {
    "language": "Haskell",
    "code": "module Robotics where\nimport Control.Robotics\n\nperformTask :: Robot -> Task -> IO TaskResult\nsimulateEnvironment :: Environment -> Robot -> IO SimulationResult"
  },
  {
    "language": "Haskell",
    "code": "module FinancialAnalytics where\nimport Finance\n\nanalyzeMarket :: MarketData -> AnalysisType -> IO AnalysisResult\npredictStock :: StockData -> IO StockPrediction"
  },
  {
    "language": "Haskell",
    "code": "module Simulation where\nimport Control.Monad\n\nrunSimulation :: SimulationEnvironment -> Simulation -> IO SimulationResult\noptimizeSimulation :: Simulation -> IO OptimizedSimulation"
  },
  {
    "language": "Haskell",
    "code": "module QuantumErrorCorrection where\nimport Quantum\n\ndetectErrors :: QuantumState -> IO [Error]\ncorrectErrors :: QuantumState -> [Error] -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module CryptographicProtocols where\nimport Crypto\n\nperformHandshake :: Protocol -> IO HandshakeResult\nestablishSecureConnection :: HandshakeResult -> IO SecureConnection"
  },
  {
    "language": "Haskell",
    "code": "module DistributedControlSystems where\nimport ControlSystems\n\ncontrolSystem :: System -> IO ControlSystem\nsimulateControl :: ControlSystem -> Input -> IO Output\noptimizeControlSystem :: ControlSystem -> IO OptimizedControlSystem"
  },
  {
    "language": "Haskell",
    "code": "module QuantumEntanglement where\nimport Quantum\n\nprepareEntangledPair :: IO EntangledPair\ntransferEntangledState :: EntangledPair -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module BigDataAnalytics where\nimport Data.BigData\n\nprocessBigData :: BigDataSet -> IO ProcessedData\nanalyzeTrends :: ProcessedData -> IO TrendsAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module Cryptocurrency where\nimport Blockchain\n\nmineBlock :: Blockchain -> IO Block\nvalidateTransaction :: Transaction -> IO Bool"
  },
  {
    "language": "Haskell",
    "code": "module QuantumRouting where\nimport Quantum\n\nrouteQuantumData :: QuantumData -> IO RoutedData\nmanageQuantumNetwork :: QuantumNetwork -> IO ManagedNetwork"
  },
  {
    "language": "Haskell",
    "code": "module QuantumAnnealing where\nimport Quantum\n\nannealQuantumSystem :: QuantumSystem -> IO AnnealedSystem\noptimizeAnnealing :: AnnealedSystem -> IO OptimizedSystem"
  },
  {
    "language": "Haskell",
    "code": "module CompilerOptimization where\nimport Compiler\n\noptimizeCompiler :: Compiler -> IO OptimizedCompiler\nimproveCode :: OptimizedCompiler -> SourceCode -> IO ImprovedCode"
  },
  {
    "language": "Haskell",
    "code": "module AutonomousAgents where\nimport Agents\n\ncreateAgent :: AgentSpecification -> IO Agent\ntrainAgent :: Agent -> TrainingData -> IO TrainedAgent"
  },
  {
    "language": "Haskell",
    "code": "module QuantumCommunication where\nimport Quantum\n\nsendQuantumMessage :: QuantumMessage -> IO SentMessage\nreceiveQuantumMessage :: IO QuantumMessage"
  },
  {
    "language": "Haskell",
    "code": "module DistributedSearch where\nimport Network.Search\n\nsearchContent :: Query -> IO SearchResults\nindexContent :: Content -> IO Index"
  },
  {
    "language": "Haskell",
    "code": "module GenomeAnalysis where\nimport Genetics\n\nanalyzeGenome :: Genome -> IO AnalysisResult\ncompareGenomes :: Genome -> Genome -> IO GenomeComparison"
  },
  {
    "language": "Haskell",
    "code": "module QuantumOptimization where\nimport Quantum\n\noptimizeQuantumAlgorithm :: QuantumAlgorithm -> IO OptimizedAlgorithm\nimproveQuantumPerformance :: OptimizedAlgorithm -> IO ImprovedPerformance"
  },
  {
    "language": "Haskell",
    "code": "module DistributedRobotics where\nimport Robotics\n\ncoordinateRobots :: [Robot] -> IO CoordinatedRobots\nsimulateRoboticSwarm :: CoordinatedRobots -> IO SwarmSimulation"
  },
  {
    "language": "Haskell",
    "code": "module QuantumDataStorage where\nimport Quantum\n\nstoreQuantumData :: QuantumData -> IO StoredData\nretrieveQuantumData :: IO QuantumData"
  },
  {
    "language": "Haskell",
    "code": "module QuantumMetaProgramming where\nimport Quantum\n\nprogramQuantumComputers :: QuantumProgram -> IO ProgrammedComputers\nverifyQuantumCode :: ProgrammedComputers -> IO VerificationResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumEncryption where\nimport Quantum\n\nencryptData :: PlainData -> Key -> IO EncryptedData\ndecryptData :: EncryptedData -> Key -> IO PlainData"
  },
  {
    "language": "Haskell",
    "code": "module ComputationalBiology where\nimport Biology\n\nsimulateCellularProcesses :: Cell -> IO ProcessSimulation\nanalyzeGeneticSequences :: GeneticSequence -> IO SequenceAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module QuantumRouting where\nimport Quantum\n\nrouteQuantumData :: QuantumData -> IO RoutedData\nmanageQuantumNetwork :: QuantumNetwork -> IO ManagedNetwork"
  },
  {
    "language": "Haskell",
    "code": "module FinancialForecasting where\nimport Finance\n\nforecastMarket :: MarketData -> IO MarketForecast\nanalyzeTrends :: MarketData -> IO TrendsAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module QuantumEntanglement where\nimport Quantum\n\ncreateEntangledPair :: IO EntangledPair\ntransferEntangledState :: EntangledPair -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module QuantumErrorCorrection where\nimport Quantum\n\ndetectErrors :: QuantumState -> IO [Error]\ncorrectErrors :: QuantumState -> [Error] -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module DistributedSystems where\nimport Network.Socket\n\ncreateSocket :: IO Socket\nsendData :: Socket -> String -> IO ()\nreceiveData :: Socket -> IO String"
  },
  {
    "language": "Haskell",
    "code": "module QuantumNetworkSecurity where\nimport Quantum\n\nestablishSecureConnection :: QuantumNetwork -> IO SecureConnection\nmonitorNetwork :: SecureConnection -> IO NetworkMonitoring"
  },
  {
    "language": "Haskell",
    "code": "module CryptographicHashing where\nimport Crypto.Hash\n\nhashData :: PlainData -> IO HashedData\nverifyHash :: HashedData -> PlainData -> IO Bool"
  },
  {
    "language": "Haskell",
    "code": "module NeuralNetworkTraining where\nimport AI\n\ntrainNetwork :: NeuralNetwork -> TrainingData -> IO TrainedNetwork\npredictWithNetwork :: TrainedNetwork -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module QuantumSimulation where\nimport Quantum\n\nsimulateQuantumSystem :: QuantumSystem -> IO SimulatedSystem\nanalyzeSimulatedSystem :: SimulatedSystem -> IO SystemAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module BlockchainContract where\nimport Blockchain\n\ncreateSmartContract :: ContractDetails -> IO SmartContract\nexecuteContract :: SmartContract -> IO ContractExecutionResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumAlgorithmOptimization where\nimport Quantum\n\noptimizeQuantumAlgorithm :: QuantumAlgorithm -> IO OptimizedAlgorithm\nimproveQuantumPerformance :: OptimizedAlgorithm -> IO ImprovedPerformance"
  },
  {
    "language": "Haskell",
    "code": "module ComputationalPhysics where\nimport Physics\n\nsimulatePhysicalPhenomena :: Phenomena -> IO SimulationResults\nanalyzeSimulationData :: SimulationResults -> IO AnalysisReport"
  },
  {
    "language": "Haskell",
    "code": "module RoboticsNavigation where\nimport Robotics\n\nplanRobotNavigation :: RobotMap -> IO NavigationPlan\nexecuteNavigation :: NavigationPlan -> IO NavigationResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumCommunication where\nimport Quantum\n\nsendQuantumMessage :: QuantumMessage -> IO SentMessage\nreceiveQuantumMessage :: IO QuantumMessage"
  },
  {
    "language": "Haskell",
    "code": "module QuantumCryptographicProtocols where\nimport Quantum\n\nperformHandshake :: Protocol -> IO HandshakeResult\nestablishSecureConnection :: HandshakeResult -> IO SecureConnection"
  },
  {
    "language": "Haskell",
    "code": "module DistributedComputingModels where\nimport Computing\n\ncreateDistributedModel :: ModelDetails -> IO DistributedModel\nperformDistributedComputing :: DistributedModel -> IO ComputingResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumTeleportation where\nimport Quantum\n\nprepareEntangledParticles :: IO EntangledParticles\ntransferQuantumState :: EntangledParticles -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module QuantumMetaProgramming where\nimport Quantum\n\nprogramQuantumComputers :: QuantumProgram -> IO ProgrammedComputers\nverifyQuantumCode :: ProgrammedComputers -> IO VerificationResult"
  },
  {
    "language": "Haskell",
    "code": "variables :: IO () variables = do let number = 42 piValue = 3.14 message = \"Hello\" isTrue = True putStrLn \"Variables defined\""
  },
  {
    "language": "Haskell",
    "code": "conditionalStatements :: Bool -> IO () conditionalStatements isTrue = if isTrue then putStrLn \"It is true!\" else putStrLn \"It is false!\""
  },
  {
    "language": "Haskell",
    "code": "loops :: IO () loops = mapM_ (\\i -> putStrLn $ \"Count: \" ++ show i) [0..4]"
  },
  {
    "language": "Haskell",
    "code": "whileLoop :: Int -> IO () whileLoop count = if count < 5 then do putStrLn $ \"Count: \" ++ show count whileLoop (count + 1) else return ()"
  },
  {
    "language": "Haskell",
    "code": "greet :: String -> IO () greet name = putStrLn $ \"Hello, \" ++ name ++ \"!\" greet \"Alice\""
  },
  {
    "language": "Haskell",
    "code": "list :: IO () list = let fruits = [\"Apple\", \"Orange\", \"Banana\"] in print fruits"
  },
  {
    "language": "Haskell",
    "code": "map :: IO () map = let ages = [(\"Alice\", 25), (\"Bob\", 30), (\"Charlie\", 28)] in print ages"
  },
  {
    "language": "Haskell",
    "code": "data Person = Person { name :: String, age :: Int } main :: IO () main = let person = Person { name = \"Alice\", age = 25 } in do putStrLn $ \"Name: \" ++ name person putStrLn $ \"Age: \" ++ show (age person)"
  },
  {
    "language": "Haskell",
    "code": "fetchData :: IO () fetchData = do putStrLn \"Fetching data...\" putStrLn \"Data fetched!\""
  },
  {
    "language": "Haskell",
    "code": "set :: IO () set = let numbers = [1, 2, 3, 4, 5] in print (Data.List.nub numbers)"
  },
  {
    "language": "Haskell",
    "code": "```data Status = Pending"
  },
  {
    "language": "Haskell",
    "code": "import System.Random main :: IO () main = do gen <- newStdGen let (randomNum, _) = randomR (1, 100) gen putStrLn $ \"Random number: \" ++ show randomNum"
  },
  {
    "language": "Haskell",
    "code": "userInput :: IO () userInput = do putStrLn \"Enter your name: \" name <- getLine putStrLn $ \"Hello, \" ++ name ++ \"!\""
  },
  {
    "language": "Haskell",
    "code": "optionalArguments :: Maybe String -> IO () optionalArguments name = case name of Just n -> putStrLn $ \"Hello, \" ++ n Nothing -> putStrLn \"Hello, World!\" optionalArguments (Just \"Alice\") optionalArguments Nothing"
  },
  {
    "language": "Haskell",
    "code": "data Bird = Bird fly :: Bird -> IO () fly _ = putStrLn \"Flying!\" main :: IO () main = fly Bird"
  },
  {
    "language": "Haskell",
    "code": "import Data.Char (toUpper) shout :: String -> IO () shout msg = putStrLn $ map toUpper msg ++ \"!!!\" main :: IO () main = shout \"hello\""
  },
  {
    "language": "Haskell",
    "code": "delayedPrint :: IO () delayedPrint = do putStrLn \"Printed immediately\" threadDelay 2000000 putStrLn \"Delayed print after 2 seconds\""
  },
  {
    "language": "Haskell",
    "code": "import Text.Regex.PCRE regexExample :: IO () regexExample = do let text = \"There are 123 apples\" let matches = getAllTextMatches $ text =~ \"\\\\d+\" :: [String] mapM_ putStrLn matches"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = putStrLn \"Hello, World!\""
  },
  {
    "language": "Haskell",
    "code": "add :: Int -> Int -> Int\nadd a b = a + b\nmain :: IO ()\nmain = print (add 3 5)"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (putStrLn . show) [0..4]"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (\\name -> putStrLn $ \"Hello, \" ++ name ++ \"!\") [\"Alice\", \"Bob\", \"Charlie\"]"
  },
  {
    "language": "Haskell",
    "code": "concatenate :: String -> String -> String\nconcatenate a b = a ++ \", \" ++ b ++ \"!\"\nmain :: IO ()\nmain = putStrLn $ concatenate \"Hello\" \"Alice\""
  },
  {
    "language": "Haskell",
    "code": "calculateArea :: Double -> Double\ncalculateArea radius = 3.14 * radius * radius\nmain :: IO ()\nmain = print $ calculateArea 7.0"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = if 10 > 5 then putStrLn \"Number is greater than 5\" else putStrLn \"Number is less than or equal to 5\""
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (\\x -> putStrLn $ \"Value: \" ++ show x) [0..4]"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = mapM_ (\\num -> putStrLn $ \"Number: \" ++ show num) [1, 2, 3, 4, 5]"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = putStrLn \"This is a Haskell program\""
  },
  {
    "language": "Haskell",
    "code": "greet :: String -> String\ngreet name = \"Hello, \" ++ name ++ \"!\"\nmain :: IO ()\nmain = putStrLn (greet \"Alice\")"
  },
  {
    "language": "Haskell",
    "code": "isEven :: Int -> Bool\nisEven n = n `mod` 2 == 0\nmain :: IO ()\nmain = print (isEven 7)"
  },
  {
    "language": "Haskell",
    "code": "printStars :: Int -> IO ()\nprintStars n = mapM_ putStrLn (replicate n \"*\")\nmain :: IO ()\nmain = printStars 5"
  },
  {
    "language": "Haskell",
    "code": "squares :: [Int]\nsquares = map (^2) [1..5]\nmain :: IO ()\nmain = print squares"
  },
  {
    "language": "Haskell",
    "code": "reverseString :: String -> String\nreverseString str = reverse str\nmain :: IO ()\nmain = putStrLn (reverseString \"Haskell\")"
  },
  {
    "language": "Haskell",
    "code": "calculateArea :: Double -> Double\ncalculateArea radius = 3.14 * radius * radius\nmain :: IO ()\nmain = print (calculateArea 5.0)"
  },
  {
    "language": "Haskell",
    "code": "checkNumber :: Int -> IO ()\ncheckNumber num = if num > 5 then putStrLn \"Number is greater than 5\" else putStrLn \"Number is less than or equal to 5\"\nmain :: IO ()\nmain = checkNumber 10"
  },
  {
    "language": "Haskell",
    "code": "printValues :: IO ()\nprintValues = mapM_ (\\x -> putStrLn $ \"Value: \" ++ show x) [1..5]\nmain :: IO ()\nmain = printValues"
  },
  {
    "language": "Haskell",
    "code": "printNumbers :: IO ()\nprintNumbers = mapM_ (\\n -> putStrLn $ \"Number: \" ++ show n) [6, 7, 8, 9, 10]\nmain :: IO ()\nmain = printNumbers"
  },
  {
    "language": "Haskell",
    "code": "printText :: IO ()\nprintText = putStrLn \"This is another Haskell program\"\nmain :: IO ()\nmain = printText"
  },
  {
    "language": "Lisp",
    "code": "(defun hello-world () (format t \"Hello, World!\")) (hello-world)"
  },
  {
    "language": "Lisp",
    "code": "(defun variables () (let ((number 42) (piValue 3.14) (message \"Hello\") (isTrue t)) (format t \"Variables defined\"))) (variables)"
  },
  {
    "language": "Lisp",
    "code": "(defun parallel-processing (tasks)\n  (mapc #'sb-thread:make-thread tasks))"
  },
  {
    "language": "Lisp",
    "code": "(defun genetic-algorithm (population)\n  (loop\n    repeat generations\n    do (let* ((selected (selection population))\n             (offspring (crossover selected))\n             (mutated (mutation offspring)))\n         (setf population (replace-subseq population mutated\n                              :start1 (position (min-by fitness population) population)\n                              :end1 (position (max-by fitness population) population)))))\n  (min-by fitness population))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-computing (circuit)\n  (let ((state (initialize-quantum-state circuit)))\n    (loop for gate in circuit do\n      (apply-gate state gate))\n    state))"
  },
  {
    "language": "Lisp",
    "code": "(defun natural-language-processing (text)\n  (let ((parsed (parse-text text)))\n    (analyze-parsed-text parsed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-systems (tasks)\n  (loop for task in tasks do\n    (sb-thread:make-thread (lambda () (perform-task task)))))"
  },
  {
    "language": "Lisp",
    "code": "(defun concurrency (tasks)\n  (mapc #'sb-thread:make-thread tasks))"
  },
  {
    "language": "Lisp",
    "code": "(defun neural-network (input)\n  (let ((network (create-neural-network)))\n    (train-neural-network network input)\n    (predict-neural-network network input)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-error-correction (state)\n  (let ((errors (detect-errors state)))\n    (correct-errors state errors)))"
  },
  {
    "language": "Lisp",
    "code": "(defun chaos-engineering (system)\n  (inject-faults system)\n  (analyze-system-behavior system))"
  },
  {
    "language": "Lisp",
    "code": "(defun blockchain (transaction)\n  (create-transaction transaction)\n  (mine-block))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-cryptography (message)\n  (let ((keys (generate-keys)))\n    (encrypt-message message keys)))"
  },
  {
    "language": "Lisp",
    "code": "(defun reactive-programming (stream)\n  (subscribe-to-stream stream)\n  (publish-to-stream stream))"
  },
  {
    "language": "Lisp",
    "code": "(defun autonomous-robotics (tasks)\n  (loop for task in tasks do\n    (plan-task task)\n    (execute-task task)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-teleportation (state)\n  (let ((particles (prepare-entangled-particles)))\n    (transfer-quantum-state state particles)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-genomic-analysis (data)\n  (let ((analysis (analyze-genomic-data data)))\n    (process-analysis-in-parallel analysis)))"
  },
  {
    "language": "Lisp",
    "code": "(defun federated-learning (model)\n  (let ((nodes (initialize-nodes)))\n    (train-model-with-federation model nodes)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-entanglement (particles)\n  (let ((state (create-entangled-state particles)))\n    (transfer-state state)))"
  },
  {
    "language": "Lisp",
    "code": "(defun big-data-analytics (data)\n  (let ((processed (process-big-data data)))\n    (analyze-trends processed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-routing (data)\n  (let ((routed (route-quantum-data data)))\n    (manage-quantum-network routed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-annealing (system)\n  (let ((annealed (anneal-quantum-system system)))\n    (optimize-annealing annealed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun compiler-optimization (compiler)\n  (let ((optimized (optimize-compiler compiler)))\n    (improve-code optimized)))"
  },
  {
    "language": "Lisp",
    "code": "(defun autonomous-agents (agents)\n  (loop for agent in agents do\n    (create-agent agent)\n    (train-agent agent)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-communication (message)\n  (let ((sent (send-quantum-message message)))\n    (receive-quantum-message)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-search (query)\n  (let ((results (search-content query)))\n    (index-content results)))"
  },
  {
    "language": "Lisp",
    "code": "(defun genome-analysis (genome)\n  (let ((analysis (analyze-genome genome)))\n    (compare-genomes analysis)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-encryption (data)\n  (let ((encrypted (encrypt-data data)))\n    (decrypt-data encrypted)))"
  },
  {
    "language": "Lisp",
    "code": "(defun computational-biology (cell)\n  (let ((simulation (simulate-cellular-processes cell)))\n    (analyze-genetic-sequences simulation)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-routing (data)\n  (let ((routed (route-quantum-data data)))\n    (manage-quantum-network routed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun financial-forecasting (market-data)\n  (let ((forecast (forecast-market market-data)))\n    (analyze-trends forecast)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-entanglement (particles)\n  (let ((state (create-entangled-state particles)))\n    (transfer-state state)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-error-correction (state)\n  (let ((errors (detect-errors state)))\n    (correct-errors state errors)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-systems (tasks)\n  (loop for task in tasks do\n    (perform-distributed-task task)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-network-security (network)\n  (let ((connection (establish-secure-connection network)))\n    (monitor-secure-connection connection)))"
  },
  {
    "language": "Lisp",
    "code": "(defun cryptographic-hashing (data)\n  (let ((hashed (hash-data data)))\n    (verify-hash hashed data)))"
  },
  {
    "language": "Lisp",
    "code": "(defun neural-network-training (network)\n  (let ((trained (train-network network)))\n    (predict-with-network trained)))"
  },
  {
    "language": "Lisp",
    "code": "(defun conditional-statements (isTrue) (if isTrue (format t \"It is true!\") (format t \"It is false!\"))) (conditional-statements t)"
  },
  {
    "language": "Lisp",
    "code": "(defun loops () (dotimes (i 5) (format t \"Count: ~A~%\" i))) (loops)"
  },
  {
    "language": "Lisp",
    "code": "(defun while-loop (count) (if (< count 5) (progn (format t \"Count: ~A~%\" count) (while-loop (+ count 1))))) (while-loop 0)"
  },
  {
    "language": "Lisp",
    "code": "(defun greet (name) (format t \"Hello, ~A!~%\" name)) (greet \"Alice\")"
  },
  {
    "language": "Lisp",
    "code": "(defun list-example () (let ((fruits '(\"Apple\" \"Orange\" \"Banana\"))) (print fruits))) (list-example)"
  },
  {
    "language": "Lisp",
    "code": "(defun map-example () (let ((ages '((Alice . 25) (Bob . 30) (Charlie . 28)))) (print ages))) (map-example)"
  },
  {
    "language": "Lisp",
    "code": "(defstruct person name age) (let ((person (make-person :name \"Alice\" :age 25))) (format t \"Name: ~A~%\" (person-name person)) (format t \"Age: ~A~%\" (person-age person)))"
  },
  {
    "language": "Lisp",
    "code": "(defun fetch-data () (format t \"Fetching data...~%\") (format t \"Data fetched!\")) (fetch-data)"
  },
  {
    "language": "Lisp",
    "code": "(defun set-example () (let ((numbers (list 1 2 3 4 5))) (print (remove-duplicates numbers)))) (set-example)"
  },
  {
    "language": "Lisp",
    "code": "(defparameter *status* '(pending approved rejected)) (let ((application-status (nth 1 *status*))) (format t \"Application Status: ~A~%\" application-status))"
  },
  {
    "language": "Lisp",
    "code": "(ql:quickload :cl-random) (let ((random-number (random:random 100))) (format t \"Random number: ~A~%\" random-number))"
  },
  {
    "language": "Lisp",
    "code": "(defun user-input () (format t \"Enter your name: \") (let ((name (read-line))) (format t \"Hello, ~A!~%\" name))) (user-input)"
  },
  {
    "language": "Lisp",
    "code": "(defun optional-arguments (&optional (name \"Anonymous\")) (format t \"Hello, ~A!~%\" name)) (optional-arguments \"Alice\") (optional-arguments)"
  },
  {
    "language": "Lisp",
    "code": "(defclass bird () ()) (defmethod fly ((bird bird)) (format t \"Flying!\")) (let ((sparrow (make-instance 'bird))) (fly sparrow))"
  },
  {
    "language": "Lisp",
    "code": "(defun shout (msg) (format t \"~A!!!~%\" (string-upcase msg))) (shout \"hello\")"
  },
  {
    "language": "Lisp",
    "code": "(defun delayed-print () (format t \"Printed immediately~%\") (sleep 2) (format t \"Delayed print after 2 seconds~%\")) (delayed-print)"
  },
  {
    "language": "Lisp",
    "code": "(ql:quickload :cl-ppcre) (let ((text \"There are 123 apples\") (matches (ppcre:all-matches-as-strings \"\\\\d+\" \"There are 123 apples\"))) (mapc #'(lambda (match) (format t \"Match: ~A~%\" match)) matches))"
  },
  {
    "language": "Lisp",
    "code": "(defun hello-world ()\n  (format t \"Hello, World!\"))\n(hello-world)"
  },
  {
    "language": "Lisp",
    "code": "(defun add (a b)\n  (+ a b))\n(print (add 3 5))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (i 5)\n  (format t \"Value: ~A~%\" i))"
  },
  {
    "language": "Lisp",
    "code": "(defparameter *names* '(\"Alice\" \"Bob\" \"Charlie\"))\n(mapc #'(lambda (name)\n          (format t \"Hello, ~A!~%\" name))\n      *names*)"
  },
  {
    "language": "Lisp",
    "code": "(defun concatenate (a b)\n  (format nil \"~A, ~A!\" a b))\n(println (concatenate \"Hello\" \"Alice\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun calculate-area (radius)\n  (* 3.14 (* radius radius)))\n(print (calculate-area 7.0))"
  },
  {
    "language": "Lisp",
    "code": "(if (> 10 5)\n    (format t \"Number is greater than 5~%\")\n    (format t \"Number is less than or equal to 5~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (x 5)\n  (format t \"Value: ~A~%\" x))"
  },
  {
    "language": "Lisp",
    "code": "(mapcar #'(lambda (num)\n            (format t \"Number: ~A~%\" num))\n        '(1 2 3 4 5))"
  },
  {
    "language": "Lisp",
    "code": "(format t \"This is a Lisp program~%\")"
  },
  {
    "language": "Lisp",
    "code": "(defun greet (name)\n  (format t \"Hello, ~A!\" name))\n(greet \"Alice\")"
  },
  {
    "language": "Lisp",
    "code": "(defun is-even (n)\n  (= (mod n 2) 0))\n(print (is-even 7))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (i 5)\n  (dotimes (j (1+ i))\n    (format t \"*\")\n  )\n  (format t \"~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun squares ()\n  (mapcar #'(lambda (x) (* x x)) '(1 2 3 4 5)))\n(print (squares))"
  },
  {
    "language": "Lisp",
    "code": "(defun reverse-string (str)\n  (reverse str))\n(println (reverse-string \"Lisp\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun calculate-area (radius)\n  (* 3.14 (* radius radius)))\n(print (calculate-area 5.0))"
  },
  {
    "language": "Lisp",
    "code": "(if (> 10 5)\n    (format t \"Number is greater than 5~%\")\n    (format t \"Number is less than or equal to 5~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (num 5)\n  (format t \"Value: ~A~%\" num))"
  },
  {
    "language": "Lisp",
    "code": "(mapcar #'(lambda (n)\n            (format t \"Number: ~A~%\" n))\n        '(6 7 8 9 10))"
  },
  {
    "language": "Lisp",
    "code": "(format t \"This is another Lisp program~%\")"
  },
  {
    "language": "Lisp",
    "code": "(defun factorial (n)\n  (if (= n 0) 1\n    (* n (factorial (- n 1)))))\n(println (factorial 5))"
  },
  {
    "language": "Lisp",
    "code": "(defun fibonacci (n)\n  (cond\n    ((= n 0) 0)\n    ((= n 1) 1)\n    (t (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))\n(println (fibonacci 8))"
  },
  {
    "language": "Lisp",
    "code": "(defun is-prime (n)\n  (if (<= n 1) nil\n    (loop for i from 2 to (isqrt n) when (zerop (mod n i)) return nil)\n    t))\n(println (is-prime 17))"
  },
  {
    "language": "Lisp",
    "code": "(defun reverse-list (lst)\n  (if (null lst) '()\n    (append (reverse-list (cdr lst)) (list (car lst)))))\n(println (reverse-list '(1 2 3 4 5)))"
  },
  {
    "language": "Lisp",
    "code": "(defun count-occurrences (item lst)\n  (count item lst))\n(println (count-occurrences 'a '(a b a c a d)))"
  },
  {
    "language": "Lisp",
    "code": "(defun remove-duplicates (lst)\n  (remove-duplicates lst :test #'equal))\n(println (remove-duplicates '(1 2 2 3 4 4 4)))"
  },
  {
    "language": "Lisp",
    "code": "(defun first-n-elements (n lst)\n  (if (<= n 0) '()\n    (cons (car lst) (first-n-elements (- n 1) (cdr lst)))))\n(println (first-n-elements 3 '(1 2 3 4 5 6)))"
  },
  {
    "language": "Lisp",
    "code": "(defun last-element (lst)\n  (if (null (cdr lst)) (car lst)\n    (last-element (cdr lst))))\n(println (last-element '(1 2 3 4 5)))"
  },
  {
    "language": "Lisp",
    "code": "(defun list-range (start end)\n  (loop for i from start to end collect i))\n(println (list-range 1 10))"
  },
  {
    "language": "Lisp",
    "code": "(defun flatten (lst)\n  (cond\n    ((null lst) '())\n    ((atom lst) (list lst))\n    (t (append (flatten (car lst)) (flatten (cdr lst))))))\n(println (flatten '(1 (2 (3 4) 5) 6)))"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Hello, World!</title> </head> <body> <h1>Hello, World!</h1> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>My Page</title> </head> <body> <h2>Welcome!</h2> <p>This is my first webpage.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Lists</title> </head> <body> <h2>Shopping List</h2> <ul> <li>Apples</li> <li>Oranges</li> <li>Bananas</li> </ul> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Links</title> </head> <body> <h2>Useful Links</h2> <a href=\"https://www.example.com\">Example</a> <a href=\"https://www.google.com\">Google</a> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Forms</title> </head> <body> <h2>Login Form</h2> <form> <label for=\"username\">Username:</label> <input type=\"text\" id=\"username\" name=\"username\"><br><br> <label for=\"password\">Password:</label> <input type=\"password\" id=\"password\" name=\"password\"><br><br> <input type=\"submit\" value=\"Submit\"> </form> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Images</title> </head> <body> <h2>Cute Animals</h2> <img src=\"cat.jpg\" alt=\"Cat\"> <img src=\"dog.jpg\" alt=\"Dog\"> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Tables</title> </head> <body> <h2>Employee Details</h2> <table border=\"1\"> <tr> <th>Name</th> <th>Age</th> </tr> <tr> <td>Alice</td> <td>25</td> </tr> <tr> <td>Bob</td> <td>30</td> </tr> </table> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Audio</title> </head> <body> <h2>Listen to Music</h2> <audio controls> <source src=\"song.mp3\" type=\"audio/mpeg\"> Your browser does not support the audio element. </audio> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Video</title> </head> <body> <h2>Watch a Video</h2> <video width=\"320\" height=\"240\" controls> <source src=\"video.mp4\" type=\"video/mp4\"> Your browser does not support the video tag. </video> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Styling</title> <style> h1 { color: blue; } p { font-size: 16px; } </style> </head> <body> <h1>Welcome!</h1> <p>This is a styled paragraph.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>JavaScript</title> <script> function showMessage() { alert('Hello, World!'); } </script> </head> <body> <h2>Click the button</h2> <button onclick=\"showMessage()\">Show Message</button> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Canvas</title> <script> function draw() { var canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d'); ctx.fillStyle = 'green'; ctx.fillRect(10, 10, 150, 100); } </script> </head> <body> <h2>Draw a Rectangle</h2> <canvas id=\"myCanvas\" width=\"200\" height=\"200\" style=\"border:1px solid black;\"></canvas> <br> <button onclick=\"draw()\">Draw</button> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Comments</title> </head> <body> <!-- This is a comment --> <h1>Welcome!</h1> <p>This is an example of using comments in HTML.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Dropdown Menu</title> <style> .dropdown { position: relative; display: inline-block; } .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 120px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); } .dropdown:hover .dropdown-content { display: block; } </style> </head> <body> <h2>Hoverable Dropdown</h2> <div class=\"dropdown\"> <span>Hover me</span> <div class=\"dropdown-content\"> <p>Dropdown item 1</p> <p>Dropdown item 2</p> <p>Dropdown item 3</p> </div> </div> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Form Validation</title> <style> .error { color: red; } </style> </head> <body> <h2>Registration Form</h2> <form onsubmit=\"return validateForm()\"> <label for=\"username\">Username:</label> <input type=\"text\" id=\"username\" name=\"username\"><br> <span id=\"username-error\" class=\"error\"></span><br> <label for=\"password\">Password:</label> <input type=\"password\" id=\"password\" name=\"password\"><br> <span id=\"password-error\" class=\"error\"></span><br> <input type=\"submit\" value=\"Submit\"> </form> <script> function validateForm() { var username = document.getElementById('username').value; var password = document.getElementById('password').value; if (username === "
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Meta Tags</title> <meta charset=\"UTF-8\"> <meta name=\"description\" content=\"Example meta tags for a webpage\"> <meta name=\"keywords\" content=\"HTML, Meta Tags, Webpage\"> <meta name=\"author\" content=\"Your Name\"> </head> <body> <h1>Webpage with Meta Tags</h1> <p>This webpage uses meta tags for SEO.</p> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Audio Playlist</title> </head> <body> <h2>My Music Playlist</h2> <audio controls> <source src=\"song1.mp3\" type=\"audio/mpeg\"> <source src=\"song2.ogg\" type=\"audio/ogg\"> Your browser does not support the audio element. </audio> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Video Playlist</title> </head> <body> <h2>My Video Playlist</h2> <video width=\"320\" height=\"240\" controls> <source src=\"video1.mp4\" type=\"video/mp4\"> <source src=\"video2.webm\" type=\"video/webm\"> Your browser does not support the video tag. </video> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>SVG</title> </head> <body> <h2>Circle</h2> <svg height=\"100\" width=\"100\"> <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" /> </svg> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Canvas Animation</title> <style> canvas { border: 1px solid black; } </style> </head> <body> <h2>Canvas Animation</h2> <canvas id=\"myCanvas\" width=\"200\" height=\"100\"></canvas> <script> var canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d'); var x = 0; function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'blue'; ctx.fillRect(x, 0, 50, 50); x += 1; if (x >= canvas.width) { x = 0; } requestAnimationFrame(draw); } draw(); </script> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Geolocation</title> </head> <body> <h2>Location Finder</h2> <p id=\"demo\"></p> <script> function getLocation() { if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition); } else { document.getElementById('demo').innerHTML = 'Geolocation is not supported by this browser.'; } } function showPosition(position) { document.getElementById('demo').innerHTML = 'Latitude: ' + position.coords.latitude + '<br>Longitude: ' + position.coords.longitude; } </script> <button onclick=\"getLocation()\">Get Location</button> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Drag and Drop</title> <style> #div1, #div2 { width: 100px; height: 50px; padding: 10px; border: 1px solid black; margin: 10px 0; } </style> <script> function allowDrop(event) { event.preventDefault(); } function drag(event) { event.dataTransfer.setData('text', event.target.id); } function drop(event) { event.preventDefault(); var data = event.dataTransfer.getData('text'); event.target.appendChild(document.getElementById(data)); } </script> </head> <body> <h2>Drag and Drop</h2> <div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div> <div id=\"div2\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div> <img id=\"drag1\" src=\"img.jpg\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"88\" height=\"31\"> <img id=\"drag2\" src=\"img.jpg\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"88\" height=\"31\"> </body> </html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html> <html> <head> <title>Local Storage</title> <script> function saveData() { var data = document.getElementById('data').value; localStorage.setItem('userInput', data); } function loadData() { var data = localStorage.getItem('userInput'); document.getElementById('display').innerHTML = 'Data from Local Storage: ' + data; } </script> </head> <body> <h2>Local Storage Example</h2> <input type=\"text\" id="
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello, World!</title>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Simple Form</title>\n</head>\n<body>\n    <form>\n        <label for=\"name\">Name:</label>\n        <input type=\"text\" id=\"name\" name=\"name\">\n        <br>\n        <input type=\"submit\" value=\"Submit\">\n    </form>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>List Example</title>\n</head>\n<body>\n    <ul>\n        <li>Apple</li>\n        <li>Orange</li>\n        <li>Banana</li>\n    </ul>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Table Example</title>\n</head>\n<body>\n    <table border=\"1\">\n        <tr>\n            <th>Name</th>\n            <th>Age</th>\n        </tr>\n        <tr>\n            <td>Alice</td>\n            <td>25</td>\n        </tr>\n        <tr>\n            <td>Bob</td>\n            <td>30</td>\n        </tr>\n    </table>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Image Example</title>\n</head>\n<body>\n    <img src=\"https://via.placeholder.com/150\" alt=\"Placeholder Image\">\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Link Example</title>\n</head>\n<body>\n    <a href=\"https://www.example.com\">Visit Example Website</a>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Button Example</title>\n</head>\n<body>\n    <button onclick=\"alert('Hello!')\">Click me</button>\n</body>\n</html>"
  },
  {
    "language": "HTML",
    "code": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Heading Example</title>\n</head>\n<body>\n    <h2>Welcome to my Website</h2>\n    <p>This is a paragraph describing the website.</p>\n</body>\n</html>"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"os\" func fileIO() { file, err := os.Create(\"test.txt\") if err != nil { fmt.Println(\"Error creating file:\", err) return } defer file.Close() file.WriteString(\"Hello, Go!\") fmt.Println(\"File created and written to.\") } func main() { fileIO() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func deferExample() { defer fmt.Println(\"World!\") fmt.Println(\"Hello,\") } func main() { deferExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func panicRecover() { defer func() { if r := recover(); r != nil { fmt.Println(\"Recovered from panic:\", r) } }() panic(\"Panic occurred!\") } func main() { panicRecover() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func channels() { ch := make(chan int) go func() { ch <- 42 }() fmt.Println(\"Channel value:\", <-ch) } func main() { channels() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func selectExample() { ch1 := make(chan string) ch2 := make(chan string) go func() { ch1 <- \"Hello\" }() go func() { ch2 <- \"World\" }() select { case msg1 := <-ch1: fmt.Println(\"Received:\", msg1) case msg2 := <-ch2: fmt.Println(\"Received:\", msg2) } } func main() { selectExample() }"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, Go!\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(\"Square root of 16 is:\", math.Sqrt(16))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := add(3, 7)\n\tfmt.Println(\"Sum:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(i)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x int\n\tfmt.Println(\"Enter a number:\")\n\tfmt.Scan(&x)\n\tfmt.Println(\"You entered:\", x)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a, b int = 5, 10\n\tfmt.Printf(\"Before swap: a = %d, b = %d\\n\", a, b)\n\t// Swap logic\n\ta, b = b, a\n\tfmt.Printf(\"After swap: a = %d, b = %d\\n\", a, b)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar message = make(chan string)\n\tgo func() {\n\t\tmessage <- \"Hello, Go Concurrency!\"\n\t}()\n\treceivedMessage := <-message\n\tfmt.Println(receivedMessage)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfruits := []string{\"apple\", \"banana\", \"orange\"}\n\tfor index, fruit := range fruits {\n\t\tfmt.Printf(\"Index: %d, Fruit: %s\\n\", index, fruit)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tconst pi = 3.14159\n\tfmt.Printf(\"Value of pi: %f\\n\", pi)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"Deferred statement 1\")\n\tdefer fmt.Println(\"Deferred statement 2\")\n\tfmt.Println(\"Main function\")\n}"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func variables() { number := 42 piValue := 3.14 message := \"Hello\" isTrue := true fmt.Println(number, piValue, message, isTrue) } func main() { variables() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func conditionalStatements(isTrue bool) { if isTrue { fmt.Println(\"It is true!\") } else { fmt.Println(\"It is false!\") } } func main() { conditionalStatements(true) }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func loops() { for i := 0; i < 5; i++ { fmt.Println(\"Count:\", i) } } func main() { loops() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func whileLoop() { count := 0 for count < 5 { fmt.Println(\"Count:\", count) count++ } } func main() { whileLoop() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func greet(name string) { fmt.Println(\"Hello,\", name+\"!\") } func main() { greet(\"Alice\") }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func list() { fruits := []string{\"Apple\", \"Orange\", \"Banana\"} fmt.Println(fruits) } func main() { list() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func mapExample() { ages := map[string]int{\"Alice\": 25, \"Bob\": 30, \"Charlie\": 28} fmt.Println(ages) } func main() { mapExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" type Person struct { name string age int } func main() { person := Person{name: \"Alice\", age: 25} fmt.Println(\"Name:\", person.name, \"Age:\", person.age) }"
  },
  {
    "language": "Go",
    "code": "package main import ( \"fmt\" \"time\" ) func fetchData() { fmt.Println(\"Fetching data...\") time.Sleep(2 * time.Second) fmt.Println(\"Data fetched!\") } func main() { fetchData() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func set() { numbers := map[int]bool{1: true, 2: true, 3: true, 4: true, 5: true} fmt.Println(numbers) } func main() { set() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" type Status int const ( PENDING Status = iota APPROVED REJECTED ) func main() { applicationStatus := APPROVED fmt.Println(\"Application Status:\", applicationStatus) }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"math/rand\" func randomNumbers() { fmt.Println(\"Random number:\", rand.Intn(100)) } func main() { randomNumbers() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func userInput() { var name string fmt.Print(\"Enter your name: \") fmt.Scanln(&name) fmt.Println(\"Hello,\", name+\"!\") } func main() { userInput() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func optionalArguments(names ...string) { for _, name := range names { fmt.Println(\"Hello,\", name+\"!\") } } func main() { optionalArguments(\"Alice\", \"Bob\") optionalArguments() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func structs() { type Rectangle struct { width, height int } var rect Rectangle rect.width = 10 rect.height = 20 fmt.Println(\"Rectangle:\", rect) } func main() { structs() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"os\" func fileIO() { file, err := os.Create(\"test.txt\") if err != nil { fmt.Println(\"Error creating file:\", err) return } defer file.Close() file.WriteString(\"Hello, Go!\") fmt.Println(\"File created and written to.\") } func main() { fileIO() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func deferExample() { defer fmt.Println(\"World!\") fmt.Println(\"Hello,\") } func main() { deferExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func panicRecover() { defer func() { if r := recover(); r != nil { fmt.Println(\"Recovered from panic:\", r) } }() panic(\"Panic occurred!\") } func main() { panicRecover() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func channels() { ch := make(chan int) go func() { ch <- 42 }() fmt.Println(\"Channel value:\", <-ch) } func main() { channels() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func selectExample() { ch1 := make(chan string) ch2 := make(chan string) go func() { ch1 <- \"Hello\" }() go func() { ch2 <- \"World\" }() select { case msg1 := <-ch1: fmt.Println(\"Received:\", msg1) case msg2 := <-ch2: fmt.Println(\"Received:\", msg2) } } func main() { selectExample() }"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, Go!\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(\"Square root of 16 is:\", math.Sqrt(16))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := add(3, 7)\n\tfmt.Println(\"Sum:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(i)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x int\n\tfmt.Println(\"Enter a number:\")\n\tfmt.Scan(&x)\n\tfmt.Println(\"You entered:\", x)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a, b int = 5, 10\n\tfmt.Printf(\"Before swap: a = %d, b = %d\\n\", a, b)\n\t// Swap logic\n\ta, b = b, a\n\tfmt.Printf(\"After swap: a = %d, b = %d\\n\", a, b)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar message = make(chan string)\n\tgo func() {\n\t\tmessage <- \"Hello, Go Concurrency!\"\n\t}()\n\treceivedMessage := <-message\n\tfmt.Println(receivedMessage)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfruits := []string{\"apple\", \"banana\", \"orange\"}\n\tfor index, fruit := range fruits {\n\t\tfmt.Printf(\"Index: %d, Fruit: %s\\n\", index, fruit)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tconst pi = 3.14159\n\tfmt.Printf(\"Value of pi: %f\\n\", pi)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"Deferred statement 1\")\n\tdefer fmt.Println(\"Deferred statement 2\")\n\tfmt.Println(\"Main function\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar age int\n\tswitch {\n\tcase age < 18:\n\t\tfmt.Println(\"You are a minor.\")\n\tcase age >= 18 && age < 60:\n\t\tfmt.Println(\"You are an adult.\")\n\tdefault:\n\t\tfmt.Println(\"You are a senior citizen.\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcurrentHour := time.Now().Hour()\n\tif currentHour < 12 {\n\t\tfmt.Println(\"Good morning!\")\n\t} else if currentHour < 17 {\n\t\tfmt.Println(\"Good afternoon!\")\n\t} else {\n\t\tfmt.Println(\"Good evening!\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x interface{}\n\tx = 42\n\tswitch x.(type) {\n\tcase int:\n\t\tfmt.Println(\"x is an integer\")\n\tcase string:\n\t\tfmt.Println(\"x is a string\")\n\tdefault:\n\t\tfmt.Println(\"x is of unknown type\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4, 5}\n\t// Doubling each element in the slice\n\tfor i := range numbers {\n\t\tnumbers[i] *= 2\n\t}\n\tfmt.Println(\"Doubled numbers:\", numbers)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Your code here\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateSum(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := calculateSum(10, 20)\n\tfmt.Println(\"Sum is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}\n\nfunc main() {\n\tresult := fibonacci(10)\n\tfmt.Println(\"Fibonacci of 10 is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc printTime() {\n\tfmt.Println(\"Current time:\", time.Now())\n}\n\nfunc main() {\n\t// Your code here\n\tprintTime()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc findMax(nums ...int) int {\n\tmax := nums[0]\n\tfor _, num := range nums {\n\t"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc reverseString(input string) string {\n\tchars := strings.Split(input, \"\")\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn strings.Join(chars, \"\")\n}\n\nfunc main() {\n\toriginal := \"Hello, Go!\"\n\treversed := reverseString(original)\n\tfmt.Printf(\"Original: %s, Reversed: %s\\n\", original, reversed)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateRandomNumber() int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(100)\n}\n\nfunc main() {\n\trandomNumber := generateRandomNumber()\n\tfmt.Println(\"Random Number:\", randomNumber)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc readFile(filename string) (string, error) {\n\tdata, err := os.ReadFile(filename)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}\n\nfunc main() {\n\tcontent, err := readFile(\"example.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"File content:\", content)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc convertStringToInt(input string) (int, error) {\n\tresult, err := strconv.Atoi(input)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn result, nil\n}\n\nfunc main() {\n\tstrNumber := \"42\"\n\tintNumber, err := convertStringToInt(strNumber)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting string to int:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Converted Int:\", intNumber)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateFactorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * calculateFactorial(n-1)\n}\n\nfunc main() {\n\tresult := calculateFactorial(5)\n\tfmt.Println(\"Factorial of 5 is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc calculateCircleArea(radius float64) float64 {\n\treturn math.Pi * math.Pow(radius, 2)\n}\n\nfunc main() {\n\tradius := 3.0\n\tarea := calculateCircleArea(radius)\n\tfmt.Printf(\"Circle area with radius %.2f: %.2f\\n\", radius, area)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n)\n\ntype Person struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tCity  string `json:\"city\"`\n}\n\nfunc main() {\n\tperson := Person{\"John Doe\", 30, \"New York\"}\n\tjsonData, err := json.Marshal(person)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"JSON Data:\", string(jsonData))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc sleepAndPrint(message string, duration time.Duration) {\n\ttime.Sleep(duration)\n\tfmt.Println(message)\n}\n\nfunc main() {\n\tsleepAndPrint(\"Message 1\", 2*time.Second)\n\tsleepAndPrint(\"Message 2\", 1*time.Second)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar age int\n\tswitch {\n\tcase age < 18:\n\t\tfmt.Println(\"You are a minor.\")\n\tcase age >= 18 && age < 60:\n\t\tfmt.Println(\"You are an adult.\")\n\tdefault:\n\t\tfmt.Println(\"You are a senior citizen.\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcurrentHour := time.Now().Hour()\n\tif currentHour < 12 {\n\t\tfmt.Println(\"Good morning!\")\n\t} else if currentHour < 17 {\n\t\tfmt.Println(\"Good afternoon!\")\n\t} else {\n\t\tfmt.Println(\"Good evening!\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x interface{}\n\tx = 42\n\tswitch x.(type) {\n\tcase int:\n\t\tfmt.Println(\"x is an integer\")\n\tcase string:\n\t\tfmt.Println(\"x is a string\")\n\tdefault:\n\t\tfmt.Println(\"x is of unknown type\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4, 5}\n\t// Doubling each element in the slice\n\tfor i := range numbers {\n\t\tnumbers[i] *= 2\n\t}\n\tfmt.Println(\"Doubled numbers:\", numbers)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Your code here\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateSum(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := calculateSum(10, 20)\n\tfmt.Println(\"Sum is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "language": "Erlang",
    "code": "module(hello). -export([world/0]). world() -> io:format(\"Hello, World!~n\")."
  },
  {
    "language": "Erlang",
    "code": "-module(parallel_processing).\n-export([execute_tasks/1]).\nexecute_tasks(Tasks) ->\n    lists:foreach(fun(Task) -> spawn(fun() -> Task() end) end, Tasks)."
  },
  {
    "language": "Erlang",
    "code": "-module(genetic_algorithm).\n-export([run_genetic_algorithm/1]).\nrun_genetic_algorithm(Population) ->\n    [select() || _ <- lists:seq(1, Generations)],\n    MinFitness = lists:min([fitness(Ind) || Ind <- Population]),\n    lists:max([fitness(Ind) || Ind <- Population, fitness(Ind) =:= MinFitness])."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_computing).\n-compile([export_all]).\nsimulate_quantum_system(Circuit) ->\n    State = initialize_quantum_state(Circuit),\n    simulate_gates(State, Circuit)."
  },
  {
    "language": "Erlang",
    "code": "-module(natural_language_processing).\n-compile([export_all]).\nprocess_text(Text) ->\n    Parsed = parse_text(Text),\n    analyze_parsed(Parsed)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_systems).\n-compile([export_all]).\nexecute_tasks(Tasks) ->\n    [spawn(fun() -> perform_task(Task) end) || Task <- Tasks]."
  },
  {
    "language": "Erlang",
    "code": "-module(concurrency).\n-compile([export_all]).\nexecute_tasks(Tasks) ->\n    [spawn(fun() -> Task() end) || Task <- Tasks]."
  },
  {
    "language": "Erlang",
    "code": "-module(neural_network).\n-compile([export_all]).\nprocess_input(Input) ->\n    Network = create_neural_network(),\n    train_network(Network, Input),\n    predict_network(Network, Input)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_error_correction).\n-compile([export_all]).\nerror_correction(State) ->\n    Errors = detect_errors(State),\n    correct_errors(State, Errors)."
  },
  {
    "language": "Erlang",
    "code": "-module(chaos_engineering).\n-compile([export_all]).\ninject_faults(System),\n    analyze_system_behavior(System)."
  },
  {
    "language": "Erlang",
    "code": "-module(blockchain).\n-compile([export_all]).\nexecute_transaction(Transaction) ->\n    create_transaction(Transaction),\n    mine_block()."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_cryptography).\n-compile([export_all]).\nsecure_communication(Message) ->\n    Keys = generate_keys(),\n    encrypt_message(Message, Keys)."
  },
  {
    "language": "Erlang",
    "code": "-module(reactive_programming).\n-compile([export_all]).\nsubscribe(Stream) ->\n    subscribe_to_stream(Stream).\n\npublish(Stream, Data) ->\n    publish_to_stream(Stream, Data)."
  },
  {
    "language": "Erlang",
    "code": "-module(autonomous_robotics).\n-compile([export_all]).\nnavigate(Task) ->\n    plan_task(Task),\n    execute_task(Task)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_teleportation).\n-compile([export_all]).\nteleport_state(State) ->\n    Particles = prepare_entangled_particles(),\n    transfer_quantum_state(State, Particles)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_genomic_analysis).\n-compile([export_all]).\nanalyze_data(Data) ->\n    Analysis = analyze_genomic_data(Data),\n    process_in_parallel(Analysis)."
  },
  {
    "language": "Erlang",
    "code": "-module(federated_learning).\n-compile([export_all]).\ntrain_model(Model) ->\n    Nodes = initialize_nodes(),\n    train_model_with_federation(Model, Nodes)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_entanglement).\n-compile([export_all]).\nentangle_particles(Particles) ->\n    State = create_entangled_state(Particles),\n    transfer_state(State)."
  },
  {
    "language": "Erlang",
    "code": "-module(big_data_analytics).\n-compile([export_all]).\nanalyze_data(Data) ->\n    Processed = process_big_data(Data),\n    analyze_trends(Processed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_routing).\n-compile([export_all]).\nroute_data(Data) ->\n    Routed = route_quantum_data(Data),\n    manage_quantum_network(Routed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_annealing).\n-compile([export_all]).\nanneal_system(System) ->\n    Annealed = anneal_quantum_system(System),\n    optimize_annealing(Annealed)."
  },
  {
    "language": "Erlang",
    "code": "-module(compiler_optimization).\n-compile([export_all]).\noptimize_compiler(Compiler) ->\n    Optimized = optimize_compiler(Compiler),\n    improve_code(Optimized)."
  },
  {
    "language": "Erlang",
    "code": "-module(autonomous_agents).\n-compile([export_all]).\noperate_agents(Agents) ->\n    lists:foreach(fun(Agent) ->\n        create_agent(Agent),\n        train_agent(Agent)\n    end, Agents)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_communication).\n-compile([export_all]).\ncommunicate(Message) ->\n    Sent = send_quantum_message(Message),\n    receive_quantum_message()."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_search).\n-compile([export_all]).\nsearch_content(Query) ->\n    Results = search_content(Query),\n    index_content(Results)."
  },
  {
    "language": "Erlang",
    "code": "-module(genome_analysis).\n-compile([export_all]).\nanalyze_genome(Genome) ->\n    Analysis = analyze_genome(Genome),\n    compare_genomes(Analysis)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_optimization).\n-compile([export_all]).\noptimize_quantum_algorithm(Algorithm) ->\n    Optimized = optimize_quantum_algorithm(Algorithm),\n    improve_quantum_performance(Optimized)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_robotics).\n-compile([export_all]).\ncoordinate_robots(Robots) ->\n    Coordinated = coordinate_robots(Robots),\n    simulate_robotic_swarm(Coordinated)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_data_storage).\n-compile([export_all]).\nstore_data(Data) ->\n    Stored = store_quantum_data(Data),\n    retrieve_quantum_data()."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_meta_programming).\n-compile([export_all]).\nprogram_computers(Program) ->\n    Programmed = program_quantum_computers(Program),\n    verify_quantum_code(Programmed)."
  },
  {
    "language": "Erlang",
    "code": "-module(fault_tolerance).\n-compile([export_all]).\napply_faults(System) ->\n    inject_faults(System),\n    monitor_system_behavior(System)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_ml).\n-compile([export_all]).\ntrain_model(Model) ->\n    Nodes = initialize_nodes(),\n    distribute_training(Model, Nodes)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_compression).\n-compile([export_all]).\ncompress_data(Data) ->\n    Compressed = quantum_compress(Data),\n    decompress_data(Compressed)."
  },
  {
    "language": "Erlang",
    "code": "-module(advanced_cryptography).\n-compile([export_all]).\nsecure_transaction(Transaction) ->\n    Keys = generate_secure_keys(),\n    encrypt_transaction(Transaction, Keys)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_realtime).\n-compile([export_all]).\nhandle_realtime_data(Data) ->\n    Distributed = distribute_realtime_data(Data),\n    analyze_realtime(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_simulation).\n-compile([export_all]).\nsimulate_quantum_process(Process) ->\n    Simulated = simulate_quantum(Process),\n    analyze_simulation(Simulated)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_energy).\n-compile([export_all]).\nmanage_energy(EnergyGrid) ->\n    Distributed = distribute_energy(EnergyGrid),\n    optimize_distribution(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_security).\n-compile([export_all]).\nensure_security(Message) ->\n    Encrypted = encrypt_message(Message),\n    ensure_encryption(Encrypted)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_analysis).\n-compile([export_all]).\nanalyze_data(Data) ->\n    Distributed = distribute_data(Data),\n    perform_analysis(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_telecommunications).\n-compile([export_all]).\ntransmit_data(Data) ->\n    Transmitted = transmit_quantum_data(Data),\n    receive_data(Transmitted)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_security).\n-compile([export_all]).\nsecure_system(System) ->\n    Secured = secure_distributed_system(System),\n    monitor_security(Secured)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_prediction).\n-compile([export_all]).\npredict_outcome(Data) ->\n    Prediction = predict_quantum_outcome(Data),\n    validate_prediction(Prediction)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_healthcare).\n-compile([export_all]).\nmanage_healthcare(Data) ->\n    Distributed = distribute_healthcare_data(Data),\n    optimize_healthcare(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_encryption).\n-compile([export_all]).\nencrypt_data(Data) ->\n    Encrypted = quantum_encrypt(Data),\n    decrypt_encrypted(Encrypted)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_recommendation).\n-compile([export_all]).\nrecommend_products(Users) ->\n    Recommendations = distribute_recommendations(Users),\n    collect_feedback(Recommendations)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_analysis).\n-compile([export_all]).\nanalyze_quantum_data(Data) ->\n    Analyzed = analyze_quantum(Data),\n    process_analysis(Analyzed)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_traffic_management).\n-compile([export_all]).\nmanage_traffic(Data) ->\n    Distributed = distribute_traffic_data(Data),\n    optimize_traffic_management(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_sensing).\n-compile([export_all]).\nmeasure_quantum_data(Data) ->\n    Measured = measure_quantum(Data),\n    analyze_measurement(Measured)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_collaboration).\n-compile([export_all]).\ncoordinate_teams(Teams) ->\n    Coordinated = coordinate_teams(Teams),\n    analyze_collaboration(Coordinated)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_simulation).\n-compile([export_all]).\nsimulate_quantum_process(Process) ->\n    Simulated = simulate_quantum(Process),\n    analyze_simulation(Simulated)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_logging).\n-compile([export_all]).\ncollect_logs(Logs) ->\n    Distributed = distribute_logs(Logs),\n    analyze_logs(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_reliability).\n-compile([export_all]).\nensure_reliability(System) ->\n    Reliable = ensure_quantum_reliability(System),\n    monitor_reliability(Reliable)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_marketing).\n-compile([export_all]).\nmarket_products(Products) ->\n    Distributed = distribute_marketing(Products),\n    analyze_effectiveness(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_data_transfer).\n-compile([export_all]).\ntransfer_data(Data) ->\n    Transferred = transfer_quantum_data(Data),\n    verify_transfer(Transferred)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_learning).\n-compile([export_all]).\nexecute_learning(Subjects) ->\n    Distributed = distribute_learning(Subjects),\n    evaluate_performance(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_pattern_recognition).\n-compile([export_all]).\nrecognize_patterns(Data) ->\n    Recognized = recognize_quantum_patterns(Data),\n    analyze_recognition(Recognized)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_weather_forecasting).\n-compile([export_all]).\npredict_weather(Data) ->\n    Predicted = distribute_weather_prediction(Data),\n    verify_predictions(Predicted)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_state_transfer).\n-compile([export_all]).\ntransfer_state(State) ->\n    Transferred = quantum_transfer_state(State),\n    validate_transfer(Transferred)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_security_monitoring).\n-compile([export_all]).\nmonitor_security(System) ->\n    Monitored = monitor_distributed_security(System),\n    analyze_security(Monitored)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_resource_optimization).\n-compile([export_all]).\noptimize_resources(Resources) ->\n    Optimized = optimize_quantum_resources(Resources),\n    evaluate_optimization(Optimized)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_customer_service).\n-compile([export_all]).\nmanage_customers(Customers) ->\n    Distributed = distribute_customer_service(Customers),\n    evaluate_satisfaction(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "module(variables). -export([example/0]). example() -> Number = 42, PiValue = 3.14, Message = \"Hello\", IsTrue = true, io:format(\"~w ~w ~s I160, [Number, PiValue, Message, IsTrue])."
  },
  {
    "language": "Erlang",
    "code": "module(conditional). -export([statements/1]). statements(true) -> io:format(\"It is true!~n\"); statements(false) -> io:format(\"It is false!~n\")"
  },
  {
    "language": "Erlang",
    "code": "-module(loops). -export([example/0]). example() -> loops(0). loops(5) -> ok; loops(Count) -> io:format(\"Count: ~w~n\", [Count]), loops(Count + 1).'"
  },
  {
    "language": "Erlang",
    "code": "-module(while). -export([example/0]). example() -> while(0). while(5) -> ok; while(Count) -> io:format(\"Count: ~w~n\", [Count]), while(Count + 1).'"
  },
  {
    "language": "Erlang",
    "code": "-module(greet). -export([hello/1]). hello(Name) -> io:format(\"Hello, ~s!~n\", [Name]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(lists). -export([example/0]). example() -> List = [1, 2, 3, 4, 5], io:format(\"~w~n\", [List]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(maps). -export([example/0]). example() -> Map = #{alice => 25, bob => 30, charlie => 28}, io:format(\"~p~n\", [Map]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(person). -export([details/0]). details() -> Person = #{name => \"Alice\", age => 25}, io:format(\"Name: ~s, Age: ~w~n\", [maps:get(name, Person), maps:get(age, Person)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(delay). -export([wait/0]). wait() -> timer:sleep(2000), io:format(\"Waited for 2 seconds!~n\").'"
  },
  {
    "language": "Erlang",
    "code": "-module(set). -export([example/0]). example() -> Set = #{1 => true, 2 => true, 3 => true, 4 => true, 5 => true}, io:format(\"~p~n\", [Set]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(status). -export([example/0]). example() -> ApplicationStatus = approved, io:format(\"Application Status: ~p~n\", [ApplicationStatus]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(random). -export([example/0]). example() -> random:seed(erlang:system_time()), io:format(\"Random Number: ~w~n\", [random:uniform(100)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(user_input). -export([example/0]). example() -> io:format(\"Enter your name: \"), Name = io:get_line(\"\"), io:format(\"Hello, ~s!~n\", [string:strip(Name)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(optional_args). -export([example/0]). example() -> optional_arguments(\"Alice\", \"Bob\"), optional_arguments(). optional_arguments() -> ok; optional_arguments(Names...) -> lists:foreach(fun(Name) -> io:format(\"Hello, ~s!~n\", [Name]) end, Names).'"
  },
  {
    "language": "Erlang",
    "code": "-module(rectangle). -export([example/0]). example() -> Rectangle = #{width => 10, height => 20}, io:format(\"Rectangle: ~p~n\", [Rectangle]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(file_io). -export([example/0]). example() -> {ok, File} = file:open(\"test.txt\", [write]), file:write(File, \"Hello, Erlang!\"), file:close(File), io:format(\"File created and written to.~n\").'"
  },
  {
    "language": "Erlang",
    "code": "-module(defer). -export([example/0]). example() -> spawn(fun() -> defer(\"World!\") end), io:format(\"Hello, \"). defer(Message) -> io:format(\"~s\", [Message]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(panic_recover). -export([example/0]). example() -> try throw(panic) catch throw:panic -> io:format(\"Recovered from panic.~n\") end.'"
  },
  {
    "language": "Erlang",
    "code": "-module(channels). -export([example/0]). example() -> {Channel, _} = erlang:spawn_monitor(fun() -> Channel = erlang:monitor(process, spawn(fun() -> io:format(\"Hello, World!~n\") end)) end), receive {'DOWN', Channel, process, _, _} -> io:format(\"Channel terminated.~n\") after 3000 -> erlang:exit(Channel, kill), io:format(\"Channel killed.~n\") end.'"
  },
  {
    "language": "Lua",
    "code": "function iterateArray(arr) local i = 0 return function() i = i + 1 return arr[i] end end arr = {10, 20, 30, 40} iterator = iterateArray(arr) while true do local val = iterator() if val == nil then break end print(\"Value:\", val) end"
  },
  {
    "language": "Lua",
    "code": "Vector = {x = 0, y = 0} Vector.__add = function(v1, v2) return {x = v1.x + v2.x, y = v1.y + v2.y} end setmetatable(Vector, Vector) v1 = {x = 10, y = 20} v2 = {x = 30, y = 40} result = v1 + v2 print(\"Resultant Vector:\", result.x, result.y)"
  },
  {
    "language": "Lua",
    "code": "function outerFunction() local outerVar = 10 local function innerFunction() outerVar = outerVar + 5 return outerVar end return innerFunction end closure = outerFunction() print(\"Closure Value 1:\", closure()) print(\"Closure Value 2:\", closure())"
  },
  {
    "language": "Lua",
    "code": "function simpleCoroutine() for i = 1, 3 do coroutine.yield(i) end end co = coroutine.create(simpleCoroutine) while coroutine.status(co) ~= \"dead\" do status, value = coroutine.resume(co) print(\"Yielded value:\", value) end"
  },
  {
    "language": "Lua",
    "code": "function divide(a, b) assert(b ~= 0, \"Division by zero!\") return a / b end success, result = pcall(divide, 10, 0) if not success then print(\"Error:\", result) else print(\"Result:\", result) end"
  },
  {
    "language": "Lua",
    "code": "Dog = {sound = \"Woof!\"} function Dog:makeSound() print(self.sound) end myDog = {} setmetatable(myDog, Dog) myDog:makeSound()"
  },
  {
    "language": "Lua",
    "code": "function readFromFile(filename) local file = io.open(filename, \"r\") if not file then error(\"File not found or cannot be opened.\") end local content = file:read(\"*a\") file:close() return content end success, content = pcall(readFromFile, \"example.txt\") if success then print(\"File Content:\") print(content) else print(\"Error:\", content) end"
  },
  {
    "language": "Lua",
    "code": "module = {} function module.greet(name) print(\"Hello,\", name) end return module"
  },
  {
    "language": "Lua",
    "code": "text = \"Lua programming is awesome!\" words = {} for word in text:gmatch(\"%S+\") do table.insert(words, word) end for i, word in ipairs(words) do print(\"Word \" .. i .. \":\", word) end"
  },
  {
    "language": "Lua",
    "code": "function add(a, b) return a + b end function executeFunction(func, a, b) print(\"Result:\", func(a, b)) end executeFunction(add, 10, 20)"
  },
  {
    "language": "Lua",
    "code": "function generatorFunction() local i = 0 return function() i = i + 1 return i end end gen = generatorFunction() print(gen(), gen(), gen())"
  },
  {
    "language": "Lua",
    "code": "local function factorial(n) if n <= 1 then return 1 else return n * factorial(n - 1) end end print(\"Factorial of 5:\", factorial(5))"
  },
  {
    "language": "Lua",
    "code": "local function closureExample() local outerVar = 10 return function() outerVar = outerVar + 5 return outerVar end end closure = closureExample() print(\"Closure Value 1:\", closure()) print(\"Closure Value 2:\", closure())"
  },
  {
    "language": "Lua",
    "code": "local function reverseArray(arr) local reversed = {} for i = #arr, 1, -1 do table.insert(reversed, arr[i]) end return reversed end arr = {10, 20, 30, 40} reversedArr = reverseArray(arr) for i, val in ipairs(reversedArr) do print(\"Reversed[\" .. i .. \"]:\", val) end"
  },
  {
    "language": "Lua",
    "code": "local function isValidEmail(email) return email:match(\"^[%w%p]+@[%w%p]+%.%w%w%w?$\") ~= nil end emails = {\"example@email.com\", \"invalid-email\", \"another.example@email.co\"} for i, email in ipairs(emails) do print(\"Email \" .. i .. \":\", email, \"Valid:\", isValidEmail(email)) end"
  },
  {
    "language": "Lua",
    "code": "local function countOccurrences(text, pattern) local count = 0 for _ in text:gmatch(pattern) do count = count + 1 end return count end text = \"Lua is a scripting language, Lua is versatile\" pattern = \"Lua\" print(\"Occurrences of 'Lua':\", countOccurrences(text, pattern))"
  },
  {
    "language": "Lua",
    "code": "local function capitalizeWords(sentence) return sentence:gsub(\"(%w)(%w*)\", function(first, rest) return first:upper() .. rest:lower() end) end sentence = \"lua programming is fun\" print(\"Capitalized:\", capitalizeWords(sentence))"
  },
  {
    "language": "Lua",
    "code": "local function binarySearch(arr, target) local left, right = 1, #arr while left <= right do local mid = math.floor((left + right) / 2) if arr[mid] == target then return mid elseif arr[mid] < target then left = mid + 1 else right = mid - 1 end end return -1 end numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90} target = 60 print(\"Index of\", target, \":\", binarySearch(numbers, target))"
  },
  {
    "language": "Lua",
    "code": "local function memoize(func) local cache = {} return function(n) if not cache[n] then cache[n] = func(n) end return cache[n] end end function fibonacci(n) if n <= 2 then return 1 else return fibonacci(n - 1) + fibonacci(n - 2) end end fibonacci = memoize(fibonacci) print(\"Fibonacci(10):\", fibonacci(10))"
  },
  {
    "language": "Lua",
    "code": "local function parseJSON(jsonString) return load(\"return \" .. jsonString)() end jsonString = '{\"name\": \"Lua\", \"type\": \"Scripting Language\"}' parsedData = parseJSON(jsonString) for key, value in pairs(parsedData) do print(key .. \":\", value) end"
  },
  {
    "language": "Prolog",
    "code": "animal(cat). animal(dog). animal(elephant). size(elephant, big). size(cat, small). sound(cat, meow). sound(dog, bark)"
  },
  {
    "language": "Prolog",
    "code": "factorial(0, 1). factorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult."
  },
  {
    "language": "Prolog",
    "code": "edge(a, b). edge(b, c). edge(c, d). connected(X, Y) :- edge(X, Y). connected(X, Y) :- edge(X, Z), connected(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "parent(john, paul). parent(paul, mary). grandparent(X, Y) :- parent(X, Z), parent(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "triangle(A, B, C) :- A + B > C, A + C > B, B + C > A."
  },
  {
    "language": "Prolog",
    "code": "```even_length([]). even_length([_, _"
  },
  {
    "language": "Prolog",
    "code": "member(X, [X"
  },
  {
    "language": "Prolog",
    "code": "max(X, Y, Max) :- (X >= Y -> Max = X ; Max = Y)."
  },
  {
    "language": "Prolog",
    "code": "fib(0, 0). fib(1, 1). fib(N, Result) :- N > 1, Prev1 is N - 1, Prev2 is N - 2, fib(Prev1, Prev1Result), fib(Prev2, Prev2Result), Result is Prev1Result + Prev2Result."
  },
  {
    "language": "Prolog",
    "code": "append([], L, L). append([H"
  },
  {
    "language": "Prolog",
    "code": "map(_, [], []). map(P, [H"
  },
  {
    "language": "Prolog",
    "code": "merge([], L, L). merge(L, [], L). merge([X"
  },
  {
    "language": "Prolog",
    "code": "divisor(X, Y) :- Y > 1, Y1 is Y - 1, X mod Y =:= 0. divisors(X, Y, [Y"
  },
  {
    "language": "Prolog",
    "code": "prime(2). prime(X) :- X > 2, \\+ has_factor(X, 2). has_factor(N, M) :- N mod M =:= 0. has_factor(N, M) :- M * M < N, M2 is M + 1, has_factor(N, M2)."
  },
  {
    "language": "Prolog",
    "code": "partition(_, [], [], []). partition(Pivot, [H"
  },
  {
    "language": "Prolog",
    "code": "animal(cat), animal(dog), animal(elephant), size(elephant, big), size(cat, small), sound(cat, meow), sound(dog, bark), factorial(0, 1), factorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult, edge(a, b), edge(b, c), edge(c, d), connected(X, Y) :- edge(X, Y), connected(X, Y) :- edge(X, Z), connected(Z, Y), parent(john, paul), parent(paul, mary), grandparent(X, Y) :- parent(X, Z), parent(Z, Y), triangle(A, B, C) :- A + B > C, A + C > B, B + C > A, even_length([]), even_length([_, _ | Tail]) :- even_length(Tail), member(X, [X | _]), member(X, [_ | Tail]) :- member(X, Tail), max(X, Y, Max) :- (X >= Y -> Max = X ; Max = Y), fib(0, 0), fib(1, 1), fib(N, Result) :- N > 1, Prev1 is N - 1, Prev2 is N - 2, fib(Prev1, Prev1Result), fib(Prev2, Prev2Result), Result is Prev1Result + Prev2Result."
  },
  {
    "language": "Scheme",
    "code": "(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (sum-of-squares a b) (+ (* a a) (* b b)))"
  },
  {
    "language": "Scheme",
    "code": "(define my-list '(1 2 3 4)) (car my-list) (cdr my-list)"
  },
  {
    "language": "Scheme",
    "code": "(define (fibonacci n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (power-of-two n) (expt 2 n))"
  },
  {
    "language": "Scheme",
    "code": "(define (sum-list lst) (if (null? lst) 0 (+ (car lst) (sum-list (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (square x) (* x x))"
  },
  {
    "language": "Scheme",
    "code": "(define (map f lst) (if (null? lst) '() (cons (f (car lst)) (map f (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (filter pred lst) (cond ((null? lst) '()) ((pred (car lst)) (cons (car lst) (filter pred (cdr lst)))) (else (filter pred (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (merge lst1 lst2) (cond ((null? lst1) lst2) ((null? lst2) lst1) ((< (car lst1) (car lst2)) (cons (car lst1) (merge (cdr lst1) lst2))) (else (cons (car lst2) (merge lst1 (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (gcd a b) (if (= b 0) a (gcd b (remainder a b))))"
  },
  {
    "language": "Scheme",
    "code": "(define (quicksort lst) (if (null? lst) '() (let ((pivot (car lst))) (append (quicksort (filter (lambda (x) (< x pivot)) (cdr lst))) (cons pivot (quicksort (filter (lambda (x) (>= x pivot)) (cdr lst))))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (reverse lst) (define (reverse-iter lst result) (if (null? lst) result (reverse-iter (cdr lst) (cons (car lst) result)))) (reverse-iter lst '()))"
  },
  {
    "language": "Scheme",
    "code": "(define (make-counter) (let ((count 0)) (lambda () (set! count (+ count 1)) count)))"
  },
  {
    "language": "Scheme",
    "code": "(define (factorial n) (let loop ((n n) (acc 1)) (if (= n 0) acc (loop (- n 1) (* acc n)))))"
  },
  {
    "language": "Scheme",
    "code": "(define greeting \"Hello, \") (define name \"Alice\") (display (string-append greeting name))"
  },
  {
    "language": "Scheme",
    "code": "(define myList '(1 2 3 4)) (define myListReversed (reverse myList)) (define myListLength (length myList))"
  },
  {
    "language": "Scheme",
    "code": "(define (apply-twice func arg) (func (func arg))) (define (add-one x) (+ x 1)) (define result (apply-twice add-one 5))"
  },
  {
    "language": "Scheme",
    "code": "(+ 10 20) (- 50 30) (* 5 6) (/ 100 4)"
  },
  {
    "language": "Scheme",
    "code": "(define (is-even? n) (= (remainder n 2) 0)) (if (is-even? 10) (display \"Number is even\") (display \"Number is odd\"))"
  },
  {
    "language": "TCL",
    "code": "set greeting \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "puts \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "for {set i 0} {$i < 5} {incr i} { puts \"Iteration: $i\" }"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} foreach item $myList { puts $item }"
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] llength $numbers"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 3; expr {$x + $y}"
  },
  {
    "language": "TCL",
    "code": "set fruits {apple banana cherry} lsearch -exact $fruits banana"
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] lsort -integer $numbers"
  },
  {
    "language": "TCL",
    "code": "set sentence \"This is a sentence.\" set words [split $sentence] lindex $words 2"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 10; if {$x > $y} { puts \"x is greater than y\" } else { puts \"x is less than or equal to y\" }"
  },
  {
    "language": "TCL",
    "code": "proc add {a b} { return [expr {$a + $b}] } add 5 3"
  },
  {
    "language": "TCL",
    "code": "set colors {red green blue} lrange $colors 0 1"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} lsearch $myList banana"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} linsert $myList end \"orange\""
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] lreverse $numbers"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 10; expr {$x * $y}"
  },
  {
    "language": "TCL",
    "code": "set sentence \"This is a sentence.\" set words [split $sentence] llength $words"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} lrange $myList 0 1"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 3; expr {$x % $y}"
  },
  {
    "language": "SmallTalk",
    "code": "Object subclass: Person [ | name age | initialize [ name := ''. age := 0. ] setName: aName [ name := aName. ] setAge: anAge [ age := anAge. ] getName [ ^name ] getAge [ ^age ] ]; person := (Person new setName: 'Alice'; setAge: 30; yourself); Transcript show: 'Name: ', (person getName), '. Age: ', (person getAge asString), '.'."
  },
  {
    "language": "SmallTalk",
    "code": "Object subclass: BankAccount [ | balance | initialize [ balance := 0. ] deposit: amount [ balance := balance + amount. ^'Deposit successful.' ] withdraw: amount [ | message | message := (balance >= amount) ifTrue: [ balance := balance - amount. 'Withdrawal successful: ', amount asString ] ifFalse: ['Insufficient funds.'] ^message ] checkBalance [ ^balance ] ]; account := BankAccount new. account deposit: 100. Transcript show: 'Balance after deposit: ', (account checkBalance) asString; cr. withdrawalMessage := account withdraw: 50. Transcript show: withdrawalMessage; cr. withdrawalMessage := account withdraw: 80. Transcript show: withdrawalMessage; cr. Transcript show: 'Final balance: ', (account checkBalance) asString; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript\n    show: 'Hello, world!';\n    cr."
  },
  {
    "language": "SmallTalk",
    "code": "| numbers |\nnumbers := #(1 2 3 4 5).\nnumbers do: [:each | Transcript show: each asString; cr]."
  },
  {
    "language": "SmallTalk",
    "code": "(1 to: 5) collect: [:each | each squared]."
  },
  {
    "language": "SmallTalk",
    "code": "| person |\nperson := Dictionary new.\nperson at: 'name' put: 'Alice'.\nperson at: 'age' put: 30."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript show: (Date today) asString; cr."
  },
  {
    "language": "SmallTalk",
    "code": "| circle |\ncircle := EllipseMorph new.\ncircle openInWorld.\ncircle color: Color blue."
  },
  {
    "language": "SmallTalk",
    "code": "| worker |\nworker := Worker new.\nworker work."
  },
  {
    "language": "SmallTalk",
    "code": "| car |\ncar := Car new.\ncar drive: 100."
  },
  {
    "language": "SmallTalk",
    "code": "| rectangle |\nrectangle := Rectangle origin: 0@0 corner: 100@100."
  },
  {
    "language": "SmallTalk",
    "code": "(1 to: 10) do: [:i |\n    Transcript show: i asString; cr.\n]."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript show: 'I love Smalltalk!'; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Cursor wait showWhile: [Sensor anyButtonPressed]."
  },
  {
    "language": "SmallTalk",
    "code": "| s |\ns := 'Hello, world!'.\ns at: 2 put: $a.\nTranscript show: s; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Display restoreAfter: [\n    Transcript show: 'Smalltalk is fun!'; cr.\n]."
  },
  {
    "language": "SmallTalk",
    "code": "| animal |\nanimal := 'Dog'.\nanimal, ' is a friendly pet.'."
  },
  {
    "language": "SmallTalk",
    "code": "Sensor waitButton."
  },
  {
    "language": "SmallTalk",
    "code": "('Smalltalk' copyFrom: 3 to: 6) reverse."
  },
  {
    "language": "R",
    "code": "# Create a data frame\ndata <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(data)\n\n# Subset based on conditions\nselected_data <- subset(data, Age > 25)\n\n# Print the subset\nprint(selected_data)"
  },
  {
    "language": "R",
    "code": "# Create a function that calculates factorial\nfactorial <- function(n) {\n    if (n == 0) {\n        return(1)\n    } else {\n        return(n * factorial(n - 1))\n    }\n}\n\n# Call the function\nresult <- factorial(5)\nprint(result)\n\n# Utilize ggplot2 package for plotting\nrequire(ggplot2)\n\n# Create sample data\ndata <- data.frame(\n    x = 1:10,\n    y = rnorm(10)\n)\n\n# Plot using ggplot2\nggplot(data, aes(x=x, y=y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Function to print elements of a list\nprint_list <- function(my_list) {\n    for (element in my_list) {\n        print(element)\n    }\n}\n\n# Create a list\nmy_list <- list(name = \"John\", age = 30, city = \"New York\")\n\n# Print elements of the list\nprint_list(my_list)\n\n# Function accepting and printing unspecified arguments\nprint_arguments <- function(...) {\n    for (arg in list(...)) {\n        print(arg)\n    }\n}\n\n# Call the function with different arguments\nprint_arguments(\"Hello\", 10, TRUE)"
  },
  {
    "language": "R",
    "code": "# Create a data frame\nstudents <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(students)\n\n# Extract specific columns\nages <- students$Age\ngrades <- students$Grade\n\n# Print extracted columns\nprint(ages)\nprint(grades)"
  },
  {
    "language": "R",
    "code": "# Function to check if a number is even\nis_even <- function(num) {\n    if (num %% 2 == 0) {\n        return(TRUE)\n    } else {\n        return(FALSE)\n    }\n}\n\n# Check numbers for evenness\nprint(is_even(5))\nprint(is_even(10))"
  },
  {
    "language": "R",
    "code": "# Loop to create a list of squares\nsquares <- c()\nfor (i in 1:10) {\n    squares[i] <- i^2\n}\n\n# Print the list of squares\nprint(squares)\n\n# Function to calculate sum of a list\ncalculate_sum <- function(nums) {\n    sum <- 0\n    for (num in nums) {\n        sum <- sum + num\n    }\n    return(sum)\n}\n\n# Calculate sum of a list of numbers\nresult <- calculate_sum(1:10)\nprint(result)"
  },
  {
    "language": "R",
    "code": "# Generating random data\nset.seed(123)\ndata <- data.frame(\n    x = 1:100,\n    y = rnorm(100)\n)\n\n# Scatter plot using base R graphics\nplot(data$x, data$y, main = \"Random Data Scatter Plot\", xlab = \"X-axis\", ylab = \"Y-axis\")"
  },
  {
    "language": "R",
    "code": "# Create a data frame\nstudents <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(students)\n\n# Subset based on conditions\nselected_students <- subset(students, Age > 25)\n\n# Print the subset\nprint(selected_students)"
  },
  {
    "language": "R",
    "code": "# Create a function that prints 'Hello' n times\nprint_hello <- function(n){\n    for (i in 1:n){\n        print(\"Hello\")\n    }\n}\n\n# Call the function\nprint_hello(3)\n\n# Utilize ggplot2 package for plotting\nrequire(ggplot2)\n\n# Create sample data\ndata <- data.frame(\n    x = 1:10,\n    y = rnorm(10)\n)\n\n# Plot using ggplot2\nggplot(data, aes(x=x, y=y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Function to accept and print unspecified arguments\nprint_arguments <- function(...){\n    for (arg in list(...)){\n        print(arg)\n    }\n}\n\n# Call the function with different arguments\nprint_arguments(\"Hello\", 10, TRUE)"
  },
  {
    "language": "R",
    "code": "# Function to calculate factorial with error handling\nfactorial <- function(n) {\n    if (n < 0) {\n        stop(\"Factorial not defined for negative numbers.\")\n    }\n    if (n == 0) {\n        return(1)\n    } else {\n        return(n * factorial(n - 1))\n    }\n}\n\n# Get user input for factorial calculation\nuser_input <- as.integer(readline(\"Enter a number to calculate its factorial: \"))\nresult <- factorial(user_input)\nprint(paste(\"Factorial of\", user_input, \"is\", result))"
  },
  {
    "language": "R",
    "code": "# Apply function to calculate square of elements in a vector\nvector <- c(1, 2, 3, 4, 5)\nsquared_vector <- sapply(vector, function(x) x^2)\nprint(squared_vector)\n\n# Apply function to a data frame\ndata <- data.frame(\n    A = c(1, 2, 3),\n    B = c(4, 5, 6),\n    C = c(7, 8, 9)\n)\nmean_values <- apply(data, 2, mean)\nprint(mean_values)"
  },
  {
    "language": "R",
    "code": "# String concatenation and substring\nstring1 <- \"Hello\"\nstring2 <- \"World!\"\nconcatenated <- paste(string1, string2)\nsubstring <- substr(concatenated, start = 3, stop = 8)\nprint(concatenated)\nprint(substring)\n\n# Checking string containment\ntext <- \"This is a sample text.\"\nif (\"sample\" %in% strsplit(text, \" \")[[1]]) {\n    print(\"String 'sample' found in text.\")\n} else {\n    print(\"String 'sample' not found in text.\")\n}"
  },
  {
    "language": "R",
    "code": "# Create matrices\nmatrix1 <- matrix(1:9, nrow = 3)\nmatrix2 <- matrix(9:1, nrow = 3)\n\n# Matrix multiplication\nresult_matrix <- matrix1 %*% matrix2\nprint(result_matrix)\n\n# Matrix transpose\ntransposed_matrix <- t(matrix1)\nprint(transposed_matrix)"
  },
  {
    "language": "R",
    "code": "# Write data to a CSV file\ndata <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28)\n)\nwrite.csv(data, \"output.csv\")\n\n# Read data from a CSV file\nread_data <- read.csv(\"output.csv\")\nprint(read_data)"
  },
  {
    "language": "R",
    "code": "# Generating random data\nset.seed(123)\ndata1 <- data.frame(\n    x = 1:50,\n    y = rnorm(50, mean = 0, sd = 1)\n)\ndata2 <- data.frame(\n    x = 1:50,\n    y = rnorm(50, mean = 2, sd = 1)\n)\n\n# Plotting multiple graphs\npar(mfrow = c(1, 2))  # Arrange plots in a 1x2 grid\nplot(data1$x, data1$y, main = \"Random Data 1\")\nplot(data2$x, data2$y, main = \"Random Data 2\")"
  },
  {
    "language": "R",
    "code": "# Using lapply to apply a function to elements of a list\nmy_list <- list(1:5, 6:10, 11:15)\n\nsquared_lists <- lapply(my_list, function(x) x^2)\nprint(squared_lists)"
  },
  {
    "language": "R",
    "code": "# Creating matrices\nmatrix1 <- matrix(1:9, nrow = 3)\nmatrix2 <- matrix(9:1, nrow = 3)\n\n# Element-wise matrix operations\nelementwise_sum <- matrix1 + matrix2\nelementwise_product <- matrix1 * matrix2\n\nprint(elementwise_sum)\nprint(elementwise_product)"
  },
  {
    "language": "R",
    "code": "# Create a factor vector\ngrades <- factor(c(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\"))\n\n# Display unique levels of the factor\nprint(levels(grades))\n\n# Convert factor to numeric\nnumeric_grades <- as.numeric(grades)\nprint(numeric_grades)"
  },
  {
    "language": "R",
    "code": "# Getting current date and time\ncurrent_date <- Sys.Date()\ncurrent_time <- Sys.time()\n\nprint(current_date)\nprint(current_time)"
  },
  {
    "language": "D",
    "code": "immutable int x = 5;\nimmutable string message = \"Hello, D!\";"
  },
  {
    "language": "D",
    "code": "pure int square(int x) {\n    return x * x;\n}"
  },
  {
    "language": "D",
    "code": "nothrow void doSomething() {\n    // Code that doesn't throw exceptions\n}"
  },
  {
    "language": "D",
    "code": "@safe {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n}'"
  },
  {
    "language": "D",
    "code": "@trusted void unsafeOperation() {\n    // Unsafe operations here\n}'"
  },
  {
    "language": "D",
    "code": "@system {\n    // Low-level system operations here\n}'"
  },
  {
    "language": "D",
    "code": "final class FinalClass {\n    // Class members and methods\n}"
  },
  {
    "language": "D",
    "code": "void modify(ref int x) {\n    x *= 2;\n}"
  },
  {
    "language": "D",
    "code": "void foo() {\n    scope int x = 10;\n    // x is valid only within this scope\n}"
  },
  {
    "language": "D",
    "code": "void modify(inout int x) {\n    x += 5;\n}"
  },
  {
    "language": "D",
    "code": "lazy int result = complexCalculation();"
  },
  {
    "language": "D",
    "code": "pure nothrow @safe int calculate(int x, int y) {\n    return x + y;\n}"
  },
  {
    "language": "D",
    "code": "nothrow pure int multiply(int a, int b) {\n    return a * b;\n}"
  },
  {
    "language": "D",
    "code": "@trusted void unsafeOperation() {\n    // Perform unsafe operations here\n}'"
  },
  {
    "language": "D",
    "code": "@safe immutable int[] createImmutableArray() {\n    return [1, 2, 3, 4, 5];\n}'"
  },
  {
    "language": "D",
    "code": "@system void systemOperation() {\n    // Perform system-level operations here\n}'"
  },
  {
    "language": "D",
    "code": "void increment(ref int x) {\n    x++;\n}"
  },
  {
    "language": "D",
    "code": "void process(inout int x) {\n    x *= 2;\n}"
  },
  {
    "language": "D",
    "code": "@safe immutable string greeting = \"Hello, World!\";'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Hello, Bash!\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor i in {1..5}; do\n\techo $i\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction greet() {\n\techo \"Welcome, $1!\"\n}\n\ngreet \"John\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nread -p \"Enter your name: \" name\n\necho \"Hello, $name!\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nif [ -f \"file.txt\" ]; then\n\techo \"File exists.\"\nelse\n\techo \"File does not exist.\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nnumbers=(1 2 3 4 5)\nfor num in \"${numbers[@]}\"; do\n\techo $num\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction swap() {\n\tlocal temp=$1\n\tlocal x=$2\n\tlocal y=$3\n\teval $1=$y $2=$x\n}\n\na=5\nb=10\nswap temp a b\necho \"After swapping: a=$a, b=$b\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nwhile true; do\n\techo \"Infinite loop...\"\n\tsleep 1\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction calculate_sum() {\n\tlocal result=$(( $1 + $2 ))\n\techo \"Sum is: $result\"\n}\n\ncalculate_sum 10 20"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfile=\"example.txt\"\nif [ -e $file ]; then\n\techo \"File exists: $file\"\nelse\n\techo \"File does not exist: $file\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor (( i=0; i<5; i++ )); do\n\techo $i\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nif [ $# -eq 0 ]; then\n\techo \"No arguments provided.\"\nelse\n\techo \"Arguments: $@\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nhour=$(date +%H)\nif [ $hour -lt 12 ]; then\n\techo \"Good morning!\"\nelif [ $hour -lt 17 ]; then\n\techo \"Good afternoon!\"\nelse\n\techo \"Good evening!\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor file in *.txt; do\n\techo \"Processing file: $file\"\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Number of arguments: $#\"\necho \"Argument 1: $1\"\necho \"Argument 2: $2\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction factorial() {\n\tif [ $1 -eq 0 ]; then\n\t\techo 1\n\telse\n\t\techo $(( $1 * $(factorial $(( $1 - 1 ))) ))\n\tfi\n}\n\nresult=$(factorial 5)\necho \"Factorial of 5 is: $result\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Current date: $(date)\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Running command: ls -l\"\nls -l"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\narray=(\"apple\" \"banana\" \"orange\")\nfor fruit in \"${array[@]}\"; do\n\techo $fruit\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction greet_user() {\n\tlocal name=$1\n\techo \"Hello, $name!\"\n}\n\ngreet_user \"Alice\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Simple function and usage\nfunction greet() {\n\techo \"Hello, $1!\"\n}\n\ngreet \"World\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Reading user input and conditional statements\nread -p \"Enter a number: \" num\nif [ $num -gt 0 ]; then\n\techo \"Number is positive\"\nelse\n\techo \"Number is non-positive\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Arrays and loops\nfruits=(\"apple\" \"banana\" \"orange\")\nfor fruit in \"${fruits[@]}\"; do\n\techo \"Fruit: $fruit\"\ndone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Functions with return values\nfunction add() {\n\tlocal result=$(( $1 + $2 ))\n\techo $result\n}\n\nsum=$(add 10 20)\necho \"Sum is: $sum\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Command substitution and file manipulation\nfiles=$(ls *.txt)\necho \"Text files: $files\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using sed for text manipulation\necho \"Hello, World!\" | sed 's/World/Universe/'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Arithmetic operations\nresult=$((5 * 3 + 2))\necho \"Result: $result\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Process management and background tasks\nfunction long_running_task() {\n\techo \"Task started\"\n\tsleep 5\n\techo \"Task completed\"\n}\n\nlong_running_task &\n\necho \"Main script continues\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Reading and parsing a CSV file\nwhile IFS=',' read -r name age city; do\n\techo \"Name: $name, Age: $age, City: $city\"\ndone < data.csv"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Associative arrays\ndeclare -A colors\n\ncolors[red]=\"#FF0000\"\ncolors[green]=\"#00FF00\"\ncolors[blue]=\"#0000FF\"\n\necho \"Red: ${colors[red]}\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Advanced string manipulation\nstring=\"Hello, World!\"\nsubstring=${string:7:5}\necho \"Substring: $substring\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Pattern matching and regular expressions\nstring=\"apple\"\nif [[ $string =~ ^[aeiou] ]]; then\n\techo \"$string starts with a vowel\"\nelse\n\techo \"$string does not start with a vowel\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using awk for text processing\necho \"John,Doe,30\" | awk -F\",\" '{print \"Name: \" $1 \" \" $2, \"Age: \" $3}'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Generating a random password\nlength=8\npassword=$(openssl rand -base64 12 | tr -dc 'a-zA-Z0-9' | head -c $length)\necho \"Random Password: $password\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Advanced if-else condition\nnum=15\nif ((num < 10)); then\n\techo \"Number is less than 10\"\nelif ((num >= 10 && num < 20)); then\n\techo \"Number is between 10 and 19\"\nelse\n\techo \"Number is 20 or greater\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Function with default parameter\nfunction greet() {\n\tlocal name=${1:-\"Guest\"}\n\techo \"Hello, $name!\"\n}\n\ngreet\n"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Sending HTTP request using curl\nresponse=$(curl -s https://api.example.com/data)\necho \"Response: $response\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using jq to process JSON data\njson='{\"name\": \"John\", \"age\": 25}'\nname=$(echo $json | jq -r '.name')\necho \"Name: $name\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Trapping signals in a script\nfunction cleanup() {\n\techo \"Cleaning up...\"\n}\n\ntrap cleanup EXIT\n\necho \"Script is running...\""
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees;"
  },
  {
    "language": "SQL",
    "code": "SELECT first_name, last_name FROM users WHERE age > 30;"
  },
  {
    "language": "SQL",
    "code": "SELECT product_name, price FROM products ORDER BY price DESC LIMIT 5;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_orders FROM orders;"
  },
  {
    "language": "SQL",
    "code": "SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department;"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO customers (first_name, last_name, email) VALUES ('John', 'Doe', 'john@example.com');"
  },
  {
    "language": "SQL",
    "code": "UPDATE products SET price = price * 1.1 WHERE category = 'Electronics';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM users WHERE last_login < '2023-01-01';"
  },
  {
    "language": "SQL",
    "code": "CREATE TABLE IF NOT EXISTS employees (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100),\n    age INT,\n    department VARCHAR(100)\n);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE products ADD COLUMN stock INT DEFAULT 0;"
  },
  {
    "language": "SQL",
    "code": "SELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_customers FROM customers WHERE country = 'USA';"
  },
  {
    "language": "SQL",
    "code": "SELECT order_date, SUM(total_amount) AS revenue FROM orders GROUP BY order_date;"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(age) AS avg_age FROM users WHERE gender = 'Female';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (101, 205, 3);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET department = 'HR' WHERE department = 'Admin';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM products WHERE stock = 0;"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_lastname ON users(last_name);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN city VARCHAR(50);"
  },
  {
    "language": "SQL",
    "code": "SELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_customers FROM customers WHERE country = 'USA';"
  },
  {
    "language": "SQL",
    "code": "SELECT order_date, SUM(total_amount) AS revenue FROM orders GROUP BY order_date;"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(age) AS avg_age FROM users WHERE gender = 'Female';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (101, 205, 3);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET department = 'HR' WHERE department = 'Admin';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM products WHERE stock = 0;"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_lastname ON users(last_name);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN city VARCHAR(50);"
  },
  {
    "language": "SQL",
    "code": "SELECT first_name, last_name, email FROM users WHERE department IN ('Sales', 'Marketing');"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(salary) AS avg_salary FROM employees WHERE department = 'HR';"
  },
  {
    "language": "SQL",
    "code": "SELECT customer_id, COUNT(order_id) AS total_orders FROM orders GROUP BY customer_id HAVING total_orders > 5;"
  },
  {
    "language": "SQL",
    "code": "SELECT product_name, price FROM products WHERE LOWER(product_name) LIKE '%phone%';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (105, 210, 2), (106, 215, 1);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET salary = salary * 1.1 WHERE age > 40;"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM users WHERE last_login < DATE_SUB(NOW(), INTERVAL 6 MONTH);"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_category ON products(category);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN state VARCHAR(50) AFTER city;"
  },
  {
    "language": "SQL",
    "code": "DROP INDEX IF EXISTS idx_lastname ON users;"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\n procedure Doors is\n    type Door_State is (Closed, Open);\n    type Door_List is array(Positive range 1..100) of Door_State;\n    The_Doors : Door_List := (others => Closed);\n begin\n    for I in 1..100 loop\n       for J in The_Doors'range loop\n          if J mod I = 0 then\n             if The_Doors(J) = Closed then\n                 The_Doors(J) := Open;\n             else\n                The_Doors(J) := Closed;\n             end if;\n          end if;\n       end loop;\n    end loop;\n    for I in The_Doors'range loop\n       Put_Line(Integer'Image(I) & \" is \" & Door_State'Image(The_Doors(I)));\n    end loop;\n end Doors;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n with Ada.Numerics.Elementary_Functions; use Ada.Numerics.Elementary_Functions;\n\n procedure Doors_Optimized is\n    Num : Float;\n begin\n    for I in 1..100 loop\n       Num := Sqrt(Float(I));\n       Put(Integer'Image(I) & \" is \");\n       if Float'Floor(Num) = Num then\n          Put_Line(\"Opened\");\n       else\n          Put_Line(\"Closed\");\n       end if;\n    end loop;\n end Doors_Optimized;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\nprocedure Game_24 is\n   subtype Operation is Character;\n   type Op_Array is array (Positive range <>) of Operation;\n   type Digit is range 1 .. 9;\n   type Digit_Array is array (Positive range <>) of Digit;\n   package Digit_IO is new Ada.Text_IO.Integer_IO (Digit);\n   package Random_Digit is new Ada.Numerics.Discrete_Random (Digit);\n   Digit_Generator : Random_Digit.Generator;\n   Given_Digits : array (1 .. 4) of Digit;\nbegin\n   Ada.Text_IO.Put_Line (\"24 Game\");\n   Ada.Text_IO.Put_Line (\"Generating 4 digits...\");\n   Random_Digit.Reset (Digit_Generator);\n   for I in Given_Digits'Range loop\n      Given_Digits (I) := Random_Digit.Random (Digit_Generator);\n   end loop;\n   Ada.Text_IO.Put (\"Your Digits:\");\n   for I in Given_Digits'Range loop\n      Digit_IO.Put (Given_Digits (I));\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Enter your Expression: \");\n   declare\n      Value : Integer;\n      Input_Operations : Op_Array (1 .. 3);\n      Input_Digits : Digit_Array (1 .. 4);\n      Unused_Digits : array (Given_Digits'Range) of Boolean :=\n        (others => True);\n   begin\n      -- get input\n      for I in 1 .. 4 loop\n         Digit_IO.Get (Input_Digits (I));\n         exit when I = 4;\n         Ada.Text_IO.Get (Input_Operations (I));\n      end loop;\n      -- check input\n      for I in Input_Digits'Range loop\n         declare\n            Found : Boolean := False;\n         begin\n            for J in Given_Digits'Range loop\n               if Unused_Digits (J) and then\n                 Given_Digits (J) = Input_Digits (I) then\n                  Unused_Digits (J) := False;\n                  Found := True;\n                  exit;\n               end if;\n            end loop;\n            if not Found then\n               Ada.Text_IO.Put_Line (\"Illegal Number used:\" &\n                                     Digit'Image (Input_Digits (I)));\n               return;\n            end if;\n         end;\n      end loop;\n      -- check value\n      Value := Integer (Input_Digits (Input_Digits'First));\n      for I in Input_Operations'Range loop\n         case Input_Operations (I) is\n            when '+' =>\n               Value := Value + Integer (Input_Digits (I + 1));\n            when '-' =>\n               Value := Value - Integer (Input_Digits (I + 1));\n            when '*' =>\n               Value := Value * Integer (Input_Digits (I + 1));\n            when '/' =>\n               Value := Value / Integer (Input_Digits (I + 1));\n            when others =>\n               Ada.Text_IO.Put_Line (\"Illegal Op used:\" &\n                                     Input_Operations (I));\n               return;\n         end case;\n      end loop;\n      if Value /= 24 then\n         Ada.Text_IO.Put_Line (\"Value\" & Integer'Image (Value) &\n                               \" is not 24!\");\n      else\n         Ada.Text_IO.Put_Line (\"You won!\");\n      end if;\n   end;\nend Game_24;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\n procedure Bottles is\n begin\n    for X in reverse 1..99 loop\n       Put_Line(Integer'Image(X) & \" bottles of beer on the wall\");\n       Put_Line(Integer'Image(X) & \" bottles of beer\");\n       Put_Line(\"Take one down, pass it around\");\n       Put_Line(Integer'Image(X - 1) & \" bottles of beer on the wall\");\n       New_Line;\n    end loop;\n end Bottles;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Tasking_99_Bottles is\n   subtype Num_Bottles is Natural range 1..99;\n   task Print is\n      entry Set (Num_Bottles);\n   end Print;\n   task body Print is\n      Num : Natural;\n   begin\n      for I in reverse Num_Bottles'range loop\n         select\n         accept\n            Set(I) do -- Rendezvous with Counter task I\n               Num := I;\n            end Set;\n            Put_Line(Integer'Image(Num) & \" bottles of beer on the wall\");\n            Put_Line(Integer'Image(Num) & \" bottles of beer\");\n            Put_Line(\"Take one down, pass it around\");\n            Put_Line(Integer'Image(Num - 1) & \" bottles of beer on the wall\");\n            New_Line;\n         or terminate; -- end when all Counter tasks have completed\n         end select;\n      end loop;\n   end Print;\n   task type Counter(I : Num_Bottles);\n   task body Counter is\n   begin\n      Print.Set(I);\n   end Counter;\n   type Task_Access is access Counter;\n\n   Task_List : array(Num_Bottles) of Task_Access;\n\nbegin\n   for I in Task_List'range loop -- Create 99 Counter tasks\n      Task_List(I) := new Counter(I);\n   end loop;\nend Tasking_99_Bottles;\n"
  },
  {
    "language": "Ada",
    "code": "-- Standard I/O Streams\n\nwith Ada.Integer_Text_Io;\nprocedure APlusB is\n   A, B : Integer;\nbegin\n   Ada.Integer_Text_Io.Get (Item => A);\n   Ada.Integer_Text_Io.Get (Item => B);\n   Ada.Integer_Text_Io.Put (A+B);\nend APlusB;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\n\nprocedure A_Plus_B is\n   type Small_Integers is range -2_000 .. +2_000;\n   subtype Input_Values is Small_Integers range -1_000 .. +1_000;\n   package IO is new Ada.Text_IO.Integer_IO (Num => Small_Integers);\n   A, B : Input_Values;\nbegin\n   IO.Get (A);\n   IO.Get (B);\n   IO.Put (A + B, Width => 4, Base => 10);\nend A_Plus_B;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Characters.Handling;\nuse Ada.Characters.Handling;\n\n\npackage Abc is\n    type Block_Faces is array(1..2) of Character;\n    type Block_List is array(positive range <>) of Block_Faces;\n    function Can_Make_Word(W: String; Blocks: Block_List) return Boolean;\nend Abc;\n\n\npackage body Abc is\n\nfunction Can_Make_Word(W: String; Blocks: Block_List) return Boolean is\n    Used : array(Blocks'Range) of Boolean := (Others => False);\n    subtype wIndex is Integer range W'First..W'Last;\n    wPos : wIndex;\nbegin\n    if W'Length = 0 then\n        return True;\n    end if;\n    wPos := W'First;\n    while True loop\n        declare\n            C : Character := To_Upper(W(wPos));\n            X : constant wIndex := wPos;\n        begin\n            for I in Blocks'Range loop\n                if (not Used(I)) then\n                    if C = To_Upper(Blocks(I)(1)) or C = To_Upper(Blocks(I)(2)) then\n                        Used(I) := True;\n                        if wPos = W'Last then\n                            return True;\n                        end if;\n                        wPos := wIndex'Succ(wPos);\n                        exit;\n                    end if;\n                end if;\n            end loop;\n            if X = wPos then\n                return False;\n            end if;\n        end;\n    end loop;\n    return False;\nend Can_Make_Word;\n\nend Abc;\n\nwith Ada.Text_IO, Ada.Strings.Unbounded, Abc;\nuse Ada.Text_IO, Ada.Strings.Unbounded, Abc;\n\nprocedure Abc_Problem is\n    Blocks : Block_List := (\n          ('B','O'), ('X','K'), ('D','Q'), ('C','P')\n        , ('N','A'), ('G','T'), ('R','E'), ('T','G')\n        , ('Q','D'), ('F','S'), ('J','W'), ('H','U')\n        , ('V','I'), ('A','N'), ('O','B'), ('E','R')\n        , ('F','S'), ('L','Y'), ('P','C'), ('Z','M')\n    );\n    function \"+\" (S : String) return Unbounded_String renames To_Unbounded_String;\n    words : array(positive range <>) of Unbounded_String := (\n          +\"A\"\n        , +\"BARK\"\n        , +\"BOOK\"\n        , +\"TREAT\"\n        , +\"COMMON\"\n        , +\"SQUAD\"\n        , +\"CONFUSE\"\n        -- Border cases:\n        -- , +\"CONFUSE2\"\n        -- , +\"\"\n    );\nbegin\n    for I in words'Range loop\n        Put_Line ( To_String(words(I)) & \": \" & Boolean'Image(Can_Make_Word(To_String(words(I)),Blocks)) );\n    end loop;\nend Abc_Problem;\n"
  },
  {
    "language": "Ada",
    "code": "type Queue is limited interface;\nprocedure Enqueue (Lounge : in out Queue; Item : in out Element) is abstract;\nprocedure Dequeue (Lounge : in out Queue; Item : in out Element) is abstract;\n"
  },
  {
    "language": "Ada",
    "code": "type Scheduler is task interface;\nprocedure Plan (Manager : in out Scheduler; Activity : in out Job) is abstract;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Finalization;\n...\ntype Node is abstract new Ada.Finalization.Limited_Controlled and Queue with record\n   Previous : not null access Node'Class := Node'Unchecked_Access;\n   Next     : not null access Node'Class := Node'Unchecked_Access;\nend record;\noverriding procedure Finalize (X : in out Node); -- Removes the node from its list if any\noverriding procedure Dequeue (Lounge : in out Node; Item : in out Element);\noverriding procedure Enqueue (Lounge : in out Node; Item : in out Element);\nprocedure Process (X : in out Node) is abstract; -- To be implemented\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Generic_Divisors;\n\nprocedure ADB_Classification is\n   function Same(P: Positive) return Positive is (P);\n   package Divisor_Sum is new Generic_Divisors\n     (Result_Type => Natural, None => 0, One => Same, Add =>  \"+\");\n\n   type Class_Type is (Deficient, Perfect, Abundant);\n\n   function Class(D_Sum, N: Natural) return Class_Type is\n      (if D_Sum < N then Deficient\n       elsif D_Sum = N then Perfect\n       else Abundant);\n\n   Cls: Class_Type;\n   Results: array (Class_Type) of Natural := (others => 0);\n\n   package NIO is new Ada.Text_IO.Integer_IO(Natural);\n   package CIO is new Ada.Text_IO.Enumeration_IO(Class_Type);\nbegin\n   for N in 1 .. 20_000 loop\n      Cls := Class(Divisor_Sum.Process(N), N);\n      Results(Cls) := Results(Cls)+1;\n   end loop;\n   for Class in Results'Range loop\n      CIO.Put(Class, 12);\n      NIO.Put(Results(Class), 8);\n      Ada.Text_IO.New_Line;\n   end loop;\n   Ada.Text_IO.Put_Line(\"--------------------\");\n   Ada.Text_IO.Put(\"Sum         \");\n   NIO.Put(Results(Deficient)+Results(Perfect)+Results(Abundant), 8);\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put_Line(\"====================\");\nend ADB_Classification;\n"
  },
  {
    "language": "Ada",
    "code": "with Accumulator;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Example is\n   package A is new Accumulator;\n   package B is new Accumulator;\nbegin\n   Put_Line (Integer'Image (A.The_Function (5)));\n   Put_Line (Integer'Image (B.The_Function (3)));\n   Put_Line (Float'Image (A.The_Function (2.3)));\nend;\n"
  },
  {
    "language": "Ada",
    "code": "generic package Accumulator is\n\n--  This Ada generic package represents an accumulator factory.\n--  The required function is provided as The_Function.\n--  The first call to The_Function sets the initial value.\n--  (Marius Amado-Alves)\n\n   function The_Function (X : Integer) return Integer;\n   function The_Function (X : Integer) return Float;\n   function The_Function (X : Float) return Float;\nend;\n"
  },
  {
    "language": "Ada",
    "code": "package body Accumulator is\n\n--  The accumulator lives through three states. It is in Virgin_State\n--  before any use of The_Function. It changes to Integer_State or\n--  Float_State, according to the input type used. The accumulation is\n--  memorized in variable I or F, according to the state. Float_State,\n--  once reached, is never left. A Float output on an Integer_State is\n--  simply a conversion, sans effect on state. (Marius Amado-Alves)\n\n   type State_T is (Virgin_State, Integer_State, Float_State);\n   State : State_T := Virgin_State;\n   I : Integer;\n   F : Float;\n\n   function The_Function (X : Float) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Float_State;\n            F := X;\n            return F;\n         when Integer_State =>\n            State := Float_State;\n            F := Float (I) + X;\n            return F;\n         when Float_State =>\n            F := F + X;\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return Float (I);\n         when Integer_State =>\n            I := I + X;\n            return Float (I);\n         when Float_State =>\n            F := F + Float (X);\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Integer is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return I;\n         when Integer_State =>\n            I := I + X;\n            return I;\n         when Float_State =>\n            F := F + Float (X);\n            return Integer (F);\n      end case;\n   end;\n\nend;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Ackermann is\n   function Ackermann (M, N : Natural) return Natural is\n   begin\n      if M = 0 then\n         return N + 1;\n      elsif N = 0 then\n         return Ackermann (M - 1, 1);\n      else\n         return Ackermann (M - 1, Ackermann (M, N - 1));\n      end if;\n   end Ackermann;\nbegin\n   for M in 0..3 loop\n      for N in 0..6 loop\n         Put (Natural'Image (Ackermann (M, N)));\n      end loop;\n      New_Line;\n   end loop;\nend Test_Ackermann;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Calendar;                       use Ada.Calendar;\nwith Ada.Numerics;                       use Ada.Numerics;\nwith Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;\nwith Ada.Text_IO;                        use Ada.Text_IO;\n\nprocedure Test_Integrator is\n   type Func is access function (T : Time) return Float;\n\n   function Zero (T : Time) return Float is\n   begin\n      return 0.0;\n   end Zero;\n\n   Epoch : constant Time := Clock;\n\n   function Sine (T : Time) return Float is\n   begin\n      return Sin (Pi * Float (T - Epoch));\n   end Sine;\n\n   task type Integrator is\n      entry Input  (Value : Func);\n      entry Output (Value : out Float);\n      entry Shut_Down;\n   end Integrator;\n\n   task body Integrator is\n      K  : Func  := Zero'Access;\n      S  : Float := 0.0;\n      F0 : Float := 0.0;\n      F1 : Float;\n      T0 : Time  := Clock;\n      T1 : Time;\n   begin\n      loop\n         select\n            accept Input (Value : Func) do\n               K := Value;\n            end Input;\n         or accept Output (Value : out Float) do\n               Value := S;\n            end Output;\n         or accept Shut_Down;\n            exit;\n         else\n            T1 := Clock;\n            F1 := K (T1);\n            S  := S + 0.5 * (F1 + F0) * Float (T1 - T0);\n            T0 := T1;\n            F0 := F1;\n         end select;\n      end loop;\n   end Integrator;\n\n   I : Integrator;\n   S : Float;\nbegin\n   I.Input (Sine'Access);\n   delay 2.0;\n   I.Input (Zero'Access);\n   delay 0.5;\n   I.Output (S);\n   Put_Line (\"Integrated\" & Float'Image (S) & \"s\");\n   I.Shut_Down;\nend Test_Integrator;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Dynamic is\n   package Abstract_Class is\n      type Class is limited interface;\n      function Boo (X : Class) return String is abstract;\n   end Abstract_Class;\n   use Abstract_Class;\n\n   package Base_Class is\n      type Base is new Class with null record;\n      overriding function Boo (X : Base) return String;\n   end Base_Class;\n\n   package body Base_Class is\n      function Boo (X : Base) return String is\n      begin\n         return \"I am Class\";\n      end Boo;\n   end Base_Class;\n   use Base_Class;\n\n   E : aliased Base;  -- An instance of Base\n\nbegin\n   -- Gone run-time\n   declare\n      type Monkey_Patch (Root : access Base) is new Class with record\n         Foo : Integer := 1;\n      end record;\n      overriding function Boo (X : Monkey_Patch) return String;\n      function Boo (X : Monkey_Patch) return String is\n      begin -- Delegation to the base\n         return X.Root.Boo;\n      end Boo;\n      EE : Monkey_Patch (E'Access); -- Extend E\n   begin\n      Put_Line (EE.Boo & \" with\" & Integer'Image (EE.Foo));\n   end;\nend Dynamic;\n"
  },
  {
    "language": "Ada",
    "code": "The_Address : System.Address;\nI : Integer;\nThe_Address := I'Address;\n"
  },
  {
    "language": "Ada",
    "code": "I : Integer;\nfor I'Address use 16#A100#;\n"
  },
  {
    "language": "Ada",
    "code": "I : Integer;\nJ : Integer;\nfor I'Address use J'Address;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\n\nprocedure Test_For_Primes is\n\n   type Pascal_Triangle_Type is array (Natural range <>) of Long_Long_Integer;\n\n   function Calculate_Pascal_Triangle (N : in Natural) return Pascal_Triangle_Type is\n      Pascal_Triangle : Pascal_Triangle_Type (0 .. N);\n   begin\n      Pascal_Triangle (0) := 1;\n      for I in Pascal_Triangle'First .. Pascal_Triangle'Last - 1 loop\n         Pascal_Triangle (1 + I) := 1;\n         for J in reverse 1 .. I loop\n            Pascal_Triangle (J) := Pascal_Triangle (J - 1) - Pascal_Triangle (J);\n         end loop;\n         Pascal_Triangle (0) := -Pascal_Triangle (0);\n      end loop;\n      return Pascal_Triangle;\n   end Calculate_Pascal_Triangle;\n\n   function Is_Prime (N : Integer) return Boolean is\n      I      : Integer;\n      Result : Boolean := True;\n      Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n   begin\n      I := N / 2;\n      while Result and I > 1 loop\n         Result := Result and Pascal_Triangle (I) mod Long_Long_Integer (N) = 0;\n         I := I - 1;\n      end loop;\n      return Result;\n   end Is_Prime;\n\n   function Image (N    : in Long_Long_Integer;\n                   Sign : in Boolean := False) return String is\n      Image : constant String := N'Image;\n   begin\n      if N < 0 then\n         return Image;\n      else\n         if Sign then\n            return \"+\" & Image (Image'First + 1 .. Image'Last);\n         else\n            return Image (Image'First + 1 .. Image'Last);\n         end if;\n      end if;\n   end Image;\n\n   procedure Show (Triangle : in Pascal_Triangle_Type) is\n      use Ada.Text_IO;\n   Begin\n      for I in reverse Triangle'Range loop\n         Put (Image (Triangle (I), Sign => True));\n         Put (\"x^\");\n         Put (Image (Long_Long_Integer (I)));\n         Put (\" \");\n      end loop;\n   end Show;\n\n   procedure Show_Pascal_Triangles is\n      use Ada.Text_IO;\n   begin\n      for N in 0 .. 9 loop\n         declare\n            Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n         begin\n            Put (\"(x-1)^\" & Image (Long_Long_Integer (N)) & \" = \");\n            Show (Pascal_Triangle);\n            New_Line;\n         end;\n      end loop;\n   end Show_Pascal_Triangles;\n\n   procedure Show_Primes is\n      use Ada.Text_IO;\n   begin\n      for N in 2 .. 63 loop\n         if Is_Prime (N) then\n            Put (N'Image);\n         end if;\n      end loop;\n      New_Line;\n   end Show_Primes;\n\nbegin\n   Show_Pascal_Triangles;\n   Show_Primes;\nend Test_For_Primes;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Characters.Latin_1;  use Ada.Characters.Latin_1;\nwith Ada.Text_IO;             use Ada.Text_IO;\nwith Strings_Edit;            use Strings_Edit;\n\nprocedure Column_Aligner is\n   Text : constant String :=\n      \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & NUL &\n      \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & NUL &\n      \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & NUL &\n      \"column$are$separated$by$at$least$one$space.\" & NUL &\n      \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & NUL &\n      \"justified,$right$justified,$or$center$justified$within$its$column.\" & NUL;\n   File    : File_Type;\n   Width   : array (1..1_000) of Natural := (others => 0);\n   Line    : String (1..200);\n   Column  : Positive := 1;\n   Start   : Positive := 1;\n   Pointer : Positive;\nbegin\n   Create (File, Out_File, \"columned.txt\");\n      -- Determining the widths of columns\n   for I in Text'Range loop\n      case Text (I) is\n         when '$' | NUL =>\n            Width (Column) := Natural'Max (Width (Column), I - Start + 1);\n            Start  := I + 1;\n            if Text (I) = NUL then\n               Column := 1;\n            else\n               Column := Column + 1;\n            end if;\n         when others =>\n            null;\n      end case;\n   end loop;\n      -- Formatting\n   for Align in Alignment loop\n      Column  := 1;\n      Start   := 1;\n      Pointer := 1;\n      for I in Text'Range loop\n         case Text (I) is\n            when '$' | NUL =>\n               Put -- Formatted output of a word\n               (  Destination => Line,\n                  Pointer     => Pointer,\n                  Value       => Text (Start..I - 1),\n                  Field       => Width (Column),\n                  Justify     => Align\n               );\n               Start  := I + 1;\n               if Text (I) = NUL then\n                  Put_Line (File, Line (1..Pointer - 1));\n                  Pointer := 1;\n                  Column := 1;\n               else\n                  Column := Column + 1;\n               end if;\n            when others =>\n               null;\n         end case;\n      end loop;\n   end loop;\n   Close (File);\nend Column_Aligner;\n"
  },
  {
    "language": "Ada",
    "code": "with Prime_Numbers, Ada.Text_IO;\n\nprocedure Test_Kth_Prime is\n\n   package Integer_Numbers is new\n     Prime_Numbers (Natural, 0, 1, 2);\n   use Integer_Numbers;\n\n   Out_Length: constant Positive := 10; -- 10 k-th almost primes\n   N: Positive; -- the \"current number\" to be checked\n\nbegin\n   for K in 1 .. 5 loop\n      Ada.Text_IO.Put(\"K =\" & Integer'Image(K) &\":  \");\n      N := 2;\n      for I in 1 .. Out_Length loop\n\t while Decompose(N)'Length /= K loop\n\t    N := N + 1;\n\t end loop; -- now N is Kth almost prime;\n\t Ada.Text_IO.Put(Integer'Image(Integer(N)));\n\t N := N + 1;\n      end loop;\n      Ada.Text_IO.New_Line;\n   end loop;\nend Test_Kth_Prime;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;\nwith Ada.Text_IO;            use Ada.Text_IO;\n\nprocedure Test_Amb is\n   type Alternatives is array (Positive range <>) of Unbounded_String;\n\n   type Amb (Count : Positive) is record\n      This : Positive := 1;\n      Left : access Amb;\n      List : Alternatives (1..Count);\n   end record;\n\n   function Image (L : Amb) return String is\n   begin\n      return To_String (L.List (L.This));\n   end Image;\n\n   function \"/\" (L, R : String) return Amb is\n      Result : Amb (2);\n   begin\n      Append (Result.List (1), L);\n      Append (Result.List (2), R);\n      return Result;\n   end \"/\";\n\n   function \"/\" (L : Amb; R : String) return Amb is\n      Result : Amb (L.Count + 1);\n   begin\n      Result.List (1..L.Count) := L.List ;\n      Append (Result.List (Result.Count), R);\n      return Result;\n   end \"/\";\n\n   function \"=\" (L, R : Amb) return Boolean is\n      Left : Unbounded_String renames L.List (L.This);\n   begin\n      return Element (Left, Length (Left)) = Element (R.List (R.This), 1);\n   end \"=\";\n\n   procedure Failure (L : in out Amb) is\n   begin\n      loop\n         if L.This < L.Count then\n            L.This := L.This + 1;\n         else\n            L.This := 1;\n            Failure (L.Left.all);\n         end if;\n         exit when L.Left = null or else L.Left.all = L;\n      end loop;\n   end Failure;\n\n   procedure Join (L : access Amb; R : in out Amb) is\n   begin\n      R.Left := L;\n      while L.all /= R loop\n         Failure (R);\n      end loop;\n   end Join;\n\n   W_1 : aliased Amb := \"the\" / \"that\" / \"a\";\n   W_2 : aliased Amb := \"frog\" / \"elephant\" / \"thing\";\n   W_3 : aliased Amb := \"walked\" / \"treaded\" / \"grows\";\n   W_4 : aliased Amb := \"slowly\" / \"quickly\";\nbegin\n   Join (W_1'Access, W_2);\n   Join (W_2'Access, W_3);\n   Join (W_3'Access, W_4);\n   Put_Line (Image (W_1) & ' ' & Image (W_2) & ' ' & Image (W_3) & ' ' & Image (W_4));\nend Test_Amb;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Generic_Divisors; use Ada.Text_IO;\n\nprocedure Amicable_Pairs is\n\n   function Same(P: Positive) return Positive is (P);\n\n   package Divisor_Sum is new Generic_Divisors\n     (Result_Type => Natural, None => 0, One => Same, Add =>  \"+\");\n\n   Num2 : Integer;\nbegin\n   for Num1 in 4 .. 20_000 loop\n      Num2 := Divisor_Sum.Process(Num1);\n      if Num1 < Num2 then\n\t if Num1 = Divisor_Sum.Process(Num2) then\n\t   Put_Line(Integer'Image(Num1) & \",\" & Integer'Image(Num2));\n\t end if;\n      end if;\n   end loop;\nend Amicable_Pairs;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Generic_Array_Sort;\nwith Ada.Containers.Indefinite_Vectors;\nprocedure Danagrams is\n   package StringVector is new Ada.Containers.Indefinite_Vectors\n      (Positive, String);\n   procedure StrSort is new Ada.Containers.Generic_Array_Sort\n      (Index_Type => Positive,\n      Element_Type => Character,\n      Array_Type => String);\n   function Derange (s1 : String; s2 : String) return Boolean is begin\n      for i in s1'Range loop\n         if (s1 (i) = s2 (i)) then return False; end if;\n      end loop;\n      return True;\n   end Derange;\n   File : File_Type;\n   len, foundlen : Positive := 1;\n   Vect, SVect : StringVector.Vector;\n   index, p1, p2 : StringVector.Extended_Index := 0;\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   while not End_Of_File (File) loop\n      declare str : String := Get_Line (File);\n      begin\n         len := str'Length;\n         if len > foundlen then\n            Vect.Append (str);\n            StrSort (str);\n            index := 0;\n            loop --  Loop through anagrams by index in vector of sorted strings\n               index := SVect.Find_Index (str, index + 1);\n               exit when index = StringVector.No_Index;\n               if Derange (Vect.Last_Element, Vect.Element (index)) then\n                     p1 := Vect.Last_Index; p2 := index;\n                     foundlen := len;\n               end if;\n            end loop;\n            SVect.Append (str);\n         end if;\n      end;\n   end loop;\n   Close (File);\n   Put_Line (Vect.Element (p1) & \" \" & Vect.Element (p2));\nend Danagrams;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\n\nwith Ada.Containers.Indefinite_Ordered_Maps;\nwith Ada.Containers.Indefinite_Ordered_Sets;\n\nprocedure Words_Of_Equal_Characters is\n   package Set_Of_Words is new Ada.Containers.Indefinite_Ordered_Sets (String);\n   use Ada.Containers, Set_Of_Words;\n   package Anagrams is new Ada.Containers.Indefinite_Ordered_Maps (String, Set);\n   use Anagrams;\n\n   File   : File_Type;\n   Result : Map;\n   Max    : Count_Type := 1;\n\n   procedure Put (Position : Anagrams.Cursor) is\n      First : Boolean := True;\n      List  : Set renames Element (Position);\n      procedure Put (Position : Set_Of_Words.Cursor) is\n      begin\n         if First then\n            First := False;\n         else\n            Put (',');\n         end if;\n         Put (Element (Position));\n      end Put;\n   begin\n      if List.Length = Max then\n         Iterate (List, Put'Access);\n         New_Line;\n      end if;\n   end Put;\n\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   loop\n      declare\n         Word : constant String     := Get_Line (File);\n         Key  : String (Word'Range) := (others => Character'Last);\n         List : Set;\n         Position : Anagrams.Cursor;\n      begin\n         for I in Word'Range loop\n            for J in Word'Range loop\n               if Key (J) > Word (I) then\n                  Key (J + 1..I) := Key (J..I - 1);\n                  Key (J) := Word (I);\n                  exit;\n               end if;\n            end loop;\n         end loop;\n         Position := Find (Result, Key);\n         if Has_Element (Position) then\n            List := Element (Position);\n            Insert (List, Word);\n            Replace_Element (Result, Position, List);\n         else\n            Insert (List, Word);\n            Include (Result, Key, List);\n         end if;\n         Max := Count_Type'Max (Max, Length (List));\n      end;\n   end loop;\nexception\n   when End_Error =>\n      Iterate (Result, Put'Access);\n      Close (File);\nend Words_Of_Equal_Characters;\n"
  },
  {
    "language": "Ada",
    "code": "generic\n   type Float_Type is digits <>;\n   Gravitation : Float_Type;\npackage Pendulums is\n   type Pendulum is private;\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum;\n   function Get_X (From : Pendulum) return Float_Type;\n   function Get_Y (From : Pendulum) return Float_Type;\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration);\nprivate\n   type Pendulum is record\n      Length   : Float_Type;\n      Theta    : Float_Type;\n      X        : Float_Type;\n      Y        : Float_Type;\n      Velocity : Float_Type;\n   end record;\nend Pendulums;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Elementary_Functions;\npackage body Pendulums is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float_Type);\n\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum is\n      Result : Pendulum;\n   begin\n      Result.Length   := Length;\n      Result.Theta    := Theta0 / 180.0 * Ada.Numerics.Pi;\n      Result.X        := Math.Sin (Theta0) * Length;\n      Result.Y        := Math.Cos (Theta0) * Length;\n      Result.Velocity := 0.0;\n      return Result;\n   end New_Pendulum;\n\n   function Get_X (From : Pendulum) return Float_Type is\n   begin\n      return From.X;\n   end Get_X;\n\n   function Get_Y (From : Pendulum) return Float_Type is\n   begin\n      return From.Y;\n   end Get_Y;\n\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration) is\n      Acceleration : constant Float_Type := Gravitation / Item.Length *\n                                            Math.Sin (Item.Theta);\n   begin\n         Item.X        := Math.Sin (Item.Theta) * Item.Length;\n         Item.Y        := Math.Cos (Item.Theta) * Item.Length;\n         Item.Velocity := Item.Velocity +\n                          Acceleration  * Float_Type (Time);\n         Item.Theta    := Item.Theta +\n                          Item.Velocity * Float_Type (Time);\n   end Update_Pendulum;\nend Pendulums;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;\nwith Ada.Calendar;\nwith Pendulums;\n\nprocedure Main is\n   package Float_Pendulum is new Pendulums (Float, -9.81);\n   use Float_Pendulum;\n   use type Ada.Calendar.Time;\n\n   My_Pendulum : Pendulum := New_Pendulum (10.0, 30.0);\n   Now, Before : Ada.Calendar.Time;\nbegin\n   Before := Ada.Calendar.Clock;\n   loop\n      Delay 0.1;\n      Now := Ada.Calendar.Clock;\n      Update_Pendulum (My_Pendulum, Now - Before);\n      Before := Now;\n      -- output positions relative to origin\n      -- replace with graphical output if wanted\n      Ada.Text_IO.Put_Line (\" X: \" & Float'Image (Get_X (My_Pendulum)) &\n                            \" Y: \" & Float'Image (Get_Y (My_Pendulum)));\n   end loop;\nend Main;\n"
  },
  {
    "language": "Ada",
    "code": "with Gtk.Main;\nwith Gtk.Handlers;\nwith Gtk.Label;\nwith Gtk.Button;\nwith Gtk.Window;\nwith Glib.Main;\n\nprocedure Animation is\n   Scroll_Forwards : Boolean := True;\n\n   package Button_Callbacks is new Gtk.Handlers.Callback\n     (Gtk.Button.Gtk_Button_Record);\n\n   package Label_Timeout is new Glib.Main.Generic_Sources\n     (Gtk.Label.Gtk_Label);\n\n   package Window_Callbacks is new Gtk.Handlers.Return_Callback\n     (Gtk.Window.Gtk_Window_Record, Boolean);\n\n   --  Callback for click event\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class);\n\n   --  Callback for delete event\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean;\n\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class)\n   is\n      pragma Unreferenced (Object);\n   begin\n      Scroll_Forwards := not Scroll_Forwards;\n   end On_Button_Click;\n\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean\n   is\n      pragma Unreferenced (Object);\n   begin\n      Gtk.Main.Main_Quit;\n      return True;\n   end On_Main_Window_Delete;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean is\n      Text : constant String := Gtk.Label.Get_Text (Data);\n   begin\n      if Scroll_Forwards then\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'First + 1 .. Text'Last) & Text (Text'First));\n      else\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'Last) & Text (Text'First .. Text'Last - 1));\n      end if;\n      return True;\n   end Scroll_Text;\n\n   Main_Window     : Gtk.Window.Gtk_Window;\n   Text_Button     : Gtk.Button.Gtk_Button;\n   Scrolling_Text  : Gtk.Label.Gtk_Label;\n   Timeout_ID      : Glib.Main.G_Source_Id;\n   pragma Unreferenced (Timeout_ID);\n\nbegin\n   Gtk.Main.Init;\n   Gtk.Window.Gtk_New (Window => Main_Window);\n   Gtk.Label.Gtk_New (Label => Scrolling_Text, Str => \"Hello World! \");\n   Gtk.Button.Gtk_New (Button => Text_Button);\n   Gtk.Button.Add (Container => Text_Button, Widget => Scrolling_Text);\n   Button_Callbacks.Connect\n     (Widget => Text_Button,\n      Name   => \"clicked\",\n      Marsh  => Button_Callbacks.To_Marshaller (On_Button_Click'Access));\n   Timeout_ID :=\n     Label_Timeout.Timeout_Add\n       (Interval => 125,\n        Func     => Scroll_Text'Access,\n        Data     => Scrolling_Text);\n   Gtk.Window.Add (Container => Main_Window, Widget => Text_Button);\n   Window_Callbacks.Connect\n     (Widget => Main_Window,\n      Name   => \"delete_event\",\n      Marsh  => Window_Callbacks.To_Marshaller (On_Main_Window_Delete'Access));\n   Gtk.Window.Show_All (Widget => Main_Window);\n   Gtk.Main.Main;\nend Animation;\n"
  },
  {
    "language": "Ada",
    "code": "   function Fib (X: in Integer) return Integer is\n      function Actual_Fib (N: in Integer) return Integer is\n      begin\n         if N < 2 then\n            return N;\n         else\n            return Actual_Fib (N-1) + Actual_Fib (N-2);\n         end if;\n      end Actual_Fib;\n   begin\n      if X < 0 then\n         raise Constraint_Error;\n      else\n         return Actual_Fib (X);\n      end if;\n   end Fib;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io;\n with Ada.Integer_text_IO;\n\n procedure Call_Back_Example is\n    -- Purpose: Apply a callback to an array\n    -- Output: Prints the squares of an integer array to the console\n\n    -- Define the callback procedure\n    procedure Display(Location : Positive; Value : Integer) is\n    begin\n       Ada.Text_Io.Put(\"array(\");\n       Ada.Integer_Text_Io.Put(Item => Location, Width => 1);\n       Ada.Text_Io.Put(\") = \");\n       Ada.Integer_Text_Io.Put(Item => Value * Value, Width => 1);\n       Ada.Text_Io.New_Line;\n    end Display;\n\n    -- Define an access type matching the signature of the callback procedure\n    type Call_Back_Access is access procedure(L : Positive; V : Integer);\n\n    -- Define an unconstrained array type\n    type Value_Array is array(Positive range <>) of Integer;\n\n    -- Define the procedure performing the callback\n    procedure Map(Values : Value_Array; Worker : Call_Back_Access) is\n    begin\n       for I in Values'range loop\n          Worker(I, Values(I));\n       end loop;\n    end Map;\n\n    -- Define and initialize the actual array\n    Sample : Value_Array := (5,4,3,2,1);\n\n begin\n    Map(Sample, Display'access);\n end Call_Back_Example;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith GNATCOLL.GMP; use GNATCOLL.GMP;\nwith GNATCOLL.GMP.Integers; use GNATCOLL.GMP.Integers;\nprocedure ArbitraryInt is\n   type stracc is access String;\n   BigInt : Big_Integer;\n   len : Natural;\n   str : stracc;\nbegin\n   Set (BigInt, 5);\n   Raise_To_N (BigInt, Unsigned_Long (4**(3**2)));\n   str := new String'(Image (BigInt));\n   len := str'Length;\n   Put_Line (\"Size is:\"& Natural'Image (len));\n   Put_Line (str (1 .. 20) & \".....\" & str (len - 19 .. len));\nend ArbitraryInt;\n"
  },
  {
    "language": "Ada",
    "code": "type My_Pointer is access My_Object;\nfor My_Pointer'Storage_Pool use My_Pool;\n"
  },
  {
    "language": "Ada",
    "code": "with System.Storage_Elements;  use System.Storage_Elements;\nwith System.Storage_Pools;     use System.Storage_Pools;\n\npackage Arena_Pools is\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with private;\n   overriding\n      procedure Allocate\n                (  Pool      : in out Arena;\n                   Address   : out System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                );\n   overriding\n      procedure Deallocate\n                (  Pool      : in out Arena;\n                   Address   : System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                )  is null;\n   overriding\n      function Storage_Size (Pool : Arena) return Storage_Count;\nprivate\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with record\n      Free : Storage_Offset := 1;\n      Core : Storage_Array (1..Size);\n   end record;\nend Arena_Pools;\n"
  },
  {
    "language": "Ada",
    "code": "package body Arena_Pools is\n   procedure Allocate\n             (  Pool      : in out Arena;\n                Address   : out System.Address;\n                Size      : Storage_Count;\n                Alignment : Storage_Count\n             )  is\n      Free : constant Storage_Offset :=\n         Pool.Free + Alignment - Pool.Core (Pool.Free)'Address mod Alignment + Size;\n   begin\n      if Free - 1 > Pool.Size then\n         raise Storage_Error;\n      end if;\n      Pool.Free := Free;\n      Address := Pool.Core (Pool.Free - Size)'Address;\n   end Allocate;\n\n   function Storage_Size (Pool : Arena) return Storage_Count is\n   begin\n      return Pool.Size;\n   end Storage_Size;\nend Arena_Pools;\n"
  },
  {
    "language": "Ada",
    "code": "with Arena_Pools;\nuse  Arena_Pools;\n\nprocedure Test_Allocator is\n   Pool : Arena_Pools.Arena (1024);\n   type Integer_Ptr is access Integer;\n   for Integer_Ptr'Storage_Pool use Pool;\n\n   X : Integer_Ptr := new Integer'(1);\n   Y : Integer_Ptr := new Integer'(2);\n   Z : Integer_Ptr;\nbegin\n   Z := new Integer;\n   Z.all := X.all + Y.all;\nend Test_Allocator;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Numerics.Generic_Complex_Types;\nwith Ada.Text_IO.Complex_IO;\n\nprocedure Complex_Operations is\n   -- Ada provides a pre-defined generic package for complex types\n   -- That package contains definitions for composition,\n   -- negation, addition, subtraction, multiplication, division,\n   -- conjugation, exponentiation, and absolute value, as well as\n   -- basic comparison operations.\n   -- Ada provides a second pre-defined package for sin, cos, tan, cot,\n   -- arcsin, arccos, arctan, arccot, and the hyperbolic versions of\n   -- those trigonometric functions.\n\n   -- The package Ada.Numerics.Generic_Complex_Types requires definition\n   -- with the real type to be used in the complex type definition.\n\n   package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Long_Float);\n   use Complex_Types;\n   package Complex_IO is new Ada.Text_IO.Complex_IO (Complex_Types);\n   use Complex_IO;\n   use Ada.Text_IO;\n\n   A : Complex := Compose_From_Cartesian (Re => 1.0, Im => 1.0);\n   B : Complex := Compose_From_Polar (Modulus => 1.0, Argument => 3.14159);\n   C : Complex;\n\nbegin\n   -- Addition\n   C := A + B;\n   Put(\"A + B = \"); Put(C);\n   New_Line;\n   -- Multiplication\n   C := A * B;\n   Put(\"A * B = \"); Put(C);\n   New_Line;\n   -- Inversion\n   C := 1.0 / A;\n   Put(\"1.0 / A = \"); Put(C);\n   New_Line;\n   -- Negation\n   C := -A;\n   Put(\"-A = \"); Put(C);\n   New_Line;\n   -- Conjugation\n   C := Conjugate (C);\nend Complex_Operations;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO, Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Arith_Geom_Mean is\n\n   type Num is digits 18; -- the largest value gnat/gcc allows\n   package N_IO is new Ada.Text_IO.Float_IO(Num);\n   package Math is new Ada.Numerics.Generic_Elementary_Functions(Num);\n\n   function AGM(A, G: Num) return Num is\n      Old_G: Num;\n      New_G: Num := G;\n      New_A: Num := A;\n   begin\n      loop\n         Old_G := New_G;\n         New_G := Math.Sqrt(New_A*New_G);\n         New_A := (Old_G + New_A) * 0.5;\n         exit when (New_A - New_G) <= Num'Epsilon;\n         -- Num'Epsilon denotes the relative error when performing arithmetic over Num\n      end loop;\n      return New_G;\n   end AGM;\n\nbegin\n   N_IO.Put(AGM(1.0, 1.0/Math.Sqrt(2.0)), Fore => 1, Aft => 17, Exp => 0);\nend Arith_Geom_Mean;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_Io;\nwith Ada.Integer_Text_IO;\n\nprocedure Integer_Arithmetic is\n   use Ada.Text_IO;\n   use Ada.Integer_Text_Io;\n\n   A, B : Integer;\nbegin\n   Get(A);\n   Get(B);\n   Put_Line(\"a+b = \" & Integer'Image(A + B));\n   Put_Line(\"a-b = \" & Integer'Image(A - B));\n   Put_Line(\"a*b = \" & Integer'Image(A * B));\n   Put_Line(\"a/b = \" & Integer'Image(A / B));\n   Put_Line(\"a mod b = \" & Integer'Image(A mod B)); -- Sign matches B\n   Put_Line(\"remainder of a/b = \" & Integer'Image(A rem B)); -- Sign matches A\n   Put_Line(\"a**b = \" & Integer'Image(A ** B));\n\nend Integer_Arithmetic;\n"
  },
  {
    "language": "Ada",
    "code": "type T is array (Positive range <>) of Integer;\nX : T := (1, 2, 3);\nY : T := X & (4, 5, 6); -- Concatenate X and (4, 5, 6)\n"
  },
  {
    "language": "Ada",
    "code": "procedure Array_Test is\n\n   A, B : array (1..20) of Integer;\n\n   -- Ada array indices may begin at any value, not just 0 or 1\n   C : array (-37..20) of integer\n\n   -- Ada arrays may be indexed by enumerated types, which are\n   -- discrete non-numeric types\n   type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\n   type Activities is (Work, Fish);\n   type Daily_Activities is array(Days) of Activities;\n   This_Week : Daily_Activities := (Mon..Fri => Work, Others => Fish);\n\n   -- Or any numeric type\n   type Fingers is range 1..4; -- exclude thumb\n   type Fingers_Extended_Type is array(fingers) of Boolean;\n   Fingers_Extended : Fingers_Extended_Type;\n\n   -- Array types may be unconstrained. The variables of the type\n   -- must be constrained\n   type Arr is array (Integer range <>) of Integer;\n   Uninitialized : Arr (1 .. 10);\n   Initialized_1 : Arr (1 .. 20) := (others => 1);\n   Initialized_2 : Arr := (1 .. 30 => 2);\n   Const         : constant Arr := (1 .. 10 => 1, 11 .. 20 => 2, 21 | 22 => 3);\n   Centered      : Arr (-50..50) := (0 => 1, Others => 0);\n\n   Result        : Integer\nbegin\n\n   A := (others => 0);     -- Assign whole array\n   B := (1 => 1, 2 => 1, 3 => 2, others => 0);\n                           -- Assign whole array, different values\n   A (1) := -1;            -- Assign individual element\n   A (2..4) := B (1..3);   -- Assign a slice\n   A (3..5) := (2, 4, -1); -- Assign a constant slice\n   A (3..5) := A (4..6);   -- It is OK to overlap slices when assigned\n\n   Fingers_Extended'First := False; -- Set first element of array\n   Fingers_Extended'Last := False;  -- Set last element of array\n\nend Array_Test;\n"
  },
  {
    "language": "Ada",
    "code": "pragma Assert (A = 42, \"Oops!\");\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Assertions;  use Ada.Assertions;\n...\nAssert (A = 42, \"Oops!\");\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Containers.Ordered_Maps;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;\n\nprocedure Associative_Array is\n\n   -- Instantiate the generic package Ada.Containers.Ordered_Maps\n\n   package Associative_Int is new Ada.Containers.Ordered_Maps(Unbounded_String, Integer);\n   use Associative_Int;\n\n   Color_Map : Map;\n   Color_Cursor : Cursor;\n   Success : Boolean;\n   Value : Integer;\nbegin\n\n   -- Add values to the ordered map\n\n   Color_Map.Insert(To_Unbounded_String(\"Red\"), 10, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Blue\"), 20, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Yellow\"), 5, Color_Cursor, Success);\n\n   -- retrieve values from the ordered map and print the value and key\n   -- to the screen\n\n   Value := Color_Map.Element(To_Unbounded_String(\"Red\"));\n   Ada.Text_Io.Put_Line(\"Red:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Blue\"));\n   Ada.Text_IO.Put_Line(\"Blue:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Yellow\"));\n   Ada.Text_IO.Put_Line(\"Yellow:\" & Integer'Image(Value));\nend Associative_Array;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Containers.Indefinite_Ordered_Maps;\n\nprocedure Test_Iteration is\n   package String_Maps is\n      new Ada.Containers.Indefinite_Ordered_Maps (String, Integer);\n   use String_Maps;\n   A     : Map;\n   Index : Cursor;\nbegin\n   A.Insert (\"hello\", 1);\n   A.Insert (\"world\", 2);\n   A.Insert (\"!\",     3);\n   Index := A.First;\n   while Index /= No_Element loop\n      Put_Line (Key (Index) & Integer'Image (Element (Index)));\n      Index := Next (Index);\n   end loop;\nend Test_Iteration;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\n\nprocedure Test_Updates is\n\n   type Bucket_Index is range 1..13;\n   package Random_Index is new Ada.Numerics.Discrete_Random (Bucket_Index);\n   use Random_Index;\n   type Buckets is array (Bucket_Index) of Natural;\n\n   protected type Safe_Buckets is\n      procedure Initialize (Value : Buckets);\n      function Get (I : Bucket_Index) return Natural;\n      procedure Transfer (I, J : Bucket_Index; Amount : Integer);\n      function Snapshot return Buckets;\n   private\n      Data : Buckets := (others => 0);\n   end Safe_Buckets;\n\n   protected body Safe_Buckets is\n      procedure Initialize (Value : Buckets) is\n      begin\n         Data := Value;\n      end Initialize;\n\n      function Get (I : Bucket_Index) return Natural is\n      begin\n         return Data (I);\n      end Get;\n\n      procedure Transfer (I, J : Bucket_Index; Amount : Integer) is\n         Increment : constant Integer :=\n            Integer'Max (-Data (J), Integer'Min (Data (I), Amount));\n      begin\n         Data (I) := Data (I) - Increment;\n         Data (J) := Data (J) + Increment;\n      end Transfer;\n\n      function Snapshot return Buckets is\n      begin\n         return Data;\n      end Snapshot;\n   end Safe_Buckets;\n\n   Data : Safe_Buckets;\n\n   task Equalize;\n   task Mess_Up;\n\n   task body Equalize is\n      Dice : Generator;\n      I, J : Bucket_Index;\n   begin\n      loop\n         I := Random (Dice);\n         J := Random (Dice);\n         Data.Transfer (I, J, (Data.Get (I) - Data.Get (J)) / 2);\n      end loop;\n   end Equalize;\n\n   task body Mess_Up is\n      Dice : Generator;\n   begin\n      loop\n         Data.Transfer (Random (Dice), Random (Dice), 100);\n      end loop;\n   end Mess_Up;\n\nbegin\n   Data.Initialize ((1,2,3,4,5,6,7,8,9,10,11,12,13));\n   loop\n      delay 1.0;\n      declare\n         State : Buckets := Data.Snapshot;\n         Sum   : Natural := 0;\n      begin\n         for Index in State'Range loop\n            Sum := Sum + State (Index);\n            Put (Integer'Image (State (Index)));\n         end loop;\n         Put (\" =\" & Integer'Image (Sum));\n         New_Line;\n      end;\n   end loop;\nend Test_Updates;\n"
  },
  {
    "language": "Ada",
    "code": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Numerics.Generic_Elementary_Functions;\nwith Ada.Numerics.Discrete_Random;\nprocedure Avglen is\n   package IIO is new Ada.Text_IO.Integer_IO (Positive); use IIO;\n   package LFIO is new Ada.Text_IO.Float_IO (Long_Float); use LFIO;\n   subtype FactN is Natural range 0..20;\n   TESTS : constant Natural := 1_000_000;\n\n   function Factorial (N : FactN) return Long_Float is\n      Result : Long_Float := 1.0;\n   begin\n      for I in 2..N loop Result := Result * Long_Float(I); end loop;\n      return Result;\n   end Factorial;\n\n   function Analytical (N : FactN) return Long_Float is\n      Sum : Long_Float := 0.0;\n   begin\n      for I in 1..N loop\n         Sum := Sum + Factorial(N) / Factorial(N - I) / Long_Float(N)**I;\n      end loop;\n      return Sum;\n   end Analytical;\n\n   function Experimental (N : FactN) return Long_Float is\n      subtype RandInt is Natural range 1..N;\n      package Random is new Ada.Numerics.Discrete_Random(RandInt);\n      seed : Random.Generator;\n      Num : RandInt;\n      count : Natural := 0;\n      bits : array(RandInt'Range) of Boolean;\n   begin\n      Random.Reset(seed);\n      for run in 1..TESTS loop\n         bits := (others  => false);\n         for I in RandInt'Range loop\n            Num := Random.Random(seed); exit when bits(Num);\n            bits(Num) := True; count := count + 1;\n         end loop;\n      end loop;\n      return Long_Float(count)/Long_Float(TESTS);\n   end Experimental;\n\n   A, E, err : Long_Float;\nbegin\n   Put_Line(\" N  avg    calc   %diff\");\n   for I in 1..20 loop\n      A := Analytical(I);  E := Experimental(I); err := abs(E-A)/A*100.0;\n      Put(I, Width=>2); Put(E ,Aft=>4, exp=>0); Put(A, Aft=>4, exp=>0);\n      Put(err, Fore=>3, Aft=>3, exp=>0); New_line;\n   end loop;\nend Avglen;\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nConsole.WriteLine(\"Hello World\");\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nconst double X = 3.141592653;\ndouble x = 3.141592653589793;\nConsole.WriteLine(x + X);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A;\n}\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nint[] B = {1, 2, 3};\nConsole.WriteLine(A[0] + A[1] + A[2]);\nConsole.WriteLine(B[0] + B[1] + B[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = new string[3];\nA[0] = \"a\";\nA[1] = \"b\";\nA[2] = \"c\";\nConsole.WriteLine(A[0] + A[1] + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nstring x = A[1];\nstring y = A[2];\nConsole.WriteLine(x + y);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nstring x = A[1];\nA[0] = \"d\";\nA[1] = A[2];\nA[2] = x;\nConsole.WriteLine(A[0] + A[1] + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\npublic class FileManipulator\n{\n    public void MoveFile(string sourceFilePath, string destinationFilePath)\n    {\n        File.Move(sourceFilePath, destinationFilePath);\n    }\n\n    public string ReadFile(string filePath)\n    {\n        return File.ReadAllText(filePath);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Graph<T>\n{\n    private Dictionary<T, List<T>> adjacencyList = new Dictionary<T, List<T>>();\n\n    public void AddVertex(T vertex)\n    {\n        adjacencyList[vertex] = new List<T>();\n    }\n\n    public void AddEdge(T from, T to)\n    {\n        if (!adjacencyList.ContainsKey(from))\n            AddVertex(from);\n        adjacencyList[from].Add(to);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class DataCompression\n{\n    public byte[] CompressData(byte[] data)\n    {\n        using (System.IO.MemoryStream output = new System.IO.MemoryStream())\n        {\n            using (System.IO.Compression.DeflateStream compressor = new System.IO.Compression.DeflateStream(output, System.IO.Compression.CompressionMode.Compress))\n            {\n                compressor.Write(data, 0, data.Length);\n            }\n            return output.ToArray();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading;\n\npublic class MultithreadingDemo\n{\n    public void RunMultipleThreads()\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            Thread thread = new Thread(DoWork);\n            thread.Start();\n        }\n    }\n\n    private void DoWork()\n    {\n        // Work to be done in each thread\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Xml;\n\npublic class XMLProcessor\n{\n    public void ValidateXML(string xmlContent)\n    {\n        XmlDocument xmlDoc = new XmlDocument();\n        xmlDoc.LoadXml(xmlContent);\n        // Perform validation or manipulation on XML data\n    }\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\"};\nint x = A.Length;\nConsole.WriteLine(x);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[, ] A = new int[, ] {{1,2},\n{3,4},\n{5,6},\n{7,8}};\nConsole.WriteLine(A[0,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[,, ] B = new int[,, ] {\n{{1,2,3},\n{4,5,6}},\n{{7,8,9},\n{10,11,12}}\n};\nConsole.WriteLine(B[0,1,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[,] C = new int[2,3];\nC[0,0] = 5;\nC[0,1] = 6;\nC[0,2] = 5;\nC[1,0] = 5;\nC[1,1] = 5;\nC[1,2] = 5;\nConsole.WriteLine(C[0,1]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "class HelloWorld {\nstatic void Main() {\nint a, b, c;\na = 1;\na += 1;\na = b = c = 1;\nConsole.WriteLine(a + b + c);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 1;\nint b = 2;\nint c = 3;\nif(a < b){c += 1;} else {c -= 1;}\nConsole.WriteLine(\"c=\" + c);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[] A = {1, 2, 3};\nif(A[0] < A[1]){A[2] += 1;}\nConsole.WriteLine(\"A[2]=\" + A[2]);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint i = 0;\nwhile (i < 5) {\nConsole.WriteLine(\"i = \" + i);\ni++;\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint i = 0;\ndo {\nConsole.WriteLine(\"i = \" + i);\ni++;\n}\nwhile (i < 5);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nint i = 0;\nstring t = \"\";\nwhile (i < A.Length) {\nt += \"\\n i[\" + i + \"]=\" + A[i];\ni++;\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nint i = 0;\nstring t = \"\";\ndo {\nt += \"\\n i[\" + i + \"]=\" + A[i];\ni++;\n}\nwhile (i < A.Length);\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 5;\nint b = 0;\nfor (int i = 0; i < a; i++) {\nb += i;\n}\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[] A = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nstring t = \"\";\nfor (int i = 0; i < A.Length; i++) {\nt += \"\\n A[\" + i + \"]=\" + A[i];\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[, ] A = new string[, ] {\n{\"a\",\"b\"},\n{\"c\",\"d\"},\n{\"e\",\"f\"},\n{\"g\",\"h\"}\n};\nstring t = \"\";\nint x = A.GetLength(0);\nint y = A.GetLength(1);\nfor (int i = 0; i < x; i++) {\nfor (int j = 0; j < y; j++) {\nt += \"\\n A[\"+i+\",\"+j+\"]=\" + A[i,j];\n}\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring[, ] A = new string[, ] {\n{\"a\",\"b\"},\n{\"c\",\"d\"},\n{\"e\",\"f\"},\n{\"g\",\"h\"}\n};\nstring t = \"\";\nint n = A.GetLength(0);\nint m = A.GetLength(1);\nint i = 0;\nint j = 0;\nfor (int v = 0; v < n*m; v++) {\nj = v % m;\nif(v!=0 && j == 0){i++;}\nt += v + \" A[\"+i+\",\"+j+\"]=\";\nt += A[i,j] + \"\\n\";\n}\nConsole.WriteLine(t);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic int compute(int x)\n{\nreturn x + x / x - x * x;\n}\nstatic void Main(string[] args)\n{\nint a = 10;\nint b = compute(a);\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nConsole.WriteLine(\"Code 65 is the:'\" + (char) 65 + \"' letter\");\nConsole.WriteLine(\"Letter A has the code:'\" + (int) 'A' + \"'\");\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic string compute(string t, string [] a)\n{\nfor (int i = 0; i < a.Length; i++) {\nt += \"\\n a[\" + i + \"]=\" + a[i];\n}\nreturn t;\n}\nstatic void Main(string[] args)\n{\nstring[] a = {\"a\", \"b\", \"c\", \"d\", \"e\"};\nstring t = \"\";\nstring b = compute(t, a);\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint a = 3;\nint b = c(c(c(c(a))));\nb = -b;\nConsole.WriteLine(b);\n}\nstatic int c(int x)\n{return x + x / x - x * x;}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main(string[] args)\n{\nint[] a = {1, 2, 3, 4, 5};\nint t = 0;\nint b = c1(t, a);\nConsole.WriteLine(b);\n}\nstatic int c1(int t, int[] a){\nreturn 5 + c2(t, a);\n}\nstatic int c2(int t, int[] a){\nreturn c3(t, a) + 5;\n}\nstatic int c3(int t, int[] a){\nint s = 1;\nreturn s + c4(t, a);\n}\nstatic int c4(int t, int[] a){\nreturn c5(t, a) + c5(t, a);\n}\nstatic int c5(int t, int[] a){\nfor (int i = 0; i < a.Length; i++) {\nt += a[i];\n}\nreturn t;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic int for_loop(int a, int b, int r){\na++;\nr += 5;\nif(a>=b){\nreturn r;\n} else {\nreturn for_loop(a, b, r);\n}\n}\nstatic void Main() {\nint a = for_loop(0, 7, 0);\nConsole.WriteLine(a);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic const double a = 3.1415;\npublic static int b;\nstatic int compute()\n{\nint x = b;\nreturn x + x / x - x * x;\n}\nstatic void Main(string[] args)\n{\nb = 11;\nint c = compute();\nConsole.WriteLine(c + \"\\n\" + a);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic static int a;\nstatic void Main() {\na = 10;\nint b = pure(a);\nConsole.WriteLine(b + \" & \" + a);\nint c = inpure(a);\nConsole.WriteLine(c + \" & \" + a);\nint d = pure(a);\nConsole.WriteLine(d + \" & \" + a);\n}\nstatic int pure(int x){\nreturn x + x / x - x * x;\n}\nstatic int inpure(int x){\na = 11;\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\npublic static int b;\npublic static int a;\nstatic void Main() {\na = 16;\nb = f(a);\nConsole.WriteLine(b);\np();\nConsole.WriteLine(b);\n}\nstatic int f(int x){\nreturn x + x / x - x * x;\n}\nstatic void p(){\nint x = a - 11;\nb = x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = \"*******%%**********%%******\";\nstring q = \"%%\";\nint b = a.Length;\nint c = a.Replace(q, \"\").Length;\nif(c < b){\nConsole.WriteLine(\"a contains q\");\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = x(\"*\", \"\", 10);\nConsole.WriteLine(\"Repeat:\\n[\" + a + \"]\");\nint b = sum(23);\nConsole.WriteLine(\"Sum:[\" + b + \"]\");\nint c = factorial(10);\nConsole.WriteLine(\n\"Factorial:\\n[\" + c + \"]\"\n);\nint[] d = sequence(5, new int[5], 0, 5);\nConsole.WriteLine(\n\"A sequence:\\n[{0}\",\nstring.Join(\",\", d) + \"]\"\n);\nint[] e = fibonacci(2,\nnew int[3] {1,2,3}, 5);\nConsole.WriteLine(\n\"Fibonacci:\\n[{0}\",\nstring.Join(\",\", e) + \"]\"\n);\nint[] q = {1, 3, 3, 4, 5, 9};\nint f = sum_array(q.Length - 1, q, 0);\nConsole.WriteLine(\n\"Sum array:[\" + f + \"]\"\n);\n}\nstatic string x(string c, string s,\nint n){\ns += c;\nif(s.Length>=n){\nreturn s;\n} else {\nreturn x(c, s, n);\n}\n}\nstatic int sum(int n){\nif (n <= 1) {return n;}\nreturn n + sum(n - 1);\n}\nstatic int factorial(int n){\nif (n <= 1) {\nreturn n;\n} else {\nreturn factorial(n - 1) * n;\n}\n}\nstatic int[] sequence(int n, int[] m,\nint i, int t){\nm[i] = n;\ni++;\nif (i >= t) {\nreturn m;\n} else {\nreturn sequence((n-1)+(n-2),\nm, i, t);\n}\n}\nstatic int[] fibonacci(int n, int[] m,\nint t){\nn++;\nArray.Resize(ref m, n+1);\nm[n] = m[n-1] + m[n-2];\nif (n >= t) {\nreturn m;\n} else {\nreturn fibonacci(n, m, t);\n}\n}\nstatic int sum_array(int n, int[] q,\nint r){\nr += q[n];\nif (n <= 0) {\nreturn r;\n} else {\nreturn sum_array(n - 1, q, r);\n}\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nstring a = distribution(3, 21);\nConsole.WriteLine(a);\n}\nstatic string distribution(\nint start, int stop){\nstring t = \"\";\nfor (int i = start; i < stop; i++) {\nt += compute(i) + \"\\n\";\n}\nreturn t;\n}\nstatic int compute(int x){\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint[] a = distribution(3, 21);\nConsole.WriteLine(string.Join(\"\\n\", a));\n}\nstatic int[] distribution(\nint start, int stop){\nint[] b = new int[stop - start];\nfor (int i = start; i < stop; i++) {\nb[i - start] = compute(i);\n}\nreturn b;\n}\nstatic int compute(int x){\nreturn x + x / x - x * x;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass HelloWorld {\nstatic void Main() {\nint a, b, c;\na = 7;\nb = 3;\na = 7; b = 3;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\npublic class SpectralForecast\n{\npublic static void Main(string[] args)\n{\nstring A = \"10.3,23.4,44.8,63.2,44.1,35.1,46.5,62.6,50.4\";\nstring B = \"18.8,43.1,52.2,45.5,46.8,46.6,67.9,66.3,70.4\";\nstring[] nA = A.Split(',');\nstring[] nB = B.Split(',');\nstring M = \"\";\ndouble maxA = 0;\ndouble maxB = 0;\ndouble d = 33;\ndouble v = 0;\ndouble[] tA = new double[nA.Length];\ndouble[] tB = new double[nB.Length];\nfor(int i=0; i < nA.Length; i++)\n{\ntA[i] = double.Parse(nA[i]);\ntB[i] = double.Parse(nB[i]);\nif (tA[i] > maxA){maxA = tA[i];}\nif (tB[i] > maxB){maxB = tB[i];}\n}\ndouble maxAB = Math.Max(maxA, maxB);\nfor(int i=0; i < tA.Length; i++) {\nv = ((d/maxA)*tA[i])+(((maxAB-d)/maxB)*tB[i]);\nM += Math.Round(v, 2);\nif(i < tA.Length-1){M += ',';}\n}\nConsole.WriteLine (M);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nString a = \"this is \";\nString b = a +\n\"C\t\"output\";\nConsole.WriteLine(b);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nString a = \"this is \"; String b = a + \"C  }\n}\n"
  },
  {
    "language": "C#",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "\n42\n3.14159265358979323846264\n'a'\n\"this text\"\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint x = 12;\nint y = 15;\nstring color = \"green\";\nstring xname = \"Paul\";\nbool logic = true;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nclass HelloWorld {\nstatic void Main() {\nint x = 12;\nint y = 15;\nstring color = \"green\";\nstring xname = \"Paul\";\nbool logic = true;\nConsole.WriteLine(logic);\nConsole.WriteLine(x + y);\nConsole.WriteLine(color + x);\nConsole.WriteLine(x + xname);\nConsole.WriteLine(x + y + color);\nConsole.WriteLine(color + x + y);\nConsole.WriteLine(x + x / x - x * x);\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Matrix\n{\n    private int[,] data;\n\n    public Matrix(int rows, int cols)\n    {\n        data = new int[rows, cols];\n    }\n\n    public int this[int row, int col]\n    {\n        get { return data[row, col]; }\n        set { data[row, col] = value; }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class CustomList<T>\n{\n    private T[] items;\n    private int count;\n\n    public CustomList()\n    {\n        items = new T[10];\n        count = 0;\n    }\n\n    public void Add(T item)\n    {\n        if (count < items.Length)\n        {\n            items[count] = item;\n            count++;\n        }\n        else\n        {\n            // Resize the array or handle full list\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Employee\n{\n    public string Name { get; set; }\n    public decimal Salary { get; set; }\n\n    public override string ToString()\n    {\n        return $\"Name: {Name}, Salary: {Salary:C}\";\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\npublic class FileManager\n{\n    public void CopyFile(string sourcePath, string destinationPath)\n    {\n        File.Copy(sourcePath, destinationPath);\n    }\n\n    public void DeleteFile(string filePath)\n    {\n        File.Delete(filePath);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading.Tasks;\n\npublic class AsyncOperations\n{\n    public async Task<string> FetchDataAsync(string url)\n    {\n        using (var client = new System.Net.Http.HttpClient())\n        {\n            return await client.GetStringAsync(url);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Polynomial\n{\n    private double[] coefficients;\n\n    public double this[int index]\n    {\n        get { return coefficients[index]; }\n        set { coefficients[index] = value; }\n    }\n\n    public int Degree\n    {\n        get { return coefficients.Length - 1; }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\npublic class LINQSample\n{\n    public void FilterData()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        var evenNumbers = numbers.Where(n => n % 2 == 0);\n        foreach (var num in evenNumbers)\n        {\n            Console.WriteLine(num);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class FibonacciSeries\n{\n    public int CalculateFibonacci(int n)\n    {\n        if (n <= 1)\n            return n;\n        return CalculateFibonacci(n - 1) + CalculateFibonacci(n - 2);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text.RegularExpressions;\n\npublic class RegexValidation\n{\n    public bool IsValidEmail(string email)\n    {\n        return Regex.IsMatch(email, @\"^\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\");\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class PrimeNumberCheck\n{\n    public bool IsPrime(int number)\n    {\n        if (number <= 1) return false;\n        for (int i = 2; i <= Math.Sqrt(number); i++)\n        {\n            if (number % i == 0) return false;\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class EncryptionHelper\n{\n    private string key = \"YourSecretKey\";\n\n    public string Encrypt(string data)\n    {\n        // Encryption logic using 'key'\n        return \"encrypted_data\";\n    }\n\n    public string Decrypt(string encryptedData)\n    {\n        // Decryption logic using 'key'\n        return \"decrypted_data\";\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Diagnostics;\n\npublic class PerformanceAnalyzer\n{\n    public void MeasurePerformance()\n    {\n        Stopwatch stopwatch = new Stopwatch();\n        stopwatch.Start();\n\n        // Code to measure performance\n\n        stopwatch.Stop();\n        Console.WriteLine(\"Elapsed time: \" + stopwatch.Elapsed);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class DateManipulation\n{\n    public DateTime GetNextWeekday(DateTime date, DayOfWeek dayOfWeek)\n    {\n        int daysUntilTarget = ((int)dayOfWeek - (int)date.DayOfWeek + 7) % 7;\n        return date.AddDays(daysUntilTarget);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class SimpleCalculator\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n\n    public int Subtract(int a, int b)\n    {\n        return a - b;\n    }\n\n    public int Multiply(int a, int b)\n    {\n        return a * b;\n    }\n\n    public double Divide(int a, int b)\n    {\n        if (b == 0)\n            throw new DivideByZeroException();\n        return (double)a / b;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class CustomQueue<T>\n{\n    private List<T> items = new List<T>();\n\n    public void Enqueue(T item)\n    {\n        items.Add(item);\n    }\n\n    public T Dequeue()\n    {\n        if (items.Count == 0)\n            throw new InvalidOperationException(\"Queue is empty\");\n\n        T item = items[0];\n        items.RemoveAt(0);\n        return item;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading;\n\npublic class ThreadDemo\n{\n    public void RunThreadExample()\n    {\n        Thread thread = new Thread(DoWork);\n        thread.Start();\n    }\n\n    private void DoWork()\n    {\n        // Code to be executed in the thread\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Net.Http;\n\npublic class WebRequestHandler\n{\n    private HttpClient client = new HttpClient();\n\n    public async void MakeRequest(string url)\n    {\n        HttpResponseMessage response = await client.GetAsync(url);\n        if (response.IsSuccessStatusCode)\n        {\n            string content = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(content);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class RandomNumberGenerator\n{\n    private static readonly Random random = new Random();\n\n    public int GenerateRandomNumber(int min, int max)\n    {\n        return random.Next(min, max + 1);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class PathOperations\n{\n    public string GetFullPath(string relativePath)\n    {\n        return System.IO.Path.GetFullPath(relativePath);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class StringReversal\n{\n    public string ReverseString(string input)\n    {\n        char[] charArray = input.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n  bool is_open[100] = { false };\n\n  // do the 100 passes\n  for (int pass = 0; pass < 100; ++pass)\n    for (int door = pass; door < 100; door += pass+1)\n      is_open[door] = !is_open[door];\n\n  // output the result\n  for (int door = 0; door < 100; ++door)\n    std::cout << \"door #\" << door+1 << (is_open[door]? \" is open.\" : \" is closed.\") << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n  int square = 1, increment = 3;\n  for (int door = 1; door <= 100; ++door)\n  {\n    std::cout << \"door #\" << door;\n    if (door == square)\n    {\n      std::cout << \" is open.\" << std::endl;\n      square += increment;\n      increment += 2;\n    }\n    else\n      std::cout << \" is closed.\" << std::endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> //compiled with \"Dev-C++\" , from RaptorOne\n\nint main()\n{\n    for(int i=1; i*i<=100; i++)\n            std::cout<<\"Door \"<<i*i<<\" is open!\"<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>    // compiled with clang (tags/RELEASE_600/final)\n#include <type_traits> // or g++ (GCC) 7.3.1 20180406 -- from hare1039\nnamespace functional_list // basic building block for template meta programming\n{\nstruct NIL\n{\n\tusing head = NIL;\n\tusing tail = NIL;\n\tfriend std::ostream& operator << (std::ostream& os, NIL const) { return os; }\n};\n\ntemplate <typename H, typename T = NIL>\nstruct list\n{\n\tusing head = H;\n\tusing tail = T;\n};\n\ntemplate <int i>\nstruct integer\n{\n\tstatic constexpr int value = i;\n\tfriend std::ostream& operator << (std::ostream& os, integer<i> const) { os << integer<i>::value; return os;}\n};\n\ntemplate <typename L, int nTH> constexpr\nauto at()\n{\n\tif constexpr (nTH == 0)\n\t\treturn (typename L::head){};\n\telse if constexpr (not std::is_same_v<typename L::tail, NIL>)\n\t\treturn at<typename L::tail, nTH - 1>();\n\telse\n\t\treturn NIL{};\n}\ntemplate <typename L, int nTH>\nusing at_t = decltype(at<L, nTH>());\n\ntemplate <typename L, typename elem> constexpr\nauto prepend() { return list<elem, L>{}; }\n\ntemplate <typename L, typename elem>\nusing prepend_t = decltype(prepend<L, elem>());\n\t\ntemplate <int Size, typename Dat = integer<0>> constexpr\nauto gen_list()\n{\n\tif constexpr (Size == 0)\n\t\treturn NIL{};\n\telse\n\t{\n\t\tusing next = decltype(gen_list<Size - 1, Dat>());\n\t\treturn prepend<next, Dat>();\n\t}\n}\ntemplate <int Size, typename Dat = integer<0>>\nusing gen_list_t = decltype(gen_list<Size, Dat>());\n\t\n} namespace fl = functional_list;\n\nconstexpr int door_amount = 101; // index from 1 to 100\n\ntemplate <typename L, int current, int moder> constexpr\nauto construct_loop()\n{\n\tusing val_t = fl::at_t<L, current>;\n\tif constexpr (std::is_same_v<val_t, fl::NIL>)\n\t\treturn fl::NIL{};\n\telse\n\t{\n\t\tconstexpr int val = val_t::value;\n\t\tusing val_add_t = fl::integer<val + 1>;\n\t\tusing val_old_t = fl::integer<val>;\n\t\n\t\tif constexpr (current == door_amount)\n\t\t{\n\t\t\tif constexpr(current % moder == 0)\n\t\t\t\treturn fl::list<val_add_t>{};\n\t\t\telse\n\t\t\t\treturn fl::list<val_old_t>{};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tusing sub_list = decltype(construct_loop<L, current + 1, moder>());\n\t\t\tif constexpr(current % moder == 0)\n\t\t\t\treturn fl::prepend<sub_list, val_add_t>();\n\t\t\telse\n\t\t\t\treturn fl::prepend<sub_list, val_old_t>();\n\t\t}\n\t}\n}\n\ntemplate <int iteration> constexpr\nauto construct()\n{\n\tif constexpr (iteration == 1) // door index = 1\n\t{\n\t\tusing l = fl::gen_list_t<door_amount>;\n\t\treturn construct_loop<l, 0, iteration>();\n\t}\n\telse\n\t{\n\t\tusing prev_iter_list = decltype(construct<iteration - 1>());\n\t\treturn construct_loop<prev_iter_list, 0, iteration>();\n\t}\n}\n\ntemplate <typename L, int pos> constexpr\nvoid show_ans()\n{\n\tif constexpr (std::is_same_v<typename L::head, fl::NIL>)\n\t\treturn;\n\telse\n\t{\n\t\tif constexpr (L::head::value % 2 == 1)\n\t\t\tstd::cout << \"Door \" << pos << \" is opened.\\n\";\n\t\tshow_ans<typename L::tail, pos + 1>();\n\t}\n}\n\nint main()\n{\n\tusing result = decltype(construct<100>());\n\tshow_ans<result, 0>();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ratio>\n#include <array>\n#include <algorithm>\n#include <random>\n\ntypedef short int Digit;  // Typedef for the digits data type.\n\nconstexpr Digit nDigits{4};      // Amount of digits that are taken into the game.\nconstexpr Digit maximumDigit{9}; // Maximum digit that may be taken into the game.\nconstexpr short int gameGoal{24};    // Desired result.\n\ntypedef std::array<Digit, nDigits> digitSet; // Typedef for the set of digits in the game.\ndigitSet d;\n\nvoid printTrivialOperation(std::string operation) { // Prints a commutative operation taking all the digits.\n\tbool printOperation(false);\n\tfor(const Digit& number : d) {\n\t\tif(printOperation)\n\t\t\tstd::cout << operation;\n\t\telse\n\t\t\tprintOperation = true;\n\t\tstd::cout << number;\n\t}\n\tstd::cout << std::endl;\n}\n\nvoid printOperation(std::string prefix, std::string operation1, std::string operation2, std::string operation3, std::string suffix = \"\") {\n\tstd::cout << prefix << d[0] << operation1 << d[1] << operation2 << d[2] << operation3 << d[3] << suffix << std::endl;\n}\n\nint main() {\n\tstd::mt19937_64 randomGenerator;\n\tstd::uniform_int_distribution<Digit> digitDistro{1, maximumDigit};\n\t// Let us set up a number of trials:\n\tfor(int trial{10}; trial; --trial) {\n\t\tfor(Digit& digit : d) {\n\t\t\tdigit = digitDistro(randomGenerator);\n\t\t\tstd::cout << digit << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t\tstd::sort(d.begin(), d.end());\n\t\t// We start with the most trivial, commutative operations:\n\t\tif(std::accumulate(d.cbegin(), d.cend(), 0) == gameGoal)\n\t\t\tprintTrivialOperation(\" + \");\n\t\tif(std::accumulate(d.cbegin(), d.cend(), 1, std::multiplies<Digit>{}) == gameGoal)\n\t\t\tprintTrivialOperation(\" * \");\n\t\t// Now let's start working on every permutation of the digits.\n\t\tdo {\n\t\t\t// Operations with 2 symbols + and one symbol -:\n\t\t\tif(d[0] + d[1] + d[2] - d[3] == gameGoal) printOperation(\"\", \" + \", \" + \", \" - \"); // If gameGoal is ever changed to a smaller value, consider adding more operations in this category.\n\t\t\t// Operations with 2 symbols + and one symbol *:\n\t\t\tif(d[0] * d[1] + d[2] + d[3] == gameGoal) printOperation(\"\", \" * \", \" + \", \" + \");\n\t\t\tif(d[0] * (d[1] + d[2]) + d[3] == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" ) + \");\n\t\t\tif(d[0] * (d[1] + d[2] + d[3]) == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" + \", \" )\");\n\t\t\t// Operations with one symbol + and 2 symbols *:\n\t\t\tif((d[0] * d[1] * d[2]) + d[3] == gameGoal) printOperation(\"( \", \" * \", \" * \", \" ) + \");\n\t\t\tif(d[0] * d[1] * (d[2] + d[3]) == gameGoal) printOperation(\"( \", \" * \", \" * ( \", \" + \", \" )\");\n\t\t\tif((d[0] * d[1]) + (d[2] * d[3]) == gameGoal) printOperation(\"( \", \" * \", \" ) + ( \", \" * \", \" )\");\n\t\t\t// Operations with one symbol - and 2 symbols *:\n\t\t\tif((d[0] * d[1] * d[2]) - d[3] == gameGoal) printOperation(\"( \", \" * \", \" * \", \" ) - \");\n\t\t\tif(d[0] * d[1] * (d[2] - d[3]) == gameGoal) printOperation(\"( \", \" * \", \" * ( \", \" - \", \" )\");\n\t\t\tif((d[0] * d[1]) - (d[2] * d[3]) == gameGoal) printOperation(\"( \", \" * \", \" ) - ( \", \" * \", \" )\");\n\t\t\t// Operations with one symbol +, one symbol *, and one symbol -:\n\t\t\tif(d[0] * d[1] + d[2] - d[3] == gameGoal) printOperation(\"\", \" * \", \" + \", \" - \");\n\t\t\tif(d[0] * (d[1] + d[2]) - d[3] == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" ) - \");\n\t\t\tif(d[0] * (d[1] - d[2]) + d[3] == gameGoal) printOperation(\"\", \" * ( \", \" - \", \" ) + \");\n\t\t\tif(d[0] * (d[1] + d[2] - d[3]) == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" - \", \" )\");\n\t\t\tif(d[0] * d[1] - (d[2] + d[3]) == gameGoal) printOperation(\"\", \" * \", \" - ( \", \" + \", \" )\");\n\t\t\t// Operations with one symbol *, one symbol /, one symbol +:\n\t\t\tif(d[0] * d[1] == (gameGoal - d[3]) * d[2]) printOperation(\"( \", \" * \", \" / \", \" ) + \");\n\t\t\tif(((d[0] * d[1]) + d[2]) == gameGoal * d[3]) printOperation(\"(( \", \" * \", \" ) + \", \" ) / \");\n\t\t\tif((d[0] + d[1]) * d[2] == gameGoal * d[3]) printOperation(\"(( \", \" + \", \" ) * \", \" ) / \");\n\t\t\tif(d[0] * d[1] == gameGoal * (d[2] + d[3])) printOperation(\"( \", \" * \", \" ) / ( \", \" + \", \" )\");\n\t\t\t// Operations with one symbol *, one symbol /, one symbol -:\n\t\t\tif(d[0] * d[1] == (gameGoal + d[3]) * d[2]) printOperation(\"( \", \" * \", \" / \", \" ) - \");\n\t\t\tif(((d[0] * d[1]) - d[2]) == gameGoal * d[3]) printOperation(\"(( \", \" * \", \" ) - \", \" ) / \");\n\t\t\tif((d[0] - d[1]) * d[2] == gameGoal * d[3]) printOperation(\"(( \", \" - \", \" ) * \", \" ) / \");\n\t\t\tif(d[0] * d[1] == gameGoal * (d[2] - d[3])) printOperation(\"( \", \" * \", \" ) / ( \", \" - \", \" )\");\n\t\t\t// Operations with 2 symbols *, one symbol /:\n\t\t\tif(d[0] * d[1] * d[2] == gameGoal * d[3]) printOperation(\"\", \" * \", \" * \", \" / \");\n\t\t\tif(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\"\", \" * \", \" / ( \", \" * \", \" )\");\n\t\t\t// Operations with 2 symbols /, one symbol -:\n\t\t\tif(d[0] * d[3] == gameGoal * (d[1] * d[3] - d[2])) printOperation(\"\", \" / ( \", \" - \", \" / \", \" )\");\n\t\t\t// Operations with 2 symbols /, one symbol *:\n\t\t\tif(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\"( \", \" * \", \" / \", \" ) / \", \"\");\n\t\t} while(std::next_permutation(d.begin(), d.end())); // All operations are repeated for all possible permutations of the numbers.\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <random>\n#include <iostream>\n#include <stack>\n#include <set>\n#include <string>\n#include <functional>\nusing namespace std;\n\nclass RPNParse\n{\npublic:\n  stack<double> stk;\n  multiset<int> digits;\n\n  void op(function<double(double,double)> f)\n  {\n    if(stk.size() < 2)\n      throw \"Improperly written expression\";\n    int b = stk.top(); stk.pop();\n    int a = stk.top(); stk.pop();\n    stk.push(f(a, b));\n  }\n\n  void parse(char c)\n  {\n    if(c >= '0' && c <= '9')\n    {\n      stk.push(c - '0');\n      digits.insert(c - '0');\n    }\n    else if(c == '+')\n      op([](double a, double b) {return a+b;});\n    else if(c == '-')\n      op([](double a, double b) {return a-b;});\n    else if(c == '*')\n      op([](double a, double b) {return a*b;});\n    else if(c == '/')\n      op([](double a, double b) {return a/b;});\n  }\n\n  void parse(string s)\n  {\n    for(int i = 0; i < s.size(); ++i)\n      parse(s[i]);\n  }\n\n  double getResult()\n  {\n    if(stk.size() != 1)\n      throw \"Improperly written expression\";\n    return stk.top();\n  }\n};\n\nint main()\n{\n  random_device seed;\n  mt19937 engine(seed());\n  uniform_int_distribution<> distribution(1, 9);\n  auto rnd = bind(distribution, engine);\n\n  multiset<int> digits;\n  cout << \"Make 24 with the digits: \";\n  for(int i = 0; i < 4; ++i)\n  {\n    int n = rnd();\n    cout << \" \" << n;\n    digits.insert(n);\n  }\n  cout << endl;\n\n  RPNParse parser;\n\n  try\n  {\n    string input;\n    getline(cin, input);\n    parser.parse(input);\n\n    if(digits != parser.digits)\n      cout << \"Error: Not using the given digits\" << endl;\n    else\n    {\n      double r = parser.getResult();\n      cout << \"Result: \" << r << endl;\n\n      if(r > 23.999 && r < 24.001)\n        cout << \"Good job!\" << endl;\n      else\n        cout << \"Try again.\" << endl;\n    }\n  }\n  catch(char* e)\n  {\n    cout << \"Error: \" << e << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Calculate hypotenuse n of OTT assuming only nothingness, unity, and hyp[n-1] if n>1\n// Nigel Galloway, May 6th., 2013\n#include <gmpxx.h>\nint N{123456};\nmpz_class hyp[N-3];\nconst mpz_class G(const int n,const int g){return g>n?0:(g==1 or n-g<2)?1:hyp[n-g-2];};\nvoid G_hyp(const int n){for(int i=0;i<N-2*n-1;i++) n==1?hyp[n-1+i]=1+G(i+n+1,n+1):hyp[n-1+i]+=G(i+n+1,n+1);}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nint main(){\n  N=25;\n  for (int n=1; n<N/2; n++){\n    G_hyp(n);\n    for (int g=0; g<N-3; g++) std::cout << std::setw(4) << hyp[g];\n    std::cout << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "int main(){\n  N = 25;\n  std::cout << std::setw(N+52) << \"1\" << std::endl;\n  std::cout << std::setw(N+55) << \"1     1\" << std::endl;\n  std::cout << std::setw(N+58) << \"1     1     1\" << std::endl;\n  std::string ott[N-3];\n  for (int n=1; n<N/2; n++) {\n    G_hyp(n);\n    for (int g=(n-1)*2; g<N-3; g++) {\n      std::string t = hyp[g-(n-1)].get_str();\n      //if (t.size()==1) t.insert(t.begin(),1,' ');\n      ott[g].append(t);\n      ott[g].append(6-t.size(),' ');\n    }\n  }\n  for(int n = 0; n<N-3; n++) {\n    std::cout <<std::setw(N+43-3*n) << 1 << \"     \" << ott[n];\n    for (int g = (n+1)/2; g>0; g--) {\n      std::string t{hyp[g-1].get_str()};\n      t.append(6-t.size(),' ');\n      std::cout << t;\n    }\n    std::cout << \"1     1\" << std::endl;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint main(){\n  for (int n=1; n<N/2; n++) G_hyp(n);\n  std::cout << \"G(23)     = \" << hyp[21] << std::endl;\n  std::cout << \"G(123)    = \" << hyp[121] << std::endl;\n  std::cout << \"G(1234)   = \" << hyp[1232] << std::endl;\n  std::cout << \"G(12345)  = \" << hyp[12343] << std::endl;\n  mpz_class r{3};\n  for (int i = 0; i<N-3; i++) r += hyp[i];\n  std::cout << \"G(123456) = \" << r << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing std::cout;\n\nint main()\n{\n  for(int bottles(99); bottles > 0; bottles -= 1){\n    cout << bottles << \" bottles of beer on the wall\\n\"\n         << bottles << \" bottles of beer\\n\"\n         << \"Take one down, pass it around\\n\"\n         << bottles - 1 << \" bottles of beer on the wall\\n\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntemplate<int max, int min> struct bottle_countdown\n{\n  static const int middle = (min + max)/2;\n  static void print()\n  {\n    bottle_countdown<max, middle+1>::print();\n    bottle_countdown<middle, min>::print();\n  }\n};\n\ntemplate<int value> struct bottle_countdown<value, value>\n{\n  static void print()\n  {\n    std::cout << value << \" bottles of beer on the wall\\n\"\n              << value << \" bottles of beer\\n\"\n              << \"Take one down, pass it around\\n\"\n              << value-1 << \" bottles of beer\\n\\n\";\n  }\n};\n\nint main()\n{\n  bottle_countdown<100, 1>::print();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid rec(int bottles)\n{\nif ( bottles!=0)\n {\n     cout << bottles << \" bottles of beer on the wall\" << endl;\n        cout << bottles << \" bottles of beer\" << endl;\n        cout << \"Take one down, pass it around\" << endl;\n        cout << --bottles << \" bottles of beer on the wall\\n\" << endl;\n    rec(bottles);\n }\n}\n\nint main()\n {\nrec(99);\nsystem(\"pause\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ostream>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main()\n{\n  std::cout << SONG;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                          //>,_\n                        //Beer Song>,_\n                       #include <iostream>\n                      using namespace std;\n                     int main(){ for( int\n                    b=-1; b<99;  cout <<\n                   '\\n') for ( int w=0;\n                  w<3; cout << \".\\n\"){\n                 if (w==2) cout << ((\n                b--) ?\"Take one dow\"\n               \"n and pass it arou\"\n              \"nd\":\"Go to the sto\"\n             \"re and buy some mo\"\n            \"re\"); if (b<0) b=99\n           ; do{ if (w) cout <<\n          \", \"; if (b) cout <<\n          b;  else  cout << (\n         (w) ? 'n' : 'N') <<\n         \"o more\"; cout <<\n         \" bottle\" ;  if\n        (b!=1) cout <<\n       's' ; cout <<\n       \" of beer\";\n      if (w!=1)\n     cout  <<\n    \" on th\"\n   \"e wall\"\n  ;} while\n (!w++);}\n  return\n       0\n       ;\n       }\n      //\n  // by barrym 2011-05-01\n     // no bottles were harmed in the\n            // making of this program!!!\n"
  },
  {
    "language": "C++",
    "code": "// Standard input-output streams\n#include <iostream>\nusing namespace std;\nint main()\n{\n   int a, b;\n   cin >> a >> b;\n   cout << a + b << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Input file: input.txt\n// Output file: output.txt\n#include <fstream>\nusing namespace std;\nint main()\n{\n   ifstream in(\"input.txt\");\n   ofstream out(\"output.txt\");\n   int a, b;\n   in >> a >> b;\n   out << a + b << endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cctype>\n\n\ntypedef std::pair<char,char> item_t;\ntypedef std::vector<item_t> list_t;\n\nbool can_make_word(const std::string& w, const list_t& vals) {\n    std::set<uint32_t> used;\n    while (used.size() < w.size()) {\n        const char c = toupper(w[used.size()]);\n        uint32_t x = used.size();\n        for (uint32_t i = 0, ii = vals.size(); i < ii; ++i) {\n            if (used.find(i) == used.end()) {\n                if (toupper(vals[i].first) == c || toupper(vals[i].second) == c) {\n                    used.insert(i);\n                    break;\n                }\n            }\n        }\n        if (x == used.size()) break;\n    }\n    return used.size() == w.size();\n}\n\n\nint main() {\n    list_t vals{ {'B','O'}, {'X','K'}, {'D','Q'}, {'C','P'}, {'N','A'}, {'G','T'}, {'R','E'}, {'T','G'}, {'Q','D'}, {'F','S'}, {'J','W'}, {'H','U'}, {'V','I'}, {'A','N'}, {'O','B'}, {'E','R'}, {'F','S'}, {'L','Y'}, {'P','C'}, {'Z','M'} };\n    std::vector<std::string> words{\"A\",\"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"};\n    for (const std::string& w : words) {\n        std::cout << w << \": \" << std::boolalpha << can_make_word(w,vals) << \".\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "class Abs {\npublic:\n\tvirtual int method1(double value) = 0;\n\tvirtual int add(int a, int b){\n\t\treturn a+b;\n\t}\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> findProperDivisors ( int n ) {\n   std::vector<int> divisors ;\n   for ( int i = 1 ; i < n / 2 + 1 ; i++ ) {\n      if ( n % i == 0 )\n\t divisors.push_back( i ) ;\n   }\n   return divisors  ;\n}\n\nint main( ) {\n   std::vector<int> deficients , perfects , abundants , divisors ;\n   for ( int n = 1 ; n < 20001 ; n++ ) {\n      divisors = findProperDivisors( n ) ;\n      int sum = std::accumulate( divisors.begin( ) , divisors.end( ) , 0 ) ;\n      if ( sum < n ) {\n\t deficients.push_back( n ) ;\n      }\n      if ( sum == n ) {\n\t perfects.push_back( n ) ;\n      }\n      if ( sum > n ) {\n\t abundants.push_back( n ) ;\n      }\n   }\n   std::cout << \"Deficient : \" << deficients.size( ) << std::endl ;\n   std::cout << \"Perfect   : \" << perfects.size( ) << std::endl ;\n   std::cout << \"Abundant  : \" << abundants.size( ) << std::endl ;\n   return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nclass Acc\n{\npublic:\n    Acc(int init)\n        : _type(intType)\n        , _intVal(init)\n    {}\n\n    Acc(float init)\n        : _type(floatType)\n        , _floatVal(init)\n    {}\n\n    int operator()(int x)\n    {\n        if( _type == intType )\n        {\n            _intVal += x;\n            return _intVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return static_cast<int>(_floatVal);\n        }\n    }\n\n    float operator()(float x)\n    {\n        if( _type == intType )\n        {\n            _floatVal = _intVal + x;\n            _type = floatType;\n            return _floatVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return _floatVal;\n        }\n    }\nprivate:\n    enum {floatType, intType} _type;\n    float _floatVal;\n    int _intVal;\n};\n\nint main()\n{\n    Acc a(1);\n    a(5);\n    Acc(3);\n    std::cout << a(2.3f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n\ntemplate <typename T>\nstd::function<T(T)> makeAccumulator(T sum) {\n\treturn [=](T increment) mutable {\n\t\treturn sum += increment;\n\t};\n}\n\nint main() {\n\tauto acc = makeAccumulator<float>(1);\n\tacc(5);\n\tmakeAccumulator(3);\n\tstd::cout << acc(2.3) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "struct CumulantBase_\n{\n   virtual ~CumulantBase_();\n   virtual std::ostream& Write(std::ostream& dst) const = 0;\n};\n\ntemplate<class T_> struct Cumulant_ : CumulantBase_\n{\n   T_ val_;\n   Cumulant_(const T_& val) : val_(val) {}\n   std::ostream& Write(std::ostream& dst) const override\n   {\n      return dst << val_;\n   }\n};\n\nstruct Accumulator_\n{\n   std::unique_ptr<CumulantBase_> val_;\n   template<class T_> Accumulator_(const T_& val) { Set(val); }\n   template<class T_> void Set(const T_& val) { val_.reset(new Cumulant_<T_>(val)); }\n"
  },
  {
    "language": "C++",
    "code": "// still inside struct Accumulator_\n\t// various operator() implementations provide a de facto multimethod\n\tAccumulator_& operator()(int more)\n\t{\n\t\tif (auto i = CoerceInt(*val_))\n\t\t\tSet(+i + more);\n\t\telse if (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(int) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(double more)\n\t{\n\t\tif (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(double) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(const String_& more)\n\t{\n\t\tif (auto s = CoerceString(*val_))\n\t\t\tSet(+s + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(string) failed\");\n\t\treturn *this;\n\t}\n};\n"
  },
  {
    "language": "C++",
    "code": "// recognize cumulants by type\nboost::optional<int> CoerceInt(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<int>*>(&c))\n\t\treturn p->val_;\n\treturn boost::optional<int>();\n}\nboost::optional<double> CoerceDouble(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<double>*>(&c))\n\t\treturn p->val_;\n\tif (auto i = CoerceInt(c))\n\t\treturn boost::optional<double>(i);\n\treturn boost::optional<double>();\n}\nboost::optional<String_> CoerceString(const CumulantBase_& c)\n{\n\tif (auto p = dynamic_cast<const Cumulant_<String_>*>(&c))\n\t\treturn p->val_;\n\treturn boost::optional<String_>();\n}\n"
  },
  {
    "language": "C++",
    "code": "std::ostream& operator<<(std::ostream& dst, const Accumulator_& acc)\n{\n\treturn acc.val_->Write(dst);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m < 4; ++m) {\n    for (unsigned int n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic interface IShape\n{\n    double GetArea();\n}\n\nclass Rectangle : IShape\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n\n    public double GetArea()\n    {\n        return Width * Height;\n    }\n}\n\nclass Circle : IShape\n{\n    public double Radius { get; set; }\n\n    public double GetArea()\n    {\n        return Math.PI * Radius * Radius;\n    }\n}\n\nclass ShapeCalculator\n{\n    public double CalculateTotalArea(IShape[] shapes)\n    {\n        double totalArea = 0;\n        foreach (var shape in shapes)\n        {\n            totalArea += shape.GetArea();\n        }\n        return totalArea;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Database\n{\n    private List<string> data = new List<string>();\n\n    public void Insert(string item)\n    {\n        data.Add(item);\n    }\n\n    public void Delete(string item)\n    {\n        data.Remove(item);\n    }\n\n    public void DisplayAllItems()\n    {\n        foreach (var item in data)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\nclass DataManager\n{\n    public void ManageData()\n    {\n        Database db = new Database();\n        db.Insert(\"Item 1\");\n        db.Insert(\"Item 2\");\n        db.Delete(\"Item 1\");\n        db.DisplayAllItems();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class ComplexNumber\n{\n    public double Real { get; private set; }\n    public double Imaginary { get; private set; }\n\n    public ComplexNumber(double real, double imaginary)\n    {\n        Real = real;\n        Imaginary = imaginary;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber c1, ComplexNumber c2)\n    {\n        return new ComplexNumber(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);\n    }\n\n    public override string ToString()\n    {\n        return $\"({Real} + {Imaginary}i)\";\n    }\n}\n\nclass ComplexNumberOperations\n{\n    public void PerformComplexOperations()\n    {\n        ComplexNumber num1 = new ComplexNumber(3, 4);\n        ComplexNumber num2 = new ComplexNumber(2, 7);\n        ComplexNumber sum = num1 + num2;\n        Console.WriteLine(\"Sum: \" + sum);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic abstract class Shape\n{\n    public abstract double Area();\n}\n\nclass Circle : Shape\n{\n    public double Radius { get; set; }\n\n    public override double Area()\n    {\n        return Math.PI * Radius * Radius;\n    }\n}\n\nclass Square : Shape\n{\n    public double SideLength { get; set; }\n\n    public override double Area()\n    {\n        return SideLength * SideLength;\n    }\n}\n\nclass ShapeCalculator\n{\n    public double CalculateTotalArea(Shape[] shapes)\n    {\n        double totalArea = 0;\n        foreach (var shape in shapes)\n        {\n            totalArea += shape.Area();\n        }\n        return totalArea;\n    }\n}"
  },
  {
    "language": "Julia",
    "code": "doors = falses(100)\nfor a in 1:100, b in a:a:100\n    doors[b] = !doors[b]\nend\nfor a = 1:100\n    println(\"Door $a is \" * (doors[a] ? \"open.\" : \"closed.\"))\nend\n"
  },
  {
    "language": "Julia",
    "code": "for i in 1:10 println(\"Door $(i^2) is open.\") end\n"
  },
  {
    "language": "Julia",
    "code": "function solve24(nums)\n    length(nums) != 4 && error(\"Input must be a 4-element Array\")\n    syms = [+,-,*,/]\n    for x in syms, y in syms, z in syms\n        for i = 1:24\n            a,b,c,d = nthperm(nums,i)\n            if round(x(y(a,b),z(c,d)),5) == 24\n                return \"($a$y$b)$x($c$z$d)\"\n            elseif round(x(a,y(b,z(c,d))),5) == 24\n                return \"$a$x($b$y($c$z$d))\"\n            elseif round(x(y(z(c,d),b),a),5) == 24\n                return \"(($c$z$d)$y$b)$x$a\"\n            elseif round(x(y(b,z(c,d)),a),5) == 24\n                return \"($b$y($c$z$d))$x$a\"\n            end\n        end\n    end\n    return \"0\"\nend\n"
  },
  {
    "language": "Julia",
    "code": "validexpr(ex::Expr) = ex.head == :call && ex.args[1] in [:*,:/,:+,:-] && all(validexpr, ex.args[2:end])\nvalidexpr(ex::Int) = true\nvalidexpr(ex::Any) = false\nfindnumbers(ex::Number) = Int[ex]\nfindnumbers(ex::Expr) = vcat(map(findnumbers, ex.args)...)\nfindnumbers(ex::Any) = Int[]\nfunction twentyfour()\n    digits = sort!(rand(1:9, 4))\n    while true\n        print(\"enter expression using $digits => \")\n        ex = parse(readline())\n        try\n            validexpr(ex) || error(\"only *, /, +, - of integers is allowed\")\n            nums = sort!(findnumbers(ex))\n            nums == digits || error(\"expression $ex used numbers $nums != $digits\")\n            val = eval(ex)\n            val == 24 || error(\"expression $ex evaluated to $val, not 24\")\n            println(\"you won!\")\n            return\n        catch e\n            if isa(e, ErrorException)\n                println(\"incorrect: \", e.msg)\n            else\n                rethrow()\n            end\n        end\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Combinatorics, StatsBase\n\nnamesofline(n) = counts([x[1] for x in integer_partitions(n)])\n\nfunction centerjustpyramid(n)\n    maxwidth = length(string(namesofline(n)))\n    for i in 1:n\n        s = string(namesofline(i))\n        println(\" \" ^ div(maxwidth - length(s), 2), s)\n    end\nend\n\ncenterjustpyramid(25)\n\nconst cachecountpartitions = Dict{BigInt,BigInt}()\nfunction countpartitions(n::BigInt)\n    if n < 0\n        0\n    elseif n < 2\n        1\n    elseif (np = get(cachecountpartitions, n, 0)) > 0\n        np\n    else\n        np = 0\n        sgn = 1\n        for k = 1:n\n            np += sgn * (countpartitions(n - (k*(3k-1)) >> 1) + countpartitions(n - (k*(3k+1)) >> 1))\n            sgn = -sgn\n        end\n        cachecountpartitions[n] = np\n    end\nend\n\nG(n) = countpartitions(BigInt(n))\n\nfor g in [23, 123, 1234, 12345]\n    @time println(\"\\nG($g) is $(G(g))\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "for i = 99:-1:1 print(\"\\n$i bottles of beer on the wall\\n$i bottles of beer\\nTake one down, pass it around\\n$(i-1) bottles of beer on the wall\\n\") end\n"
  },
  {
    "language": "Julia",
    "code": "bottles(n) = n==0 ? \"No more bottles\" :\n             n==1 ? \"1 bottle\" :\n             \"$n bottles\"\n\nfor n = 99:-1:1\n    println(\"\"\"\n        $(bottles(n)) of beer on the wall\n        $(bottles(n)) of beer\n        Take one down, pass it around\n        $(bottles(n-1)) of beer on the wall\n    \"\"\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "bottles(n) = \"$(n==0 ? \"No more\" : n) bottle$(n==1 ? \"\" : \"s\")\"\n"
  },
  {
    "language": "Julia",
    "code": "input = parse.(Int, split(readline(stdin)))\nprintln(stdout, sum(input))\n"
  },
  {
    "language": "Julia",
    "code": "julia> println(parse(Int, readuntil(stdin, ' ')) + parse(Int, readuntil(stdin, '\\n')))\n1 2\n3\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nfunction abc(str::AbstractString, list)\n    isempty(str) && return true\n    for i in eachindex(list)\n        str[end] in list[i] &&\n            any([abc(str[1:end-1], deleteat!(copy(list), i))]) &&\n            return true\n    end\n    return false\nend\n\nlet test = [\"A\", \"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"],\n    list = [\"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\n            \"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"]\n    for str in test\n        @printf(\"%-8s |  %s\\n\", str, abc(str, list))\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "abstract type \u00abname\u00bb end\nabstract type \u00abname\u00bb <: \u00absupertype\u00bb end\n"
  },
  {
    "language": "Julia",
    "code": "abstract type Number end\nabstract type Real          <: Number end\nabstract type FloatingPoint <: Real end\nabstract type Integer       <: Real end\nabstract type Signed        <: Integer end\nabstract type Unsigned      <: Integer end\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib(p::Int64, a::Int64)\n    n = one(p)\n    pcon = one(p)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum(n::Int64)\n    dsum = one(n)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "const L = 2*10^4\niclasslabel = [\"Deficient\", \"Perfect\", \"Abundant\"]\niclass = zeros(Int64, 3)\niclass[1] = one(Int64) #by convention 1 is deficient\n\nfor n in 2:L\n    if isprime(n)\n        iclass[1] += 1\n    else\n        iclass[sign(divisorsum(n)-n)+2] += 1\n    end\nend\n\nprintln(\"Classification of integers from 1 to \", L)\nfor i in 1:3\n    println(\"   \", iclasslabel[i], \", \", iclass[i])\nend\n"
  },
  {
    "language": "Julia",
    "code": "function accumulator(i)\n\tf(n) = i += n\n\treturn f\nend\n\nx = accumulator(1)\n@show x(5)\n\naccumulator(3)\n@show x(2.3)\n"
  },
  {
    "language": "Julia",
    "code": "function ack(m,n)\n    if m == 0\n        return n + 1\n    elseif n == 0\n        return ack(m-1,1)\n    else\n        return ack(m-1,ack(m,n-1))\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "ack2(m::Integer, n::Integer) = m == 0 ? n + 1 : n == 0 ? ack2(m - 1, 1) : ack2(m - 1, ack2(m, n - 1))\n"
  },
  {
    "language": "Julia",
    "code": "using Memoize\n@memoize ack3(m::Integer, n::Integer) = m == 0 ? n + 1 : n == 0 ? ack3(m - 1, 1) : ack3(m - 1, ack3(m, n - 1))\n"
  },
  {
    "language": "Julia",
    "code": "mutable struct Integrator\n    func::Function\n    runningsum::Float64\n    dt::Float64\n    running::Bool\n    function Integrator(f::Function, dt::Float64)\n        this = new()\n        this.func = f\n        this.runningsum = 0.0\n        this.dt = dt\n        this.running = false\n        return this\n    end\nend\n\nfunction run(integ::Integrator, lastval::Float64 = 0.0)\n    lasttime = time()\n    while integ.running\n        sleep(integ.dt)\n        newtime = time()\n        measuredinterval = newtime - lasttime\n        newval = integ.func(measuredinterval)\n        integ.runningsum += (lastval + newval) * measuredinterval / 2.0\n        lasttime = newtime\n        lastval = newval\n    end\nend\n\nstart!(integ::Integrator) = (integ.running = true; @async run(integ))\nstop!(integ) = (integ.running = false)\nf1(t) = sin(2\u03c0 * t)\nf2(t) = 0.0\n\nit = Integrator(f1, 0.00001)\nstart!(it)\nsleep(2.0)\nit.func = f2\nsleep(0.5)\nv2 = it.runningsum\nprintln(\"After 2.5 seconds, integrator value was $v2\")\n"
  },
  {
    "language": "Julia",
    "code": "{\"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    },\n    {\n      \"type\": \"mobile\",\n      \"number\": \"123 456-7890\"\n    }]}\n"
  },
  {
    "language": "Julia",
    "code": "mutable struct Contact\n    name::String\n    phonenumber::Dict{Any,Any}\nend\n\nperson = Contact(\"Jane Doe\", Dict())\nperson.phonenumber[\"home\"] = \"212 555-1234\"\n"
  },
  {
    "language": "Julia",
    "code": "julia> x = [1, 2, 3]\njulia> ptr = pointer_from_objref(x)\nPtr{Void} @0x000000010282e4a0\njulia> unsafe_pointer_to_objref(ptr)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n"
  },
  {
    "language": "Julia",
    "code": "julia> A = [1, 2.3, 4]\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 4.0\n\njulia> p = pointer(A)\nPtr{Float64} @0x0000000113f70d60\n\njulia> unsafe_load(p, 3)\n4.0\n\njulia> unsafe_store!(p, 3.14159, 3)\njulia> A\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 3.14149\n\njulia> pointer_to_array(p, (3,))\n3-element Array{Float64,1}:\n 1.0\n 2.3\n 3.14149\n"
  },
  {
    "language": "Julia",
    "code": "julia>\njulia> q = convert(Ptr{Float64}, 0x0000000113f70d68)\nPtr{Float64} @0x0000000113f70d68\n\njulia> B = pointer_to_array(q, (2,))\n2-element Array{Float64,1}:\n 2.3\n 3.14149\n"
  },
  {
    "language": "Julia",
    "code": "function polycoefs(n::Int64)\n    pc = typeof(n)[]\n    if n < 0\n        return pc\n    end\n    sgn = one(n)\n    for k in n:-1:0\n        push!(pc, sgn*binomial(n, k))\n        sgn = -sgn\n    end\n    return pc\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nfunction stringpoly(n::Int64)\n    if n < 0\n        return \"\"\n    end\n    st = @sprintf \"(x - 1)^{%d} & = & \" n\n    for (i, c) in enumerate(polycoefs(n))\n        if i == 1\n            op = \"\"\n            ac = c\n        elseif c < 0\n            op = \"-\"\n            ac = abs(c)\n        else\n            op = \"+\"\n            ac = abs(c)\n        end\n        p = n + 1 - i\n        if p == 0\n            st *= @sprintf \" %s %d\\\\\\\\\" op ac\n        elseif ac == 1\n            st *= @sprintf \" %s x^{%d}\" op p\n        else\n            st *= @sprintf \" %s %dx^{%d}\" op ac p\n        end\n    end\n    return st\nend\n"
  },
  {
    "language": "Julia",
    "code": "function isaksprime(n::Int64)\n    if n < 2\n        return false\n    end\n    for c in polycoefs(n)[2:(end-1)]\n        if c%n != 0\n            return false\n        end\n    end\n    return true\nend\n"
  },
  {
    "language": "Julia",
    "code": "println(\"<math>\")\nprintln(\"\\\\begin{array}{lcl}\")\nfor i in 0:10\n    println(stringpoly(i))\nend\nprintln(\"\\\\end{array}\")\nprintln(\"</math>\\n\")\n\nL = 50\nprint(\"AKS primes less than \", L, \":  \")\nsep = \"\"\nfor i in 1:L\n    if isaksprime(i)\n        print(sep, i)\n        sep = \", \"\n    end\nend\nprintln()\n"
  },
  {
    "language": "Julia",
    "code": "txt = \"\"\"Given\\$a\\$txt\\$file\\$of\\$many\\$lines,\\$where\\$fields\\$within\\$a\\$line\\$\nare\\$delineated\\$by\\$a\\$single\\$'dollar'\\$character,\\$write\\$a\\$program\nthat\\$aligns\\$each\\$column\\$of\\$fields\\$by\\$ensuring\\$that\\$words\\$in\\$each\\$\ncolumn\\$are\\$separated\\$by\\$at\\$least\\$one\\$space.\nFurther,\\$allow\\$for\\$each\\$word\\$in\\$a\\$column\\$to\\$be\\$either\\$left\\$\njustified,\\$right\\$justified,\\$or\\$center\\$justified\\$within\\$its\\$column.\"\"\"\n\n# left/right/center justification of strings:\nljust(s, width) = s * \" \"^max(0, width - length(s))\nrjust(s, width) = \" \"^max(0, width - length(s)) * s\nfunction center(s, width)\n  pad = width - length(s)\n  if pad <= 0\n    return s\n  else\n    pad2 = div(pad, 2)\n    return \" \"^pad2 * s * \" \"^(pad - pad2)\n  end\nend\n\nparts = [split(rstrip(line, '$'), '$') for line in split(txt, '\\n')]\n\nmax_widths = zeros(Int, maximum(length, parts))\nfor line in parts\n  for (i, word) in enumerate(line)\n    max_widths[i] = max(max_widths[i], length(word))\n  end\nend\nmax_widths += 1 # separate cols by at least one space\n\nfor (label, justify) in ((\"Left\", ljust), (\"Right\",rjust), (\"Center\",center))\n  println(label, \" column-aligned output:\")\n  for line in parts\n    for (j, word) in enumerate(line)\n      print(justify(word, max_widths[j]))\n    end\n    println()\n  end\n  println(\"-\"^sum(max_widths))\nend\n"
  },
  {
    "language": "Julia",
    "code": "function aliquotclassifier{T<:Integer}(n::T)\n    a = T[n]\n    b = divisorsum(a[end])\n    len = 1\n    while len < 17 && !(b in a) && 0 < b && b < 2^47+1\n        push!(a, b)\n        b = divisorsum(a[end])\n        len += 1\n    end\n    if b in a\n        1 < len || return (\"Perfect\", a)\n        if b == a[1]\n            2 < len || return (\"Amicable\", a)\n            return (\"Sociable\", a)\n        elseif b == a[end]\n            return (\"Aspiring\", a)\n        else\n            return (\"Cyclic\", push!(a, b))\n        end\n    end\n    push!(a, b)\n    b != 0 || return (\"Terminating\", a)\n    return (\"Non-terminating\", a)\nend\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib{T<:Integer}(p::T, a::T)\n    n = one(T)\n    pcon = one(T)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum{T<:Integer}(n::T)\n    dsum = one(T)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Printf\n\nprintln(\"Classification Tests:\")\ntests = [1:12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\nfor i in tests\n    (class, a) = aliquotclassifier(i)\n    println(@sprintf(\"%8d => \", i), @sprintf(\"%16s, \", class), a)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(undef,N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nisalmostprime(n::Integer, k::Integer) = sum(values(factor(n))) == k\n\nfunction almostprimes(N::Integer, k::Integer) # return first N almost-k primes\n    P = Vector{typeof(k)}(undef,N)\n    i = 0; n = 2\n    while i < N\n        if isalmostprime(n, k) P[i += 1] = n end\n        n += 1\n    end\n    return P\nend\n\nfor k in 1:5\n    println(\"$k-Almost-primes: \", join(almostprimes(10, k), \", \"), \"...\")\nend\n"
  },
  {
    "language": "Julia",
    "code": "# This is a general purpose AMB function that takes a two-argument failure function and\n# arbitrary number of iterable objects and returns the first solution found as an array\n# this function is in essence an iterative backtracking solver\n\nfunction amb(failure, itrs...)\n    n = length(itrs)\n    if n == 1 return end\n    states = Vector(n)\n    values = Vector(n)\n    # starting point, we put down the first value from the first iterable object\n    states[1] = start(itrs[1])\n    values[1], states[1] = next(itrs[1], states[1])\n    i = 1\n    # main solver loop\n    while true\n        # test for failure\n        if i > 1 && failure(values[i-1], values[i])\n            # loop for generating a new value upon failure\n            # in fact this would be way more readable using goto, but Julia doesn't seem to have that :(\n            while true\n                # if we failed, we must generate a new value, but first we must check whether there is any\n                if done(itrs[i], states[i])\n                    # backtracking step with sanity check in case we ran out of values from the current generator\n                    if i == 1\n                        return\n                    else\n                        i -= 1\n                        continue\n                    end\n                else\n                    # if there is indeed a new value, generate it\n                    values[i], states[i] = next(itrs[i], states[i])\n                    break\n                end\n            end\n        else\n            # no failure branch\n            # if solution is ready (i.e. all generators are used) just return it\n            if i == n return values end\n            # else start up the next generator\n            i += 1\n            states[i] = start(itrs[i])\n            values[i], states[i] = next(itrs[i], states[i])\n        end\n    end\nend\n\n# Call our generic AMB function according to the task description and\n# form the solution sentence from the returned array of words\namb((s1,s2) -> s1[end] != s2[1], # failure function\n    [\"the\", \"that\", \"a\"],\n    [\"frog\", \"elephant\", \"thing\"],\n    [\"walked\", \"treaded\", \"grows\"],\n    [\"slowly\", \"quickly\"]) |>\n    x -> join(x, \" \") |>\n    println\n"
  },
  {
    "language": "Julia",
    "code": "function pcontrib(p::Int64, a::Int64)\n    n = one(p)\n    pcon = one(p)\n    for i in 1:a\n        n *= p\n        pcon += n\n    end\n    return pcon\nend\n\nfunction divisorsum(n::Int64)\n    dsum = one(n)\n    for (p, a) in factor(n)\n        dsum *= pcontrib(p, a)\n    end\n    dsum -= n\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Primes\n\nconst L = 2*10^4\nacnt = 0\n\nprintln(\"Amicable pairs not greater than \", L)\n\nfor i in 2:L\n    !isprime(i) || continue\n    j = divisorsum(i)\n    j < i && divisorsum(j) == i || continue\n    acnt += 1\n    println(@sprintf(\"%4d\", acnt), \" => \", j, \", \", i)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using Base.isless\n# Let's define the less than operator for any two vectors that have the same type:\n# This does lexicographic comparison, we use it on vectors of chars in this task.\nfunction Base.isless(t1, t2)\n    for (a, b) in zip(t1, t2) # zip only to the shorter length\n        if !isequal(a, b)\n            return isless(a, b)\n        end\n    end\n    return length(t1) < length(t2)\nend\n\n# The sort function of Julia doesn't work on strings, so we write one:\n# This returns a sorted vector of the chars of the given string\nsortchars(s::AbstractString) = sort(collect(Char, s))\n\n# Custom comparator function for sorting the loaded wordlist\nsortanagr(s1::AbstractString, s2::AbstractString) =\n    if length(s1) != length(s2) length(s1) < length(s2) else sortchars(s1) < sortchars(s2) end\n\n# Tests if two strings are deranged anagrams, returns a bool:\n# in our case s2 is never longer than s1\nfunction deranged(s1::AbstractString, s2::AbstractString)\n    # Tests for derangement first\n    for (a, b) in zip(s1, s2)\n        if a == b return false end\n    end\n    # s1 and s2 are deranged, but are they anagrams at all?\n    return sortchars(s1) == sortchars(s2)\nend\n\n# Task starts here, we load the wordlist line by line, strip eol char, and sort the wordlist\n# in a way that ensures that longer words come first and anagrams go next to each other\nwords = sort(open(readlines, \"./data/unixdict.txt\"), rev = true, lt = sortanagr)\n\n# Now we just look for deranged anagrams in the neighbouring words of the sorted wordlist\nfor i in 1:length(words)-1\n    if deranged(words[i], words[i+1])\n        # The first match is guaranteed to be the longest due to the custom sorting\n        println(\"The longest deranged anagrams are $(words[i]) and $(words[i+1])\")\n        break\n    end\nend\n"
  },
  {
    "language": "Julia",
    "code": "url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\nwordlist = open(readlines, download(url))\n\nwsort(word::AbstractString) = join(sort(collect(word)))\n\nfunction anagram(wordlist::Vector{<:AbstractString})\n    dict = Dict{String, Set{String}}()\n    for word in wordlist\n        sorted = wsort(word)\n        push!(get!(dict, sorted, Set{String}()), word)\n    end\n    wcnt = maximum(length, values(dict))\n    return collect(Iterators.filter((y) -> length(y) == wcnt, values(dict)))\nend\n\nprintln.(anagram(wordlist))\n"
  },
  {
    "language": "Julia",
    "code": "using Luxor\nusing Colors\nusing BoundaryValueDiffEq\n\n# constants for differential equations and movie\nconst g = 9.81\nconst L = 1.0                         # pendulum length in meters\nconst bobd = 0.10                     # pendulum bob diameter in meters\nconst framerate = 50.0                # intended frame rate/sec\nconst t0 = 0.0                        # start time (s)\nconst tf = 2.3                        # end simulation time (s)\nconst dtframe = 1.0/framerate         # time increment per frame\nconst tspan = LinRange(t0, tf, Int(floor(tf*framerate)))  # array of time points in animation\n\nconst bgcolor = \"black\"               # gif background\nconst leaderhue = (0.80, 0.70, 0.20)  # gif swing arm hue light gold\nconst hslcolors = [HSL(col) for col in (distinguishable_colors(\n                   Int(floor(tf*framerate)+3),[RGB(1,1,1)])[2:end])]\nconst giffilename = \"pendulum.gif\"    # output file\n\n# differential equations\nsimplependulum(du, u, p, t) = (\u03b8=u[1]; d\u03b8=u[2]; du[1]=d\u03b8; du[2]=-(g/L)*sin(\u03b8))\nbc2(residual, u, p, t) = (residual[1] = u[end\u00f72][1] + pi/2; residual[2] = u[end][1] - pi/2)\nbvp2 = BVProblem(simplependulum, bc2, [pi/2,pi/2], (tspan[1],tspan[end]))\nsol2 = solve(bvp2, MIRK4(), dt=dtframe) # use the MIRK4 solver for TwoPointBVProblem\n\n# movie making background\nbackdrop(scene, framenumber) = background(bgcolor)\n\nfunction frame(scene, framenumber)\n    u1, u2 = sol2.u[framenumber]\n    y, x = L*cos(u1), L*sin(u1)\n    sethue(leaderhue)\n    poly([Point(-4.0, 0.0), Point(4.0, 0.0),\n          Point(160.0x,160.0y)], :fill)\n    sethue(Colors.HSV(framenumber*4.0, 1, 1))\n    circle(Point(160.0x,160.0y), 160bobd, :fill)\n    text(string(\"frame $framenumber of $(scene.framerange.stop)\"),\n        Point(0.0, -190.0),\n        halign=:center)\nend\n\nmuv = Movie(400, 400, \"Pendulum Demo\", 1:length(tspan))\nanimate(muv, [Scene(muv, backdrop),\n              Scene(muv, frame, easingfunction=easeinoutcubic)],\n              creategif=true, pathname=giffilename)\n"
  },
  {
    "language": "Julia",
    "code": "using Tk\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction windowanim(stepinterval::Float64)\n    wind = Window(\"Animation\", 300, 100)\n    frm = Frame(wind)\n    hello = \"Hello World!                                           \"\n    but = Button(frm, width=30, text=hello)\n    rightward = true\n    callback(s) = (rightward = !rightward)\n    bind(but, \"command\", callback)\n    pack(frm, expand=true, fill = \"both\")\n    pack(but, expand=true, fill = \"both\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    while true\n        but[:text] = permut[ppos]\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if ppos > pmod\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if ppos < 1\n                ppos = pmod\n            end\n        end\n    end\nend\n\nwindowanim(frameinterval)\n"
  },
  {
    "language": "Julia",
    "code": "using Gtk.ShortNames\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction textanimation(stepinterval::Float64)\n    hello = \"Hello World!                        \"\n    win = Window(\"Animation\", 210, 40) |> (Frame() |> (but = Button(\"Switch Directions\")))\n    rightward = true\n    switchdirections(s) = (rightward = !rightward)\n    signal_connect(switchdirections, but, \"clicked\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    nobreak = true\n    endit(w) = (nobreak = false)\n    signal_connect(endit, win, :destroy)\n    showall(win)\n    while nobreak\n        setproperty!(but, :label, permut[ppos])\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if(ppos > pmod)\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if(ppos < 1)\n                ppos = pmod\n            end\n        end\n    end\nend\n\ntextanimation(frameinterval)\n"
  },
  {
    "language": "Julia",
    "code": "function fib(n)\n    if n < 0\n        throw(ArgumentError(\"negative arguments not allowed\"))\n    end\n    aux(m) = m < 2 ? one(m) : aux(m-1) + aux(m-2)\n    aux(n)\nend\n"
  },
  {
    "language": "Julia",
    "code": "using SHA  # security instincts say do not write bare passwords to a shared file even in toy code :)\n\nmutable struct Personnel\n    fullname::String\n    office::String\n    extension::String\n    homephone::String\n    email::String\n    Personnel(ful,off,ext,hom,ema) = new(ful,off,ext,hom,ema)\nend\n\nmutable struct Passwd\n     account::String\n     password::String\n     uid::Int32\n     gid::Int32\n     personal::Personnel\n     directory::String\n     shell::String\n     Passwd(acc,pas,uid,gid,per,dir,she) =  new(acc,pas,uid,gid,per,dir,she)\nend\n\nfunction writepasswd(filename, passrecords)\n    if(passrecords isa Array) == false\n        passrecords = [passrecords]\n    end\n    fh = open(filename, \"a\") # should throw an exception if cannot open in a locked or exclusive mode for append\n    for pas in passrecords\n        record = join([pas.account, bytes2hex(sha256(pas.password)), pas.uid, pas.gid,\n                 join([pas.personal.fullname, pas.personal.office, pas.personal.extension,\n                 pas.personal.homephone, pas.personal.email], ','),\n                 pas.directory, pas.shell], ':')\n        write(fh, record, \"\\n\")\n    end\n    close(fh)\nend\n\nconst jsmith = Passwd(\"jsmith\",\"x\",1001, 1000, Personnel(\"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\"), \"/home/jsmith\", \"/bin/bash\")\nconst jdoe = Passwd(\"jdoe\",\"x\",1002, 1000, Personnel(\"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\"), \"/home/jdoe\", \"/bin/bash\")\nconst xyz = Passwd(\"xyz\",\"x\",1003, 1000, Personnel(\"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\"), \"/home/xyz\", \"/bin/bash\")\n\nconst pfile = \"pfile.csv\"\nwritepasswd(pfile, [jsmith, jdoe])\nprintln(\"Before last record added, file is:\\n$(readstring(pfile))\")\nwritepasswd(pfile, xyz)\nprintln(\"After last record added, file is:\\n$(readstring(pfile))\")\n"
  },
  {
    "language": "Julia",
    "code": "numbers = [1, 3, 5, 7]\n\n@show [n ^ 2 for n in numbers]                  # list comprehension\nsquare(x) = x ^ 2; @show map(square, numbers)   # functional form\n@show map(x -> x ^ 2, numbers)                  # functional form with anonymous function\n@show [n * n for n in numbers]    \t\t\t\t# no need for a function,\n@show numbers .* numbers                        # element-wise operation\n@show numbers .^ 2                              # includes .+, .-, ./, comparison, and bitwise operations as well\n"
  },
  {
    "language": "Julia",
    "code": "julia> @elapsed bigstr = string(BigInt(5)^4^3^2)\n0.017507363\n\njulia> length(bigstr)\n183231\n\njulia> bigstr[1:20]\n\"62060698786608744707\"\n\njulia> bigstr[end-20:end]\n\"892256259918212890625\"\n"
  },
  {
    "language": "Julia",
    "code": "matrix = zeros(Float64, (1000,1000,1000))\n# use matrix, then when done set variable to 0 to garbage collect the matrix:\nmatrix = 0 # large memory pool will now be collected when needed\n"
  },
  {
    "language": "Julia",
    "code": "julia> z1 = 1.5 + 3im\njulia> z2 = 1.5 + 1.5im\njulia> z1 + z2\n3.0 + 4.5im\njulia> z1 - z2\n0.0 + 1.5im\njulia> z1 * z2\n-2.25 + 6.75im\njulia> z1 / z2\n1.5 + 0.5im\njulia> - z1\n-1.5 - 3.0im\njulia> conj(z1), z1'   # two ways to conjugate\n(1.5 - 3.0im,1.5 - 3.0im)\njulia> abs(z1)\n3.3541019662496847\njulia> z1^z2\n-1.102482955327779 - 0.38306415117199305im\njulia> real(z1)\n1.5\njulia> imag(z1)\n3.0\n"
  },
  {
    "language": "Kotlin",
    "code": "fun oneHundredDoors(): List<Int> {\n    val doors = BooleanArray(100, { false })\n    for (i in 0..99) {\n        for (j in i..99 step (i + 1)) {\n            doors[j] = !doors[j]\n        }\n    }\n    return doors\n        .mapIndexed { i, b -> i to b }\n        .filter { it.second }\n        .map { it.first + 1 }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\nimport java.util.Random\n\nconst val N_CARDS = 4\nconst val SOLVE_GOAL = 24\nconst val MAX_DIGIT = 9\n\nclass Frac(val num: Int, val den: Int)\n\nenum class OpType { NUM, ADD, SUB, MUL, DIV }\n\nclass Expr(\n    var op:    OpType = OpType.NUM,\n    var left:  Expr?  = null,\n    var right: Expr?  = null,\n    var value: Int    = 0\n)\n\nfun showExpr(e: Expr?, prec: OpType, isRight: Boolean) {\n    if (e == null) return\n    val op = when (e.op) {\n        OpType.NUM -> { print(e.value); return }\n        OpType.ADD -> \" + \"\n        OpType.SUB -> \" - \"\n        OpType.MUL -> \" x \"\n        OpType.DIV -> \" / \"\n    }\n\n    if ((e.op == prec && isRight) || e.op < prec) print(\"(\")\n    showExpr(e.left, e.op, false)\n    print(op)\n    showExpr(e.right, e.op, true)\n    if ((e.op == prec && isRight) || e.op < prec) print(\")\")\n}\n\nfun evalExpr(e: Expr?): Frac {\n    if (e == null) return Frac(0, 1)\n    if (e.op == OpType.NUM) return Frac(e.value, 1)\n    val l = evalExpr(e.left)\n    val r = evalExpr(e.right)\n    return when (e.op) {\n        OpType.ADD -> Frac(l.num * r.den + l.den * r.num, l.den * r.den)\n        OpType.SUB -> Frac(l.num * r.den - l.den * r.num, l.den * r.den)\n        OpType.MUL -> Frac(l.num * r.num, l.den * r.den)\n        OpType.DIV -> Frac(l.num * r.den, l.den * r.num)\n        else       -> throw IllegalArgumentException(\"Unknown op: ${e.op}\")\n    }\n}\n\nfun solve(ea: Array<Expr?>, len: Int): Boolean {\n    if (len == 1) {\n        val final = evalExpr(ea[0])\n        if (final.num == final.den * SOLVE_GOAL && final.den != 0) {\n            showExpr(ea[0], OpType.NUM, false)\n            return true\n        }\n    }\n\n    val ex = arrayOfNulls<Expr>(N_CARDS)\n    for (i in 0 until len - 1) {\n        for (j in i + 1 until len) ex[j - 1] = ea[j]\n        val node = Expr()\n        ex[i] = node\n        for (j in i + 1 until len) {\n            node.left = ea[i]\n            node.right = ea[j]\n            for (k in OpType.values().drop(1)) {\n                node.op = k\n                if (solve(ex, len - 1)) return true\n            }\n            node.left = ea[j]\n            node.right = ea[i]\n            node.op = OpType.SUB\n            if (solve(ex, len - 1)) return true\n            node.op = OpType.DIV\n            if (solve(ex, len - 1)) return true\n            ex[j] = ea[j]\n        }\n        ex[i] = ea[i]\n    }\n    return false\n}\n\nfun solve24(n: IntArray) =\n    solve (Array(N_CARDS) { Expr(value = n[it]) }, N_CARDS)\n\nfun main(args: Array<String>) {\n    val r = Random()\n    val n = IntArray(N_CARDS)\n    for (j in 0..9) {\n        for (i in 0 until N_CARDS) {\n            n[i] = 1 + r.nextInt(MAX_DIGIT)\n            print(\" ${n[i]}\")\n        }\n        print(\":  \")\n        println(if (solve24(n)) \"\" else \"No solution\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Random\nimport java.util.Scanner\nimport java.util.Stack\n\ninternal object Game24 {\n    fun run() {\n        val r = Random()\n        val digits = IntArray(4).map { r.nextInt(9) + 1 }\n        println(\"Make 24 using these digits: $digits\")\n        print(\"> \")\n\n        val s = Stack<Float>()\n        var total = 0L\n        val cin = Scanner(System.`in`)\n        for (c in cin.nextLine()) {\n            when (c) {\n                in '0'..'9' -> {\n                    val d = c - '0'\n                    total += (1 shl (d * 5)).toLong()\n                    s += d.toFloat()\n                }\n                else ->\n                    if (\"+/-*\".indexOf(c) != -1) {\n                        s += c.applyOperator(s.pop(), s.pop())\n                    }\n            }\n        }\n\n        when {\n            tally(digits) != total ->\n                print(\"Not the same digits. \")\n            s.peek().compareTo(target) == 0 ->\n                println(\"Correct!\")\n            else ->\n                print(\"Not correct.\")\n        }\n    }\n\n    private fun Char.applyOperator(a: Float, b: Float) = when (this) {\n        '+' -> a + b\n        '-' -> b - a\n        '*' -> a * b\n        '/' -> b / a\n        else -> Float.NaN\n    }\n\n    private fun tally(a: List<Int>): Long = a.reduce({ t, i -> t + (1 shl (i * 5)) }).toLong()\n\n    private val target = 24\n}\n\nfun main(args: Array<String>) = Game24.run()\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.min\nimport java.math.BigInteger\nimport java.util.ArrayList\nimport java.util.Arrays.asList\n\nfun namesOfGod(n: Int): List<BigInteger> {\n    val cache = ArrayList<List<BigInteger>>()\n    cache.add(asList(BigInteger.ONE))\n\n    (cache.size..n).forEach { l ->\n        val r = ArrayList<BigInteger>()\n        r.add(BigInteger.ZERO)\n\n        (1..l).forEach { x ->\n            r.add(r[r.size - 1] + cache[l - x][min(x, l - x)])\n        }\n        cache.add(r)\n    }\n    return cache[n]\n}\n\nfun row(n: Int) = namesOfGod(n).let { r -> (0 until n).map { r[it + 1] - r[it] } }\n\nfun main(args: Array<String>) {\n    println(\"Rows:\")\n    (1..25).forEach {\n        System.out.printf(\"%2d: %s%n\", it, row(it))\n    }\n\n    println(\"\\nSums:\")\n    intArrayOf(23, 123, 1234, 1234).forEach {\n        val c = namesOfGod(it)\n        System.out.printf(\"%s %s%n\", it, c[c.size - 1])\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    for (i in 99.downTo(1)) {\n        println(\"$i bottles of beer on the wall\")\n        println(\"$i bottles of beer\")\n        println(\"Take one down, pass it around\")\n    }\n    println(\"No more bottles of beer on the wall!\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun main(args: Array<String>) {\n    val r = Regex(\"\"\"-?\\d+[ ]+-?\\d+\"\"\")\n    while(true) {\n        print(\"Enter two integers separated by space(s) or q to quit: \")\n        val input: String = readLine()!!.trim()\n        if (input == \"q\" || input == \"Q\") break\n        if (!input.matches(r)) {\n            println(\"Invalid input, try again\")\n            continue\n        }\n        val index = input.lastIndexOf(' ')\n        val a = input.substring(0, index).trimEnd().toInt()\n        val b = input.substring(index + 1).toInt()\n        if (Math.abs(a) > 1000 || Math.abs(b) > 1000) {\n            println(\"Both numbers must be in the interval [-1000, 1000] - try again\")\n        }\n        else {\n            println(\"Their sum is ${a + b}\\n\")\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "object ABC_block_checker {\n    fun run() {\n        val blocks = arrayOf(\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\")\n\n        println(\"\\\"\\\": \" + blocks.canMakeWord(\"\"))\n        val words = arrayOf(\"A\", \"BARK\", \"book\", \"treat\", \"COMMON\", \"SQuAd\", \"CONFUSE\")\n        for (w in words)  println(\"$w: \" + blocks.canMakeWord(w))\n    }\n\n    private fun Array<String>.swap(i: Int, j: Int) {\n        val tmp = this[i]\n        this[i] = this[j]\n        this[j] = tmp\n    }\n\n    private fun Array<String>.canMakeWord(word: String): Boolean {\n        if (word.isEmpty())\n            return true\n\n        val c = Character.toUpperCase(word.first())\n        var i = 0\n        forEach { b ->\n            if (b.first().toUpperCase() == c || b[1].toUpperCase() == c) {\n                swap(0, i)\n                if (drop(1).toTypedArray().canMakeWord(word.substring(1)))\n                    return true\n                swap(0, i)\n            }\n            i++\n        }\n\n        return false\n    }\n}\n\nfun main(args: Array<String>) = ABC_block_checker.run()\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\ninterface Announcer {\n    fun announceType()\n\n    // interface can contain non-abstract members but cannot store state\n    fun announceName() {\n        println(\"I don't have a name\")\n    }\n}\n\nabstract class Animal: Announcer {\n    abstract fun makeNoise()\n\n    // abstract class can contain non-abstract members\n    override fun announceType() {\n        println(\"I am an Animal\")\n    }\n}\n\nclass Dog(private val name: String) : Animal() {\n    override fun makeNoise() {\n       println(\"Woof!\")\n    }\n\n    override fun announceName() {\n       println(\"I'm called $name\")\n    }\n}\n\nclass Cat: Animal() {\n    override fun makeNoise() {\n       println(\"Meow!\")\n    }\n\n    override fun announceType() {\n       println(\"I am a Cat\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val d = Dog(\"Fido\")\n    with(d) {\n        makeNoise()\n        announceType()  // inherits Animal's implementation\n        announceName()\n    }\n    println()\n    val c = Cat()\n    with(c) {\n        makeNoise()\n        announceType()\n        announceName()  // inherits Announcer's implementation\n   }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun sumProperDivisors(n: Int) =\n    if (n < 2) 0 else (1..n / 2).filter { (n % it) == 0 }.sum()\n\nfun main(args: Array<String>) {\n    var sum: Int\n    var deficient = 0\n    var perfect = 0\n    var abundant = 0\n\n    for (n in 1..20000) {\n        sum = sumProperDivisors(n)\n        when {\n            sum < n -> deficient++\n            sum == n -> perfect++\n            sum > n -> abundant++\n        }\n    }\n\n    println(\"The classification of the numbers from 1 to 20,000 is as follows:\\n\")\n    println(\"Deficient = $deficient\")\n    println(\"Perfect   = $perfect\")\n    println(\"Abundant  = $abundant\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun foo(n: Double): (d: Double) -> Double {\n    var nn = n\n    return { nn += it; nn }\n}\n\nfun foo(n: Int): (i: Int) -> Int {\n    var nn = n\n    return { nn += it; nn }\n}\n\nfun main(args: Array<String>) {\n    val x = foo(1.0) // calls 'Double' overload\n    x(5.0)\n    foo(3.0)\n    println(x(2.3))\n    val y = foo(1)   // calls 'Int' overload\n    y(5)\n    foo(5)\n    println(y(2))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun A(m: Long, n: Long): Long = when {\n    m == 0L -> n + 1\n    m > 0L -> when {\n        n == 0L -> A(m - 1, 1)\n        n > 0L -> A(m - 1, A(m, n - 1))\n        else -> throw IllegalArgumentException(\"illegal n\")\n    }\n    else -> throw IllegalArgumentException(\"illegal m\")\n}\n\nfun main(args: Array<String>) {\n    val M: Long = 4\n    val N: Long = 20\n    val r = 0..N\n    for (m  in 0..M) {\n        print(\"\\nA($m, $r) =\")\n        var able = true\n        r.forEach {\n            try {\n                if (able) {\n                    val a = A(m, it)\n                    print(\" %6d\".format(a))\n                } else\n                    print(\"      ?\")\n            } catch(e: Throwable) {\n                print(\"      ?\")\n                able = false\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import org.apache.directory.api.ldap.model.exception.LdapException\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection\nimport java.io.IOException\nimport java.util.logging.Level\nimport java.util.logging.Logger\n\nclass LDAP(map: Map<String, String>) {\n    fun run() {\n        var connection: LdapNetworkConnection? = null\n        try {\n            if (info) log.info(\"LDAP Connection to $hostname on port $port\")\n            connection = LdapNetworkConnection(hostname, port.toInt())\n\n            try {\n                if (info) log.info(\"LDAP bind\")\n                connection.bind()\n            } catch (e: LdapException) {\n                log.severe(e.toString())\n            }\n\n            try {\n                if (info) log.info(\"LDAP unbind\")\n                connection.unBind()\n            } catch (e: LdapException) {\n                log.severe(e.toString())\n            }\n        } finally {\n            try {\n                if (info) log.info(\"LDAP close connection\")\n                connection!!.close()\n            } catch (e: IOException) {\n                log.severe(e.toString())\n            }\n        }\n    }\n\n    private val log = Logger.getLogger(LDAP::class.java.name)\n    private val info = log.isLoggable(Level.INFO)\n    private val hostname: String by map\n    private val port: String by map\n}\n\nfun main(args: Array<String>) = LDAP(mapOf(\"hostname\" to \"localhost\", \"port\"  to \"10389\")).run()\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.0\n\nimport kotlin.math.*\n\ntypealias Function = (Double) -> Double\n\n/**\n * Integrates input function K over time\n * S + (t1 - t0) * (K(t1) + K(t0)) / 2\n */\nclass Integrator {\n    private val start: Long\n    private @Volatile var running = false\n    private lateinit var func: Function\n    private var t0 = 0.0\n    private var v0 = 0.0\n    private var sum = 0.0\n\n    constructor(func: Function) {\n        start = System.nanoTime()\n        setFunc(func)\n        Thread(this::integrate).start()\n    }\n\n    fun setFunc(func: Function) {\n        this.func = func\n        v0 = func(0.0)\n        t0 = 0.0\n    }\n\n    fun getOutput() = sum\n\n    fun stop() {\n        running = false\n    }\n\n    private fun integrate() {\n        running = true\n        while (running) {\n            try {\n                Thread.sleep(1)\n                update()\n            }\n            catch(e: InterruptedException) {\n                return\n            }\n        }\n    }\n\n    private fun update() {\n        val t1 = (System.nanoTime() - start) / 1.0e9\n        val v1 = func(t1)\n        val rect = (t1 - t0) * (v0 + v1) / 2.0\n        sum  += rect\n        t0 = t1\n        v0 = v1\n    }\n}\n\nfun main(args: Array<String>) {\n    val integrator = Integrator( { sin(PI * it) } )\n    Thread.sleep(2000)\n\n    integrator.setFunc( { 0.0 } )\n    Thread.sleep(500)\n\n    integrator.stop()\n    println(integrator.getOutput())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nclass SomeClass {\n    val runtimeVariables = mutableMapOf<String, Any>()\n}\n\nfun main(args: Array<String>) {\n    val sc = SomeClass()\n    println(\"Create two variables at runtime: \")\n    for (i in 1..2) {\n        println(\"  Variable #$i:\")\n        print(\"       Enter name  : \")\n        val name = readLine()!!\n        print(\"       Enter value : \")\n        val value = readLine()!!\n        sc.runtimeVariables.put(name, value)\n        println()\n    }\n    while (true) {\n        print(\"Which variable do you want to inspect ? \")\n        val name = readLine()!!\n        val value = sc.runtimeVariables[name]\n        if (value == null) {\n            println(\"There is no variable of that name, try again\")\n        } else {\n            println(\"Its value is '${sc.runtimeVariables[name]}'\")\n            return\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    val intVar = nativeHeap.alloc<IntVar>()\n    intVar.value = 42\n    with(intVar) { println(\"Value is $value, address is $rawPtr\") }\n    nativeHeap.free(intVar)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun binomial(n: Int, k: Int): Long = when {\n    n < 0 || k < 0 -> throw IllegalArgumentException(\"negative numbers not allowed\")\n    k == 0         -> 1L\n    k == n         -> 1L\n    else           -> {\n        var prod = 1L\n        var div  = 1L\n        for (i in 1..k) {\n            prod *= (n + 1 - i)\n            div  *= i\n            if (prod % div == 0L) {\n                prod /= div\n                div = 1L\n            }\n        }\n        prod\n    }\n}\n\nfun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n    return (1 until n).none { binomial(n, it) % n.toLong() != 0L }\n}\n\nfun main(args: Array<String>) {\n    var coeff: Long\n    var sign: Int\n    var op: String\n    for (n in 0..9) {\n        print(\"(x - 1)^$n = \")\n        sign = 1\n        for (k in n downTo 0) {\n            coeff = binomial(n, k)\n            op = if (sign == 1) \" + \" else \" - \"\n            when (k) {\n                n    -> print(\"x^$n\")\n                0    -> println(\"${op}1\")\n                else -> print(\"$op${coeff}x^$k\")\n            }\n            if (n == 0) println()\n            sign *= -1\n        }\n    }\n    // generate primes under 62\n    var p = 2\n    val primes = mutableListOf<Int>()\n    do {\n        if (isPrime(p)) primes.add(p)\n        if (p != 2) p += 2 else p = 3\n    }\n    while (p < 62)\n    println(\"\\nThe prime numbers under 62 are:\")\n    println(primes)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.nio.charset.StandardCharsets\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\nenum class AlignFunction {\n    LEFT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + s.length + 's').format(s)) },\n    RIGHT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + l + 's').format(s)) },\n    CENTER { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + ((l + s.length) / 2) + 's').format(s)) };\n\n    abstract operator fun invoke(s: String, l: Int): String\n}\n\n/** Aligns fields into columns, separated by \"|\".\n * @constructor Initializes columns aligner from lines in a list of strings.\n * @property lines Lines in a single string. Empty string does form a column.\n */\nclass ColumnAligner(val lines: List<String>) {\n     operator fun invoke(a: AlignFunction) : String {\n        var result = \"\"\n        for (lineWords in words) {\n            for (i in lineWords.indices) {\n                if (i == 0)\n                    result += '|'\n                result += a(lineWords[i], column_widths[i])\n                result += '|'\n            }\n            result += '\\n'\n        }\n        return result\n    }\n\n    private val words = arrayListOf<Array<String>>()\n    private val column_widths = arrayListOf<Int>()\n\n    init {\n        lines.forEach  {\n            val lineWords = java.lang.String(it).split(\"\\\\$\")\n            words += lineWords\n            for (i in lineWords.indices) {\n                if (i >= column_widths.size) {\n                    column_widths += lineWords[i].length\n                } else {\n                    column_widths[i] = Math.max(column_widths[i], lineWords[i].length)\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isEmpty()) {\n        println(\"Usage: ColumnAligner file [L|R|C]\")\n        return\n    }\n    val ca = ColumnAligner(Files.readAllLines(Paths.get(args[0]), StandardCharsets.UTF_8))\n    val alignment = if (args.size >= 2) args[1] else \"L\"\n    when (alignment) {\n        \"L\" -> print(ca(AlignFunction.LEFT))\n        \"R\" -> print(ca(AlignFunction.RIGHT))\n        \"C\" -> print(ca(AlignFunction.CENTER))\n        else -> System.err.println(\"Error! Unknown alignment: \" + alignment)\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.3\n\ndata class Classification(val sequence: List<Long>, val aliquot: String)\n\nconst val THRESHOLD = 1L shl 47\n\nfun sumProperDivisors(n: Long): Long {\n    if (n < 2L) return 0L\n    val sqrt = Math.sqrt(n.toDouble()).toLong()\n    var sum = 1L + (2L..sqrt)\n        .filter { n % it == 0L }\n        .map { it + n / it }\n        .sum()\n    if (sqrt * sqrt == n) sum -= sqrt\n    return sum\n}\n\nfun classifySequence(k: Long): Classification {\n    require(k > 0)\n    var last = k\n    val seq = mutableListOf(k)\n    while (true) {\n        last = sumProperDivisors(last)\n        seq.add(last)\n        val n = seq.size\n        val aliquot = when {\n            last == 0L                  -> \"Terminating\"\n            n == 2 && last == k         -> \"Perfect\"\n            n == 3 && last == k         -> \"Amicable\"\n            n >= 4 && last == k         -> \"Sociable[${n - 1}]\"\n            last == seq[n - 2]          -> \"Aspiring\"\n            last in seq.slice(1..n - 3) -> \"Cyclic[${n - 1 - seq.indexOf(last)}]\"\n            n == 16 || last > THRESHOLD -> \"Non-Terminating\"\n            else                        -> \"\"\n        }\n        if (aliquot != \"\") return Classification(seq, aliquot)\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\"Aliqot classifications - periods for Sociable/Cyclic in square brackets:\\n\")\n    for (k in 1L..10) {\n        val (seq, aliquot) = classifySequence(k)\n        println(\"${\"%2d\".format(k)}: ${aliquot.padEnd(15)} $seq\")\n    }\n\n    val la = longArrayOf(\n        11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488\n    )\n    println()\n\n    for (k in la) {\n        val (seq, aliquot) = classifySequence(k)\n        println(\"${\"%7d\".format(k)}: ${aliquot.padEnd(15)} $seq\")\n    }\n\n    println()\n\n    val k = 15355717786080L\n    val (seq, aliquot) = classifySequence(k)\n    println(\"$k: ${aliquot.padEnd(15)} $seq\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun Int.k_prime(x: Int): Boolean {\n    var n = x\n    var f = 0\n    var p = 2\n    while (f < this && p * p <= n) {\n        while (0 == n % p) { n /= p; f++ }\n        p++\n    }\n    return f + (if (n > 1) 1 else 0) == this\n}\n\nfun Int.primes(n : Int) : List<Int> {\n    var i = 2\n    var list = mutableListOf<Int>()\n    while (list.size < n) {\n        if (k_prime(i)) list.add(i)\n        i++\n    }\n    return list\n}\n\nfun main(args: Array<String>) {\n    for (k in 1..5)\n        println(\"k = $k: \" + k.primes(10))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.41\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nfun main(args: Array<String>) = amb {\n    val a = amb(\"the\", \"that\", \"a\")\n    val b = amb(\"frog\", \"elephant\", \"thing\")\n    val c = amb(\"walked\", \"treaded\", \"grows\")\n    val d = amb(\"slowly\", \"quickly\")\n\n    if (a[a.lastIndex] != b[0]) amb()\n    if (b[b.lastIndex] != c[0]) amb()\n    if (c[c.lastIndex] != d[0]) amb()\n\n    println(listOf(a, b, c, d))\n\n\n    val x = amb(1, 2, 3)\n    val y = amb(7, 6, 4, 5)\n    if (x * y != 8) amb()\n    println(listOf(x, y))\n}\n\n\nclass AmbException(): Exception(\"Refusing to execute\")\ndata class AmbPair<T>(val cont: Continuation<T>, val valuesLeft: MutableList<T>)\n\n@RestrictsSuspension\nclass AmbEnvironment {\n    val ambList = mutableListOf<AmbPair<*>>()\n\n    suspend fun <T> amb(value: T, vararg rest: T): T = suspendCoroutineOrReturn { cont ->\n        if (rest.size > 0) {\n            ambList.add(AmbPair(clone(cont), mutableListOf(*rest)))\n        }\n\n        value\n    }\n\n    suspend fun amb(): Nothing = suspendCoroutine<Nothing> { }\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <R> amb(block: suspend AmbEnvironment.() -> R): R {\n    var result: R? = null\n    var toThrow: Throwable? = null\n\n    val dist = AmbEnvironment()\n    block.startCoroutine(receiver = dist, completion = object : Continuation<R> {\n        override val context: CoroutineContext get() = EmptyCoroutineContext\n        override fun resume(value: R) { result = value }\n        override fun resumeWithException(exception: Throwable) { toThrow = exception }\n    })\n\n    while (result == null && toThrow == null && !dist.ambList.isEmpty()) {\n        val last = dist.ambList.run { this[lastIndex] }\n\n        if (last.valuesLeft.size == 1) {\n            dist.ambList.removeAt(dist.ambList.lastIndex)\n            last.apply {\n                (cont as Continuation<Any?>).resume(valuesLeft[0])\n            }\n        } else {\n            val value = last.valuesLeft.removeAt(last.valuesLeft.lastIndex)\n            (clone(last.cont) as Continuation<Any?>).resume(value)\n        }\n    }\n\n    if (toThrow != null)\n    {\n        throw toThrow!!\n    }\n    else if (result != null)\n    {\n        return result!!\n    }\n    else\n    {\n        throw AmbException()\n    }\n}\n\nval UNSAFE = Class.forName(\"sun.misc.Unsafe\")\n    .getDeclaredField(\"theUnsafe\")\n    .apply { isAccessible = true }\n    .get(null) as sun.misc.Unsafe\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <T: Any> clone(obj: T): T {\n    val clazz = obj::class.java\n    val copy = UNSAFE.allocateInstance(clazz) as T\n    copyDeclaredFields(obj, copy, clazz)\n    return copy\n}\n\ntailrec fun <T> copyDeclaredFields(obj: T, copy: T, clazz: Class<out T>) {\n    for (field in clazz.declaredFields) {\n        field.isAccessible = true\n        val v = field.get(obj)\n        field.set(copy, if (v === obj) copy else v)\n    }\n    val superclass = clazz.superclass\n    if (superclass != null) copyDeclaredFields(obj, copy, superclass)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun sumProperDivisors(n: Int): Int {\n    if (n < 2) return 0\n    return (1..n / 2).filter{ (n % it) == 0 }.sum()\n}\n\nfun main(args: Array<String>) {\n    val sum = IntArray(20000, { sumProperDivisors(it) } )\n    println(\"The pairs of amicable numbers below 20,000 are:\\n\")\n    for(n in 2..19998) {\n        val m = sum[n]\n        if (m > n && m < 20000 && n == sum[m]) {\n            println(n.toString().padStart(5) + \" and \" + m.toString().padStart(5))\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\n\nfun isDeranged(s1: String, s2: String): Boolean {\n    return (0 until s1.length).none { s1[it] == s2[it] }\n}\n\nfun main(args: Array<String>) {\n    val url = URL(\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) {\n            anagrams.put(key, mutableListOf<String>())\n            anagrams[key]!!.add(word)\n        }\n        else {\n            val deranged = anagrams[key]!!.any { isDeranged(it, word) }\n            if (deranged) {\n                anagrams[key]!!.add(word)\n                count = Math.max(count, word.length)\n            }\n        }\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size > 1 && it[0].length == count }\n        .forEach { println(it) }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\nimport kotlin.math.max\n\nfun main() {\n    val url = URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) anagrams[key] = mutableListOf()\n        anagrams[key]?.add(word)\n        count = max(count, anagrams[key]?.size ?: 0)\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size == count }\n        .forEach { println(it) }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.awt.*\nimport java.util.concurrent.*\nimport javax.swing.*\n\nclass Pendulum(private val length: Int) : JPanel(), Runnable {\n    init {\n        val f = JFrame(\"Pendulum\")\n        f.add(this)\n        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        f.pack()\n        f.isVisible = true\n        isDoubleBuffered = true\n    }\n\n    override fun paint(g: Graphics) {\n        with(g) {\n            color = Color.WHITE\n            fillRect(0, 0, width, height)\n            color = Color.BLACK\n            val anchor = Element(width / 2, height / 4)\n            val ball = Element((anchor.x + Math.sin(angle) * length).toInt(), (anchor.y + Math.cos(angle) * length).toInt())\n            drawLine(anchor.x, anchor.y, ball.x, ball.y)\n            fillOval(anchor.x - 3, anchor.y - 4, 7, 7)\n            fillOval(ball.x - 7, ball.y - 7, 14, 14)\n        }\n    }\n\n    override fun run() {\n        angleVelocity += -9.81 / length * Math.sin(angle) * dt\n        angle += angleVelocity * dt\n        repaint()\n    }\n\n    override fun getPreferredSize() = Dimension(2 * length + 50, length / 2 * 3)\n\n    private data class Element(val x: Int, val y: Int)\n\n    private val dt = 0.1\n    private var angle = Math.PI / 2\n    private var angleVelocity = 0.0\n}\n\nfun main(a: Array<String>) {\n    val executor = Executors.newSingleThreadScheduledExecutor()\n    executor.scheduleAtFixedRate(Pendulum(200), 0, 15, TimeUnit.MILLISECONDS)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.0\n\nimport java.awt.Dimension\nimport java.awt.event.MouseAdapter\nimport java.awt.event.MouseEvent\nimport java.util.*\nimport javax.swing.JFrame\nimport javax.swing.JLabel\n\nclass Rotate : JFrame() {\n    val text = \"Hello World! \"\n    val label = JLabel(text)\n    var rotRight = true\n    var startIdx = 0\n\n    init {\n        preferredSize = Dimension(96, 64)\n        label.addMouseListener(object: MouseAdapter() {\n            override fun mouseClicked(evt: MouseEvent) {\n                rotRight = !rotRight\n            }\n        })\n        add(label)\n        pack()\n        defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        isVisible = true\n    }\n}\n\nfun getRotatedText(text: String, startIdx: Int): String {\n    val ret = StringBuilder()\n    var i = startIdx\n    do {\n        ret.append(text[i++])\n        i %= text.length\n    }\n    while (i != startIdx)\n    return ret.toString()\n}\n\nfun main(args: Array<String>) {\n    val rot = Rotate()\n    val task = object : TimerTask() {\n        override fun run() {\n            if (rot.rotRight) {\n                if (--rot.startIdx < 0) rot.startIdx += rot.text.length\n            }\n            else {\n                if (++rot.startIdx >= rot.text.length) rot.startIdx -= rot.text.length\n            }\n            rot.label.text = getRotatedText(rot.text, rot.startIdx)\n        }\n    }\n    Timer(false).schedule(task, 0, 500)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun fib(n: Int): Int {\n   require(n >= 0)\n   fun fib1(k: Int, a: Int, b: Int): Int =\n       if (k == 0) a else fib1(k - 1, b, a + b)\n   return fib1(n, 0, 1)\n}\n\nfun main(args: Array<String>) {\n    for (i in 0..20) print(\"${fib(i)} \")\n    println()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Version 1.2.41\n\nimport java.io.File\n\nclass Record(\n    val account: String,\n    val password: String,\n    val uid: Int,\n    val gid: Int,\n    val gecos: List<String>,\n    val directory: String,\n    val shell: String\n){\n    override fun toString() =\n        \"$account:$password:$uid:$gid:${gecos.joinToString(\",\")}:$directory:$shell\"\n}\n\nfun parseRecord(line: String): Record {\n    val fields = line.split(':')\n    return Record(\n        fields[0],\n        fields[1],\n        fields[2].toInt(),\n        fields[3].toInt(),\n        fields[4].split(','),\n        fields[5],\n        fields[6]\n    )\n}\n\nfun main(args: Array<String>) {\n    val startData = listOf(\n        \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n        \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\"\n    )\n    val records = startData.map { parseRecord(it) }\n    val f = File(\"passwd.csv\")\n    f.printWriter().use {\n        for (record in records) it.println(record)\n    }\n    println(\"Initial records:\\n\")\n    f.forEachLine {\n        println(parseRecord(it))\n    }\n\n    val newData = \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n    val record = parseRecord(newData)\n    if (!f.setWritable(true, true)) {\n        println(\"\\nFailed to make file writable only by owner\\n.\")\n    }\n    f.appendText(\"$record\\n\")\n    println(\"\\nRecords after another one is appended:\\n\")\n    f.forEachLine {\n        println(parseRecord(it))\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)  // build\n    val function = { i: Int -> i * i } // function to apply\n    val list = array.map { function(it) } // process each item\n    println(list) // print results\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigInteger\n\nfun main(args: Array<String>) {\n    val x = BigInteger.valueOf(5).pow(Math.pow(4.0, 3.0 * 3.0).toInt())\n    val y = x.toString()\n    val len = y.length\n    println(\"5^4^3^2 = ${y.substring(0, 20)}...${y.substring(len - 20)} and has $len digits\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    memScoped {\n        val intVar1 = alloc<IntVar>()\n        intVar1.value = 1\n        val intVar2 = alloc<IntVar>()\n        intVar2.value = 2\n        println(\"${intVar1.value} + ${intVar2.value} = ${intVar1.value + intVar2.value}\")\n    }\n    // native memory used by intVar1 & intVar2 is automatically freed when memScoped block ends\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class Complex(private val real: Double, private val imag: Double) {\n    operator fun plus(other: Complex) = Complex(real + other.real, imag + other.imag)\n\n    operator fun times(other: Complex) = Complex(\n        real * other.real - imag * other.imag,\n        real * other.imag + imag * other.real\n    )\n\n    fun inv(): Complex {\n        val denom = real * real + imag * imag\n        return Complex(real / denom, -imag / denom)\n    }\n\n    operator fun unaryMinus() = Complex(-real, -imag)\n\n    operator fun minus(other: Complex) = this + (-other)\n\n    operator fun div(other: Complex) = this * other.inv()\n\n    fun conj() = Complex(real, -imag)\n\n    override fun toString() =\n        if (imag >= 0.0) \"$real + ${imag}i\"\n        else \"$real - ${-imag}i\"\n}\n\nfun main(args: Array<String>) {\n    val x = Complex(1.0, 3.0)\n    val y = Complex(5.0, 2.0)\n    println(\"x     =  $x\")\n    println(\"y     =  $y\")\n    println(\"x + y =  ${x + y}\")\n    println(\"x - y =  ${x - y}\")\n    println(\"x * y =  ${x * y}\")\n    println(\"x / y =  ${x / y}\")\n    println(\"-x    =  ${-x}\")\n    println(\"1 / x =  ${x.inv()}\")\n    println(\"x*    =  ${x.conj()}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.10\n\n/* if string is empty, returns zero */\nfun String.toDoubleOrZero() = this.toDoubleOrNull() ?: 0.0\n\nfun multiply(s: String): String {\n    val b = s.split('*').map { it.toDoubleOrZero() }\n    return (b[0] * b[1]).toString()\n}\n\nfun divide(s: String): String {\n    val b = s.split('/').map { it.toDoubleOrZero() }\n    return (b[0] / b[1]).toString()\n}\n\nfun add(s: String): String {\n    var t = s.replace(Regex(\"\"\"^\\+\"\"\"), \"\").replace(Regex(\"\"\"\\++\"\"\"), \"+\")\n    val b = t.split('+').map { it.toDoubleOrZero() }\n    return (b[0] + b[1]).toString()\n}\n\nfun subtract(s: String): String {\n    var t = s.replace(Regex(\"\"\"(\\+-|-\\+)\"\"\"), \"-\")\n    if (\"--\" in t) return add(t.replace(\"--\", \"+\"))\n    val b = t.split('-').map { it.toDoubleOrZero() }\n    return (if (b.size == 3) -b[1] - b[2] else b[0] - b[1]).toString()\n}\n\nfun evalExp(s: String): String {\n    var t = s.replace(Regex(\"\"\"[()]\"\"\"), \"\")\n    val reMD = Regex(\"\"\"\\d+\\.?\\d*\\s*[*/]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reM  = Regex( \"\"\"\\*\"\"\")\n    val reAS = Regex(\"\"\"-?\\d+\\.?\\d*\\s*[+-]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reA  = Regex(\"\"\"\\d\\+\"\"\")\n\n    while (true) {\n        val match = reMD.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reM.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, multiply(exp))\n            else\n                t.replace(exp, divide(exp))\n    }\n\n    while (true) {\n        val match = reAS.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reA.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, add(exp))\n            else\n                t.replace(exp, subtract(exp))\n    }\n\n    return t\n}\n\nfun evalArithmeticExp(s: String): Double {\n    var t = s.replace(Regex(\"\"\"\\s\"\"\"), \"\").replace(\"\"\"^\\+\"\"\", \"\")\n    val rePara = Regex(\"\"\"\\([^()]*\\)\"\"\")\n    while(true) {\n        val match = rePara.find(t)\n        if (match == null) break\n        val exp = match.value\n        t = t.replace(exp, evalExp(exp))\n    }\n    return evalExp(t).toDoubleOrZero()\n}\n\nfun main(arsg: Array<String>) {\n    listOf(\n        \"2+3\",\n        \"2+3/4\",\n        \"2*3-4\",\n        \"2*(3+4)+5/6\",\n        \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n        \"2*-3--4+-0.25\",\n         \"-4 - 3\",\n         \"((((2))))+ 3 * 5\",\n         \"1 + 2 * (3 + (4 * 5 + 6 * 7 * 8) - 9) / 10\",\n         \"1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22/(7 + 2*(3 - 1)) - 1)) + 1\"\n    ).forEach { println(\"$it = ${evalArithmeticExp(it)}\") }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.math.MathContext\n\nval con1024 = MathContext(1024)\nval bigTwo  = BigDecimal(2)\nval bigFour = bigTwo * bigTwo\n\nfun bigSqrt(bd: BigDecimal, con: MathContext): BigDecimal {\n    var x0 = BigDecimal.ZERO\n    var x1 = BigDecimal.valueOf(Math.sqrt(bd.toDouble()))\n    while (x0 != x1) {\n        x0 = x1\n        x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con)\n    }\n    return x1\n}\n\nfun main(args: Array<String>) {\n    var a = BigDecimal.ONE\n    var g = a.divide(bigSqrt(bigTwo, con1024), con1024)\n    var t : BigDecimal\n    var sum = BigDecimal.ZERO\n    var pow = bigTwo\n    while (a != g) {\n        t = (a + g).divide(bigTwo, con1024)\n        g = bigSqrt(a * g, con1024)\n        a = t\n        pow *= bigTwo\n        sum += (a * a - g * g) * pow\n    }\n    val pi = (bigFour * a * a).divide(BigDecimal.ONE - sum, con1024)\n    println(pi)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun agm(a: Double, g: Double): Double {\n    var aa = a             // mutable 'a'\n    var gg = g             // mutable 'g'\n    var ta: Double         // temporary variable to hold next iteration of 'aa'\n    val epsilon = 1.0e-16  // tolerance for checking if limit has been reached\n\n    while (true) {\n        ta = (aa + gg) / 2.0\n        if (Math.abs(aa - ta) <= epsilon) return ta\n        gg = Math.sqrt(aa * gg)\n        aa = ta\n    }\n}\n\nfun main(args: Array<String>) {\n    println(agm(1.0, 1.0 / Math.sqrt(2.0)))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1\n\nfun main(args: Array<String>) {\n    val r = Regex(\"\"\"-?\\d+[ ]+-?\\d+\"\"\")\n    while(true) {\n        print(\"Enter two integers separated by space(s) or q to quit: \")\n        val input: String = readLine()!!.trim()\n        if (input == \"q\" || input == \"Q\") break\n        if (!input.matches(r)) {\n            println(\"Invalid input, try again\")\n            continue\n        }\n        val index = input.lastIndexOf(' ')\n        val a = input.substring(0, index).trimEnd().toLong()\n        val b = input.substring(index + 1).toLong()\n        println(\"$a + $b = ${a + b}\")\n        println(\"$a - $b = ${a - b}\")\n        println(\"$a * $b = ${a * b}\")\n        if (b != 0L) {\n            println(\"$a / $b = ${a / b}\")  // rounds towards zero\n            println(\"$a % $b = ${a % b}\")  // if non-zero, matches sign of first operand\n        }\n        else {\n            println(\"$a / $b = undefined\")\n            println(\"$a % $b = undefined\")\n        }\n        val d = Math.pow(a.toDouble(), b.toDouble())\n        print(\"$a ^ $b = \")\n        if (d % 1.0 == 0.0) {\n            if (d >= Long.MIN_VALUE.toDouble() && d <= Long.MAX_VALUE.toDouble())\n                println(\"${d.toLong()}\")\n            else\n                println(\"out of range\")\n        }\n        else if (!d.isFinite())\n            println(\"not finite\")\n        else\n            println(\"not integral\")\n        println()\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.1.2\n\nfun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\n\ninfix fun Long.ldiv(denom: Long) = Frac(this, denom)\n\ninfix fun Int.idiv(denom: Int) = Frac(this.toLong(), denom.toLong())\n\nfun Long.toFrac() = Frac(this, 1)\n\nfun Int.toFrac() = Frac(this.toLong(), 1)\n\nclass Frac : Comparable<Frac> {\n    val num: Long\n    val denom: Long\n\n    companion object {\n        val ZERO = Frac(0, 1)\n        val ONE  = Frac(1, 1)\n    }\n\n    constructor(n: Long, d: Long) {\n        require(d != 0L)\n        var nn = n\n        var dd = d\n        if (nn == 0L) {\n            dd = 1\n        }\n        else if (dd < 0) {\n            nn = -nn\n            dd = -dd\n        }\n        val g = Math.abs(gcd(nn, dd))\n        if (g > 1) {\n            nn /= g\n            dd /= g\n        }\n        num = nn\n        denom = dd\n    }\n\n    constructor(n: Int, d: Int) : this(n.toLong(), d.toLong())\n\n    operator fun plus(other: Frac) =\n        Frac(num * other.denom + denom * other.num, other.denom * denom)\n\n    operator fun unaryPlus() = this\n\n    operator fun unaryMinus() = Frac(-num, denom)\n\n    operator fun minus(other: Frac) = this + (-other)\n\n    operator fun times(other: Frac) = Frac(this.num * other.num, this.denom * other.denom)\n\n    operator fun rem(other: Frac) = this - Frac((this / other).toLong(), 1) * other\n\n    operator fun inc() = this + ONE\n    operator fun dec() = this - ONE\n\n    fun inverse(): Frac {\n        require(num != 0L)\n        return Frac(denom, num)\n    }\n\n    operator fun div(other: Frac) = this * other.inverse()\n\n    fun abs() = if (num >= 0) this else -this\n\n    override fun compareTo(other: Frac): Int {\n        val diff = this.toDouble() - other.toDouble()\n        return when {\n            diff < 0.0  -> -1\n            diff > 0.0  -> +1\n            else        ->  0\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n       if (other == null || other !is Frac) return false\n       return this.compareTo(other) == 0\n    }\n\n    override fun hashCode() = num.hashCode() xor denom.hashCode()\n\n    override fun toString() = if (denom == 1L) \"$num\" else \"$num/$denom\"\n\n    fun toDouble() = num.toDouble() / denom\n\n    fun toLong() = num / denom\n}\n\nfun isPerfect(n: Long): Boolean {\n    var sum = Frac(1, n)\n    val limit = Math.sqrt(n.toDouble()).toLong()\n    for (i in 2L..limit) {\n        if (n % i == 0L) sum += Frac(1, i) + Frac(1, n / i)\n    }\n    return sum == Frac.ONE\n}\n\nfun main(args: Array<String>) {\n    var frac1 = Frac(12, 3)\n    println (\"frac1 = $frac1\")\n    var frac2 = 15 idiv 2\n    println(\"frac2 = $frac2\")\n    println(\"frac1 <= frac2 is ${frac1 <= frac2}\")\n    println(\"frac1 >= frac2 is ${frac1 >= frac2}\")\n    println(\"frac1 == frac2 is ${frac1 == frac2}\")\n    println(\"frac1 != frac2 is ${frac1 != frac2}\")\n    println(\"frac1 + frac2 = ${frac1 + frac2}\")\n    println(\"frac1 - frac2 = ${frac1 - frac2}\")\n    println(\"frac1 * frac2 = ${frac1 * frac2}\")\n    println(\"frac1 / frac2 = ${frac1 / frac2}\")\n    println(\"frac1 % frac2 = ${frac1 % frac2}\")\n    println(\"inv(frac1)    = ${frac1.inverse()}\")\n    println(\"abs(-frac1)   = ${-frac1.abs()}\")\n    println(\"inc(frac2)    = ${++frac2}\")\n    println(\"dec(frac2)    = ${--frac2}\")\n    println(\"dbl(frac2)    = ${frac2.toDouble()}\")\n    println(\"lng(frac2)    = ${frac2.toLong()}\")\n    println(\"\\nThe Perfect numbers less than 2^19 are:\")\n    // We can skip odd numbers as no known perfect numbers are odd\n    for (i in 2 until (1 shl 19) step 2) {\n        if (isPerfect(i.toLong())) print(\"  $i\")\n    }\n    println()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val a: Array<Int> = arrayOf(1, 2, 3) // initialise a\n    val b: Array<Int> = arrayOf(4, 5, 6) // initialise b\n    val c: Array<Int> = (a.toList() + b.toList()).toTypedArray()\n    println(c)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun arrayConcat(a: Array<Any>, b: Array<Any>): Array<Any> {\n    return Array(a.size + b.size, { if (it in a.indices) a[it] else b[it - a.size] })\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val a: Collection<Int> = listOf(1, 2, 3) // initialise a\n    val b: Collection<Int> = listOf(4, 5, 6) // initialise b\n    val c: Collection<Int> = a + b\n    println(c)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(x: Array<String>) {\n    var a = arrayOf(1, 2, 3, 4)\n    println(a.asList())\n    a += 5\n    println(a.asList())\n    println(a.reversedArray().asList())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6 (assert.kt)\n\nfun main(args: Array<String>) {\n   val a = 42\n   assert(a == 43)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    // map definition:\n    val map = mapOf(\"foo\" to 5,\n                    \"bar\" to 10,\n                    \"baz\" to 15,\n                    \"foo\" to 6)\n\n    // retrieval:\n    println(map[\"foo\"]) // => 6\n    println(map[\"invalid\"]) // => null\n\n    // check keys:\n    println(\"foo\" in map) // => true\n    println(\"invalid\" in map) // => false\n\n    // iterate over keys:\n    for (k in map.keys) print(\"$k \")\n    println()\n\n    // iterate over values:\n    for (v in map.values) print(\"$v \")\n    println()\n\n    // iterate over key, value pairs:\n    for ((k, v) in map) println(\"$k => $v\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(a: Array<String>) {\n    val map = mapOf(\"hello\" to 1, \"world\" to 2, \"!\" to 3)\n\n    with(map) {\n        entries.forEach { println(\"key = ${it.key}, value = ${it.value}\") }\n        keys.forEach { println(\"key = $it\") }\n        values.forEach { println(\"value = $it\") }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.2.0\n\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.concurrent.thread\n\nconst val NUM_BUCKETS = 10\n\nclass Buckets(data: IntArray) {\n    private val data = data.copyOf()\n\n    operator fun get(index: Int) = synchronized(data) { data[index] }\n\n    fun transfer(srcIndex: Int, dstIndex: Int, amount: Int): Int {\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Negative amount: $amount\")\n        }\n        if (amount == 0) return 0\n        synchronized(data) {\n            var a = amount\n            if (data[srcIndex] - a < 0) a = data[srcIndex]\n            if (data[dstIndex] + a < 0) a = Int.MAX_VALUE - data[dstIndex]\n            if (a < 0) throw IllegalStateException()\n            data[srcIndex] -= a\n            data[dstIndex] += a\n            return a\n        }\n    }\n\n    val buckets get() = synchronized(data) { data.copyOf() }\n\n    fun transferRandomAmount() {\n        val rnd = ThreadLocalRandom.current()\n        while (true) {\n            val srcIndex = rnd.nextInt(NUM_BUCKETS)\n            val dstIndex = rnd.nextInt(NUM_BUCKETS)\n            val amount = rnd.nextInt() and Int.MAX_VALUE\n            transfer(srcIndex, dstIndex, amount)\n        }\n    }\n\n    fun equalize() {\n        val rnd = ThreadLocalRandom.current()\n        while (true) {\n            val srcIndex = rnd.nextInt(NUM_BUCKETS)\n            val dstIndex = rnd.nextInt(NUM_BUCKETS)\n            val amount = (this[srcIndex] - this[dstIndex]) / 2\n            if (amount >= 0) transfer(srcIndex, dstIndex, amount)\n        }\n    }\n\n    fun print() {\n        while (true) {\n            val nextPrintTime = System.currentTimeMillis() + 3000\n            while (true) {\n                val now = System.currentTimeMillis()\n                if (now >= nextPrintTime) break\n                try {\n                    Thread.sleep(nextPrintTime - now)\n                }\n                catch (e: InterruptedException) {\n                    return\n                }\n            }\n            val bucketValues = buckets\n            println(\"Current values: ${bucketValues.total} ${bucketValues.asList()}\")\n        }\n    }\n}\n\nval IntArray.total: Long get() {\n    var sum = 0L\n    for (d in this) sum += d\n    return sum\n}\n\nfun main(args: Array<String>) {\n    val rnd = ThreadLocalRandom.current()\n    val values = IntArray(NUM_BUCKETS) { rnd.nextInt() and Int.MAX_VALUE }\n    println(\"Initial array:  ${values.total} ${values.asList()}\")\n    val buckets = Buckets(values)\n    thread(name = \"equalizer\")   { buckets.equalize() }\n    thread(name = \"transferrer\") { buckets.transferRandomAmount() }\n    thread(name = \"printer\")     { buckets.print() }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "const val NMAX  = 20\nconst val TESTS = 1000000\nval rand = java.util.Random()\n\nfun avg(n: Int): Double {\n    var sum = 0\n    for (t in 0 until TESTS) {\n        val v = BooleanArray(NMAX)\n        var x = 0\n        while (!v[x]) {\n            v[x] = true\n            sum++\n            x = rand.nextInt(n)\n        }\n    }\n    return sum.toDouble() / TESTS\n}\n\nfun ana(n: Int): Double {\n    val nn = n.toDouble()\n    var term = 1.0\n    var sum = 1.0\n    for (i in n - 1 downTo 1) {\n        term *= i / nn\n        sum += term\n    }\n    return sum\n}\n\nfun main(args: Array<String>) {\n    println(\" N    average    analytical    (error)\")\n    println(\"===  =========  ============  =========\")\n    for (n in 1..NMAX) {\n        val a = avg(n)\n        val b = ana(n)\n        println(String.format(\"%3d   %6.4f   %10.4f      (%4.2f%%)\", n, a, b, Math.abs(a - b) / b * 100.0))\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val nums = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)\n    println(\"average = %f\".format(nums.average()))\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.5-2\n\nfun meanAngle(angles: DoubleArray): Double {\n    val sinSum = angles.sumByDouble {  Math.sin(it * Math.PI / 180.0) }\n    val cosSum = angles.sumByDouble {  Math.cos(it * Math.PI / 180.0) }\n    return Math.atan2(sinSum / angles.size, cosSum / angles.size) * 180.0 / Math.PI\n}\n\nfun main(args: Array<String>) {\n    val angles1 = doubleArrayOf(350.0, 10.0)\n    val angles2 = doubleArrayOf(90.0, 180.0, 270.0, 360.0)\n    val angles3 = doubleArrayOf(10.0, 20.0, 30.0)\n    val fmt  = \"%.2f degrees\" // format results to 2 decimal places\n    println(\"Mean for angles 1 is ${fmt.format(meanAngle(angles1))}\")\n    println(\"Mean for angles 2 is ${fmt.format(meanAngle(angles2))}\")\n    println(\"Mean for angles 3 is ${fmt.format(meanAngle(angles3))}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "// version 1.0.6\n\nfun meanAngle(angles: DoubleArray): Double {\n    val sinSum = angles.sumByDouble {  Math.sin(it * Math.PI / 180.0) }\n    val cosSum = angles.sumByDouble {  Math.cos(it * Math.PI / 180.0) }\n    return Math.atan2(sinSum / angles.size, cosSum / angles.size) * 180.0 / Math.PI\n}\n\n/* time string assumed to be in format \"hh:mm:ss\" */\nfun timeToSecs(t: String): Int {\n    val hours = t.slice(0..1).toInt()\n    val mins  = t.slice(3..4).toInt()\n    val secs  = t.slice(6..7).toInt()\n    return 3600 * hours + 60 * mins + secs\n}\n\n/* 1 second of time = 360/(24 * 3600) = 1/240th degree */\nfun timeToDegrees(t: String): Double = timeToSecs(t) / 240.0\n\nfun degreesToTime(d: Double): String {\n    var dd = d\n    if (dd < 0.0) dd += 360.0\n    var secs  = (dd * 240.0).toInt()\n    val hours = secs / 3600\n    var mins  = secs % 3600\n    secs  = mins % 60\n    mins /= 60\n    return String.format(\"%2d:%2d:%2d\", hours, mins, secs)\n}\n\nfun main(args: Array<String>) {\n    val tm = arrayOf(\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\")\n    val angles = DoubleArray(4) { timeToDegrees(tm[it]) }\n    val mean = meanAngle(angles)\n    println(\"Average time is : ${degreesToTime(mean)}\")\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun median(l: List<Double>) = l.sorted().let { (it[it.size / 2] + it[(it.size - 1) / 2]) / 2 }\n\nfun main(args: Array<String>) {\n    median(listOf(5.0, 3.0, 4.0)).let { println(it) }  // 4\n    median(listOf(5.0, 4.0, 2.0, 3.0)).let { println(it) }  // 3.5\n    median(listOf(3.0, 4.0, 1.0, -8.4, 7.2, 4.0, 1.0, 1.2)).let { println(it) }  // 2.1\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun <T> modeOf(a: Array<T>) {\n    val sortedByFreq = a.groupBy { it }.entries.sortedByDescending { it.value.size }\n    val maxFreq = sortedByFreq.first().value.size\n    val modes = sortedByFreq.takeWhile { it.value.size == maxFreq }\n    if (modes.size == 1)\n       println(\"The mode of the collection is ${modes.first().key} which has a frequency of $maxFreq\")\n    else {\n       print(\"There are ${modes.size} modes with a frequency of $maxFreq, namely : \")\n       println(modes.map { it.key }.joinToString(\", \"))\n    }\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(7, 1, 1, 6, 2, 4, 2, 4, 2, 1, 5)\n    println(\"[\" + a.joinToString(\", \") + \"]\")\n    modeOf(a)\n    println()\n    val b = arrayOf(true, false, true, false, true, true)\n    println(\"[\" + b.joinToString(\", \") + \"]\")\n    modeOf(b)\n}\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100;\ntmp=ConstantArray[-1,n];\nDo[tmp[[i;;;;i]]*=-1;,{i,n}];\nDo[Print[\"door \",i,\" is \",If[tmp[[i]]==-1,\"closed\",\"open\"]],{i,1,Length[tmp]}]\n"
  },
  {
    "language": "Mathematica",
    "code": "f[n_] = \"Closed\";\nDo[Do[If[f[n] == \"Closed\", f[n] = \"Open\", f[n] = \"Closed\"], {n, k, 100, k}], {k, 1, 100}];\nTable[f[n], {n, 1, 100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Fold[\n ReplacePart[#1, (i_ /; Mod[i, #2] == 0) :> (-#1[[i]])] &,\n ConstantArray[-1, {100}],\n Range[100]\n] /. {1 -> \"Open\", -1 -> \"Closed\"}\n"
  },
  {
    "language": "Mathematica",
    "code": "Do[Print[\"door \",i,\" is \",If[IntegerQ[Sqrt[i]],\"open\",\"closed\"]],{i,100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100;\na=Range[1,Sqrt[n]]^2\nDo[Print[\"door \",i,\" is \",If[MemberQ[a,i],\"open\",\"closed\"]],{i,100}]\n"
  },
  {
    "language": "Mathematica",
    "code": "n=100\nnn=1\na=0\nFor[i=1,i<=n,i++,\n If[i==nn,\n  Print[\"door \",i,\" is open\"];\n  a++;\n  nn+=2a+1;\n ,\n  Print[\"door \",i,\" is closed\"];\n ];\n]\n"
  },
  {
    "language": "Mathematica",
    "code": "Pick[Range[100], Xor@@@Array[Divisible[#1,#2]&, {100,100}]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Range[Sqrt[100]]^2\n"
  },
  {
    "language": "Mathematica",
    "code": "treeR[n_] := Table[o[trees[a], trees[n - a]], {a, 1, n - 1}]\ntreeR[1] := n\ntree[n_] :=\n Flatten[treeR[n] //. {o[a_List, b_] :> (o[#, b] & /@ a),\n    o[a_, b_List] :> (o[a, #] & /@ b)}]\ngame24play[val_List] :=\n Union[StringReplace[StringTake[ToString[#, InputForm], {10, -2}],\n     \"-1*\" ~~ n_ :> \"-\" <> n] & /@ (HoldForm /@\n      Select[Union@\n        Flatten[Outer[# /. {o[q_Integer] :> #2[[q]],\n             n[q_] :> #3[[q]]} &,\n          Block[{O = 1, N = 1}, # /. {o :> o[O++], n :> n[N++]}] & /@\n           tree[4], Tuples[{Plus, Subtract, Times, Divide}, 3],\n          Permutations[Array[v, 4]], 1]],\n       Quiet[(# /. v[q_] :> val[[q]]) == 24] &] /.\n     Table[v[q] -> val[[q]], {q, 4}])]\n"
  },
  {
    "language": "Mathematica",
    "code": "game24play[RandomInteger[{1, 9}, 4]]\n"
  },
  {
    "language": "Mathematica",
    "code": "evaluate[HoldForm[op_[l_, r_]]] := op[evaluate[l], evaluate[r]];\nevaluate[x_] := x;\ncombine[l_, r_ /; evaluate[r] != 0] := {HoldForm[Plus[l, r]],\n   HoldForm[Subtract[l, r]], HoldForm[Times[l, r]],\n   HoldForm[Divide[l, r]] };\ncombine[l_, r_] := {HoldForm[Plus[l, r]], HoldForm[Subtract[l, r]],\n   HoldForm[Times[l, r]]};\nsplit[items_] :=\n  Table[{items[[1 ;; i]], items[[i + 1 ;; Length[items]]]}, {i, 1,\n    Length[items] - 1}];\nexpressions[{x_}] := {x};\nexpressions[items_] :=\n  Flatten[Table[\n    Flatten[Table[\n      combine[l, r], {l, expressions[sp[[1]]]}, {r,\n       expressions[sp[[2]]]}], 2], {sp, split[items]}]];\n\n(* Must use all atoms in given order. *)\nsolveMaintainOrder[goal_, items_] :=\n  Select[expressions[items], (evaluate[#] == goal) &];\n(* Must use all atoms, but can permute them. *)\nsolveCanPermute[goal_, items_] :=\n  Flatten[Table[\n    solveMaintainOrder[goal, pitems], {pitems,\n     Permutations[items]}]];\n(* Can use any subset of atoms. *)\nsolveSubsets[goal_, items_] :=\n  Flatten[Table[\n    solveCanPermute[goal, is], {is,\n     Subsets[items, {1, Length[items]}]}], 2];\n\n(* Demonstration to find all the ways to create 1/5 from {2, 3, 4, 5}. *)\nsolveMaintainOrder[1/5, Range[2, 5]]\nsolveCanPermute[1/5, Range[2, 5]]\nsolveSubsets[1/5, Range[2, 5]]\n"
  },
  {
    "language": "Mathematica",
    "code": "isLegal[n_List, x_String] :=\n Quiet[Check[\n   With[{h = ToExpression[x, StandardForm, HoldForm]},\n    If[Cases[Level[h, {2, \\[Infinity]}, Hold, Heads -> True],\n        Except[_Integer | Plus | _Plus | Times | _Times | Power |\n          Power[_, -1]]] === {} &&\n      Sort[Level[h /. Power[q_, -1] -> q, {-1}] /.\n         q_Integer -> Abs[q]] === Sort[n], ReleaseHold[h]]], Null]]\nGrid[{{Button[\n    \"new numbers\", {a, b, c, d} = Table[RandomInteger[{1, 9}], {4}]],\n   InputField[Dynamic[x], String]}, {Dynamic[{a, b, c, d}],\n   Dynamic[Switch[isLegal[{a, b, c, d}, x], Null,\n     \"Sorry, that is invalid.\", 24, \"Congrats! That's 24!\", _,\n     \"Sorry, that makes \" <> ToString[ToExpression@x, InputForm] <>\n      \", not 24.\"]]}}]\n"
  },
  {
    "language": "Mathematica",
    "code": "Table[Last /@ Reverse@Tally[First /@ IntegerPartitions[n]], {n, 10}] // Grid\n"
  },
  {
    "language": "Mathematica",
    "code": "PartitionsP /@ {23, 123, 1234, 12345}\n"
  },
  {
    "language": "Mathematica",
    "code": "DiscretePlot[PartitionsP[n], {n, 1, 999}, PlotRange -> All]\n"
  },
  {
    "language": "Mathematica",
    "code": "Bottle[n_] := ToString[n] <> If[n==1,\" bottle\",\" bottles\"] <> \" of beer\"\n\nBottleSong[n_] := Speak[\n  Bottle[n] <> \" on the wall,\" <>\n  Bottle[n] <>\n  \", take one down, pass it around,\" <>\n  Bottle[n-1] <> \" on the wall.\"\n]\n\nBottleSong /@ Range[99,1,-1]\n"
  },
  {
    "language": "Mathematica",
    "code": "Input[] + Input[]\n"
  },
  {
    "language": "Mathematica",
    "code": "blocks=Partition[Characters[ToLowerCase[\"BOXKDQCPNAGTRETGQDFSJWHUVIANOBERFSLYPCZM\"]],2];\nClearAll[DoStep,ABCBlockQ]\nDoStep[chars_List,blcks_List,chosen_List]:=Module[{opts},\n If[chars=!={},\n  opts=Select[blcks,MemberQ[#,First[chars]]&];\n  {Rest[chars],DeleteCases[blcks,#,1,1],Append[chosen,#]}&/@opts\n ,\n  {{chars,blcks,chosen}}\n ]\n]\nDoStep[opts_List]:=Flatten[DoStep@@@opts,1]\nABCBlockQ[str_String]:=(FixedPoint[DoStep,{{Characters[ToLowerCase[str]],blocks,{}}}]=!={})\n"
  },
  {
    "language": "Mathematica",
    "code": "(* Define an interface, Foo, which requires that the functions Foo, Bar, and Baz be defined *)\nInterfaceFooQ[obj_] := ValueQ[Foo[obj]] && ValueQ[Bar[obj]] && ValueQ[Baz[obj]];\nPrintFoo[obj_] := Print[\"Object \", obj, \" does not implement interface Foo.\"];\nPrintFoo[obj_?InterfaceFooQ] := Print[\n   \"Foo: \", Foo[obj], \"\\n\",\n   \"Bar: \", Bar[obj], \"\\n\",\n   \"Baz: \", Baz[obj], \"\\n\"];\n\n(* Extend all integers with Interface Foo *)\nFoo[x_Integer] := Mod[x, 2];\nBar[x_Integer] := Mod[x, 3];\nBaz[x_Integer] := Mod[x, 5];\n\n(* Extend a particular string with Interface Foo *)\nFoo[\"Qux\"] = \"foo\";\nBar[\"Qux\"] = \"bar\";\nBaz[\"Qux\"] = \"baz\";\n\n(* Print a non-interface object *)\nPrintFoo[{\"Some\", \"List\"}];\n(* And for an integer *)\nPrintFoo[8];\n(* And for the specific string *)\nPrintFoo[\"Qux\"];\n(* And finally a non-specific string *)\nPrintFoo[\"foobarbaz\"]\n"
  },
  {
    "language": "Mathematica",
    "code": "classify[n_Integer] := Sign[Total[Most@Divisors@n] - n]\n\nStringJoin[\n Flatten[Tally[\n     Table[classify[n], {n, 20000}]] /. {-1 -> \"deficient: \",\n     0 -> \"  perfect: \", 1 -> \"  abundant: \"}] /.\n  n_Integer :> ToString[n]]\n"
  },
  {
    "language": "Mathematica",
    "code": "accFactory[initial_] :=\n  Module[{total = initial},\n    Function[x, total += x]\n  ]\nx=accFactory[1];\nx[5.0];\naccFactory[3];\nx[2.3]\n"
  },
  {
    "language": "Mathematica",
    "code": "$RecursionLimit=Infinity\nAckermann1[m_,n_]:=\n If[m==0,n+1,\n  If[ n==0,Ackermann1[m-1,1],\n   Ackermann1[m-1,Ackermann1[m,n-1]]\n  ]\n ]\n\n Ackermann2[0,n_]:=n+1;\n Ackermann2[m_,0]:=Ackermann1[m-1,1];\n Ackermann2[m_,n_]:=Ackermann1[m-1,Ackermann1[m,n-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Flatten[#,1]&@Table[{\"Ackermann2[\"<>ToString[i]<>\",\"<>ToString[j]<>\"] =\",Ackermann2[i,j]},{i,3},{j,8}]//Grid\n"
  },
  {
    "language": "Mathematica",
    "code": "Ackermann2[1,1] =\t3\nAckermann2[1,2] =\t4\nAckermann2[1,3] =\t5\nAckermann2[1,4] =\t6\nAckermann2[1,5] =\t7\nAckermann2[1,6] =\t8\nAckermann2[1,7] =\t9\nAckermann2[1,8] =\t10\nAckermann2[2,1] =\t5\nAckermann2[2,2] =\t7\nAckermann2[2,3] =\t9\nAckermann2[2,4] =\t11\nAckermann2[2,5] =\t13\nAckermann2[2,6] =\t15\nAckermann2[2,7] =\t17\nAckermann2[2,8] =\t19\nAckermann2[3,1] =\t13\nAckermann2[3,2] =\t29\nAckermann2[3,3] =\t61\nAckermann2[3,4] =\t125\nAckermann2[3,5] =\t253\nAckermann2[3,6] =\t509\nAckermann2[3,7] =\t1021\nAckermann2[3,8] =\t2045\n"
  },
  {
    "language": "Mathematica",
    "code": "Clear[Ackermann3]\n$RecursionLimit=Infinity;\nAckermann3[0,n_]:=n+1;\nAckermann3[1,n_]:=n+2;\nAckermann3[2,n_]:=3+2n;\nAckermann3[3,n_]:=5+8 (2^n-1);\nAckermann3[m_,0]:=Ackermann3[m-1,1];\nAckermann3[m_,n_]:=Ackermann3[m-1,Ackermann3[m,n-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "Ackermann3[4, 1]\nAckermann3[4, 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "65533\n2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880........699146577530041384717124577965048175856395072895337539755822087777506072339445587895905719156733\n"
  },
  {
    "language": "Mathematica",
    "code": "Block[{start = SessionTime[], K, t0 = 0, t1, kt0, S = 0},\n K[t_] = Sin[2 Pi f t] /. f -> 0.5; kt0 = K[t0];\n While[True, t1 = SessionTime[] - start;\n  S += (kt0 + (kt0 = K[t1])) (t1 - t0)/2; t0 = t1;\n  If[t1 > 2, K[t_] = 0; If[t1 > 2.5, Break[]]]]; S]\n"
  },
  {
    "language": "Mathematica",
    "code": "f[a]=1;\nf[b]=2;\nf[a]=3;\n? f\n"
  },
  {
    "language": "Mathematica",
    "code": "Print[\"powers of (x-1)\"]\n(x - 1)^( Range[0, 7]) // Expand // TableForm\nPrint[\"primes under 50\"]\npoly[p_] := (x - 1)^p - (x^p - 1) // Expand;\ncoefflist[p_Integer] := Coefficient[poly[p], x, #] & /@ Range[0, p - 1];\nAKSPrimeQ[p_Integer] := (Mod[coefflist[p] , p] // Union) == {0};\nSelect[Range[1, 50], AKSPrimeQ]\n"
  },
  {
    "language": "Mathematica",
    "code": "TableForm[StringSplit[StringSplit[a,\"\\n\"],\"$\"],TableAlignments -> Center]\n"
  },
  {
    "language": "Mathematica",
    "code": "seq[n_] :=\n  NestList[If[# == 0, 0,\n     DivisorSum[#, # &, Function[div, div != #]]] &, n, 16];\nclass[seq_] :=\n  Which[Length[seq] < 2, \"Non-terminating\", MemberQ[seq, 0],\n   \"Terminating\", seq[[1]] == seq[[2]], \"Perfect\",\n   Length[seq] > 2 && seq[[1]] == seq[[3]], \"Amicable\",\n   Length[seq] > 3 && MemberQ[seq[[4 ;;]], seq[[1]]], \"Sociable\",\n   MatchQ[class[Rest[seq]], \"Perfect\" | \"Aspiring\"], \"Aspiring\",\n   MatchQ[class[Rest[seq]], \"Amicable\" | \"Sociable\" | \"Cyclic\"],\n   \"Cyclic\", True, \"Non-terminating\"];\nnotate[seq_] :=\n  Which[seq == {}, {},\n   MemberQ[Rest[seq],\n    seq[[1]]], {Prepend[TakeWhile[Rest[seq], # != seq[[1]] &],\n     seq[[1]]]}, True, Prepend[notate[Rest[seq]], seq[[1]]]];\nPrint[{#, class[seq[#]], notate[seq[#]] /. {0} -> 0}] & /@ {1, 2, 3, 4, 5, 6, 7,\n   8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909,\n   562, 1064, 1488, 15355717786080};\n"
  },
  {
    "language": "Mathematica",
    "code": "kprimes[k_,n_] :=\n  (* generates a list of the n smallest k-almost-primes *)\n  Module[{firstnprimes, runningkprimes = {}},\n  firstnprimes = Prime[Range[n]];\n  runningkprimes = firstnprimes;\n  Do[\n   runningkprimes =\n     Outer[Times, firstnprimes , runningkprimes ] // Flatten // Union  // Take[#, n] & ;\n   (* only keep lowest n numbers in our running list *)\n   , {i, 1, k - 1}];\n  runningkprimes\n  ]\n(* now to create table with n=10 and k ranging from 1 to 5 *)\nTable[Flatten[{\"k = \" <> ToString[i] <> \": \", kprimes[i, 10]}], {i,1,5}] // TableForm\n"
  },
  {
    "language": "Mathematica",
    "code": " CheckValid[i_List]:=If[Length[i]<=1,True,And@@(StringTake[#[[1]],-1]==StringTake[#[[2]],1]&/@Partition[i,2,1])]\n sets={{\"the\",\"that\",\"a\"},{\"frog\",\"elephant\",\"thing\"},{\"walked\",\"treaded\",\"grows\"},{\"slowly\",\"quickly\"}};\n Select[Tuples[sets],CheckValid]\n"
  },
  {
    "language": "Mathematica",
    "code": "{{\"that\", \"thing\", \"grows\", \"slowly\"}}\n"
  },
  {
    "language": "Mathematica",
    "code": "CheckValid2[i_List] := StringFreeQ[StringJoin[Riffle[i, \",\"]], a_ ~~ \",\" ~~ b_ /; a =!= b]\n"
  },
  {
    "language": "Mathematica",
    "code": "amicableQ[n_] :=\n Module[{sum = Total[Most@Divisors@n]},\n  sum != n && n == Total[Most@Divisors@sum]]\n\nGrid@Partition[Cases[Range[4, 20000], _?(amicableQ@# &)], 2]\n"
  },
  {
    "language": "Mathematica",
    "code": "list=Import[\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\ntext={#,StringJoin@@Sort[Characters[#]]}&/@list;\ntext=SortBy[text,#[[2]]&];\nsplits=Split[text,#1[[2]]==#2[[2]]&][[All,All,1]];\nmaxlen=Max[Length/@splits];\nSelect[splits,Length[#]==maxlen&]\n"
  },
  {
    "language": "Mathematica",
    "code": "{{abel,able,bale,bela,elba},{caret,carte,cater,crate,trace},{angel,angle,galen,glean,lange},{alger,glare,lager,large,regal},{elan,lane,lean,lena,neal},{evil,levi,live,veil,vile}}\n"
  },
  {
    "language": "Mathematica",
    "code": "splits = Gather[list, Sort[Characters[#]] == Sort[Characters[#2]] &];\nmaxlen = Max[Length /@ splits];\nSelect[splits, Length[#] == maxlen &]\n"
  },
  {
    "language": "Mathematica",
    "code": "anagramGroups = GatherBy[SortBy[GatherBy[list,Sort[Characters[#]] &],Length],Length];\nanagramGroups[[-1]]\n"
  },
  {
    "language": "Mathematica",
    "code": "list=Import[\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\nMaximalBy[GatherBy[list, Sort@*Characters], Length]\n"
  },
  {
    "language": "Mathematica",
    "code": "words=First/@Import[\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\",\"Table\"];\nanagramDegrangement=Function[{w1,w2},\n\tModule[{c1=ToCharacterCode@w1,c2=ToCharacterCode@w2},\n\tSort@c1==Sort@c2&&Select[c1-c2,#==0&,1]==={}]];\ngs=Select[GatherBy[words,{StringLength@#,Union@ToCharacterCode@#}&],Length@#>=2&];\nFirst@Flatten[Function[ws,Select[Join@@Outer[List,ws,ws,1],anagramDegrangement@@#&]]/@SortBy[gs,-StringLength@First@#&],1]\n"
  },
  {
    "language": "Mathematica",
    "code": "list = Import[\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\",\"Lines\"];\nMaximalBy[\n Select[GatherBy[list, Sort@*Characters],\n  Length@# > 1 && And @@ MapThread[UnsameQ, Characters /@ #] &],\n StringLength@*First]\n"
  },
  {
    "language": "Mathematica",
    "code": "freq = 8; length = freq^(-1/2);\nAnimate[Graphics[\n  List[{Line[{{0, 0}, length {Sin[T], -Cos[T]}} /. {T -> (Pi/6) Cos[2 Pi freq t]}], PointSize[Large],\n               Point[{length {Sin[T], -Cos[T]}} /. {T -> (Pi/6) Cos[2 Pi freq t]}]}],\n  PlotRange -> {{-0.3, 0.3}, {-0.5, 0}}], {t, 0, 1}, AnimationRate -> 0.07]\n"
  },
  {
    "language": "Mathematica",
    "code": "mystring = \"Hello World! \";\nScroll[str_, dir_] := StringJoin @@ RotateLeft[str // Characters, dir];\nGiveString[dir_] := (mystring = Scroll[mystring, dir]);\nCreateDialog[{\n   DynamicModule[{direction = -1},\n    EventHandler[\n     Dynamic[TextCell[\n       Refresh[GiveString[direction], UpdateInterval -> 1/8]],\n      TrackedSymbols -> {}], {\"MouseClicked\" :> (direction *= -1)}]]\n   }];\n"
  },
  {
    "language": "Mathematica",
    "code": "check := #<0&\nfib := If[check[#],Throw[\"Negative Argument\"],If[#<=1,1,#0[#-2]+#0[#-1]]&[#]]&\nfib /@ Range[0,10]\n\n{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89}\n"
  },
  {
    "language": "Mathematica",
    "code": "check := (Print[#];#<0)&\nfib /@ Range[0,4]\n0\n1\n2\n3\n4\n\n{1, 1, 2, 3, 5}\n"
  },
  {
    "language": "Mathematica",
    "code": "data = <|\"account\" -> \"xyz\", \"password\" -> \"x\", \"UID\" -> 1003,\n   \"GID\" -> 1000, \"fullname\" -> \"X Yz\", \"office\" -> \"Room 1003\",\n   \"extension\" -> \"(234)555-8913\", \"homephone\" -> \"(234)555-0033\",\n   \"email\" -> \"xyz@rosettacode.org\", \"directory\" -> \"/home/xyz\",\n   \"shell\" -> \"/bin/bash\"|>;\nasString[data_] :=\n  StringRiffle[\n   ToString /@\n    Insert[data /@ {\"account\", \"password\", \"UID\", \"GID\", \"directory\",\n       \"shell\"},\n     StringRiffle[\n      data /@ {\"fullname\", \"office\", \"extension\", \"homephone\",\n        \"email\"}, \",\"], 5], \":\"];\nfname = FileNameJoin[{$TemporaryDirectory, \"testfile\"}];\nstr = OpenWrite[fname]; (* Use OpenAppend if file exists *)\nClose[str];\nPrint[\"Appended record: \" <> asString[data]];\n"
  },
  {
    "language": "Mathematica",
    "code": "(#*#)& /@ {1, 2, 3, 4}\n\nMap[Function[#*#], {1, 2, 3, 4}]\n\nMap[((#*#)&,{1,2,3,4}]\n\nMap[Function[w,w*w],{1,2,3,4}]\n"
  },
  {
    "language": "MATLAB",
    "code": "a = false(1,100);\nfor b=1:100\n  for i = b:b:100\n    a(i) = ~a(i);\n  end\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "for x=1:100;\n  if sqrt(x) == floor(sqrt(x))\n    a(i)=1;\n  end\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "a = zeros(100,1);\nfor counter = 1:sqrt(100);\n  a(counter^2) = 1;\nend\na\n"
  },
  {
    "language": "MATLAB",
    "code": "function [doors,opened,closed] = hundredDoors()\n\n    %Initialize the doors, make them booleans for easy vectorization\n    doors = logical( (1:1:100) );\n\n    %Go through the flipping process, ignore the 1 case because the doors\n    %array is already initialized to all open\n    for initialPosition = (2:100)\n        doors(initialPosition:initialPosition:100) = not( doors(initialPosition:initialPosition:100) );\n    end\n\n    opened = find(doors); %Stores the numbers of the open doors\n    closed = find( not(doors) ); %Stores the numbers of the closed doors\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "doors((1:10).^2) = 1;\n\ndoors\n"
  },
  {
    "language": "MATLAB",
    "code": "  function twentyfour()\n  N = 4;\n  n = ceil(rand(1,N)*9);\n  printf('Generate a equation with the numbers %i, %i, %i, %i and +, -, *, /, () operators ! \\n',n);\n  s = input(': ','s');\n  t = s;\n  for k = 1:N,\n    [x,t] = strtok(t,'+-*/() \\t');\n     if length(x)~=1,\n       error('invalid sign %s\\n',x);\n     end;\n     y = x-'0';\n     if ~(0 < y & y < 10)\n       error('invalid sign %s\\n',x);\n     end;\n     z(1,k) = y;  \t\n  end;\n  if any(sort(z)-sort(n))\n    error('numbers do not match.\\n');\t\n  end;\n\n  val =  eval(s);\n  if val==24,\n    fprintf('expression \"%s\" results in %i.\\n',s,val);\t\n  else\n    fprintf('expression \"%s\" does not result in 24 but %i.\\n',s,val);\n  end; \t\n"
  },
  {
    "language": "MATLAB",
    "code": "function ninetyNineBottlesOfBeer()\n\n    disp( [ sprintf(['%d bottles of beer on the wall, %d bottles of beer.\\n'...\n        'Take one down, pass it around...\\n'],[(99:-1:2);(99:-1:2)])...\n        sprintf(['1 bottle of beer on the wall, 1 bottle of beer.\\nTake'...\n        'one down, pass it around;\\nNo more bottles of beer on the wall.']) ] );\n\n    %The end of this song makes me sad. The shelf should always have more\n    %beer...like college.\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function sumOfInputs = APlusB()\n    inputStream = input('Enter two numbers, separated by a space: ', 's');\n    numbers = str2num(inputStream);                         %#ok<ST2NM>\n    if any(numbers < -1000 | numbers > 1000)\n        warning('APlusB:OutOfRange', 'Some numbers are outside the range');\n    end\n    sumOfInputs = sum(numbers);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function testABC\n    combos = ['BO' ; 'XK' ; 'DQ' ; 'CP' ; 'NA' ; 'GT' ; 'RE' ; 'TG' ; 'QD' ; ...\n        'FS' ; 'JW' ; 'HU' ; 'VI' ; 'AN' ; 'OB' ; 'ER' ; 'FS' ; 'LY' ; ...\n        'PC' ; 'ZM'];\n    words = {'A' 'BARK' 'BOOK' 'TREAT' 'COMMON' 'SQUAD' 'CONFUSE'};\n    for k = 1:length(words)\n        possible = canMakeWord(words{k}, combos);\n        fprintf('Can%s make word %s.\\n', char(~possible.*'NOT'), words{k})\n    end\nend\n\nfunction isPossible = canMakeWord(word, combos)\n    word = lower(word);\n    combos = lower(combos);\n    isPossible = true;\n    k = 1;\n    while isPossible && k <= length(word)\n        [r, c] = find(combos == word(k), 1);\n        if ~isempty(r)\n            combos(r, :) = '';\n        else\n            isPossible = false;\n        end\n        k = k+1;\n    end\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "classdef (Abstract) AbsClass\n   ...\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "methods (Abstract)\n   abstMethod(obj)\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "properties (Abstract)\n   AbsProp\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function A = ackermannFunction(m,n)\n    if m == 0\n        A = n+1;\n    elseif (m > 0) && (n == 0)\n        A = ackermannFunction(m-1,1);\n    else\n        A = ackermannFunction( m-1,ackermannFunction(m,n-1) );\n    end\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function amicable\n    tic\n    N=2:1:20000; aN=[];\n    N(isprime(N))=[]; %erase prime numbers\n    I=1;\n    a=N(1); b=sum(pd(a));\n    while length(N)>1\n        if a==b %erase perfect numbers;\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        elseif b<a %the first member of an amicable pair is abundant not defective\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        elseif ~ismember(b,N) %the other member was previously erased\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n        else\n            c=sum(pd(b));\n            if a==c\n                aN(I,:)=[I a b]; I=I+1;\n                N(N==b)=[];\n            else\n                if ~ismember(c,N) %the other member was previously erased\n                    N(N==b)=[];\n                end\n            end\n            N(N==a)=[]; a=N(1); b=sum(pd(a));\n            clear c\n        end\n    end\n    disp(array2table(aN,'Variablenames',{'N','Amicable1','Amicable2'}))\n    toc\nend\n\nfunction D=pd(x)\n    K=1:ceil(x/2);\n    D=K(~(rem(x, K)));\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "%This is a numerical simulation of a pendulum with a massless pivot arm.\n\n%% User Defined Parameters\n%Define external parameters\ng = -9.8;\ndeltaTime = 1/50; %Decreasing this will increase simulation accuracy\nendTime = 16;\n\n%Define pendulum\nrodPivotPoint = [2 2]; %rectangular coordinates\nrodLength = 1;\nmass = 1; %of the bob\nradius = .2; %of the bob\ntheta = 45; %degrees, defines initial position of the bob\nvelocity = [0 0]; %cylindrical coordinates; first entry is radial velocity,\n                  %second entry is angular velocity\n\n%% Simulation\nassert(radius < rodLength,'Pendulum bob radius must be less than the length of the rod.');\n\nposition = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]); %in rectangular coordinates\n\n%Generate graphics, render pendulum\nfigure;\naxesHandle = gca;\nxlim(axesHandle, [(rodPivotPoint(1) - rodLength - radius) (rodPivotPoint(1) + rodLength + radius)] );\nylim(axesHandle, [(rodPivotPoint(2) - rodLength - radius) (rodPivotPoint(2) + rodLength + radius)] );\n\nrectHandle = rectangle('Position',[(position - radius/2) radius radius],...\n    'Curvature',[1,1],'FaceColor','g'); %Pendulum bob\nhold on\nplot(rodPivotPoint(1),rodPivotPoint(2),'^'); %pendulum pivot\nlineHandle = line([rodPivotPoint(1) position(1)],...\n    [rodPivotPoint(2) position(2)]); %pendulum rod\nhold off\n\n%Run simulation, all calculations are performed in cylindrical coordinates\nfor time = (deltaTime:deltaTime:endTime)\n\n    drawnow; %Forces MATLAB to render the pendulum\n\n    %Find total force\n    gravitationalForceCylindrical = [mass*g*cosd(theta) mass*g*sind(theta)];\n\n    %This code is just incase you want to add more forces,e.g friction\n    totalForce = gravitationalForceCylindrical;\n\n    %If the rod isn't massless or is a spring, etc., modify this line\n    %accordingly\n    rodForce = [-totalForce(1) 0]; %cylindrical coordinates\n\n    totalForce = totalForce + rodForce;\n\n    acceleration = totalForce / mass; %F = ma\n    velocity = velocity + acceleration * deltaTime;\n    rodLength = rodLength + velocity(1) * deltaTime;\n    theta = theta + velocity(2) * deltaTime; % Attention!! Mistake here.\n    % Velocity needs to be divided by pendulum length and scaled to degrees:\n    % theta = theta + velocity(2) * deltaTime/rodLength/pi*180;\n\n    position = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]);\n\n    %Update figure with new position info\n    set(rectHandle,'Position',[(position - radius/2) radius radius]);\n    set(lineHandle,'XData',[rodPivotPoint(1) position(1)],'YData',...\n        [rodPivotPoint(2) position(2)]);\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "  DS{1}.account='jsmith';\n  DS{1}.password='x';\n  DS{1}.UID=1001;\n  DS{1}.GID=1000;\n  DS{1}.fullname='Joe Smith';\n  DS{1}.office='Room 1007';\n  DS{1}.extension='(234)555-8917';\n  DS{1}.homephone='(234)555-0077';\n  DS{1}.email='jsmith@rosettacode.org';\n  DS{1}.directory='/home/jsmith';\n  DS{1}.shell='/bin/bash';\n\n  DS{2}.account='jdoe';\n  DS{2}.password='x';\n  DS{2}.UID=1002;\n  DS{2}.GID=1000;\n  DS{2}.fullname='Jane Doe';\n  DS{2}.office='Room 1004';\n  DS{2}.extension='(234)555-8914';\n  DS{2}.homephone='(234)555-0044';\n  DS{2}.email='jdoe@rosettacode.org';\n  DS{2}.directory='/home/jdoe';\n  DS{2}.shell='/bin/bash';\n\n  function WriteRecord(fid, rec)\n     fprintf(fid,\"%s:%s:%i:%i:%s,%s,%s,%s,%s:%s%s\\n\", rec.account, rec.password, rec.UID, rec.GID, rec.fullname, rec.office, rec.extension, rec.homephone, rec.email, rec.directory, rec.shell);\n     return;\n  end\n\n  %% write\n  fid = fopen('passwd.txt','w');\n  WriteRecord(fid,DS{1});\n  WriteRecord(fid,DS{2});\n  fclose(fid);\n\n  new.account='xyz';\n  new.password='x';\n  new.UID=1003;\n  new.GID=1000;\n  new.fullname='X Yz';\n  new.office='Room 1003';\n  new.extension='(234)555-8913';\n  new.homephone='(234)555-0033';\n  new.email='xyz@rosettacode.org';\n  new.directory='/home/xyz';\n  new.shell='/bin/bash';\n\n  %% append\n  fid = fopen('passwd.txt','a+');\n  WriteRecord(fid,new);\n  fclose(fid);\n\n  % read password file\n  fid = fopen('passwd.txt','r');\n  while ~feof(fid)\n\tprintf('%s\\n',fgetl(fid));\n  end;\n  fclose(fid);\n"
  },
  {
    "language": "MATLAB",
    "code": ">> array = [1 2 3 4 5]\n\narray =\n\n     1     2     3     4     5\n\n>> arrayfun(@sin,array)\n\nans =\n\n  Columns 1 through 4\n\n   0.841470984807897   0.909297426825682   0.141120008059867  -0.756802495307928\n\n  Column 5\n\n  -0.958924274663138\n\n>> cellarray = {1,2,3,4,5}\n\ncellarray =\n\n    [1]    [2]    [3]    [4]    [5]\n\n>> cellfun(@tan,cellarray)\n\nans =\n\n  Columns 1 through 4\n\n   1.557407724654902  -2.185039863261519  -0.142546543074278   1.157821282349578\n\n  Column 5\n\n  -3.380515006246586\n"
  },
  {
    "language": "MATLAB",
    "code": ">> answer = vpi(5)^(vpi(4)^(vpi(3)^vpi(2)));\n>> numDigits = order(answer) + 1\n\nnumDigits =\n\n      183231\n\n>> [sprintf('%d',leadingdigit(answer,20)) '...' sprintf('%d',trailingdigit(answer,20))]\n%First and Last 20 Digits\n\nans =\n\n62060698786608744707...92256259918212890625\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = 1+i\n\na =\n\n  1.000000000000000 + 1.000000000000000i\n\n>> b = 3+7i\n\nb =\n\n  3.000000000000000 + 7.000000000000000i\n\n>> a+b\n\nans =\n\n  4.000000000000000 + 8.000000000000000i\n\n>> a-b\n\nans =\n\n -2.000000000000000 - 6.000000000000000i\n\n>> a*b\n\nans =\n\n -4.000000000000000 +10.000000000000000i\n\n>> a/b\n\nans =\n\n  0.172413793103448 - 0.068965517241379i\n\n>> -a\n\nans =\n\n -1.000000000000000 - 1.000000000000000i\n\n>> a'\n\nans =\n\n  1.000000000000000 - 1.000000000000000i\n\n>> a^b\n\nans =\n\n  0.000808197112874 - 0.011556516327187i\n\n>> norm(a)\n\nans =\n\n   1.414213562373095\n"
  },
  {
    "language": "MATLAB",
    "code": "function [a,g]=agm(a,g)\n%%arithmetic_geometric_mean(a,g)\n\twhile (1)\n\t\ta0=a;\n\t\ta=(a0+g)/2;\n\t\tg=sqrt(a0*g);\n\tif (abs(a0-a) < a*eps) break; end;\n\tend;\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "disp(\"integer a: \"); a = scanf(\"%d\", 1);\ndisp(\"integer b: \"); b = scanf(\"%d\", 1);\na+b\na-b\na*b\nfloor(a/b)\nmod(a,b)\na^b\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = [1 2 3]\n\na =\n\n     1     2     3\n\n>> b = [4 5 6]\n\nb =\n\n     4     5     6\n\n>> concat = [a b]\n\nconcat =\n\n     1     2     3     4     5     6\n\n>> concat = [a;b]\n\nconcat =\n\n     1     2     3\n     4     5     6\n"
  },
  {
    "language": "MATLAB",
    "code": ">> c = randn([3,4,5]);\n>> d = randn([3,4,7]);\n>> e = cat(3,c,d);\n>> size(e)\n   ans =\n\n    3    4   12\n"
  },
  {
    "language": "MATLAB",
    "code": ">> a = [1 2 35] %Declaring a vector (i.e. one-dimensional array)\n\na =\n\n     1     2    35\n\n>> a = [1 2 35;5 7 9] % Declaring a matrix (i.e. two-dimensional array)\n\na =\n\n     1     2    35\n     5     7     9\n\n>> a3 = reshape(1:2*3*4,[2,3,4]);   % declaring a three-dimensional array of size 2x3x4\n\na3 =\n\nans(:,:,1) =\n\n   1   3   5\n   2   4   6\n\nans(:,:,2) =\n\n    7    9   11\n    8   10   12\n\nans(:,:,3) =\n\n   13   15   17\n   14   16   18\n\nans(:,:,4) =\n\n   19   21   23\n   20   22   24\n\n\n>> a(2,3) %Retrieving value using row and column indicies\n\n     9\n\n>> a(6) %Retrieving value using array subscript\n\nans =\n\n     9\n\n>> a = [a [10;42]] %Added a column vector to the array\n\na =\n\n     1     2    35    10\n     5     7     9    42\n\n>> a(:,1) = [] %Deleting array elements\n\na =\n\n     2    35    10\n     7     9    42\n"
  },
  {
    "language": "MATLAB",
    "code": "assert(x == 42,'x = %d, not 42.',x);\n"
  },
  {
    "language": "MATLAB",
    "code": "x = 3;\nassert(x == 42,'Assertion Failed: x = %d, not 42.',x);\n??? Assertion Failed: x = 3, not 42.\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash.a = 1;\n   hash.b = 2;\n   hash.C = [3,4,5];\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash = [];\n   hash = setfield(hash,'a',1); \t\n   hash = setfield(hash,'b',2); \t\n   hash = setfield(hash,'C',[3,4,5]);\n"
  },
  {
    "language": "MATLAB",
    "code": "   hash.('a') = 1; \t\n   hash.('b') = 2; \t\n   hash.('C') = [3,4,5];\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map({'a' 'b' 'C'}, [1 2 3]);\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map;\nm('a') = 1;\nm('b') = 2;\nm('C') = 3;\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map([51 72 37], {'fiftyone' 'seventytwo' 'thirtyseven'});\n"
  },
  {
    "language": "MATLAB",
    "code": "m = containers.Map('KeyType', 'double', 'ValueType', 'any');\nm(51) = 'fiftyone';\nm(72) = 'seventytwo';\nm(37) = 'thirtyseven';\n"
  },
  {
    "language": "MATLAB",
    "code": "   keys = fieldnames(hash);\n   for k=1:length(keys),\n        key = keys{k};\n\tvalue = getfield(hash,key);        % get value of key\n\thash = setfield(hash,key,-value);  % set value of key\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "   keys = fieldnames(hash);\n   for k=1:length(keys),\n        key = keys{k};\n        value = hash.(key);     % get value of key\n        hash.(key) = -value;    % set value of key\n   end;\n"
  },
  {
    "language": "MATLAB",
    "code": "function meanValue = findmean(setOfValues)\n   meanValue = mean(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function u = mean_angle(phi)\n\tu = angle(mean(exp(i*pi*phi/180)))*180/pi;\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function t = mean_time_of_day(t)\n    c = pi/(12*60*60);\n    for k=1:length(t)\n\ta = sscanf(t{k},'%d:%d:%d');\n\tphi(k) = (a(1)*3600+a(2)*60+a(3));\n    end;\n    d = angle(mean(exp(i*phi*c)))/(2*pi); % days\n    if (d<0) d += 1;\n    t = datestr(d,\"HH:MM:SS\");\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "function medianValue = findmedian(setOfValues)\n   medianValue = median(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function modeValue = findmode(setOfValues)\n   modeValue = mode(setOfValues);\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function [A,G,H] = pythagoreanMeans(list)\n\n    A = mean(list);\n    G = geomean(list);\n    H = harmmean(list);\n\nend\n"
  },
  {
    "language": "MATLAB",
    "code": "function [A,G,H] = pythagoreanMeans(list)\n    A = mean(list);           % arithmetic mean\n    G = exp(mean(log(list))); % geometric mean\n    H = 1./mean(1./list);     % harmonic mean\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> [A,G,H]=pythagoreanMeans((1:10))\n\nA =\n\n   5.500000000000000\n\n\nG =\n\n   4.528728688116765\n\n\nH =\n\n   3.414171521474055\n"
  },
  {
    "language": "MATLAB",
    "code": "function rms = quadraticMean(list)\n    rms = sqrt(mean(list.^2));\nend\n"
  },
  {
    "language": "MATLAB",
    "code": ">> quadraticMean((1:10))\n\nans =\n\n   6.204836822995429\n"
  },
  {
    "language": "MATLAB",
    "code": " [m,z] = filter(ones(1,P),P,x);\n"
  },
  {
    "language": "MATLAB",
    "code": " [m,z] = filter(ones(1,P),P,x,z);\n"
  },
  {
    "language": "MATLAB",
    "code": "function x = isbb(s)\n   t = cumsum((s=='[') - (s==']'));\n   x = all(t>=0) && (t(end)==0);\nend;\n"
  },
  {
    "language": "MATLAB",
    "code": "  dec2bin(5)\n  dec2bin(50)\n  dec2bin(9000)\n"
  },
  {
    "language": "MATLAB",
    "code": "function mid = binarySearchRec(list,value,low,high)\n\n    if( high < low )\n        mid = [];\n        return\n    end\n\n    mid = floor((low + high)/2);\n\n    if( list(mid) > value )\n        mid = binarySearchRec(list,value,low,mid-1);\n        return\n    elseif( list(mid) < value )\n        mid = binarySearchRec(list,value,mid+1,high);\n        return\n    else\n        return\n    end\n\nend\n"
  },
  {
    "language": "Perl",
    "code": "my @doors;\nfor my $pass (1 .. 100) {\n    for (1 .. 100) {\n        if (0 == $_ % $pass) {\n            $doors[$_] = not $doors[$_];\n        };\n    };\n};\n\nprint \"Door $_ is \", $doors[$_] ? \"open\" : \"closed\", \"\\n\" for 1 .. 100;\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\nuse strict;\nuse warnings;\n\nmy @doors = (1) x 100;\nfor my $N (1 .. 100) {\n   $doors[$_]=1-$doors[$_] for map { $_*$N - 1 } 1 .. int(100/$N);\n}\nprint join(\"\\n\", map { \"Door $_ is Open\" } grep { ! $doors[$_-1] } 1 .. 100), \"\\n\";\nprint \"The rest are closed\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "print \"Door $_ is open\\n\" for map $_**2, 1 .. 10;\n"
  },
  {
    "language": "Perl",
    "code": "print \"Door $_ is \", qw\"closed open\"[int sqrt == sqrt], \"\\n\" for 1..100;\n"
  },
  {
    "language": "Perl",
    "code": "while( ++$i <= 100 )\n{\n    $root = sqrt($i);\n    if ( int( $root ) == $root )\n    {\n        print \"Door $i is open\\n\";\n    }\n    else\n    {\n        print \"Door $i is closed\\n\";\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "# Fischer-Krause ordered permutation generator\n# http://faq.perl.org/perlfaq4.html#How_do_I_permute_N_e\nsub permute (&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$#_;\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $#idx;\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n# generate all possible combinations of operators\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/env perl\nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q')\n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  # remove all white space\n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  # not correct digits\n      $entry =~ /\\d\\d/ ||                # combined digits\n      $entry =~ m|[-+*/]{2}| ||          # combined operators\n      $entry =~ tr|-0-9()+*/||c)         # Invalid characters\n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/:all/;\n\nsub triangle_row {\n  my($n,@row) = (shift);\n  # Tally by first element of the unrestricted integer partitions.\n  forpart { $row[ $_[0] - 1 ]++ } $n;\n  @row;\n}\n\nprintf \"%2d: %s\\n\", $_, join(\" \",triangle_row($_)) for 1..25;\nprint \"\\n\";\nsay \"P($_) = \", partitions($_) for (23, 123, 1234, 12345);\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\n# Where perl6 uses arbitrary precision integers everywhere\n# that you don't tell it not to do so, perl5 will only use\n# them where you *do* tell it do so.\nuse Math::BigInt;\nuse constant zero => Math::BigInt->bzero;\nuse constant one  => Math::BigInt->bone;\n\nmy @todo = [one];\nmy @sums = (zero);\nsub nextrow {\n   my $n = shift;\n   for my $l (@todo .. $n) {\n      $sums[$l] = zero;\n      #print \"$l\\r\" if $l < $n;\n      my @r;\n      for my $x (reverse 0 .. $l-1) {\n         my $todo = $todo[$x];\n         $sums[$x] += shift @$todo if @$todo;\n         push @r, $sums[$x];\n      }\n      push @todo, \\@r;\n   }\n   @{ $todo[$n] };\n}\n\nprint \"rows:\\n\";\nfor(1..25) {\n   printf(\"%2d: \", $_);\n   print join(' ', nextrow($_)), \"\\n\";\n}\nprint \"\\nsums:\\n\";\nfor (23, 123, 1234, 12345) {\n   print $_, \".\" x (8 - length);\n   my $i = 0;\n   $i += $_ for nextrow($_);\n   print $i, \"\\n\";\n}\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl -w\n\nmy $verse = <<\"VERSE\";\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\nVERSE\n\n{\n    $verse =~ s/(\\d+)/$1-1/ge;\n    $verse =~ s/\\b1 bottles/1 bottle/g;\n    my $done = $verse =~ s/\\b0 bottle/No bottles/g; # if we make this replacement, we're also done.\n\n    print $verse;\n    redo unless $done;\n}\n"
  },
  {
    "language": "Perl",
    "code": "for $n (reverse(0..99))\n{\n    $bottles = sprintf(\"%s bottle%s of beer on the wall\\n\",(($n==0)?\"No\":$n), (($n==1)?\"\":\"s\"));\n    print( (($n==99)?\"\":\"$bottles\\n\") .\n\t   (($n==0)?\"\":(substr(${bottles}x2,0,-12) . \"\\nTake one down, pass it around\\n\")) );\n}\n"
  },
  {
    "language": "Perl",
    "code": "use 5.10.0;\n\n$num = 99;\nwhile ($num > 0) {\n    my $s = \"s\" unless ($num == 1);\n    say \"$num bottle$s of beer on the wall, $num bottle$s of beer\";\n    $num--;\n    my $s = \"s\" unless ($num == 1);\n    $num = \"No more\" if ($num == 0);\n    say \"Take one down, pass it around, $num bottle$s of beer on the wall\\n\"\n}\n\nsay \"No more bottles of beer on the wall, no more bottles of beer.\";\nsay \"Go to the store and buy some more, 99 bottles of beer on the wall.\";\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/env perl\nuse strict;\nuse warnings;\n\nsub bottles() { sprintf qq{%s bottle%s of beer}\n               , $_ || 'No'\n               , $_==1 ? '' : 's';\n               }\nsub store() { $_=99; qq{Go to the store, buy some more...\\n}; }\nsub wall() { qq{ on the wall\\n} }\nsub take() { $_-- ? qq{Take one down, pass it around\\n} : store }\ndo { print bottles, wall\n         , bottles, qq{\\n}\n         , take\n         , bottles, qq{\\n\\n}\n   } for reverse 0..99;\n"
  },
  {
    "language": "Perl",
    "code": "my ($a,$b) = split(' ', scalar(<STDIN>));\nprint \"$a $b \" . ($a + $b) . \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "say sum split /\\s+/,  scalar <STDIN>;\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\nuse warnings;\nuse strict;\n\n\nsub can_make_word {\n    my ($word, @blocks) = @_;\n    $_ = uc join q(), sort split // for @blocks;\n    my %blocks;\n    $blocks{$_}++ for @blocks;\n    return _can_make_word(uc $word, %blocks)\n}\n\n\nsub _can_make_word {\n    my ($word, %blocks) = @_;\n    my $char = substr $word, 0, 1, q();\n\n    my @candidates = grep 0 <= index($_, $char), keys %blocks;\n    for my $candidate (@candidates) {\n        next if $blocks{$candidate} <= 0;\n        local $blocks{$candidate} = $blocks{$candidate} - 1;\n        return 1 if q() eq $word or _can_make_word($word, %blocks);\n    }\n    return\n}\n"
  },
  {
    "language": "Perl",
    "code": "use Test::More tests => 8;\n\nmy @blocks1 = qw(BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM);\nis(can_make_word(\"A\",       @blocks1), 1);\nis(can_make_word(\"BARK\",    @blocks1), 1);\nis(can_make_word(\"BOOK\",    @blocks1), undef);\nis(can_make_word(\"TREAT\",   @blocks1), 1);\nis(can_make_word(\"COMMON\",  @blocks1), undef);\nis(can_make_word(\"SQUAD\",   @blocks1), 1);\nis(can_make_word(\"CONFUSE\", @blocks1), 1);\n\nmy @blocks2 = qw(US TZ AO QA);\nis(can_make_word('auto', @blocks2), 1);\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse strict;\n\nsub frob { die \"abstract\" }\nsub baz { die \"abstract\" }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse strict;\n\nsub frob { ... }\nsub baz { ... }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse Moose::Role;\n\nrequires qw/frob baz/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "package AbstractFoo;\n\nuse Role::Tiny;\n\nrequires qw/frob baz/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\nmy @type = <Perfect Abundant Deficient>;\nsay join \"\\n\", map { sprintf \"%2d %s\", $_, $type[divisor_sum($_)-$_ <=> $_] } 1..12;\nmy %h;\n$h{divisor_sum($_)-$_ <=> $_}++ for 1..20000;\nsay \"Perfect: $h{0}    Deficient: $h{-1}    Abundant: $h{1}\";\n"
  },
  {
    "language": "Perl",
    "code": "sub div_sum {\n    my($n) = @_;\n    my $sum = 0;\n    map { $sum += $_ unless $n % $_ } 1 .. $n-1;\n    $sum;\n}\n\nmy @type = <Perfect Abundant Deficient>;\nsay join \"\\n\", map { sprintf \"%2d %s\", $_, $type[div_sum($_) <=> $_] } 1..12;\nmy %h;\n$h{div_sum($_) <=> $_}++ for 1..20000;\nsay \"Perfect: $h{0}    Deficient: $h{-1}    Abundant: $h{1}\";\n"
  },
  {
    "language": "Perl",
    "code": "sub accumulator {\n  my $sum = shift;\n  sub { $sum += shift }\n}\n\nmy $x = accumulator(1);\n$x->(5);\naccumulator(3);\nprint $x->(2.3), \"\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "{\n    my @memo;\n    sub A {\n        my( $m, $n ) = @_;\n        $memo[ $m ][ $n ] and return $memo[ $m ][ $n ];\n        $m or return $n + 1;\n        return $memo[ $m ][ $n ] = (\n            $n\n               ? A( $m - 1, A( $m, $n - 1 ) )\n               : A( $m - 1, 1 )\n        );\n    }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub A {\n    my ($m, $n) = @_;\n    if    ($m == 0) { $n + 1 }\n    elsif ($n == 0) { A($m - 1, 1) }\n    else            { A($m - 1, A($m, $n - 1)) }\n}\n"
  },
  {
    "language": "Perl",
    "code": "sub A {\n  my ($m, $n) = @_;\n  $m == 0 ? $n + 1 :\n  $n == 0 ? A($m - 1, 1) :\n            A($m - 1, A($m, $n - 1))\n}\n"
  },
  {
    "language": "Perl",
    "code": "use Memoize;  memoize('ack2');\nuse bigint try=>\"GMP\";\n\nsub ack2 {\n   my ($m, $n) = @_;\n   $m == 0 ? $n + 1 :\n   $m == 1 ? $n + 2 :\n   $m == 2 ? 2*$n + 3 :\n   $m == 3 ? 8 * (2**$n - 1) + 5 :\n   $n == 0 ? ack2($m-1, 1)\n           : ack2($m-1, ack2($m, $n-1));\n}\nprint \"ack2(3,4) is \", ack2(3,4), \"\\n\";\nprint \"ack2(4,1) is \", ack2(4,1), \"\\n\";\nprint \"ack2(4,2) has \", length(ack2(4,2)), \" digits\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\nuse Math::BigInt;\n\nuse constant two => Math::BigInt->new(2);\n\nsub ack {\n\tmy $n = pop;\n\twhile( @_ ) {\n\t\tmy $m = pop;\n\t\tif( $m > 3 ) {\n\t\t\tpush @_, (--$m) x $n;\n\t\t\tpush @_, reverse 3 .. --$m;\n\t\t\t$n = 13;\n\t\t} elsif( $m == 3 ) {\n\t\t\tif( $n < 29 ) {\n\t\t\t\t$n = ( 1 << ( $n + 3 ) ) - 3;\n\t\t\t} else {\n\t\t\t\t$n = two ** ( $n + 3 ) - 3;\n\t\t\t}\n\t\t} elsif( $m == 2 ) {\n\t\t\t$n = 2 * $n + 3;\n\t\t} elsif( $m >= 0 ) {\n\t\t\t$n = $n + $m + 1;\n\t\t} else {\n\t\t\tdie \"negative m!\";\n\t\t}\n\t}\n\t$n;\n}\n\nprint \"ack(3,4) is \", ack(3,4), \"\\n\";\nprint \"ack(4,1) is \", ack(4,1), \"\\n\";\nprint \"ack(4,2) has \", length(ack(4,2)), \" digits\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use Net::LDAP;\n\nmy $ldap = Net::LDAP->new('ldap://ldap.example.com') or die $@;\nmy $mesg = $ldap->bind( $bind_dn, password => $bind_pass );\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\n\nuse strict;\nuse 5.10.0;\n\npackage Integrator;\nuse threads;\nuse threads::shared;\n\nsub new {\n\tmy $cls = shift;\n\tmy $obj = bless {\tt\t=> 0,\n\t\t\t\tsum\t=> 0,\n\t\t\t\tref $cls ? %$cls : (),\n\t\t\t\tstop\t=> 0,\n\t\t\t\ttid\t=> 0,\n\t\t\t\tfunc\t=> shift,\n\t\t\t}, ref $cls || $cls;\n\n\tshare($obj->{sum});\n\tshare($obj->{stop});\n\n\t$obj->{tid} = async {\n\t\tmy $upd = 0.1; # update every 0.1 second\n\t\twhile (!$obj->{stop}) {\n\t\t\t{\n\t\t\t\tmy $f = $obj->{func};\n\t\t\t\tmy $t = $obj->{t};\n\n\t\t\t\t$obj->{sum} += ($f->($t) + $f->($t + $upd))* $upd/ 2;\n\t\t\t\t$obj->{t} += $upd;\n\t\t\t}\n\t\t\tselect(undef, undef, undef, $upd);\n\t\t}\n\t#\tsay \"stopping $obj\";\n\t};\n\t$obj\n}\n\nsub output { shift->{sum} }\n\nsub delete {\n\tmy $obj = shift;\n\t$obj->{stop} = 1;\n\t$obj->{tid}->join;\n}\n\nsub setinput {\n\t# This is surprisingly difficult because of the perl sharing model.\n\t# Func refs can't be shared, thus can't be replaced by another thread.\n\t# Have to create a whole new object... there must be a better way.\n\tmy $obj = shift;\n\t$obj->delete;\n\t$obj->new(shift);\n}\n\npackage main;\n\nmy $x = Integrator->new(sub { sin(atan2(1, 1) * 8 * .5 * shift) });\n\nsleep(2);\nsay \"sin after 2 seconds: \", $x->output;\n\n$x = $x->setinput(sub {0});\n\nselect(undef, undef, undef, .5);\nsay \"0 after .5 seconds: \", $x->output;\n\n$x->delete;\n"
  },
  {
    "language": "Perl",
    "code": "package Empty;\n\n# Constructor. Object is hash.\nsub new { return bless {}, shift; }\n\npackage main;\n\n# Object.\nmy $o = Empty->new;\n\n# Set runtime variable (key => value).\n$o->{'foo'} = 1;\n"
  },
  {
    "language": "Perl",
    "code": "use Scalar::Util qw(refaddr);\nprint refaddr(\\my $v), \"\\n\";  # 140502490125712\n"
  },
  {
    "language": "Perl",
    "code": "printf \"%p\", $v; # 7fc949039590\n"
  },
  {
    "language": "Perl",
    "code": "my $a = 12;\nmy $b = \\$a; # get reference\n$$b = $$b + 30; # access referenced value\nprint $a; # prints 42\n"
  },
  {
    "language": "Perl",
    "code": "my $a = 12;\nour $b; # you can overlay only global variables (this line is only for strictness)\n*b = \\$a;\nprint $b; # prints 12\n$b++;\nprint $a; # prints 13\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n# Select one of these lines.  Math::BigInt is in core, but quite slow.\nuse Math::BigInt;  sub binomial { Math::BigInt->new(shift)->bnok(shift) }\n# use Math::Pari \"binomial\";\n# use ntheory \"binomial\";\n\nsub binprime {\n  my $p = shift;\n  return 0 unless $p >= 2;\n  # binomial is symmetric, so only test half the terms\n  for (1 .. ($p>>1)) { return 0 if binomial($p,$_) % $p }\n  1;\n}\nsub coef {                   # For prettier printing\n  my($n,$e) = @_;\n  return $n unless $e;\n  $n = \"\" if $n==1;\n  $e==1 ? \"${n}x\" : \"${n}x^$e\";\n}\nsub binpoly {\n  my $p = shift;\n  join(\" \", coef(1,$p),\n            map { join(\"\",(\"+\",\"-\")[($p-$_)&1],\" \",coef(binomial($p,$_),$_)) }\n            reverse 0..$p-1 );\n}\nprint \"expansions of (x-1)^p:\\n\";\nprint binpoly($_),\"\\n\" for 0..9;\nprint \"Primes to 80: [\", join(\",\", grep { binprime($_) } 2..80), \"]\\n\";\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory \":all\";\n# Uncomment next line to see the r and s values used.  Set to 2 for more detail.\n# prime_set_config(verbose => 1);\nsay join(\" \", grep { is_aks_prime($_) } 1_000_000_000 .. 1_000_000_100);\n"
  },
  {
    "language": "Perl",
    "code": "#/usr/bin/perl -w\nuse strict ;\n\ndie \"Call : perl columnaligner.pl <inputfile> <printorientation>!\\n\" unless\n   @ARGV == 2 ; #$ARGV[ 0 ] contains example file , $ARGV[1] any of 'left' , 'right' or 'center'\ndie \"last argument must be one of center, left or right!\\n\" unless\n   $ARGV[ 1 ] =~ /center|left|right/ ;\nsub printLines( $$$ ) ;\nopen INFILE , \"<\" , \"$ARGV[ 0 ]\" or die \"Can't open $ARGV[ 0 ]!\\n\" ;\nmy @lines = <INFILE> ;\nclose INFILE ;\nchomp @lines ;\nmy @fieldwidths = map length, split /\\$/ , $lines[ 0 ] ;\nforeach my $i ( 1..$#lines ) {\n   my @words = split /\\$/ , $lines[ $i ] ;\n   foreach my $j ( 0..$#words ) {\n      if ( $j <= $#fieldwidths ) {\n         if ( length $words[ $j ] > $fieldwidths[ $j ] ) {\n               $fieldwidths[ $j ] = length $words[ $j ] ;\n         }\n      }\n      else {\n         push @fieldwidths, length $words[ $j ] ;\n      }\n   }\n}\nprintLine( $_ , $ARGV[ 1 ] , \\@fieldwidths ) foreach @lines ;\n##################################################################    ####\nsub printLine {\n   my $line = shift ;\n   my $orientation = shift ;\n   my $widthref = shift ;\n   my @words = split /\\$/, $line ;\n   foreach my $k ( 0..$#words ) {\n      my $printwidth = $widthref->[ $k ] + 1 ;\n      if ( $orientation eq 'center' ) {\n         $printwidth++ ;\n      }\n      if ( $orientation eq 'left' ) {\n         print $words[ $k ] ;\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n      }\n      elsif ( $orientation eq 'right' ) {\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n         print $words[ $k ] ;\n      }\n      elsif ( $orientation eq 'center' ) {\n         my $left = int( ( $printwidth - length $words[ $k ] )     / 2 ) ;\n         my $right = $printwidth - length( $words[ $k ] ) - $left      ;\n         print \" \" x $left ;\n         print $words[ $k ] ;\n         print \" \" x $right ;\n      }\n   }\n   print \"\\n\" ;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use List::Util qw(max);\n\nsub columns {\n    my @lines = map [split /\\$/] => split /\\n/ => shift;\n    my $pos = {qw/left 0 center 1 right 2/}->{+shift};\n    for my $col (0 .. max map {$#$_} @lines) {\n        my $max = max my @widths = map {length $_->[$col]} @lines;\n        for my $row (0 .. $#lines) {\n            my @pad = map {' ' x $_, ' ' x ($_ + 0.5)} ($max - $widths[$row]) / 2;\n            for ($lines[$row][$col])\n                {$_ = join '' => @pad[0 .. $pos-1], $_, @pad[$pos .. $#pad]}\n        }\n    }\n    join '' => map {\"@$_\\n\"} @lines\n}\n\nprint columns <<'END', $_ for qw(left right center);\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    # push onto allterms here if we want the cyclic term to display\n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/factor/;\nsub almost {\n  my($k,$n) = @_;\n  my $i = 1;\n  map { $i++ while scalar factor($i) != $k; $i++ } 1..$n;\n}\nsay \"$_ : \", join(\" \", almost($_,10)) for 1..5;\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nsub k_almost_prime;\n\nfor my $k ( 1 .. 5 ) {\n\tmy $almost = 0;\n\tprint join(\", \", map {\n\t\t1 until k_almost_prime ++$almost, $k;\n\t\t\"$almost\";\n\t} 1 .. 10), \"\\n\";\n}\n\nsub nth_prime;\n\nsub k_almost_prime {\n\tmy ($n, $k) = @_;\n\treturn if $n <= 1 or $k < 1;\n\tmy $which_prime = 0;\n\tfor my $count ( 1 .. $k ) {\n\t\twhile( $n % nth_prime $which_prime ) {\n\t\t\t++$which_prime;\n\t\t}\n\t\t$n /= nth_prime $which_prime;\n\t\treturn if $n == 1 and $count != $k;\n\t}\n\t($n == 1) ? 1 : ();\n}\n\nBEGIN {\n\t# This is loosely based on one of the python solutions\n\t# to the RC Sieve of Eratosthenes task.\n\tmy @primes = (2, 3, 5, 7);\n\tmy $p_iter = 1;\n\tmy $p = $primes[$p_iter];\n\tmy $q = $p*$p;\n\tmy %sieve;\n\tmy $candidate = $primes[-1] + 2;\n\tsub nth_prime {\n\t\tmy $n = shift;\n\t\treturn if $n < 0;\n\t\tOUTER: while( $#primes < $n ) {\n\t\t\twhile( my $s = delete $sieve{$candidate} ) {\n\t\t\t\tmy $next = $s + $candidate;\n\t\t\t\t$next += $s while exists $sieve{$next};\n\t\t\t\t$sieve{$next} = $s;\n\t\t\t\t$candidate += 2;\n\t\t\t}\n\t\t\twhile( $candidate < $q ) {\n\t\t\t\tpush @primes, $candidate;\n\t\t\t\t$candidate += 2;\n\t\t\t\tnext OUTER if exists $sieve{$candidate};\n\t\t\t}\n\t\t\tmy $twop = 2 * $p;\n\t\t\tmy $next = $q + $twop;\n\t\t\t$next += $twop while exists $sieve{$next};\n\t\t\t$sieve{$next} = $twop;\n\t\t\t$p = $primes[++$p_iter];\n\t\t\t$q = $p * $p;\t\n\t\t\t$candidate += 2;\n\t\t}\n\t\treturn $primes[$n];\n\t}\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nuse constant EXIT_FAILURE => 1;\nuse constant EXIT_SUCCESS => 0;\n\nsub amb {\n   exit(EXIT_FAILURE) if !@_;\n   for my $word (@_) {\n      my $pid = fork;\n      die $! unless defined $pid;\n      return $word if !$pid;\n      my $wpid = waitpid $pid, 0;\n      die $! unless $wpid == $pid;\n      exit(EXIT_SUCCESS) if $? == EXIT_SUCCESS;\n   }\n   exit(EXIT_FAILURE);\n}\n\nsub joined {\n   my ($join_a, $join_b) = @_;\n   substr($join_a, -1) eq substr($join_b, 0, 1);\n}\n\nmy $w1 = amb(qw(the that a));\nmy $w2 = amb(qw(frog elephant thing));\nmy $w3 = amb(qw(walked treaded grows));\nmy $w4 = amb(qw(slowly quickly));\n\namb() unless joined $w1, $w2;\namb() unless joined $w2, $w3;\namb() unless joined $w3, $w4;\n\nprint \"$w1 $w2 $w3 $w4\\n\";\nexit(EXIT_SUCCESS);\n"
  },
  {
    "language": "Perl",
    "code": "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse feature 'say';\nuse re 'eval';\n\nsub amb ($@) {\n    my $var = shift;\n    join ' || ', map { \"(?{ $var = '$_' })\" } @_;\n}\n\nsub joins {\n    substr(shift,-1,1) eq substr(shift,0,1)\n}\n\nmy ($a,$b,$c,$d);\n'' =~ m/\n    (??{  amb '$a', qw[the that a]           })\n    (??{  amb '$b', qw[frog elephant thing]  })\n    (??{  amb '$c', qw[walked treaded grows] })\n    (??{  amb '$d', qw[slowly quickly]       })\n    (?(?{ joins($b, $c)                      })|(*FAIL))\n    (?(?{ joins($a, $b)                      })|(*FAIL))\n    (?(?{ joins($c, $d)                      })|(*FAIL))\n    (?{   say \"$a $b $c $d\"                  })\n/x;\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\n\nsub amb {\n   if( @_ == 0 ) {\n      no warnings 'exiting';\n      next AMB;\n   }\n   my $code = pop;\n   my @words = @_;\n   my @index = (0) x @words;\n   AMB: while( 1 ) {\n      my @w = map $words[$_][$index[$_]], 0 .. $#_;\n      return $code->( @w );\n   } continue {\n      my $i = 0;\n      while( ++$index[$i] == @{$words[$i]} ) {\n         $index[$i] = 0;\n         return if ++$i == @index;\n      }\n   }\n}\n\nmy @w1 = qw(the that a);\nmy @w2 = qw(frog elephant thing);\nmy @w3 = qw(walked treaded grows);\nmy @w4 = qw(slowly quickly);\n\nsub joined {\n   my ($join_a, $join_b) = @_;\n   substr($join_a, -1) eq substr($join_b, 0, 1);\n}\n\namb( \\(@w1, @w2, @w3, @w4), sub {\n   my ($w1, $w2, $w3, $w4) = @_;\n   amb() unless joined($w1, $w2);\n   amb() unless joined($w2, $w3);\n   amb() unless joined($w3, $w4);\n   print \"$w1 $w2 $w3 $w4\\n\";\n});\n"
  },
  {
    "language": "Perl",
    "code": "use ntheory qw/divisor_sum/;\nfor my $x (1..20000) {\n  my $y = divisor_sum($x)-$x;\n  say \"$x $y\" if $y > $x && $x == divisor_sum($y)-$y;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use List::Util 'max';\n\nmy @words = split \"\\n\", do { local( @ARGV, $/ ) = ( 'unixdict.txt' ); <> };\nmy %anagram;\nfor my $word (@words) {\n    push @{ $anagram{join '', sort split '', $word} }, $word;\n}\n\nmy $count = max(map {scalar @$_} values %anagram);\nfor my $ana (values %anagram) {\n    print \"@$ana\\n\" if @$ana == $count;\n}\n"
  },
  {
    "language": "Perl",
    "code": "push @{$anagram{ join '' => sort split '' }}, $_ for @words;\n$max > @$_  or  $max = @$_    for values %anagram;\n@$_ == $max and print \"@$_\\n\" for values %anagram;\n"
  },
  {
    "language": "Perl",
    "code": "sub deranged {                          # only anagrams ever get here\n        my @a = split('', shift);       # split word into letters\n        my @b = split('', shift);\n        for (0 .. $#a) {\n                $a[$_] eq $b[$_] and return;\n        }\n        return 1\n}\n\nsub find_deranged {\n        for my $i ( 0 .. $#_ ) {\n                for my $j ( $i+1 .. $#_ ) {\n                        next unless deranged $_[$i], $_[$j];\n\n                        print \"length \", length($_[$i]), \": $_[$i] => $_[$j]\\n\";\n                        return 1;\n                }\n        }\n}\n\nmy %letter_list;\nopen my $in, 'unixdict.txt';\n\nlocal $/ = undef;\n\nfor (split(' ', <$in>)) {\n        # store anagrams in hash table by letters they contain\n        push @{ $letter_list{ join('', sort split('', $_)) } }, $_\n}\n\nfor (   sort { length($b) <=> length($a) }      # sort by length, descending\n        grep { @{ $letter_list{$_} } > 1 }      # take only ones with anagrams\n        keys %letter_list               )\n{\n        # if we find a pair, they are the longested due to the sort before\n        last if find_deranged(@{ $letter_list{$_} });\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfor ($i = 1; $i <= 100; $i++) {\n\t$root = sqrt($i);\n\t$state = ($root == ceil($root)) ? 'open' : 'closed';\n\techo \"Door {$i}: {$state}\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$doors = array_fill(1, 100, false);\nfor ($pass = 1; $pass <= 100; ++$pass) {\n\tfor ($nr = 1; $nr <= 100; ++$nr) {\n\t\tif ($nr % $pass == 0) {\n\t\t\t$doors[$nr] = !$doors[$nr];\n\t\t}\n\t}\n}\nfor ($nr = 1; $nr <= 100; ++$nr)\n\tprintf(\"Door %d: %s\\n\", $nr, ($doors[$nr])?'open':'closed');\n?>\n"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/env php\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n<?php\n\nwhile (true) {\n    $numbers = make_numbers();\n\n    for ($iteration_num = 1; ; $iteration_num++) {\n        echo \"Expresion $iteration_num: \";\n\n        $entry = rtrim(fgets(STDIN));\n\n        if ($entry === '!') break;\n        if ($entry === 'q') exit;\n\n        $result = play($numbers, $entry);\n\n        if ($result === null) {\n            echo \"That's not valid\\n\";\n            continue;\n        }\n        elseif ($result != 24) {\n            echo \"Sorry, that's $result\\n\";\n            continue;\n        }\n        else {\n            echo \"That's right! 24!!\\n\";\n            exit;\n        }\n    }\n}\n\nfunction make_numbers() {\n    $numbers = array();\n\n    echo \"Your four digits: \";\n\n    for ($i = 0; $i < 4; $i++) {\n        $number = rand(1, 9);\n        // The check is needed to avoid E_NOTICE from PHP\n        if (!isset($numbers[$number])) {\n            $numbers[$number] = 0;\n        }\n        $numbers[$number]++;\n        print \"$number \";\n    }\n\n    print \"\\n\";\n\n    return $numbers;\n}\n\nfunction play($numbers, $expression) {\n    $operator = true;\n    for ($i = 0, $length = strlen($expression); $i < $length; $i++) {\n        $character = $expression[$i];\n\n        if (in_array($character, array('(', ')', ' ', \"\\t\"))) continue;\n\n        $operator = !$operator;\n\n        if (!$operator) {\n            if (!empty($numbers[$character])) {\n                $numbers[$character]--;\n                continue;\n            }\n            return;\n        }\n        elseif (!in_array($character, array('+', '-', '*', '/'))) {\n            return;\n        }\n    }\n\n    foreach ($numbers as $remaining) {\n        if ($remaining > 0) {\n            return;\n        }\n    }\n\n    return eval(\"return $expression;\");\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$plural = 's';\nforeach (range(99, 1) as $i) {\n    echo \"$i bottle$plural of beer on the wall,\\n\";\n    echo \"$i bottle$plural of beer!\\n\";\n    echo \"Take one down, pass it around!\\n\";\n    if ($i - 1 == 1)\n        $plural = '';\n\n    if ($i > 1)\n        echo ($i - 1) . \" bottle$plural of beer on the wall!\\n\\n\";\n    else\n        echo \"No more bottles of beer on the wall!\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nforeach(range(99,1) as $i) {\n    $p = ($i>1)?\"s\":\"\";\n    echo <<< EOV\n$i bottle$p of beer on the wall\n$i bottle$p of beer\nTake one down, pass it around\n\n\nEOV;\n}\necho \"No more Bottles of beer on the wall\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$verse = <<<VERSE\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\n\nVERSE;\n\nforeach (range(1,99) as $i) { // loop 99 times\n    $verse = preg_replace('/\\d+/e', '$0 - 1', $verse);\n    $verse = preg_replace('/\\b1 bottles/', '1 bottle', $verse);\n    $verse = preg_replace('/\\b0 bottle/', 'No bottles', $verse);\n\n    echo $verse;\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  for($i=100;$i>0;$i--){\n    $p2=$i.\" bottle\".(($i>1)?\"s\":\"\").\" of beer\";\n    $p1=$p2.\" on the wall\\n\";\n    $p3=\"Take one down, pass it around\\n\";\n    echo (($i<100)?$p1.\"\\n\":\"\").$p1.$p2.\"\\n\".$p3.(($i<2)?($i-1).substr($p1,1,28):\"\");\n  }\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$bottles = 99;\n\nwhile ($bottles > 0) {\n\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer on the wall\\n\", $bottles);\t\t//X bottles of beer on the wall\n\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer\\n\", $bottles);\t\t\t\t//X bottles of beer\n\tprintf(\"Take one down, pass it around\\n\");\t\t\t\t\t\t\t\t\t\t//Take one down, pass it around\n\n\t$bottles--;\n\n\tif ($bottles > 0) {\n\t\tprintf(ngettext('%d bottle', '%d bottles', $bottles) . \" of beer on the wall\\n\\n\", $bottles);\t//X bottles of beer on the wall\n\t}\n}\nprintf('No more bottles of beer on the wall');\t\t\t\t\t\t\t\t\t\t\t//No more bottles of beer on the wall\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$lyrics = <<<ENDVERSE\n%2\\$d bottle%1\\$s of beer on the wall\n%2\\$d bottle%1\\$s of beer\nTake one down, pass it around\n%4\\$s bottle%3\\$s of beer on the wall\n\n\nENDVERSE;\n\n$x = 99;\nwhile ( $x > 0 ) {\n   printf( $lyrics, $x != 1 ? 's' : '', $x--, $x != 1 ? 's' : '', $x > 0 ? $x : 'No more' );\n}\n"
  },
  {
    "language": "PHP",
    "code": "fscanf(STDIN, \"%d %d\\n\", $a, $b); //Reads 2 numbers from STDIN\necho ($a + $b) . \"\\n\";\n"
  },
  {
    "language": "PHP",
    "code": "$in = fopen(\"input.dat\", \"r\");\nfscanf($in, \"%d %d\\n\", $a, $b); //Reads 2 numbers from file $in\nfclose($in);\n\n$out = fopen(\"output.dat\", \"w\");\nfwrite($out, ($a + $b) . \"\\n\");\nfclose($out);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = array(\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\");\n\nfunction canMakeWord($word) {\n    $word = strtoupper($word);\n    $blocks = array(\n            \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n            \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n            \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n            \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n    );\n\n    foreach (str_split($word) as $char) {\n        foreach ($blocks as $k => $block) {\n            if (strpos($block, $char) !== FALSE) {\n                unset($blocks[$k]);\n                continue(2);\n            }\n        }\n        return false;\n    }\n    return true;\n}\n\nforeach ($words as $word) {\n    echo $word.': ';\n    echo canMakeWord($word) ? \"True\" : \"False\";\n    echo \"\\r\\n\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "abstract class Abs {\n\tabstract public function method1($value);\n\tabstract protected function method2($name);\n\tfunction add($a, $b){\n\t\treturn a + b;\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "interface Inter {\n\tpublic function method1($value);\n\tpublic function method2($name);\n\tpublic function add($a, $b);\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction accumulator($start){\n return create_function('$x','static $v='.$start.';return $v+=$x;');\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; //prints 10\necho $acc(10), \"\\n\"; //prints 20\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction accumulator($sum){\n return function ($x) use (&$sum) { return $sum += $x; };\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; //prints 10\necho $acc(10), \"\\n\"; //prints 20\n?>\n"
  },
  {
    "language": "PHP",
    "code": "function ackermann( $m , $n )\n{\n    if ( $m==0 )\n    {\n        return $n + 1;\n    }\n    elseif ( $n==0 )\n    {\n        return ackermann( $m-1 , 1 );\n    }\n    return ackermann( $m-1, ackermann( $m , $n-1 ) );\n}\n\necho ackermann( 3, 4 );\n// prints 125\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$ldap = ldap_connect($hostname, $port);\n$success = ldap_bind($ldap, $username, $password);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$l = ldap_connect('ldap.example.com');\nldap_set_option($l, LDAP_OPT_PROTOCOL_VERSION, 3);\nldap_set_option($l, LDAP_OPT_REFERRALS, false);\n\n$bind = ldap_bind($l, 'me@example.com', 'password');\n\n$base = 'dc=example, dc=com';\n$criteria = '(&(objectClass=user)(sAMAccountName=username))';\n$attributes = array('displayName', 'company');\n\n$search = ldap_search($l, $base, $criteria, $attributes);\n$entries = ldap_get_entries($l, $search);\n\nvar_dump($entries);\n"
  },
  {
    "language": "PHP",
    "code": "class E {};\n\n$e=new E();\n\n$e->foo=1;\n\n$e->{\"foo\"} = 1; // using a runtime name\n$x = \"foo\";\n$e->$x = 1; // using a runtime name in a variable\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$j2justtype = array('L' => STR_PAD_RIGHT,\n                    'R' => STR_PAD_LEFT,\n                    'C' => STR_PAD_BOTH);\n\n/**\n Justify columns of textual tabular input where the record separator is the newline\n and the field separator is a 'dollar' character.\n justification can be L, R, or C; (Left, Right, or Centered).\n\n Return the justified output as a string\n*/\nfunction aligner($str, $justification = 'L') {\n  global $j2justtype;\n  assert(array_key_exists($justification, $j2justtype));\n  $justtype = $j2justtype[$justification];\n\n  $fieldsbyrow = array();\n  foreach (explode(\"\\n\", $str) as $line)\n    $fieldsbyrow[] = explode('$', $line);\n  $maxfields = max(array_map('count', $fieldsbyrow));\n\n  foreach (range(0, $maxfields-1) as $col) {\n    $maxwidth = 0;\n    foreach ($fieldsbyrow as $fields)\n      $maxwidth = max($maxwidth, strlen($fields[$col]));\n    foreach ($fieldsbyrow as &$fields)\n      $fields[$col] = str_pad($fields[$col], $maxwidth, ' ', $justtype);\n    unset($fields); // see http://bugs.php.net/29992\n  }\n  $result = '';\n  foreach ($fieldsbyrow as $fields)\n    $result .= implode(' ', $fields) . \"\\n\";\n  return $result;\n}\n\n$textinfile = 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$\\'dollar\\'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.';\n\nforeach (array('L', 'R', 'C') as $j)\n  echo aligner($textinfile, $j);\n\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = file(\n    'http://www.puzzlers.org/pub/wordlists/unixdict.txt',\n    FILE_IGNORE_NEW_LINES\n);\n$length = 0;\n\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $chars = implode(\"\", $chars);\n    $length = strlen($chars);\n    $anagrams[$length][$chars][] = $word;\n}\n\nkrsort($anagrams);\n\nforeach ($anagrams as $anagram) {\n    $final_words = array();\n    foreach ($anagram as $words) {\n        if (count($words) >= 2) {\n            $counts = array();\n            foreach ($words as $word) {\n                $counts[$word] = array($word);\n                foreach ($words as $second_word) {\n                    for ($i = 0, $length = strlen($word); $i < $length; $i++) {\n                        if ($word[$i] === $second_word[$i]) continue 2;\n                    }\n                    $counts[$word][] = $second_word;\n                }\n            }\n            $max = 0;\n            $max_key = '';\n            foreach ($counts as $name => $count) {\n                if (count($count) > $max) {\n                    $max = count($count);\n                    $max_key = $name;\n                }\n            }\n            if ($max > 1) {\n                $final_words[] = $counts[$max_key];\n            }\n        }\n    }\n    if ($final_words) break;\n}\n\nforeach ($final_words as $final_word) {\n    echo implode(\" \", $final_word), \"\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$words = explode(\"\\n\", file_get_contents('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'));\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $anagram[implode($chars)][] = $word;\n}\n\n$best = max(array_map('count', $anagram));\nforeach ($anagram as $ana)\n    if (count($ana) == $best)\n        print_r($ana);\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) { // This function must be called using call_user_func() only\n        if ($n < 2)\n            return 1;\n        else {\n            $g = debug_backtrace()[1]['args'][0];\n            return call_user_func($g, $n-1) + call_user_func($g, $n-2);\n        }\n    };\n    return call_user_func($f, $n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) use (&$f) {\n        if ($n < 2)\n            return 1;\n        else\n            return $f($n-1) + $f($n-2);\n    };\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass fib_helper {\n    function __invoke($n) {\n        if ($n < 2)\n            return 1;\n        else\n            return $this($n-1) + $this($n-2);\n    }\n}\n\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = new fib_helper();\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$filename = '/tmp/passwd';\n\n$data = array(\n    'account:password:UID:GID:fullname,office,extension,homephone,email:directory:shell' . PHP_EOL,\n    'jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash' . PHP_EOL,\n    'jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jdoe:/bin/bash' . PHP_EOL,\n);\nfile_put_contents($filename, $data, LOCK_EX);\n\necho 'File contents before new record added:', PHP_EOL, file_get_contents($filename), PHP_EOL;\n\n$data = array(\n    'xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash' . PHP_EOL\n);\nfile_put_contents($filename, $data, FILE_APPEND | LOCK_EX);\n\necho 'File contents after new record added:', PHP_EOL, file_get_contents($filename), PHP_EOL;\n"
  },
  {
    "language": "PHP",
    "code": "function cube($n)\n{\n   return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$y = bcpow('5', bcpow('4', bcpow('3', '2')));\nprintf(\"5**4**3**2 = %s...%s and has %d digits\\n\", substr($y,0,20), substr($y,-20), strlen($y));\n?>\n"
  },
  {
    "language": "PHP",
    "code": "define('PRECISION', 13);\n\nfunction agm($a0, $g0, $tolerance = 1e-10)\n{\n    // the bc extension deals in strings and cannot convert\n    // floats in scientific notation by itself - hence\n    // this manual conversion to a string\n    $limit = number_format($tolerance, PRECISION, '.', '');\n    $an    = $a0;\n    $gn    = $g0;\n    do {\n        list($an, $gn) = array(\n            bcdiv(bcadd($an, $gn), 2),\n            bcsqrt(bcmul($an, $gn)),\n        );\n    } while (bccomp(bcsub($an, $gn), $limit) > 0);\n\n    return $an;\n}\n\nbcscale(PRECISION);\necho agm(1, 1 / bcsqrt(2));\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$a = fgets(STDIN);\n$b = fgets(STDIN);\n\necho\n    \"sum:                 \", $a + $b, \"\\n\",\n    \"difference:          \", $a - $b, \"\\n\",\n    \"product:             \", $a * $b, \"\\n\",\n    \"truncating quotient: \", (int)($a / $b), \"\\n\",\n    \"flooring quotient:   \", floor($a / $b), \"\\n\",\n    \"remainder:           \", $a % $b, \"\\n\",\n    \"power:               \", $a ** $b, \"\\n\"; // PHP 5.6+ only\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$arr1 = array(1, 2, 3);\n$arr2 = array(4, 5, 6);\n$arr3 = array_merge($arr1, $arr2);\n"
  },
  {
    "language": "PHP",
    "code": "$NumberArray = array(0, 1, 2, 3, 4, 5, 6);\n$LetterArray = array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n$simpleForm = ['apple', 'orange'];\n"
  },
  {
    "language": "PHP",
    "code": "echo $CustomKeyArray[\"b\"]; // Returns C\n"
  },
  {
    "language": "PHP",
    "code": "$BlankArray = array();\n"
  },
  {
    "language": "PHP",
    "code": "$BlankArray[] = \"Not Blank Anymore\";\n"
  },
  {
    "language": "PHP",
    "code": "$AssignArray[\"CertainKey\"] = \"Value\";\n"
  },
  {
    "language": "PHP",
    "code": "$MultiArray = array(\n                array(0, 0, 0, 0, 0, 0),\n                array(1, 1, 1, 1, 1, 1),\n                array(2, 2, 2, 2, 2, 2),\n                array(3, 3, 3, 3, 3, 3)\n          );\n"
  },
  {
    "language": "PHP",
    "code": "$arr = ['apple', 'orange'];\narray_push($arr, 'pear');\nprint implode(',', $arr); // Returns apple,orange,pear\n"
  },
  {
    "language": "PHP",
    "code": "echo $NumberArray[5]; // Returns 5\necho $LetterArray[5]; // Returns f\n"
  },
  {
    "language": "PHP",
    "code": "echo $MultiArray[1][5]; // 2\n"
  },
  {
    "language": "PHP",
    "code": "print_r($MultiArray);\n"
  },
  {
    "language": "PHP",
    "code": "Array(\n    0 => array(\n            0 => 0\n            1 => 0\n            2 => 0\n            3 => 0\n            4 => 0\n            5 => 0\n         )\n    1 => array(\n            0 => 1\n            1 => 1\n            2 => 1\n            3 => 1\n            4 => 1\n            5 => 1\n         )\n    2 => array(\n            0 => 2\n            1 => 2\n            2 => 2\n            3 => 2\n            4 => 2\n            5 => 2\n         )\n    3 => array(\n            0 => 3\n            1 => 3\n            2 => 3\n            3 => 3\n            4 => 3\n            5 => 3\n         )\n)\n"
  },
  {
    "language": "PHP",
    "code": "$StartIndexAtOne = array(1 => \"A\", \"B\", \"C\", \"D\");\n"
  },
  {
    "language": "PHP",
    "code": "$CustomKeyArray = array(\"d\" => \"A\", \"c\" => \"B\", \"b\" =>\"C\", \"a\" =>\"D\");\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$a = 5\n#...input or change $a here\nassert($a == 42) # when $a is not 42, take appropriate actions,\n                 # which is set by assert_options()\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$array = array();\n$array = []; // Simpler form of array initialization\n$array['foo'] = 'bar';\n$array['bar'] = 'foo';\n\necho($array['foo']); // bar\necho($array['moo']); // Undefined index\n\n// Alternative (inline) way\n$array2 = array('fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green');\n\n// Another alternative (simpler) way\n$array2 = ['fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green'];\n\n// Check if key exists in the associative array\necho(isset($array['foo'])); // Faster, but returns false if the value of the element is set to null\necho(array_key_exists('foo', $array)); // Slower, but returns true if the value of the element is null\n"
  },
  {
    "language": "PHP",
    "code": "foreach($array as $key => $value)\n{\n   echo \"Key: $key Value: $value\";\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$pairs = array( \"hello\" => 1,\n\t\t\"world\" => 2,\n\t\t\"!\"     => 3 );\n\n// iterate over key-value pairs\nforeach($pairs as $k => $v) {\n  echo \"(k,v) = ($k, $v)\\n\";\n}\n\n// iterate over keys\nforeach(array_keys($pairs) as $key) {\n  echo \"key = $key, value = $pairs[$key]\\n\";\n}\n\n// iterate over values\nforeach($pairs as $value) {\n  echo \"values = $value\\n\";\n}\n?>\n"
  },
  {
    "language": "PHP",
    "code": "$nums = array(3, 1, 4, 1, 5, 9);\nif ($nums)\n    echo array_sum($nums) / count($nums), \"\\n\";\nelse\n    echo \"0\\n\";\n"
  },
  {
    "language": "Swift",
    "code": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* do the 100 passes */\nfor i in 1...100 {\n    /* map on a strideTo instance to only visit the needed doors on each iteration */\n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* set i^2 doors to opened */\nvar i = 1\ndo {\n    doorsStateList[(i*i)-1] = DoorState.Opened\n    ++i\n} while (i*i) <= doorsStateList.count\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits : \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n// check value of expression provided by the operator\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n\n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n\n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n\n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n\n\n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n\n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n\n        for oper in opr {\n          expression += oper\n        }\n\n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n// n=4, total=64, npow=16\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n\n  var solution = \"\"\n\n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n\n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits : \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n// check value of expression provided by the operator\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "var cache = [[1]]\nfunc namesOfGod(n:Int) -> [Int] {\n    for l in cache.count...n {\n        var r = [0]\n        for x in 1...l {\n            r.append(r[r.count - 1] + cache[l - x][min(x, l-x)])\n        }\n        cache.append(r)\n    }\n    return cache[n]\n}\n\nfunc row(n:Int) -> [Int] {\n    let r = namesOfGod(n)\n    var returnArray = [Int]()\n    for i in 0...n - 1 {\n        returnArray.append(r[i + 1] - r[i])\n    }\n    return returnArray\n}\n\nprintln(\"rows:\")\nfor x in 1...25 {\n    println(\"\\(x): \\(row(x))\")\n}\n\nprintln(\"\\nsums: \")\n\nfor x in [23, 123, 1234, 12345] {\n    cache = [[1]]\n    var array = namesOfGod(x)\n    var numInt = array[array.count - 1]\n    println(\"\\(x): \\(numInt)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet input = NSFileHandle.fileHandleWithStandardInput()\n\nlet data = input.availableData\nlet str = NSString(data: data, encoding: NSUTF8StringEncoding)!\n\nlet nums = str.componentsSeparatedByString(\" \")\nlet a = (nums[0] as String).toInt()!\nlet b = (nums[1] as String).toInt()!\n\nprint(\" \\(a + b)\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet input = FileHandle.standardInput\n\nlet data = input.availableData\nlet str = String(data: data, encoding: .utf8)!\nlet nums = str.split(separator: \" \")\n    .map { String($0.unicodeScalars\n        .filter { CharacterSet.decimalDigits.contains($0) }) }\n\nlet a = Int(nums[0])!\nlet b = Int(nums[1])!\n\nprint(\" \\(a + b)\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can ? \"can\" : \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Swift\n\nfunc canMake(word: String) -> Bool {\n\tvar blocks = [\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t]\n\t\n\tfor letter in word.uppercased().characters {\n\t\tguard let index = blocks.index(where: { $0.characters.contains(letter) }) else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tblocks.remove(at: index)\n\t}\n\t\n\treturn true\n}\n\nlet words = [\"a\", \"bARK\", \"boOK\", \"TreAt\", \"CoMmon\", \"SquAd\", \"CONFUse\"]\n\nwords.forEach { print($0, canMake(word: $0)) }\n"
  },
  {
    "language": "Swift",
    "code": "var deficients = 0 // sumPd < n\nvar perfects = 0 // sumPd = n\nvar abundants = 0 // sumPd > n\n\n// 1 is deficient (no proper divisor)\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 // 1 is a proper divisor of all integer above 1\n\n    var maxPdToTest = i/2 // the max divisor to test\n\n    for var j = 2; j < maxPdToTest; j++ {\n\n        if (i%j) == 0 {\n            // j is a proper divisor\n            sumPd += j\n\n            // New maximum for divisibility check\n            maxPdToTest = i / j\n\n            // To add to sum of proper divisors unless already done\n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n\n    // Select type according to sum of Proper divisors\n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n"
  },
  {
    "language": "Swift",
    "code": "func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n"
  },
  {
    "language": "Swift",
    "code": "func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "// For NSObject, NSTimeInterval and NSThread\nimport Foundation\n// For PI and sin\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n\n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n\n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n\n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n\n    func Output() -> Double {\n        return S\n    }\n\n}\n\n// main\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n\n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet fooKey = UnsafeMutablePointer<UInt8>.alloc(1)\n\nclass MyClass { }\nlet e = MyClass()\n\n// set\nobjc_setAssociatedObject(e, fooKey, 1, .OBJC_ASSOCIATION_RETAIN)\n\n// get\nif let associatedObject = objc_getAssociatedObject(e, fooKey) {\n  print(\"associated object: \\(associatedObject)\")\n} else {\n  print(\"no associated object\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "class MyClass { }\n\nfunc printAddress<T>(of pointer: UnsafePointer<T>) {\n    print(pointer)\n}\n\nfunc test() {\n    var x = 42\n    var y = 3.14\n    var z = \"foo\"\n    var obj = MyClass()\n\n    // Use a pointer to a variable on the stack and print its address.\n    withUnsafePointer(to: &x)   { print($0) }\n    withUnsafePointer(to: &y)   { print($0) }\n    withUnsafePointer(to: &z)   { print($0) }\n    withUnsafePointer(to: &obj) { print($0) }\n\n    // Alternately:\n    printAddress(of: &x)\n    printAddress(of: &y)\n    printAddress(of: &z)\n    printAddress(of: &obj)\n\n    // Printing the address of an object that an object reference points to.\n    print(Unmanaged.passUnretained(obj).toOpaque())\n}\n\ntest()\n"
  },
  {
    "language": "Swift",
    "code": "func polynomialCoeffs(n: Int) -> [Int] {\n    var result = [Int](count : n+1, repeatedValue : 0)\n\n    result[0]=1\n    for i in 1 ..< n/2+1 { //Progress up, until reaching the middle value\n        result[i] = result[i-1] * (n-i+1)/i;\n    }\n    for i in n/2+1 ..< n+1 { //Copy the inverse of the first part\n        result[i] = result[n-i];\n    }\n    // Take into account the sign\n    for i in stride(from: 1, through: n, by: 2) {\n        result[i] = -result[i]\n    }\n\n    return result\n}\n\nfunc isPrime(n: Int) -> Bool {\n\n    var coeffs = polynomialCoeffs(n)\n\n    coeffs[0]--\n    coeffs[n]++\n\n    for i in 1 ... n {\n        if coeffs[i]%n != 0 {\n            return false\n        }\n    }\n\n    return true\n}\n\nfor i in 0...10 {\n\n    let coeffs = polynomialCoeffs(i)\n\n    print(\"(x-1)^\\(i) = \")\n    if i == 0 {\n        print(\"1\")\n    } else {\n        if i == 1 {\n            print(\"x\")\n        } else {\n            print(\"x^\\(i)\")\n            if i == 2 {\n                print(\"\\(coeffs[i-1])x\")\n            } else {\n                for j in 1...(i - 2) {\n                    if j%2 == 0 {\n                        print(\"+\\(coeffs[j])x^\\(i-j)\")\n                    } else {\n                        print(\"\\(coeffs[j])x^\\(i-j)\")\n                    }\n                }\n                if (i-1)%2 == 0 {\n                    print(\"+\\(coeffs[i-1])x\")\n                } else {\n                    print(\"\\(coeffs[i-1])x\")\n                }\n            }\n        }\n        if i%2 == 0 {\n            print(\"+\\(coeffs[i])\")\n        } else {\n            print(\"\\(coeffs[i])\")\n        }\n    }\n    println()\n}\n\nprintln()\nprint(\"Primes under 50 : \")\n\nfor i in 1...50 {\n    if isPrime(i) {\n        print(\"\\(i) \")\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n\n    if n == 1 { return [] }\n\n    var result = [Int]()\n\n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n\n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n\n    return sorted(result)\n\n}\n\n\nfunc sumDivs(n:Int) -> Int {\n\n    struct Cache { static var sum = [Int:Int]() }\n\n    if let sum = Cache.sum[n] { return sum }\n\n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n\n    Cache.sum[n] = sum\n\n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n\n    if n == m { return false }\n\n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n\n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc sigma(n: Int) -> Int {\n\n    if n == 1 { return 0 }          // definition of aliquot sum\n\n    var result = 1\n    let root = sqrt(n)\n\n    for var div = 2; div <= root; ++div {\n        if n % div == 0 {\n            result += div + n/div\n        }\n\n    }\n    if root*root == n { result -= root }\n\n    return (result)\n}\n\nfunc amicables (upTo: Int) -> () {\n\n    var aliquot = Array(count: upTo+1, repeatedValue: 0)\n\n    for i in 1 ... upTo {           // fill lookup array\n        aliquot[i] = sigma(i)\n    }\n\n for i in 1 ... upTo {\n        let a = aliquot[i]\n        if a > upTo {continue}      //second part of pair out-of-bounds\n\n        if a == i {continue}        //skip perfect numbers\n\n        if i == aliquot[a] {\n            print(\"\\(i, a)\")\n            aliquot[a] = upTo+1     //prevent second display of pair\n        }\n    }\n}\n\namicables(20_000)\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nlet wordsURL = NSURL(string: \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")!\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords//[0..<100] // used to limit the size while testing\n\nextension String {\n    var charactersAscending : String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n\n    var knownwords = charsToWords[chars] ?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let fib: Int -> Int = {\n  func f(n: Int) -> Int {\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprint(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "let fib: Int -> Int = {\n  var f: (Int -> Int)!\n  f = { n in\n    assert(n >= 0, \"fib: no negative numbers\")\n    return n < 2 ? 1 : f(n-1) + f(n-2)\n  }\n  return f\n}()\n\nprintln(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nfunc fib(n: Int) -> Int {\n  assert(n >= 0, \"fib: no negative numbers\")\n  return y {f in {n in n < 2 ? 1 : f(n-1) + f(n-2)}} (n)\n}\n\nprintln(fib(8))\n"
  },
  {
    "language": "Swift",
    "code": "func square(n: Int) -> Int {\n    return n * n\n}\n\nlet numbers = [1, 3, 5, 7]\n\nlet squares1a = numbers.map(square)         // map method on array\n\nlet squares1b = numbers.map {x in x*x}      // map method on array with anonymous function\n\nlet squares1b = numbers.map { $0 * $0 }      // map method on array with anonymous function and unnamed parameters\n\nlet isquares1 = numbers.lazy.map(square)   // lazy sequence\n"
  },
  {
    "language": "Swift",
    "code": "public struct Complex {\n\n    public let real : Double\n    public let imaginary : Double\n\n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n\n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n\n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n\n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n\n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n\n}\npublic func + (left: Complex, right: Complex) -> Complex {\n\n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n\n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n// Checking equality is almost necessary for a struct of this type  to be useful\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n"
  },
  {
    "language": "Swift",
    "code": "extension Complex : CustomStringConvertible {\n\n    public var description : String {\n\n        guard real != 0 || imaginary != 0 else { return \"0\" }\n\n        let rs : String = real != 0 ? \"\\(real)\" : \"\"\n        let iS : String\n        let sign : String\n        let iSpace = real != 0 ? \" \" : \"\"\n        switch imaginary {\n        case let i where i < 0:\n            sign = \"-\"\n            iS = i == -1 ? \"i\" : \"\\(-i)i\"\n        case let i where i > 0:\n            sign = real != 0 ? \"+\" : \"\"\n            iS = i == 1 ? \"i\" : \"\\(i)i\"\n        default:\n            sign = \"\"\n            iS = \"\"\n        }\n        return \"\\(rs)\\(iSpace)\\(sign)\\(iSpace)\\(iS)\"\n    }\n}\n"
  },
  {
    "language": "Swift",
    "code": "public func - (left:Complex, right:Complex) -> Complex {\n    return left + -right\n}\n\npublic func / (divident:Complex, divisor:Complex) -> Complex {\n    let rc = divisor.conjugate\n    let num = divident * rc\n    let den = divisor * rc\n    return Complex(real: num.real/den.real, imaginary: num.imaginary/den.real)\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "let a = 6\nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func gcd(with other: Self) -> Self {\n    var gcd = self\n    var b = other\n\n    while b != 0 {\n      (gcd, b) = (b, gcd % b)\n    }\n\n    return gcd\n  }\n\n  @inlinable\n  public func lcm(with other: Self) -> Self {\n    let g = gcd(with: other)\n\n    return self / g * other\n  }\n}\n\npublic struct Frac<NumType: BinaryInteger & SignedNumeric>: Equatable {\n  @usableFromInline\n  var _num: NumType\n\n  @usableFromInline\n  var _dom: NumType\n\n  @usableFromInline\n  init(_num: NumType, _dom: NumType) {\n    self._num = _num\n    self._dom = _dom\n  }\n\n  @inlinable\n  public init(numerator: NumType, denominator: NumType) {\n    let divisor = numerator.gcd(with: denominator)\n\n    self._num = numerator / divisor\n    self._dom = denominator / divisor\n  }\n\n  @inlinable\n  public static func + (lhs: Frac, rhs: Frac) -> Frac {\n    let multiplier = lhs._dom.lcm(with: rhs.denominator)\n\n    return Frac(\n      numerator: lhs._num * multiplier / lhs._dom + rhs._num * multiplier / rhs._dom,\n      denominator: multiplier\n    )\n  }\n\n  @inlinable\n  public static func += (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + rhs\n  }\n\n  @inlinable\n  public static func - (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs + -rhs\n  }\n\n  @inlinable\n  public static func -= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs + -rhs\n  }\n\n  @inlinable\n  public static func * (lhs: Frac, rhs: Frac) -> Frac {\n    return Frac(numerator: lhs._num * rhs._num, denominator: lhs._dom * rhs._dom)\n  }\n\n  @inlinable\n  public static func *= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs * rhs\n  }\n\n  @inlinable\n  public static func / (lhs: Frac, rhs: Frac) -> Frac {\n    return lhs * Frac(_num: rhs._dom, _dom: rhs._num)\n  }\n\n  @inlinable\n  public static func /= (lhs: inout Frac, rhs: Frac) {\n    lhs = lhs / rhs\n  }\n\n  @inlinable\n  prefix static func - (rhs: Frac) -> Frac {\n    return Frac(_num: -rhs._num, _dom: rhs._dom)\n  }\n}\n\nextension Frac {\n  @inlinable\n  public var numerator: NumType {\n    get { _num }\n    set {\n      let divisor = newValue.gcd(with: denominator)\n\n      _num = newValue / divisor\n      _dom = denominator / divisor\n    }\n  }\n\n  @inlinable\n  public var denominator: NumType {\n    get { _dom }\n    set {\n      let divisor = newValue.gcd(with: numerator)\n\n      _num = numerator / divisor\n      _dom = newValue / divisor\n    }\n  }\n}\n\nextension Frac: CustomStringConvertible {\n  public var description: String {\n    let neg = numerator < 0 || denominator < 0\n\n    return \"Frac(\\(neg ? \"-\" : \"\")\\(abs(numerator)) / \\(abs(denominator)))\"\n  }\n}\n\nextension Frac: Comparable {\n  @inlinable\n  public static func <(lhs: Frac, rhs: Frac) -> Bool {\n    return lhs._num * rhs._dom < lhs._dom * rhs._num\n  }\n}\n\nextension Frac: ExpressibleByIntegerLiteral {\n  public init(integerLiteral value: Int) {\n    self._num = NumType(value)\n    self._dom = 1\n  }\n}\n\n\nfor candidate in 2..<1<<19 {\n  var sum = Frac(numerator: 1, denominator: candidate)\n\n  let m = Int(ceil(Double(candidate).squareRoot()))\n\n  for factor in 2..<m where candidate % factor == 0 {\n    sum += Frac(numerator: 1, denominator: factor)\n    sum += Frac(numerator: 1, denominator: candidate / factor)\n  }\n\n  if sum == 1 {\n    print(\"\\(candidate) is perfect\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n"
  },
  {
    "language": "Swift",
    "code": "// Arrays are typed in Swift, however, using the Any object we can add any type. Swift does not support fixed length arrays\nvar anyArray = [Any]()\nanyArray.append(\"foo\") // Adding to an Array\nanyArray.append(1) // [\"foo\", 1]\nanyArray.removeAtIndex(1) // Remove object\nanyArray[0] = \"bar\" // [\"bar\"]\n"
  },
  {
    "language": "Swift",
    "code": "var a = 5\n//...input or change a here\nassert(a == 42) // aborts program when a is not 42\nassert(a == 42, \"Error message\") // aborts program\n       // when a is not 42 with \"Error message\" for the message\n       // the error message must be a static string\n"
  },
  {
    "language": "Swift",
    "code": "// make an empty map\nvar a = [String: Int]()\n// or\nvar b: [String: Int] = [:]\n\n// make an empty map with an initial capacity\nvar c = [String: Int](minimumCapacity: 42)\n\n// set a value\nc[\"foo\"] = 3\n\n// make a map with a literal\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n"
  },
  {
    "language": "Swift",
    "code": "let myMap = [\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 ]\n\n// iterating over key-value pairs:\nfor (key, value) in myMap {\n    println(\"key = \\(key), value = \\(value)\")\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfinal class AtomicBuckets: CustomStringConvertible {\n  var count: Int {\n    return buckets.count\n  }\n\n  var description: String {\n    return withBucketsLocked { \"\\(buckets)\" }\n  }\n\n  var total: Int {\n    return withBucketsLocked { buckets.reduce(0, +) }\n  }\n\n  private let lock = DispatchSemaphore(value: 1)\n\n  private var buckets: [Int]\n\n  subscript(n: Int) -> Int {\n    return withBucketsLocked { buckets[n] }\n  }\n\n  init(with buckets: [Int]) {\n    self.buckets = buckets\n  }\n\n  func transfer(amount: Int, from: Int, to: Int) {\n    withBucketsLocked {\n      let transferAmount = buckets[from] >= amount ? amount : buckets[from]\n\n      buckets[from] -= transferAmount\n      buckets[to] += transferAmount\n    }\n  }\n\n  private func withBucketsLocked<T>(do: () -> T) -> T {\n    let ret: T\n\n    lock.wait()\n    ret = `do`()\n    lock.signal()\n\n    return ret\n  }\n}\n\nlet bucks = AtomicBuckets(with: [21, 39, 40, 20])\nlet order = DispatchSource.makeTimerSource()\nlet chaos = DispatchSource.makeTimerSource()\nlet printer = DispatchSource.makeTimerSource()\n\nprinter.setEventHandler {\n  print(\"\\(bucks) = \\(bucks.total)\")\n}\n\nprinter.schedule(deadline: .now(), repeating: .seconds(1))\nprinter.activate()\n\norder.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n  let (v1, v2) = (bucks[b1], bucks[b2])\n\n  guard v1 != v2 else {\n    return\n  }\n\n  if v1 > v2 {\n    bucks.transfer(amount: (v1 - v2) / 2, from: b1, to: b2)\n  } else {\n    bucks.transfer(amount: (v2 - v1) / 2, from: b2, to: b1)\n  }\n}\n\norder.schedule(deadline: .now(), repeating: .milliseconds(5))\norder.activate()\n\nchaos.setEventHandler {\n  let (b1, b2) = (Int.random(in: 0..<bucks.count), Int.random(in: 0..<bucks.count))\n\n  bucks.transfer(amount: Int.random(in: 0..<(bucks[b1] + 1)), from: b1, to: b2)\n}\n\nchaos.schedule(deadline: .now(), repeating: .milliseconds(5))\nchaos.activate()\n\ndispatchMain()\n"
  },
  {
    "language": "Swift",
    "code": "func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n"
  },
  {
    "language": "Swift",
    "code": "// Extend the Collection protocol. Any type that conforms to extension where its Element type conforms to Hashable will automatically gain this method.\nextension Collection where Element: Hashable {\n\n    /// Return a Mode of the function, or nil if none exist.\n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        // Standard for loop. Can also use the forEach(_:) or reduce(into:) methods on self.\n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        // The max(by:) method used here to find one of the elements with the highest associated count.\n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() // returns \"a\"\n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() // returns 3\n\nlet emptyArray: [Int] = []\nemptyArray.mode() // returns nil\n"
  },
  {
    "language": "Swift",
    "code": "extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n"
  },
  {
    "language": "Swift",
    "code": "struct SimpleMovingAverage {\n  var period: Int\n  var numbers = [Double]()\n\n  mutating func addNumber(_ n: Double) -> Double {\n    numbers.append(n)\n\n    if numbers.count > period {\n      numbers.removeFirst()\n    }\n\n    guard !numbers.isEmpty else {\n      return 0\n    }\n\n    return numbers.reduce(0, +) / Double(numbers.count)\n  }\n}\n\nfor period in [3, 5] {\n  print(\"Moving average with period \\(period)\")\n\n  var averager = SimpleMovingAverage(period: period)\n\n  for n in [1.0, 2, 3, 4, 5, 5, 4, 3, 2, 1] {\n    print(\"n: \\(n); average \\(averager.addNumber(n))\")\n  }\n}\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\nfunc isBal(str: String) -> Bool {\n\n  var count = 0\n\n  return !str.characters.contains { ($0 == \"[\"  ? ++count : --count) < 0 } && count == 0\n\n}\n"
  },
  {
    "language": "Swift",
    "code": "isBal(\"[[[]]]\") // true\n\nisBal(\"[]][[]\") // false\n"
  },
  {
    "language": "Swift",
    "code": "func randBrack(n: Int) -> String {\n\n  var bracks: [Character] = Array(Repeat(count: n, repeatedValue: \"[\"))\n\n  for i in UInt32(n+1)...UInt32(n + n) {\n\n    bracks.insert(\"]\", atIndex: Int(arc4random_uniform(i)))\n\n  }\n\n  return String(bracks)\n\n}\n"
  },
  {
    "language": "Swift",
    "code": "randBrack(2) // \"]][[\"\n"
  },
  {
    "language": "Swift",
    "code": "func randIsBal(n: Int) {\n\n  let (bal, un) = (\"\", \"un\")\n\n  for str in (1...n).map(randBrack) {\n\n    print(\"\\(str) is \\(isBal(str) ? bal : un)balanced\\n\")\n\n  }\n}\n\nrandIsBal(4)\n"
  },
  {
    "language": "Swift",
    "code": "//    ][ is unbalanced\n//\n//    ]][[ is unbalanced\n//\n//    []][[] is unbalanced\n//\n//    [][][[]] is balanced\n"
  },
  {
    "language": "Swift",
    "code": "import Foundation\n\n/* Reads from a file and returns the content as a String */\nfunc readFromFile(fileName file:String) -> String{\n\n    var ret:String = \"\"\n\n    let path = Foundation.URL(string: \"file://\"+file)\n\n    do {\n        ret = try String(contentsOf: path!, encoding: String.Encoding.utf8)\n    }\n    catch {\n        print(\"Could not read from file!\")\n        exit(-1)\n    }\n\n    return ret\n}\n\n/* Calculates the probability following Benford's law */\nfunc benford(digit z:Int) -> Double {\n\n    if z<=0 || z>9 {\n        perror(\"Argument must be between 1 and 9.\")\n        return 0\n    }\n\n    return log10(Double(1)+Double(1)/Double(z))\n}\n\n// get CLI input\nif CommandLine.arguments.count < 2 {\n    print(\"Usage: Benford [FILE]\")\n    exit(-1)\n}\n\nlet pathToFile = CommandLine.arguments[1]\n\n// Read from given file and parse into lines\nlet content = readFromFile(fileName: pathToFile)\nlet lines = content.components(separatedBy: \"\\n\")\n\nvar digitCount:UInt64 = 0\nvar countDigit:[UInt64] = [0,0,0,0,0,0,0,0,0]\n\n// check digits line by line\nfor line in lines {\n    if line == \"\" {\n        continue\n    }\n    let charLine = Array(line.characters)\n        switch(charLine[0]){\n            case \"1\":\n                countDigit[0] += 1\n                digitCount += 1\n                break\n            case \"2\":\n                countDigit[1] += 1\n                digitCount += 1\n                break\n            case \"3\":\n                countDigit[2] += 1\n                digitCount += 1\n                break\n            case \"4\":\n                countDigit[3] += 1\n                digitCount += 1\n                break\n            case \"5\":\n                countDigit[4] += 1\n                digitCount += 1\n                break\n            case \"6\":\n                countDigit[5] += 1\n                digitCount += 1\n                break\n            case \"7\":\n                countDigit[6] += 1\n                digitCount += 1\n                break\n            case \"8\":\n                countDigit[7] += 1\n                digitCount += 1\n                break\n            case \"9\":\n                countDigit[8] += 1\n                digitCount += 1\n                break\n            default:\n                break\n        }\n\n}\n\n// print result\nprint(\"Digit\\tBenford [%]\\tObserved [%]\\tDeviation\")\nprint(\"~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~~~~\\t~~~~~~~~~\")\nfor i in 0..<9 {\n    let temp:Double = Double(countDigit[i])/Double(digitCount)\n    let ben = benford(digit: i+1)\n    print(String(format: \"%d\\t%.2f\\t\\t%.2f\\t\\t%.4f\", i+1,ben*100,temp*100,ben-temp))\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#! /bin/bash\n\ndeclare -a doors\nfor((i=1; i <= 100; i++)); do\n    doors[$i]=0\ndone\n\nfor((i=1; i <= 100; i++)); do\n    for((j=i; j <= 100; j += i)); do\n\techo $i $j\n\tdoors[$j]=$(( doors[j] ^ 1 ))\n    done\ndone\n\nfor((i=1; i <= 100; i++)); do\n    if [[ ${doors[$i]} -eq 0 ]]; then\n\top=\"closed\"\n    else\n\top=\"open\"\n    fi\n    echo $i $op\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nfor i in {1..100}; do\n  door[$i*$i]=1\n  [ -z ${door[$i]} ] && echo \"$i closed\" || echo \"$i open\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "gen_digits() {\n    awk 'BEGIN { srand()\n                 for(i = 1; i <= 4; i++) print 1 + int(9 * rand())\n         }' | sort\n}\n\nsame_digits() {\n    [ \"$(tr -dc 0-9 | sed 's/./&\\n/g' | grep . | sort)\" = \"$*\" ]\n}\n\nguessed() {\n    [ \"$(echo \"$1\" | tr -dc '\\n0-9()*/+-' | bc 2>/dev/null)\" = 24 ]\n}\n\n\nwhile :\ndo\n    digits=$(gen_digits)\n    echo\n    echo Digits: $digits\n    read -r expr\n\n    echo \" $expr\" | same_digits \"$digits\" || \\\n        { echo digits should be: $digits; continue; }\n\n    guessed \"$expr\" && message=correct \\\n                    || message=wrong\n\n    echo $message\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a b || exit\necho `expr \"$a\" + \"$b\"`\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\nread a b || exit\necho $(( a + b ))\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "echo 2 3 | ksh a+b.sh\n5\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "set line=$<\nset input=($line)\n@ sum = $input[1] + $input[2]\necho $sum\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "can_build_word() {\n    if [[ $1 ]]; then\n        can_build_word_rec \"$1\" BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\n    else\n        return 1\n    fi\n}\n\ncan_build_word_rec() {\n    [[ -z $1 ]] && return 0\n\n    local -u word=$1       # uppercase the first parameter\n    shift\n    local blocks=(\"$@\")\n\n    # see if we have a block for the first letter\n    local letter=${word:0:1} indices=() i\n    for (( i=0; i<${#blocks[@]}; i++ )); do\n        if [[ ${blocks[i]} == *$letter* ]]; then\n            indices+=($i)\n        fi\n    done\n    (( ${#indices[@]} == 0 )) && return 1\n\n    local tmp\n    for i in ${indices[@]}; do\n        tmp=( \"${blocks[@]}\" )\n        unset \"tmp[$i]\"\n        can_build_word_rec \"${word:1}\" \"${tmp[@]}\" && return 0\n    done\n\n    return 1\n}\n\nwords=( \"\" A BARK Book treat COMMON Squad confuse )\nfor word in \"${words[@]}\"; do\n    can_build_word \"$word\" \"${blocks[@]}\" && ans=yes || ans=no\n    printf \"%s\\t%s\\n\" \"$word\" $ans\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\naccumulator() {\n\t# Define a global function named $1\n\t# with a global variable named ${1}_sum.\n\teval \"${1}_sum=\\$2\"\n\teval \"$1() {\n\t\t${1}_sum=\\$(echo \\\"(\\$${1}_sum) + (\\$2)\\\" | bc)\n\t\teval \\\"\\$1=\\\\\\$${1}_sum\\\"  # Provide the current sum.\n\t}\"\n}\n\naccumulator x 1\nx r 5\naccumulator y 3\nx r 2.3\necho $r\ny r -3000\necho $r\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "fn accumulator n {\n\tresult @ i {\n\t\tn = `{echo $n + $i | bc}\n\t\tresult $n\n\t}\n}\n\nfn-x = <={accumulator 1}\nx 5\nfn-y = <={accumulator 3}\necho <={x 2.3}\necho <={y -3000}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "ack() {\n  local m=$1\n  local n=$2\n  if [ $m -eq 0 ]; then\n    echo -n $((n+1))\n  elif [ $n -eq 0 ]; then\n    ack $((m-1)) 1\n  else\n    ack $((m-1)) $(ack $m $((n-1)))\n  fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "for ((m=0;m<=3;m++)); do\n  for ((n=0;n<=6;n++)); do\n    ack $m $n\n    echo -n \" \"\n  done\n  echo\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\n\nLDAP_HOST=\"localhost\"\nLDAP_PORT=11389\nLDAP_DN_STR=\"uid=admin,ou=system\"\nLDAP_CREDS=\"********\"\nLDAP_BASE_DN=\"ou=users,o=mojo\"\nLDAP_SCOPE=\"sub\"\nLDAP_FILTER=\"(&(objectClass=person)(&(uid=*mil*)))\"\nLDAP_ATTRIBUTES=\"dn cn sn uid\"\n\nldapsearch \\\n  -s base \\\n  -h $LDAP_HOST \\\n  -p $LDAP_PORT \\\n  -LLL \\\n  -x \\\n  -v \\\n  -s $LDAP_SCOPE \\\n  -D $LDAP_DN_STR \\\n  -w $LDAP_CREDS \\\n  -b $LDAP_BASE_DN \\\n  $LDAP_FILTER \\\n  $LDAP_ATTRIBUTES\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "cat <<EOF_OUTER > just-nocenter.sh\n#!/bin/sh\n\ntd() {\ncat <<'EOF'\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEOF\n}\n\nrows=$( td | wc -l )\n\n# get the number of fields\nfields=$(td | rs -c'$' -g1 -h | awk '{print $2}')\n\n# get the max of the value widths\ncwidth=$(td | rs -c'$' -g1 -w1 2>/dev/null | awk 'BEGIN{w=0}{if(length>w){w=length}}END{print w}')\n\n# compute the minimum line width for the columns\nlwidth=$(( (1 + cwidth) * fields ))\n\n# left adjusted columns\ntd | rs -c'$' -g1 -zn -w$lwidth\n\necho \"\"\n\n# right adjusted columns\ntd | rs -c'$' -g1 -znj -w$lwidth\n\necho \"\"\n\nexit\nEOF_OUTER\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "$ ./just-nocenter.sh\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "function get_words {\n    typeset host=www.puzzlers.org\n    typeset page=/pub/wordlists/unixdict.txt\n    exec 7<>/dev/tcp/$host/80\n    print -e -u7 \"GET $page HTTP/1.1\\r\\nhost: $host\\r\\nConnection: close\\r\\n\\r\\n\"\n    # remove the http header and save the word list\n    sed 's/\\r$//; 1,/^$/d' <&7 >\"$1\"\n    exec 7<&-\n}\n\nfunction is_deranged {\n    typeset -i i\n    for ((i=0; i<${#1}; i++)); do\n        [[ ${1:i:1} == ${2:i:1} ]] && return 1\n    done\n    return 0\n}\n\nfunction word2key {\n    typeset -a chars=( $(\n        for ((i=0; i<${#word}; i++)); do\n            echo \"${word:i:1}\"\n        done | sort\n    ) )\n    typeset IFS=\"\"\n    echo \"${chars[*]}\"\n}\n\n[[ -f word.list ]] || get_words word.list\n\ntypeset -A words\ntypeset -i max=0\n\nwhile IFS= read -r word; do\n    key=$(word2key $word)\n    if [[ -z \"${words[\"$key\"]}\" ]]; then\n        words[\"$key\"]=$word\n    else\n        if (( ${#word} > max )); then\n            if is_deranged \"${words[\"$key\"]}\" \"$word\"; then\n                max_deranged=(\"${words[\"$key\"]}\" \"$word\")\n                max=${#word}\n            fi\n        fi\n    fi\ndone <word.list\necho $max - ${max_deranged[@]}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "http_get_body() {\n    local host=$1\n    local uri=$2\n    exec 5<> /dev/tcp/$host/80\n    printf >&5 \"%s\\r\\n\" \"GET $uri HTTP/1.1\" \"Host: $host\" \"Connection: close\" \"\"\n    mapfile -t -u5\n    local lines=( \"${MAPFILE[@]//$'\\r'}\" )\n    local i=0 found=0\n    for (( ; found == 0; i++ )); do\n        [[ -z ${lines[i]} ]] && (( found++ ))\n    done\n    printf \"%s\\n\" \"${lines[@]:i}\"\n    exec 5>&-\n}\n\ndeclare -A wordlist\n\nwhile read -r word; do\n    uniq_letters=( $(for ((i=0; i<${#word}; i++)); do echo \"${word:i:1}\"; done | sort) )\n    wordlist[\"${uniq_letters[*]}\"]+=\"$word \"\ndone < <( http_get_body wiki.puzzlers.org  /pub/wordlists/unixdict.txt )\n\nmaxlen=0\nmaxwords=()\n\nfor key in \"${!wordlist[@]}\"; do\n    words=( ${wordlist[$key]} )\n    if (( ${#words[@]} > maxlen )); then\n        maxlen=${#words[@]}\n        maxwords=( \"${wordlist[\"$key\"]}\" )\n    elif (( ${#words[@]} == maxlen )); then\n        maxwords+=( \"${wordlist[$key]}\" )\n    fi\ndone\n\nprintf \"%s\\n\" \"${maxwords[@]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "fib() {\n  if test 0 -gt \"$1\"; then\n    echo \"fib: fib of negative\" 1>&2\n    return 1\n  else\n    (\n      fib2() {\n        if test 2 -gt \"$1\"; then\n          echo \"$1\"\n        else\n          echo $(( $(fib2 $(($1 - 1)) ) + $(fib2 $(($1 - 2)) ) ))\n        fi\n      }\n      fib2 \"$1\"\n    )\n  fi\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "$ for i in -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12; do\n>   fib $i\n> done\nfib: fib of negative\nfib: fib of negative\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "rec1=(\n    jsmith\n    x\n    1001\n    1000\n    \"Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org\"\n    /home/jsmith\n    /bin/bash\n)\n\nrec2=(\n    jdoe\n    x\n    1002\n    1000\n    \"Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org\"\n    /home/jdoe\n    /bin/bash\n)\n\nrec3=(\n    xyz\n    x\n    1003\n    1000\n    \"X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org\"\n    /home/xyz\n    /bin/bash\n)\n\nfilename=./passwd-ish\n\n# use parentheses to run the commands in a subshell, so the\n# current shell's IFS variable is not changed\n(\n    IFS=:\n    echo \"${rec1[*]}\"\n    echo \"${rec2[*]}\"\n) > \"$filename\"\n\necho before appending:\ncat \"$filename\"\n\n# appending, use the \">>\" redirection symbol\nIFS=:\necho \"${rec3[*]}\" >> \"$filename\"\n\necho after appending:\ncat \"$filename\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map() {\n\tmap_command=$1\n\tshift\n\tfor i do \"$map_command\" \"$i\"; done\n}\nlist=1:2:3\n(IFS=:; map echo $list)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map() {\n\ttypeset command=$1\n\tshift\n\tfor i do \"$command\" \"$i\"; done\n}\nset -A ary 1 2 3\nmap print \"${ary[@]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "map(){for i ($*[2,-1]) $1 $i}\na=(1 2 3)\nmap print $a\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -T Complex_t=(\n    float real=0\n    float imag=0\n\n    function to_s {\n        print -- \"${_.real} + ${_.imag} i\"\n    }\n\n    function dup {\n        nameref other=$1\n        _=( real=${other.real} imag=${other.imag} )\n    }\n\n    function add {\n        typeset varname\n        for varname; do\n            nameref other=$varname\n            (( _.real += other.real ))\n            (( _.imag += other.imag ))\n        done\n    }\n\n    function negate {\n        (( _.real *= -1 ))\n        (( _.imag *= -1 ))\n    }\n\n    function conjugate {\n        (( _.imag *= -1 ))\n    }\n\n    function multiply {\n        typeset varname\n        for varname; do\n            nameref other=$varname\n            float a=${_.real} b=${_.imag} c=${other.real} d=${other.imag}\n            (( _.real = a*c - b*d ))\n            (( _.imag = b*c + a*d ))\n        done\n    }\n\n    function inverse {\n        if (( _.real == 0 && _.imag == 0 )); then\n            print -u2 \"division by zero\"\n            return 1\n        fi\n        float denom=$(( _.real*_.real + _.imag*_.imag ))\n        (( _.real = _.real / denom ))\n        (( _.imag = -1 * _.imag / denom ))\n    }\n)\n\nComplex_t a=(real=1 imag=1)\na.to_s        # 1 + 1 i\n\nComplex_t b=(real=3.14159 imag=1.2)\nb.to_s        # 3.14159 + 1.2 i\n\nComplex_t c\nc.add a b\nc.to_s        # 4.14159 + 2.2 i\n\nc.negate\nc.to_s        # -4.14159 + -2.2 i\n\nc.conjugate\nc.to_s        # -4.14159 + 2.2 i\n\nc.dup a\nc.multiply b\nc.to_s        # 1.94159 + 4.34159 i\n\nComplex_t d=(real=2 imag=1)\nd.inverse\nd.to_s        # 0.4 + -0.2 i\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "function agm {\n    float a=$1 g=$2 eps=${3:-1e-11} tmp\n    while (( abs(a-g) > eps )); do\n        print \"debug: a=$a\\tg=$g\"\n        tmp=$(( (a+g)/2.0 ))\n        g=$(( sqrt(a*g) ))\n        a=$tmp\n    done\n    echo $a\n}\n\nagm $((1/sqrt(2))) 1\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "while (( abs(a-g) > eps ))\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "while [[ $a != $g ]]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a; read b;\necho \"a+b     = \"  `expr $a  +  $b`\necho \"a-b     = \"  `expr $a  -  $b`\necho \"a*b     = \"  `expr $a \\*  $b`\necho \"a/b     = \"  `expr $a  /  $b` # truncates towards 0\necho \"a mod b = \"  `expr $a  %  $b` # same sign as first operand\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/sh\nread a; read b;\necho \"a+b     = $((a+b))\"\necho \"a-b     = $((a-b))\"\necho \"a*b     = $((a*b))\"\necho \"a/b     = $((a/b))\" # truncates towards 0\necho \"a mod b = $((a%b))\" # same sign as first operand\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "array1=( 1 2 3 4 5 )\narray2=( 6 7 8 9 10 )\nbotharrays=( ${array1[@]} ${array2[@]} )\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "array1='1 2 3 4 5'\narray2='6 7 8 9 10'\n\n# Concatenated to a Bash array ...\nbotharrays_a=( $array1 $array2 )\n\n# Concatenated to a string ...\nbotharrays_s=\"$array1 $array2\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "alist=( item1 item2 item3 )  # creates a 3 item array called \"alist\"\ndeclare -a list2        # declare an empty list called \"list2\"\ndeclare -a list3[0]     # empty list called \"list3\"; the subscript is ignored\n\n# create a 4 item list, with a specific order\nlist5=([3]=apple [2]=cherry [1]=banana [0]=strawberry)\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "count=${#alist[*]}\necho \"The number of items in alist is ${#alist[*]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "x=0\nwhile [[ $x < ${#alist[*]} ]]; do\n  echo \"Item $x = ${alist[$x]}\"\n  : $((x++))\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "x=${#alist[*]}       # start with the number of items in the array\nwhile [[ $x > 0 ]]; do     # while there are items left\n  : $((x--))               # decrement first, because indexing is zero-based\n  echo \"Item $x = ${alist[$x]}\"   # show the current item\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "alist[${#alist[*]}]=new_item\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# shell function to append values to an array\n# push LIST VALUES ...\npush() {\n  local var=${1:?'Missing variable name!'}\n  shift\n  eval \"\\$$var=( \\\"\\${$var[@]}\\\" \\\"$@\\\" )\"\n}\n\npush alist \"one thing to add\"\npush alist many words to add\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist[0]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "# pop ARRAY -- pop the last item on ARRAY and output it\n\npop() {\n  local var=${1:?'Missing array name'}\n  local x ;   eval \"x=\\${#$var[*]}\"\n  if [[ $x > 0 ]]; then\n    local val ; eval \"val=\\\"\\${$var[$((--x))]}\\\"\"\n    unset $var[$x]\n  else\n    echo 1>&2 \"No items in $var\" ; exit 1\n  fi\n  echo \"$val\"\n}\n\nalist=(a b c)\npop alist\na\npop alist\nb\npop alist\nc\npop alist\nNo items in alist\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "unset alist[*]\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "assert() {\n    if test ! $1; then\n        [[ $2 ]] && echo \"$2\" >&2\n        exit 1\n    fi\n}\nx=42\nassert \"$x -eq 42\" \"that's not the answer\"\n((x--))\nassert \"$x -eq 42\" \"that's not the answer\"\necho \"won't get here\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A hash\nhash=( [key1]=val1 [key2]=val2 )\nhash[key3]=val3\necho \"${hash[key3]}\"\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "declare -A hash\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A a=([key1]=value1 [key2]=value2)\n\n# just keys\nprintf '%s\\n' \"${!a[@]}\"\n\n# just values\nprintf '%s\\n' \"${a[@]}\"\n\n# keys and values\nfor key in \"${!a[@]}\"; do\n\tprintf '%s => %s\\n' \"$key\" \"${a[$key]}\"\ndone\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "typeset -A a\na=(key1 value1 key2 value2)\n\n# just keys\nprint -l -- ${(k)a}\n\n# just values\nprint -l -- ${(v)a}\n\n# keys and values\nprintf '%s => %s\\n' ${(kv)a}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "mean() {\n\tif expr $# >/dev/null; then\n\t\t(count=0\n\t\t sum=0\n\t\t while expr $# \\> 0 >/dev/null; do\n\t\t\tsum=`expr $sum + \"$1\"`\n\t\t\tresult=$?\n\t\t\texpr $result \\> 1 >/dev/null && exit $result\n\n\t\t\tcount=`expr $count + 1`\n\t\t\tshift\n\t\t done\n\t\t expr $sum / $count)\n\telse\n\t\techo 0\n\tfi\n}\n\nprintf \"test 1: \"; mean\t\t\t\t# 0\nprintf \"test 2: \"; mean 300\t\t\t# 300\nprintf \"test 3: \"; mean 300 100 400\t\t# 266\nprintf \"test 4: \"; mean -400 400 -1300 200\t# -275\nprintf \"test 5: \"; mean -\t\t\t# expr: syntax error\nprintf \"test 6: \"; mean 1 2 A 3\t\t\t# expr: non-numeric argument\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "#!/bin/bash\n\nfunction mode {\n    declare -A map\n    max=0\n    for x in \"$@\"; do\n\ttmp=$((${map[$x]} + 1))\n\tmap[$x]=$tmp\n\t((tmp > max)) && max=$tmp\n    done\n    for x in \"${!map[@]}\"; do\n\t[[ ${map[$x]} == $max ]] && echo -n \"$x \"\n    done\n    echo\n}\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "mode 1 2 1 2 a b a b a 2\na 2\n"
  },
  {
    "language": "UNIX-Shell",
    "code": "generate() {\n    local b=()\n    local i j tmp\n    for ((i=1; i<=$1; i++)); do\n        b+=( '[' ']')\n    done\n    for ((i=${#b[@]}-1; i>0; i--)); do\n        j=$(rand $i)\n        tmp=${b[j]}\n        b[j]=${b[i]}\n        b[i]=$tmp\n    done\n    local IFS=\n    echo \"${b[*]}\"\n}\n\n# a random number in the range [0,n)\nrand() {\n    echo $(( $RANDOM % $1 ))\n}\n\nbalanced() {\n    local -i lvl=0\n    local i\n    for ((i=0; i<${#1}; i++)); do\n        case ${1:i:1} in\n            '[') ((lvl++));;\n            ']') (( --lvl < 0 )) && return 1;;\n        esac\n    done\n    (( lvl == 0 )); return $?\n}\n\nfor ((i=0; i<=10; i++)); do\n    test=$(generate $i)\n    balanced \"$test\" && result=OK || result=\"NOT OK\"\n    printf \"%s\\t%s\\n\" \"$test\" \"$result\"\ndone\n"
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. HelloWorld. PROCEDURE DIVISION. DISPLAY \"Hello, world!\"."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. AddNumbers. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num1 PIC 9(3) VALUE 123. 01 Num2 PIC 9(3) VALUE 456. 01 Result PIC 9(4). PROCEDURE DIVISION. COMPUTE Result = Num1 + Num2. DISPLAY \"Sum is: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. Factorial. DATA DIVISION. WORKING-STORAGE SECTION. 01 Number PIC 9(2) VALUE 5. 01 Result PIC 9(4). PROCEDURE DIVISION. COMPUTE Result = 1. PERFORM VARYING Number FROM 1 BY 1 UNTIL Number > 5 MULTIPLY Result BY Number. END-PERFORM. DISPLAY \"Factorial of 5 is: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. Fibonacci. DATA DIVISION. WORKING-STORAGE SECTION. 01 n PIC 9(2) VALUE 10. 01 a PIC 9(5) VALUE 0. 01 b PIC 9(5) VALUE 1. 01 c PIC 9(5). PROCEDURE DIVISION. DISPLAY a DISPLAY b PERFORM VARYING n FROM 1 BY 1 UNTIL n > 10   COMPUTE c = a + b   DISPLAY c   COMPUTE a = b   COMPUTE b = c END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram1.\nPROCEDURE DIVISION.\n    DISPLAY 'Hello, world!'.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram2.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 + Num2.\n    DISPLAY 'Sum is ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram3.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Customer-Record.\n    05 Cust-Name PIC X(30).\n    05 Cust-Age PIC 99.\n    05 Cust-Balance PIC 9(6)V99 VALUE 100.50.\nPROCEDURE DIVISION.\n    DISPLAY 'Customer Details: ', Cust-Name, Cust-Age, Cust-Balance.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram4.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Counter PIC 9(2) VALUE 1.\nPROCEDURE DIVISION.\n    PERFORM VARYING Counter FROM 1 BY 1 UNTIL Counter > 10\n        DISPLAY 'Counter is ', Counter\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram12.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Array-Data.\n    05 Array OCCURS 5 TIMES PIC X(5).\nPROCEDURE DIVISION.\n    MOVE 'COBOL' TO Array(1).\n    MOVE 'Fortran' TO Array(2).\n    MOVE 'Java' TO Array(3).\n    MOVE 'Python' TO Array(4).\n    MOVE 'C++' TO Array(5).\n    PERFORM VARYING Array FROM 1 BY 1 UNTIL Array > 5\n        DISPLAY 'Programming Language: ', Array(Array)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram13.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Result PIC 9(5).\nPROCEDURE DIVISION.\n    MOVE 123 TO Result.\n    IF Result > 100\n        DISPLAY 'Result is greater than 100'\n    ELSE\n        DISPLAY 'Result is less than or equal to 100'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram14.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Length PIC 9(2) VALUE 10.\n01 InputStr PIC X(10) VALUE 'Hello'.\n01 OutputStr PIC X(10).\nPROCEDURE DIVISION.\n    MOVE InputStr TO OutputStr(1:Length).\n    DISPLAY 'Output: ', OutputStr\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram15.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 * Num2.\n    DISPLAY 'Multiplication Result: ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram16.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    END-READ.\n    CLOSE InputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram17.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nFD OutputFile.\n01 OutputRecord.\n    05 OutputField1 PIC X(10).\n    05 OutputField2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    OPEN OUTPUT OutputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            MOVE Field1 TO OutputField1\n            MOVE Field2 TO OutputField2\n            WRITE OutputRecord\n            DISPLAY 'Record written'\n    END-READ.\n    CLOSE InputFile.\n    CLOSE OutputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram18.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Item PIC X(10).\n        10 Quantity PIC 9(3).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'Item: ', Item(Table-Entry), ' Quantity: ', Quantity(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram19.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Employee-Data.\n    05 Emp-ID PIC 9(5) VALUE 12345.\n    05 Emp-Name PIC X(20) VALUE 'John Doe'.\n    05 Emp-Salary PIC 9(6)V99 VALUE 2500.75.\nPROCEDURE DIVISION.\n    COMPUTE Emp-Salary = Emp-Salary + 200.\n    DISPLAY 'Updated Salary: ', Emp-Salary.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram20.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Random-Numbers.\n    05 Rand-Num PIC 9(2) OCCURS 5 TIMES.\nPROCEDURE DIVISION.\n    PERFORM VARYING Rand-Num FROM 1 BY 1 UNTIL Rand-Num > 5\n        COMPUTE Rand-Num(Rand-Num) = FUNCTION RANDOM(99)\n        DISPLAY 'Random Number: ', Rand-Num(Rand-Num)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram21.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram22.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Customer-Record.\n    05 Cust-Name PIC X(30).\n    05 Cust-Age PIC 99.\n    05 Cust-Balance PIC 9(6)V99 VALUE 100.50.\nPROCEDURE DIVISION.\n    DISPLAY 'Customer Details: ', Cust-Name, Cust-Age, Cust-Balance.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram23.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Counter PIC 9(2) VALUE 1.\nPROCEDURE DIVISION.\n    PERFORM VARYING Counter FROM 1 BY 1 UNTIL Counter > 10\n        DISPLAY 'Counter is ', Counter\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram24.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Array-Data.\n    05 Array OCCURS 5 TIMES PIC X(5).\nPROCEDURE DIVISION.\n    MOVE 'COBOL' TO Array(1).\n    MOVE 'Fortran' TO Array(2).\n    MOVE 'Java' TO Array(3).\n    MOVE 'Python' TO Array(4).\n    MOVE 'C++' TO Array(5).\n    PERFORM VARYING Array FROM 1 BY 1 UNTIL Array > 5\n        DISPLAY 'Programming Language: ', Array(Array)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram25.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Date-Present PIC 9(8) VALUE 20220107.\nPROCEDURE DIVISION.\n    DISPLAY 'Year: ', Date-Present(1:4)\n    DISPLAY 'Month: ', Date-Present(5:2)\n    DISPLAY 'Day: ', Date-Present(7:2)\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram26.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Result PIC 9(5).\nPROCEDURE DIVISION.\n    MOVE 123 TO Result.\n    IF Result > 100\n        DISPLAY 'Result is greater than 100'\n    ELSE\n        DISPLAY 'Result is less than or equal to 100'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram27.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Length PIC 9(2) VALUE 10.\n01 InputStr PIC X(10) VALUE 'Hello'.\n01 OutputStr PIC X(10).\nPROCEDURE DIVISION.\n    MOVE InputStr TO OutputStr(1:Length).\n    DISPLAY 'Output: ', OutputStr\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram28.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 * Num2.\n    DISPLAY 'Multiplication Result: ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram29.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    DISPLAY 'Enter Field1: '\n    ACCEPT Field1\n    DISPLAY 'Enter Field2: '\n    ACCEPT Field2\n    DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram30.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Item PIC X(10).\n        10 Quantity PIC 9(3).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'Item: ', Item(Table-Entry), ' Quantity: ', Quantity(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram31.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    END-READ.\n    CLOSE InputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram32.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nFD OutputFile.\n01 OutputRecord.\n    05 OutputField1 PIC X(10).\n    05 OutputField2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    OPEN OUTPUT OutputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            MOVE Field1 TO OutputField1\n            MOVE Field2 TO OutputField2\n            WRITE OutputRecord\n            DISPLAY 'Record written'\n    END-READ.\n    CLOSE InputFile.\n    CLOSE OutputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram33.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram34.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Date-Present PIC 9(8) VALUE 20220107.\nPROCEDURE DIVISION.\n    DISPLAY 'Year: ', Date-Present(1:4)\n    DISPLAY 'Month: ', Date-Present(5:2)\n    DISPLAY 'Day: ', Date-Present(7:2)\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram35.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Customer-Record.\n    05 Cust-Name PIC X(30).\n    05 Cust-Age PIC 99.\n    05 Cust-Balance PIC 9(6)V99 VALUE 100.50.\nPROCEDURE DIVISION.\n    DISPLAY 'Customer Details: ', Cust-Name, Cust-Age, Cust-Balance.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram36.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Result PIC 9(5).\nPROCEDURE DIVISION.\n    MOVE 123 TO Result.\n    IF Result > 100\n        DISPLAY 'Result is greater than 100'\n    ELSE\n        DISPLAY 'Result is less than or equal to 100'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram37.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Length PIC 9(2) VALUE 10.\n01 InputStr PIC X(10) VALUE 'Hello'.\n01 OutputStr PIC X(10).\nPROCEDURE DIVISION.\n    MOVE InputStr TO OutputStr(1:Length).\n    DISPLAY 'Output: ', OutputStr\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram38.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Num1 PIC 9(3) VALUE 123.\n01 Num2 PIC 9(3) VALUE 456.\n01 Result PIC 9(4).\nPROCEDURE DIVISION.\n    COMPUTE Result = Num1 * Num2.\n    DISPLAY 'Multiplication Result: ', Result.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram39.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    DISPLAY 'Enter Field1: '\n    ACCEPT Field1\n    DISPLAY 'Enter Field2: '\n    ACCEPT Field2\n    DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram40.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Item PIC X(10).\n        10 Quantity PIC 9(3).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'Item: ', Item(Table-Entry), ' Quantity: ', Quantity(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram41.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Random-Numbers.\n    05 Rand-Num PIC 9(2) OCCURS 5 TIMES.\nPROCEDURE DIVISION.\n    PERFORM VARYING Rand-Num FROM 1 BY 1 UNTIL Rand-Num > 5\n        COMPUTE Rand-Num(Rand-Num) = FUNCTION RANDOM(99)\n        DISPLAY 'Random Number: ', Rand-Num(Rand-Num)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram42.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram43.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Date-Present PIC 9(8) VALUE 20220107.\nPROCEDURE DIVISION.\n    DISPLAY 'Year: ', Date-Present(1:4)\n    DISPLAY 'Month: ', Date-Present(5:2)\n    DISPLAY 'Day: ', Date-Present(7:2)\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram5.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            DISPLAY 'Field1: ', Field1, ' Field2: ', Field2\n    END-READ.\n    CLOSE InputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram6.\nDATA DIVISION.\nFILE SECTION.\nFD InputFile.\n01 InputRecord.\n    05 Field1 PIC X(10).\n    05 Field2 PIC 9(3).\nFD OutputFile.\n01 OutputRecord.\n    05 OutputField1 PIC X(10).\n    05 OutputField2 PIC 9(3).\nPROCEDURE DIVISION.\n    OPEN INPUT InputFile.\n    OPEN OUTPUT OutputFile.\n    READ InputFile\n        AT END\n            DISPLAY 'End of file'\n        NOT AT END\n            MOVE Field1 TO OutputField1\n            MOVE Field2 TO OutputField2\n            WRITE OutputRecord\n            DISPLAY 'Record written'\n    END-READ.\n    CLOSE InputFile.\n    CLOSE OutputFile.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram7.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 10 TIMES.\n        10 Employee-ID PIC 9(5).\n        10 Employee-Name PIC X(20).\nPROCEDURE DIVISION.\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 10\n        DISPLAY 'ID: ', Employee-ID(Table-Entry), ' Name: ', Employee-Name(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram8.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Employee-Data.\n    05 Emp-ID PIC 9(5) VALUE 12345.\n    05 Emp-Name PIC X(20) VALUE 'John Doe'.\n    05 Emp-Salary PIC 9(6)V99 VALUE 2500.75.\nPROCEDURE DIVISION.\n    COMPUTE Emp-Salary = Emp-Salary + 200.\n    DISPLAY 'Updated Salary: ', Emp-Salary.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram9.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Random-Numbers.\n    05 Rand-Num PIC 9(2) OCCURS 5 TIMES.\nPROCEDURE DIVISION.\n    PERFORM VARYING Rand-Num FROM 1 BY 1 UNTIL Rand-Num > 5\n        COMPUTE Rand-Num(Rand-Num) = FUNCTION RANDOM(99)\n        DISPLAY 'Random Number: ', Rand-Num(Rand-Num)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SampleProgram10.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 Table-Data.\n    05 Table-Entry OCCURS 5 TIMES.\n        10 Month PIC X(10).\n        10 Sales PIC 9(6)V99.\nPROCEDURE DIVISION.\n    MOVE 'January' TO Month(1).\n    MOVE 'February' TO Month(2).\n    MOVE 'March' TO Month(3).\n    MOVE 'April' TO Month(4).\n    MOVE 'May' TO Month(5).\n    PERFORM VARYING Table-Entry FROM 1 BY 1 UNTIL Table-Entry > 5\n        DISPLAY 'Month: ', Month(Table-Entry)\n    END-PERFORM.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ReverseString. DATA DIVISION. WORKING-STORAGE SECTION. 01 Input-String PIC X(20) VALUE 'COBOL'. 01 Output-String PIC X(20). PROCEDURE DIVISION. MOVE Function REVERSE OF Input-String TO Output-String. DISPLAY \"Reversed string: \" Output-String."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MultiplicationTable. DATA DIVISION. WORKING-STORAGE SECTION. 01 i PIC 9(2) VALUE 1. 01 j PIC 9(2) VALUE 1. PROCEDURE DIVISION. PERFORM VARYING i FROM 1 BY 1 UNTIL i > 10   PERFORM VARYING j FROM 1 BY 1 UNTIL j > 10     COMPUTE Result = i * j     DISPLAY i \" * \" j \" = \" Result   END-PERFORM END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. SimpleMath. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num1 PIC 9(2) VALUE 10. 01 Num2 PIC 9(2) VALUE 5. 01 Result PIC 9(3). PROCEDURE DIVISION. ADD Num1 TO Num2 GIVING Result. DISPLAY \"Addition: \" Result. SUBTRACT Num1 FROM Num2 GIVING Result. DISPLAY \"Subtraction: \" Result. MULTIPLY Num1 BY Num2 GIVING Result. DISPLAY \"Multiplication: \" Result. DIVIDE Num1 INTO Num2 GIVING Result. DISPLAY \"Division: \" Result."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ArrayOperations. DATA DIVISION. WORKING-STORAGE SECTION. 01 Numbers OCCURS 5 TIMES PIC 9(2) VALUE ZEROES. 01 Index PIC 9 VALUE 1. PROCEDURE DIVISION. PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 5   COMPUTE Numbers(Index) = Index * 10   DISPLAY \"Index \" Index \": \" Numbers(Index) END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. BubbleSort. DATA DIVISION. WORKING-STORAGE SECTION. 01 Numbers OCCURS 10 TIMES PIC 9(2) VALUE ZEROES. 01 Index1 PIC 9 VALUE 1. 01 Index2 PIC 9 VALUE 1. 01 Temp PIC 9. PROCEDURE DIVISION. PERFORM VARYING Index1 FROM 1 BY 1 UNTIL Index1 > 10   PERFORM VARYING Index2 FROM 1 BY 1 UNTIL Index2 > 10 - Index1     IF Numbers(Index2) > Numbers(Index2 + 1)       MOVE Numbers(Index2) TO Temp       MOVE Numbers(Index2 + 1) TO Numbers(Index2)       MOVE Temp TO Numbers(Index2 + 1)     END-IF   END-PERFORM END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. ConcatenateStrings. DATA DIVISION. WORKING-STORAGE SECTION. 01 String1 PIC X(10) VALUE 'Hello'. 01 String2 PIC X(10) VALUE 'COBOL'. 01 ResultString PIC X(20). PROCEDURE DIVISION. STRING String1 DELIMITED BY SIZE   String2 DELIMITED BY SIZE INTO ResultString. DISPLAY \"Concatenated string: \" ResultString."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. PalindromeCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 InputString PIC X(20) VALUE 'LEVEL'. 01 ReverseString PIC X(20). PROCEDURE DIVISION. MOVE Function REVERSE OF InputString TO ReverseString. IF InputString = ReverseString     DISPLAY \"Palindrome!\" ELSE     DISPLAY \"Not a Palindrome!\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. EvenOddCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Number PIC 9(2) VALUE 11. PROCEDURE DIVISION. IF Number MOD 2 = 0     DISPLAY Number \" is Even.\" ELSE     DISPLAY Number \" is Odd.\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MaxOfThree. DATA DIVISION. WORKING-STORAGE SECTION. 01 A PIC 9(2) VALUE 25. 01 B PIC 9(2) VALUE 37. 01 C PIC 9(2) VALUE 19. 01 MaxNumber PIC 9(2). PROCEDURE DIVISION. IF A > B AND A > C     MOVE A TO MaxNumber ELSE IF B > A AND B > C     MOVE B TO MaxNumber ELSE     MOVE C TO MaxNumber END-IF. DISPLAY \"Maximum Number is: \" MaxNumber."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. MergeArrays. DATA DIVISION. WORKING-STORAGE SECTION. 01 Array1 OCCURS 5 TIMES PIC 9(2) VALUE 10, 20, 30, 40, 50. 01 Array2 OCCURS 5 TIMES PIC 9(2) VALUE 60, 70, 80, 90, 100. 01 MergedArray OCCURS 10 TIMES PIC 9(2). PROCEDURE DIVISION. PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 5   MOVE Array1(Index) TO MergedArray(Index)   MOVE Array2(Index) TO MergedArray(Index + 5) END-PERFORM. DISPLAY \"Merged Array: \". PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 10   DISPLAY MergedArray(Index) END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. PrimeNumberCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Num PIC 9(2) VALUE 17. 01 PrimeFlag PIC X VALUE 'Y'. 01 Divisor PIC 9(2). PROCEDURE DIVISION. PERFORM VARYING Divisor FROM 2 BY 1 UNTIL Divisor > Num / 2   IF Num MOD Divisor = 0       MOVE 'N' TO PrimeFlag       EXIT PERFORM   END-IF END-PERFORM. IF PrimeFlag = 'Y'   DISPLAY Num \" is a Prime Number.\" ELSE   DISPLAY Num \" is not a Prime Number.\" END-IF"
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. AreaOfCircle. DATA DIVISION. WORKING-STORAGE SECTION. 01 Radius PIC 9(3) VALUE 10. 01 Pi PIC 9V9(6) VALUE 3.14159. 01 Area PIC 9(5)V99. PROCEDURE DIVISION. COMPUTE Area = Pi * Radius * Radius. DISPLAY \"Area of Circle: \" Area."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. FibonacciSeries. DATA DIVISION. WORKING-STORAGE SECTION. 01 FirstNum PIC 9(2) VALUE 0. 01 SecondNum PIC 9(2) VALUE 1. 01 NextNum PIC 9(2). PROCEDURE DIVISION. DISPLAY FirstNum DISPLAY SecondNum PERFORM VARYING Index FROM 1 BY 1 UNTIL Index > 8   COMPUTE NextNum = FirstNum + SecondNum   DISPLAY NextNum   COMPUTE FirstNum = SecondNum   COMPUTE SecondNum = NextNum END-PERFORM."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. CountWords. DATA DIVISION. WORKING-STORAGE SECTION. 01 Sentence PIC X(50) VALUE 'COBOL programming is fun and structured.'. 01 WordCount PIC 9(3). PROCEDURE DIVISION. STRING LENGTH OF Sentence DELIMITED BY SPACES INTO WordCount. DISPLAY \"Number of Words: \" WordCount."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. StringConcatenation. DATA DIVISION. WORKING-STORAGE SECTION. 01 String1 PIC X(20) VALUE 'Hello'. 01 String2 PIC X(20) VALUE 'COBOL'. 01 ResultString PIC X(40). PROCEDURE DIVISION. MOVE Function CONCATENATE OF String1 AND String2 TO ResultString. DISPLAY \"Concatenated string: \" ResultString."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION. PROGRAM-ID. LeapYearCheck. DATA DIVISION. WORKING-STORAGE SECTION. 01 Year PIC 9(4) VALUE 2024. PROCEDURE DIVISION. IF (Year MOD 4 = 0 AND Year MOD 100 <> 0) OR (Year MOD 400 = 0)     DISPLAY Year \" is a Leap Year.\" ELSE     DISPLAY Year \" is not a Leap Year.\" END-IF."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. FILE-HANDLING.\n\nDATA DIVISION.\nFILE SECTION.\n    FD INPUT-FILE.\n    01 INPUT-RECORD.\n        05 NAME    PIC X(20).\n        05 AGE     PIC 99.\n\nWORKING-STORAGE SECTION.\n    01 OUTPUT-RECORD.\n        05 RESULT  PIC X(30).\n\nPROCEDURE DIVISION.\n    OPEN INPUT INPUT-FILE.\n    READ INPUT-FILE INTO INPUT-RECORD\n        AT END DISPLAY 'End of file reached'\n    END-READ.\n\n    PERFORM UNTIL EOF\n        MOVE NAME TO RESULT\n        DISPLAY 'Name: ' RESULT\n        MOVE AGE TO RESULT\n        DISPLAY 'Age: ' RESULT\n        READ INPUT-FILE INTO INPUT-RECORD\n            AT END SET EOF TO TRUE\n        END-READ\n    END-PERFORM.\n\n    CLOSE INPUT-FILE.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MAIN-PROGRAM.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 5.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    PERFORM MULTIPLY-BY-TWO.\n    DISPLAY 'Result: ' RESULT.\n    STOP RUN.\n\nMULTIPLY-BY-TWO.\n    MULTIPLY NUMBER BY 2 GIVING RESULT."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. CONDITIONAL.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUM PIC 99 VALUE 10.\n\nPROCEDURE DIVISION.\n    IF NUM > 5\n        DISPLAY 'Number is greater than 5'\n    ELSE\n        DISPLAY 'Number is less than or equal to 5'\n    END-IF.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. ADD-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 10.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    ADD 20 TO NUMBER.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after adding 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SUBTRACT-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 50.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    SUBTRACT 20 FROM NUMBER.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after subtracting 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MULTIPLY-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 99 VALUE 3.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    MULTIPLY NUMBER BY 20.\n    MOVE NUMBER TO RESULT.\n    DISPLAY 'Result after multiplying by 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. DIVIDE-20.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 NUMBER PIC 999 VALUE 100.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    DIVIDE NUMBER BY 20 GIVING RESULT.\n    DISPLAY 'Result after dividing by 20: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. DISPLAY-MESSAGE.\n\nPROCEDURE DIVISION.\n    DISPLAY 'This is a sample COBOL program'.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. READ-WRITE-FILE.\n\nDATA DIVISION.\nFILE SECTION.\n    FD MY-FILE.\n    01 RECORD.\n        05 NAME PIC X(30).\n        05 AGE PIC 99.\n\nPROCEDURE DIVISION.\n    OPEN OUTPUT MY-FILE.\n    MOVE 'John' TO NAME.\n    MOVE 25 TO AGE.\n    WRITE RECORD.\n    CLOSE MY-FILE.\n    STOP RUN."
  },
  {
    "language": "COBOL",
    "code": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SIMPLE-ADD.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n    01 A PIC 99 VALUE 5.\n    01 B PIC 99 VALUE 10.\n    01 RESULT PIC 99.\n\nPROCEDURE DIVISION.\n    ADD A, B GIVING RESULT.\n    DISPLAY 'Result of addition: ' RESULT.\n    STOP RUN."
  },
  {
    "language": "Dart",
    "code": "void main() { print('Hello, World!'); }"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var shoppingList = ['apples', 'bananas', 'oranges'];\n  var prices = {'apples': 1.50, 'bananas': 0.80, 'oranges': 1.20};\n  var total = 0.0;\n\n  for (var item in shoppingList) {\n    total += prices[item] ?? 0;\n  }\n\n  print('Total cost: \\$total');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var fibonacci = [0, 1];\n  for (var i = 2; i < 10; i++) {\n    fibonacci.add(fibonacci[i - 1] + fibonacci[i - 2]);\n  }\n  print('Fibonacci sequence: \\$fibonacci');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var words = ['hello', 'world', 'dart', 'openai', 'programming'];\n  var longestWord = words.reduce((a, b) => a.length > b.length ? a : b);\n  print('Longest word: \\$longestWord');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var colors = {'red', 'green', 'blue', 'yellow', 'orange'};\n  var color = colors.elementAt(2);\n  print('Selected color: \\$color');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var number = 17;\n  var isPrime = true;\n  for (var i = 2; i <= number / 2; ++i) {\n    if (number % i == 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  print('Is \\$number prime? \\$isPrime');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var inputString = 'Hello, dart!';\n  var vowels = 'aeiouAEIOU';\n  var count = 0;\n\n  for (var i = 0; i < inputString.length; i++) {\n    if (vowels.contains(inputString[i])) {\n      count++;\n    }\n  }\n  print('Number of vowels: \\$count');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var students = {\n    'Alice': 95,\n    'Bob': 72,\n    'Charlie': 85,\n    'David': 90,\n    'Eve': 68\n  };\n\n  var passed = students.entries.where((entry) => entry.value >= 70);\n  print('Number of students passed: \\${passed.length}');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var temperatures = [23, 26, 28, 21, 19, 25, 30];\n  var average = temperatures.reduce((a, b) => a + b) / temperatures.length;\n  print('Average temperature: \\$average');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [2, 4, 6, 8, 10];\n  var squares = numbers.map((num) => num * num).toList();\n  print('Squared numbers: \\$squares');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {  var list1 = [1, 2, 3, 4, 5];  var list2 = [3, 4, 5, 6, 7];  var commonElements = list1.toSet().intersection(list2.toSet());  print('Common elements: \\$commonElements');}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [1, 2, 3, 4, 5];\n  var evenNumbers = numbers.where((number) => number % 2 == 0).toList();\n  print('Even numbers: \\$evenNumbers');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var data = {'name': 'Alice', 'age': 30};\n  var keys = data.keys.toList();\n  var values = data.values.toList();\n  print('Keys: \\$keys');\n  print('Values: \\$values');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var sum = list.reduce((value, element) => value + element);\n  var average = sum / list.length;\n  print('Average: \\$average');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var filteredList = myList.where((fruit) => fruit.length > 5).toList();\n  print('Fruits with length greater than 5: \\\\$filteredList');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [4, 7, 12, 18, 25];\n  var average = myList.reduce((a, b) => a + b) / myList.length;\n  print('Average: \\\\$average');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'dart is an interesting language';\n  var words = sentence.split(' ');\n  var longestWord = words.reduce((a, b) => a.length > b.length ? a : b);\n  print('Longest word: \\\\$longestWord');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [3, 6, 9, 12, 15];\n  var sum = list.fold(0, (previous, current) => previous + current);\n  print('Sum: \\\\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [10, 20, 30, 40, 50];\n  var result = myList.map((value) => value * 2).toList();\n  print('Doubled list: \\\\$result');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'Learning dart is fun!';\n  var charCount = sentence.runes.toSet().length;\n  print('Unique characters: \\\\$charCount');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [1, 2, 3, 4, 5];\n  var oddNumbers = myList.where((number) => number % 2 != 0).toList();\n  print('Odd numbers: \\\\$oddNumbers');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var firstThreeLetters = myList.map((fruit) => fruit.substring(0, 3)).toList();\n  print('First three letters: \\\\$firstThreeLetters');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var number = 42;\n  var isEven = number.isEven;\n  print('Is \\\\$number even? \\\\$isEven');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var containsA = myList.any((fruit) => fruit.contains('a'));\n  print('Any fruit contains letter \\'a\\': \\\\$containsA');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [2, 4, 6, 8, 10];\n  var product = myList.reduce((value, element) => value * element);\n  print('Product: \\\\$product');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var reversedList = myList.map((fruit) => fruit.split('').reversed.join()).toList();\n  print('Reversed fruits: \\\\$reversedList');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = [10, 20, 30, 40, 50];\n  var result = myList.where((value) => value > 25).toList();\n  print('Values greater than 25: \\\\$result');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var myList = ['apple', 'banana', 'cherry', 'date'];\n  var concatenated = myList.reduce((value, element) => value + element);\n  print('Concatenated fruits: \\\\$concatenated');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'This is a sample sentence';\n  var count = sentence.split(' ').length;\n  print('Word count: \\\\$count');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'The quick brown fox jumps over the lazy dog';\n  var words = sentence.split(' ');\n  var wordCount = words.length;\n  print('Word count: \\$wordCount');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [2, 3, 5, 7, 11, 13];\n  var squaredNumbers = numbers.map((num) => num * num).toList();\n  print('Squared numbers: \\$squaredNumbers');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var sentence = 'Hello, world!';\n  var reversed = sentence.split('').reversed.join();\n  print('Reversed: \\$reversed');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var input = '1, 2, 3, 4, 5';\n  var numbers = input.split(', ').map((str) => int.parse(str)).toList();\n  var sum = numbers.reduce((value, element) => value + element);\n  print('Sum: \\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var squares = list.map((num) => num * num).toList();\n  var filtered = squares.where((num) => num.isEven).toList();\n  print('Filtered: \\$filtered');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var sum = list.fold(0, (acc, current) => acc + current);\n  print('Sum: \\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var names = ['Alice', 'Bob', 'Charlie'];\n  var nameWithL = names.firstWhere((name) => name.startsWith('L'), orElse: () => 'None');\n  print('Name starting with L: \\$nameWithL');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var values = [1, 2, 3, 4, 5];\n  var product = values.reduce((value, element) => value * element);\n  print('Product: \\$product');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var reversedList = list.reversed.toList();\n  print('Reversed list: \\$reversedList');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [3, 7, 12, 18, 22, 30];\n  var multiplesOfThree = numbers.where((number) => number % 3 == 0).toList();\n  print('Multiples of three: \\$multiplesOfThree');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var list = [1, 2, 3, 4, 5];\n  var sum = list.fold(0, (previousValue, element) => previousValue + element);\n  print('Sum: \\$sum');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  var numbers = [2, 4, 6, 8, 10];\n  var squares = numbers.map((num) => num * num).toList();\n  print('Squared numbers: \\$squares');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() { int number = 42; String message = 'Hello'; double piValue = 3.14; bool isTrue = true; }"
  },
  {
    "language": "Dart",
    "code": "void main() { bool isTrue = true; if (isTrue) { print('It is true!'); } else { print('It is false!'); } }"
  },
  {
    "language": "Dart",
    "code": "void main() { for (var i = 0; i < 5; i++) { print('Count: $i'); } }"
  },
  {
    "language": "Dart",
    "code": "void main() { int count = 0; while (count < 5) { print('Count: $count'); count++; } }"
  },
  {
    "language": "Dart",
    "code": "void greet(String name) { print('Hello, $name!'); } void main() { greet('Alice'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { List<String> fruits = ['Apple', 'Orange', 'Banana']; print(fruits); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Map<String, int> ages = {'Alice': 25, 'Bob': 30, 'Charlie': 28}; print(ages); }"
  },
  {
    "language": "Dart",
    "code": "class Person { String name; int age; Person(this.name, this.age); } void main() { var person = Person('Alice', 25); print('Name: ${person.name}, Age: ${person.age}'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Future<void> fetchData() async { await Future.delayed(Duration(seconds: 2)); print('Data fetched!'); } fetchData(); print('Fetching data...'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { Set<int> numbers = {1, 2, 3, 4, 5}; print(numbers); }"
  },
  {
    "language": "Dart",
    "code": "enum Status { pending, approved, rejected } void main() { var applicationStatus = Status.approved; print('Application Status: $applicationStatus'); }"
  },
  {
    "language": "Dart",
    "code": "import 'dart:math'; void main() { var random = Random(); print('Random number: ${random.nextInt(100)}'); }"
  },
  {
    "language": "Dart",
    "code": "import 'dart:io'; void main() { stdout.write('Enter your name: '); var name = stdin.readLineSync(); print('Hello, $name!'); }"
  },
  {
    "language": "Dart",
    "code": "void greet({String name = 'Anonymous'}) { print('Hello, $name!'); } void main() { greet(name: 'Alice'); greet(); }"
  },
  {
    "language": "Dart",
    "code": "class Bird { void fly() { print('Flying!'); } } class Sparrow extends Bird {} void main() { var sparrow = Sparrow(); sparrow.fly(); }"
  },
  {
    "language": "Dart",
    "code": "extension StringExtension on String { void shout() { print('${this.toUpperCase()}!!!'); } } void main() { var message = 'hello'; message.shout(); }"
  },
  {
    "language": "Dart",
    "code": "Future<void> delayedPrint() { return Future.delayed(Duration(seconds: 2), () { print('Delayed print after 2 seconds'); }); } void main() { delayedPrint(); print('Printed immediately'); }"
  },
  {
    "language": "Dart",
    "code": "void main() { RegExp regex = RegExp(r'\\d+'); String text = 'There are 123 apples'; Iterable<Match> matches = regex.allMatches(text); matches.forEach((match) => print(match.group(0))); }"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  print('Hello, World!');\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  int result = add(3, 5);\n  print('Result: result');\n}\n\nint add(int a, int b) {\n  return a + b;\n}"
  },
  {
    "language": "Dart",
    "code": "void main() {\n  for (int i = 0; i < 5; i++) {\n    print('Value: i');\n  }\n}"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM HelloWorld PRINT *, 'Hello, World!' END PROGRAM HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "program HelloWorld\n  print *, 'Hello, World!'\nend program HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "program SumNumbers\n  integer :: sum\n  sum = 0\n  do i = 1, 10\n     sum = sum + i\n  end do\n  print *, 'Sum: ', sum\nend program SumNumbers"
  },
  {
    "language": "Fortran",
    "code": "program Factorial\n  integer :: n = 5, fact = 1, i\n  do i = 1, n\n     fact = fact * i\n  end do\n  print *, 'Factorial of ', n, ' is ', fact\nend program Factorial"
  },
  {
    "language": "Fortran",
    "code": "program PrimeCheck\n  integer :: number = 17, i, flag = 0\n  do i = 2, number - 1\n     if (mod(number, i) == 0) then\n        flag = 1\n        exit\n     end if\n  end do\n  if (flag == 0) then\n     print *, number, ' is prime'\n  else\n     print *, number, ' is not prime'\n  end if\nend program PrimeCheck"
  },
  {
    "language": "Fortran",
    "code": "program Fibonacci\n  integer :: n = 10, first = 0, second = 1, next, i\n  print *, 'Fibonacci Series: '\n  do i = 0, n\n     if (i <= 1) then\n        next = i\n     else\n        next = first + second\n        first = second\n        second = next\n     end if\n     print *, next\n  end do\nend program Fibonacci"
  },
  {
    "language": "Fortran",
    "code": "program ArraySum\n  integer :: arr(5) = [1, 2, 3, 4, 5], i, sum = 0\n  do i = 1, size(arr)\n     sum = sum + arr(i)\n  end do\n  print *, 'Sum of array elements: ', sum\nend program ArraySum"
  },
  {
    "language": "Fortran",
    "code": "program SphereVolume\n  real :: radius = 5.0, volume\n  volume = (4.0 / 3.0) * 3.14159 * radius**3\n  print *, 'Volume of sphere: ', volume\nend program SphereVolume"
  },
  {
    "language": "Fortran",
    "code": "program LargestNumber\n  integer :: numbers(5) = [5, 12, 9, 3, 18], i, max\n  max = numbers(1)\n  do i = 2, size(numbers)\n     if (numbers(i) > max) then\n        max = numbers(i)\n     end if\n  end do\n  print *, 'Largest number: ', max\nend program LargestNumber"
  },
  {
    "language": "Fortran",
    "code": "program BubbleSort\n  integer :: arr(5) = [64, 34, 25, 12, 22], i, j, temp\n  do i = 1, size(arr) - 1\n     do j = 1, size(arr) - i\n        if (arr(j) > arr(j + 1)) then\n           temp = arr(j)\n           arr(j) = arr(j + 1)\n           arr(j + 1) = temp\n        end if\n     end do\n  end do\n  print *, 'Sorted array: ', arr\nend program BubbleSort"
  },
  {
    "language": "Fortran",
    "code": "program QuadraticEquation\n  real :: a = 2.0, b = -7.0, c = 3.0\n  real :: discriminant, root1, root2\n  discriminant = b**2 - 4 * a * c\n  root1 = (-b + sqrt(discriminant)) / (2 * a)\n  root2 = (-b - sqrt(discriminant)) / (2 * a)\n  print *, 'Roots: ', root1, root2\nend program QuadraticEquation"
  },
  {
    "language": "Fortran",
    "code": "program ArmstrongNumber\n  integer :: number = 153, temp, digit, sum = 0\n  temp = number\n  do while (temp /= 0)\n     digit = mod(temp, 10)\n     sum = sum + digit**3\n     temp = temp / 10\n  end do\n  if (sum == number) then\n     print *, number, ' is an Armstrong number'\n  else\n     print *, number, ' is not an Armstrong number'\n  end if\nend program ArmstrongNumber"
  },
  {
    "language": "Fortran",
    "code": "program GCD\n  integer :: num1 = 45, num2 = 60, temp1, temp2\n  temp1 = num1\n  temp2 = num2\n  do while (temp2 /= 0)\n     if (temp1 > temp2) then\n        temp1 = temp1 - temp2\n     else\n        temp2 = temp2 - temp1\n     end if\n  end do\n  print *, 'GCD: ', temp1\nend program GCD"
  },
  {
    "language": "Fortran",
    "code": "program CountVowels\n  character(len=50) :: sentence = 'Fortran programming language'\n  integer :: i, vowels = 0\n  do i = 1, len_trim(sentence)\n     if (any(sentence(i:i) == ['a', 'e', 'i', 'o', 'u'])) then\n        vowels = vowels + 1\n     end if\n  end do\n  print *, 'Number of vowels: ', vowels\nend program CountVowels"
  },
  {
    "language": "Fortran",
    "code": "program DecimalToBinary\n  integer :: decimal = 19, binary(32), quotient, i = 1\n  quotient = decimal\n  do while (quotient > 0)\n     binary(i) = mod(quotient, 2)\n     quotient = quotient / 2\n     i = i + 1\n  end do\n  print *, 'Binary equivalent of ', decimal, ' is: '\n  do i = i - 1, 1, -1\n     print *, binary(i)\n  end do\nend program DecimalToBinary"
  },
  {
    "language": "Fortran",
    "code": "program ArrayAverage\n  integer :: arr(6) = [10, 15, 20, 25, 30, 35], i, sum = 0\n  real :: average\n  do i = 1, size(arr)\n     sum = sum + arr(i)\n  end do\n  average = real(sum) / size(arr)\n  print *, 'Average of array elements: ', average\nend program ArrayAverage"
  },
  {
    "language": "Fortran",
    "code": "program LeapYear\n  integer :: year = 2024\n  if (mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0)) then\n     print *, year, ' is a leap year'\n  else\n     print *, year, ' is not a leap year'\n  end if\nend program LeapYear"
  },
  {
    "language": "Fortran",
    "code": "program SumOfSeries\n  integer :: n = 10, i\n  real :: sum = 0.0\n  do i = 1, n\n     sum = sum + 1.0 / real(i)\n  end do\n  print *, 'Sum of series: ', sum\nend program SumOfSeries"
  },
  {
    "language": "Fortran",
    "code": "program ReverseString\n  character(len=20) :: str = 'Fortran'\n  integer :: len, i\n  len = len_trim(str)\n  print *, 'Original string: ', str\n  print *, 'Reversed string: '\n  do i = len, 1, -1\n     print *, str(i:i)\n  end do\nend program ReverseString"
  },
  {
    "language": "Fortran",
    "code": "program MatrixMultiplication\n  integer, parameter :: n = 3, m = 2, p = 3\n  integer :: a(n, m) = reshape([1, 2, 3, 4, 5, 6], [n, m])\n  integer :: b(m, p) = reshape([7, 8, 9, 10, 11, 12], [m, p])\n  integer :: c(n, p), i, j, k\n  do i = 1, n\n     do j = 1, p\n        c(i, j) = 0\n        do k = 1, m\n           c(i, j) = c(i, j) + a(i, k) * b(k, j)\n        end do\n     end do\n  end do\n  print *, 'Matrix multiplication result: '\n  do i = 1, n\n     do j = 1, p\n        print *, c(i, j)\n     end do\n  end do\nend program MatrixMultiplication"
  },
  {
    "language": "Fortran",
    "code": "program NewtonRaphson\n  real :: x0 = 2.0, x, epsilon = 0.0001\n  do\n     x = x0 - (x0**3 - 2*x0 - 5) / (3*x0**2 - 2)\n     if (abs(x - x0) < epsilon) exit\n     x0 = x\n  end do\n  print *, 'Root using Newton-Raphson method: ', x\nend program NewtonRaphson"
  },
  {
    "language": "Fortran",
    "code": "program SineSeries\n  real :: x = 1.2, sine = 0.0, term, epsilon = 0.0001\n  integer :: i, sign = 1\n  do i = 1, 1000\n     term = sign * x**((2*i) - 1) / product([(2 * j) - 1, j = 1, i])\n     if (abs(term) < epsilon) exit\n     sine = sine + term\n     sign = -sign\n  end do\n  print *, 'Sine of ', x, ' is ', sine\nend program SineSeries"
  },
  {
    "language": "Fortran",
    "code": "program MatrixTranspose\n  integer, parameter :: n = 3, m = 2\n  integer :: a(n, m) = reshape([1, 2, 3, 4, 5, 6], [n, m]), b(m, n), i, j\n  do i = 1, n\n     do j = 1, m\n        b(j, i) = a(i, j)\n     end do\n  end do\n  print *, 'Original Matrix: '\n  do i = 1, n\n     print *, (a(i, j), j = 1, m)\n  end do\n  print *, 'Transposed Matrix: '\n  do i = 1, m\n     print *, (b(i, j), j = 1, n)\n  end do\nend program MatrixTranspose"
  },
  {
    "language": "Fortran",
    "code": "program SimpsonRule\n  real :: a = 0.0, b = 1.0, integral, h, x\n  integer :: n = 10, i\n  h = (b - a) / real(n)\n  integral = func(a) + func(b)\n  do i = 1, n - 1, 2\n     x = a + real(i) * h\n     integral = integral + 4.0 * func(x)\n  end do\n  do i = 2, n - 2, 2\n     x = a + real(i) * h\n     integral = integral + 2.0 * func(x)\n  end do\n  integral = integral * h / 3.0\n  print *, 'Integral using Simpson's rule: ', integral\ncontains\n  real function func(x)\n    real, intent(in) :: x\n    func = x**2 + 1\n  end function func\nend program SimpsonRule"
  },
  {
    "language": "Fortran",
    "code": "program LagrangeInterpolation\n  real :: xvals(5) = [1.0, 2.0, 3.0, 4.0, 5.0], yvals(5) = [1.0, 8.0, 27.0, 64.0, 125.0], x = 2.5, result = 0.0\n  integer :: n = size(xvals), i, j\n  do i = 1, n\n     product = yvals(i)\n     do j = 1, n\n        if (j /= i) product = product * (x - xvals(j)) / (xvals(i) - xvals(j))\n     end do\n     result = result + product\n  end do\n  print *, 'Interpolated value at ', x, ' is ', result\nend program LagrangeInterpolation"
  },
  {
    "language": "Fortran",
    "code": "program JacobiMethod\n  real :: A(3,3) = reshape([10, 2, 1, 1, 5, 1, 2, 3, 10], [3,3])\n  real :: b(3) = [7, -8, 6], x(3) = [0, 0, 0], x_new(3), tol = 0.0001\n  integer :: max_iter = 1000, iter = 0, i, j\n  do while (iter < max_iter)\n     do i = 1, size(b)\n        x_new(i) = b(i)\n        do j = 1, size(b)\n           if (i /= j) x_new(i) = x_new(i) - A(i, j) * x(j)\n        end do\n        x_new(i) = x_new(i) / A(i, i)\n     end do\n     if (all(abs(x_new - x) < tol)) exit\n     x = x_new\n     iter = iter + 1\n  end do\n  print *, 'Solution using Jacobi method: ', x_new\nend program JacobiMethod"
  },
  {
    "language": "Fortran",
    "code": "program HeapSort\n  integer, parameter :: n = 10\n  integer :: arr(n) = [12, 11, 13, 5, 6, 7, 15, 8, 14, 9]\n  call heapify(arr, n)\n  do i = n, 2, -1\n     call swap(arr(1), arr(i))\n     call heapify(arr, i - 1)\n  end do\n  print *, 'Sorted array: ', arr\ncontains\n  subroutine swap(a, b)\n    integer, intent(inout) :: a, b\n    integer :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap\n  subroutine heapify(arr, size)\n    integer, intent(inout) :: arr(:), size\n    integer :: i, j, parent, left, right, largest\n    do i = size / 2, 1, -1\n       parent = i\n       left = 2 * parent\n       right = 2 * parent + 1\n       if (left <= size .and. arr(left) > arr(parent)) then\n          largest = left\n       else\n          largest = parent\n       end if\n       if (right <= size .and. arr(right) > arr(largest)) largest = right\n       if (largest /= parent) then\n          call swap(arr(parent), arr(largest))\n          call heapify(arr, size)\n       end if\n    end do\n  end subroutine heapify\nend program HeapSort"
  },
  {
    "language": "Fortran",
    "code": "program RungeKutta\n  real :: h = 0.1, t = 0.0, y = 1.0, k1, k2, k3, k4\n  integer :: i\n  do i = 1, 10\n     k1 = h * f(t, y)\n     k2 = h * f(t + h/2, y + k1/2)\n     k3 = h * f(t + h/2, y + k2/2)\n     k4 = h * f(t + h, y + k3)\n     y = y + (k1 + 2*k2 + 2*k3 + k4) / 6\n     t = t + h\n     print *, 't = ', t, ' y = ', y\n  end do\ncontains\n  real function f(t, y)\n    real, intent(in) :: t, y\n    f = t*y + y**2\n  end function f\nend program RungeKutta"
  },
  {
    "language": "Fortran",
    "code": "program FFT\n  integer, parameter :: n = 8\n  complex :: data(n) = [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0), (1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0)]\n  call fft(data, n)\n  print *, 'FFT Result: ', data\ncontains\n  subroutine fft(data, n)\n    complex, intent(inout) :: data(:)\n    integer, intent(in) :: n\n    ! FFT implementation\n    ! ... (omitted for brevity)\n  end subroutine fft\nend program FFT"
  },
  {
    "language": "Fortran",
    "code": "program BesselFunction\n  real :: x = 2.0, j0, j1\n  j0 = bessj0(x)\n  j1 = bessj1(x)\n  print *, 'Bessel function J0(x): ', j0\n  print *, 'Bessel function J1(x): ', j1\ncontains\n  real function bessj0(x)\n    real, intent(in) :: x\n    ! Bessel function calculation for J0(x)\n    ! ... (omitted for brevity)\n  end function bessj0\n  real function bessj1(x)\n    real, intent(in) :: x\n    ! Bessel function calculation for J1(x)\n    ! ... (omitted for brevity)\n  end function bessj1\nend program BesselFunction"
  },
  {
    "language": "Fortran",
    "code": "program MonteCarloPi\n  integer :: n = 1000000, i\n  real :: x, y, pi_approx, count\n  count = 0\n  do i = 1, n\n     x = random_number()\n     y = random_number()\n     if (x**2 + y**2 <= 1.0) count = count + 1\n  end do\n  pi_approx = 4.0 * count / n\n  print *, 'Approximation of Pi using Monte Carlo method: ', pi_approx\nend program MonteCarloPi"
  },
  {
    "language": "Fortran",
    "code": "program NelderMead\n  real :: x0(2) = [0.0, 0.0]\n  real :: simplex(3,2), tol = 0.0001\n  integer :: i\n  ! Initialize simplex\n  simplex = reshape([-1.0, -1.0, 1.0, -1.0, 0.0, 1.0], [3,2])\n  do i = 1, 100\n     call sort_simplex(simplex)\n     ! Perform Nelder-Mead optimization steps\n     ! ... (omitted for brevity)\n  end do\n  print *, 'Optimal solution: ', simplex(1, :)\ncontains\n  subroutine sort_simplex(simplex)\n    real, intent(inout) :: simplex(:,:)\n    ! Sort simplex points based on function evaluation\n    ! ... (omitted for brevity)\n  end subroutine sort_simplex\nend program NelderMead"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Variables INTEGER :: number REAL :: piValue CHARACTER(LEN=5) :: message LOGICAL :: isTrue number = 42 piValue = 3.14 message = 'Hello' isTrue = .TRUE. END PROGRAM Variables"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM ConditionalStatements LOGICAL :: isTrue isTrue = .TRUE. IF (isTrue) THEN PRINT *, 'It is true!' ELSE PRINT *, 'It is false!' END IF END PROGRAM ConditionalStatements"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Loops INTEGER :: i DO i = 0, 4 PRINT *, 'Count: ', i END DO END PROGRAM Loops"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM WhileLoop INTEGER :: count count = 0 DO WHILE (count < 5) PRINT *, 'Count: ', count count = count + 1 END DO END PROGRAM WhileLoop"
  },
  {
    "language": "Fortran",
    "code": "SUBROUTINE Greet(name) CHARACTER(LEN=10) :: name PRINT *, 'Hello, ', name, '!' END SUBROUTINE Greet PROGRAM Main CALL Greet('Alice') END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Arrays INTEGER, DIMENSION(3) :: numbers numbers = [1, 2, 3] PRINT *, numbers END PROGRAM Arrays"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Arrays2D INTEGER, DIMENSION(2, 3) :: matrix matrix = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3]) PRINT *, matrix END PROGRAM Arrays2D"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Functions SUBROUTINE AddNumbers(a, b) INTEGER :: a, b PRINT *, 'Sum:', a + b END SUBROUTINE AddNumbers PROGRAM Main CALL AddNumbers(5, 7) END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Modules MODULE MathFunctions CONTAINS FUNCTION Cube(x) REAL :: x Cube = x**3 END FUNCTION Cube END MODULE MathFunctions PROGRAM Main USE MathFunctions REAL :: result result = Cube(3.0) PRINT *, 'Cube:', result END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM IfElseStatements INTEGER :: age age = 18 IF (age < 18) THEN PRINT *, 'You are a minor.' ELSEIF (age >= 18 .AND. age < 65) THEN PRINT *, 'You are an adult.' ELSE PRINT *, 'You are a senior citizen.' END IF END PROGRAM IfElseStatements"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM RandomNumbers INTEGER :: randomNum CALL RANDOM_NUMBER(randomNum) randomNum = randomNum * 100 PRINT *, 'Random number:', randomNum END PROGRAM RandomNumbers"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM UserInput CHARACTER(LEN=20) :: name PRINT *, 'Enter your name: ' READ *, name PRINT *, 'Hello, ', TRIM(name), '!' END PROGRAM UserInput"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM OptionalArguments SUBROUTINE Greet(name) CHARACTER(LEN=10), OPTIONAL :: name IF (PRESENT(name)) THEN PRINT *, 'Hello, ', name, '!' ELSE PRINT *, 'Hello, World!' END IF END SUBROUTINE Greet PROGRAM Main CALL Greet('Alice') CALL Greet() END PROGRAM Main"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM DerivedTypes TYPE Person CHARACTER(LEN=20) :: name INTEGER :: age END TYPE Person TYPE(Person) :: individual individual%name = 'Alice' individual%age = 25 PRINT *, 'Name:', individual%name PRINT *, 'Age:', individual%age END PROGRAM DerivedTypes"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM FileIO INTEGER :: num, i OPEN(UNIT=10, FILE='numbers.txt', STATUS='OLD') DO i = 1, 3 READ(10, *) num PRINT *, 'Number:', num END DO CLOSE(10) END PROGRAM FileIO"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM AllocateArray INTEGER, ALLOCATABLE :: arr(:) ALLOCATE(arr(5)) arr = [1, 2, 3, 4, 5] PRINT *, arr DEALLOCATE(arr) END PROGRAM AllocateArray"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM RegexExample CHARACTER(LEN=50) :: text CHARACTER(LEN=20) :: pattern INTEGER :: i, nmatches INTEGER, ALLOCATABLE :: matches(:) text = 'There are 123 apples' pattern = '(\\d+)' CALL GET_MATCHES(text, pattern, matches, nmatches) DO i = 1, nmatches PRINT *, 'Match: ', TRIM(matches(i)) END DO END PROGRAM RegexExample"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM HelloWorld\n    PRINT *, 'Hello, World!'\nEND PROGRAM HelloWorld"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM SimpleCalculation\n    INTEGER :: num1 = 123, num2 = 456, result\n    result = num1 + num2\n    PRINT *, 'Result: ', result\nEND PROGRAM SimpleCalculation"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Looping\n    INTEGER :: i\n    DO i = 1, 10\n        PRINT *, 'Value of i: ', i\n    END DO\nEND PROGRAM Looping"
  },
  {
    "language": "Fortran",
    "code": "PROGRAM Conditional\n    INTEGER :: num\n    num = 10\n    IF (num > 5) THEN\n        PRINT *, 'Number is greater than 5'\n    ELSE\n        PRINT *, 'Number is less than or equal to 5'\n    END IF\nEND PROGRAM Conditional"
  },
  {
    "language": "Groovy",
    "code": "def greet() { println 'Hello, World!' } greet()"
  },
  {
    "language": "Groovy",
    "code": "def factorial(int n) {\n    if (n <= 1) return 1\n    return n * factorial(n - 1)\n}\nprintln 'Factorial of 5: ' + factorial(5)"
  },
  {
    "language": "Groovy",
    "code": "def ackermann(int m, int n) {\n    if (m == 0) return n + 1\n    else if (n == 0) return ackermann(m - 1, 1)\n    else return ackermann(m - 1, ackermann(m, n - 1))\n}\nprintln 'Ackermann of (3, 4): ' + ackermann(3, 4)"
  },
  {
    "language": "Groovy",
    "code": "def fibonacci(int n) {\n    def fib = [0, 1]\n    (2..n).each { fib << fib[-1] + fib[-2] }\n    return fib[n]\n}\nprintln 'Fibonacci of 8: ' + fibonacci(8)"
  },
  {
    "language": "Groovy",
    "code": "def quicksort(list) {\n    if (list.size() <= 1) return list\n    def pivot = list.removeAt(list.size() / 2)\n    def (less, greater) = list.partition { it < pivot }\n    return (quicksort(less) << pivot << quicksort(greater)).flatten()\n}\ndef numbers = [5, 3, 7, 2, 9, 1]\nprintln 'Sorted list: ' + quicksort(numbers)"
  },
  {
    "language": "Groovy",
    "code": "def binarySearch(list, int target) {\n    def low = 0, high = list.size() - 1\n    while (low <= high) {\n        def mid = (low + high) / 2\n        if (list[mid] == target) return mid\n        else if (list[mid] < target) low = mid + 1\n        else high = mid - 1\n    }\n    return -1\n}\ndef sortedList = [2, 4, 6, 8, 10, 12, 14, 16, 18]\nprintln 'Index of 10 in list: ' + binarySearch(sortedList, 10)"
  },
  {
    "language": "Groovy",
    "code": "def mergeSort(list) {\n    def merge(left, right) {\n        def result = []\n        while (left.size() && right.size()) {\n            if (left[0] <= right[0]) result << left.remove(0)\n            else result << right.remove(0)\n        }\n        return result + left + right\n    }\n    if (list.size() <= 1) return list\n    def mid = list.size() / 2\n    def left = mergeSort(list[0..(mid - 1)])\n    def right = mergeSort(list[mid..-1])\n    return merge(left, right)\n}\ndef numbers = [38, 27, 43, 3, 9, 82, 10]\nprintln 'Sorted list: ' + mergeSort(numbers)"
  },
  {
    "language": "Groovy",
    "code": "def matrixMultiplication(matrixA, matrixB) {\n    def result = []\n    for (int i = 0; i < matrixA.size(); i++) {\n        def row = []\n        for (int j = 0; j < matrixB[0].size(); j++) {\n            def sum = 0\n            for (int k = 0; k < matrixB.size(); k++) {\n                sum += matrixA[i][k] * matrixB[k][j]\n            }\n            row << sum\n        }\n        result << row\n    }\n    return result\n}\ndef matrix1 = [[1, 2, 3], [4, 5, 6]]\ndef matrix2 = [[7, 8], [9, 10], [11, 12]]\nprintln 'Matrix Multiplication: ' + matrixMultiplication(matrix1, matrix2)"
  },
  {
    "language": "Groovy",
    "code": "def sieveOfEratosthenes(int n) {\n    def primes = []\n    def sieve = new boolean[n + 1]\n    for (int i = 2; i <= n; i++) {\n        if (!sieve[i]) {\n            primes << i\n            for (int j = i * i; j <= n; j += i) {\n                sieve[j] = true\n            }\n        }\n    }\n    return primes\n}\nprintln 'Primes up to 50: ' + sieveOfEratosthenes(50)"
  },
  {
    "language": "Groovy",
    "code": "def hanoi(int n, String source, String auxiliary, String destination) {\n    if (n == 1) {\n        println 'Move disk 1 from ' + source + ' to ' + destination\n        return\n    }\n    hanoi(n - 1, source, destination, auxiliary)\n    println 'Move disk ' + n + ' from ' + source + ' to ' + destination\n    hanoi(n - 1, auxiliary, source, destination)\n}\nhanoi(3, 'A', 'B', 'C')"
  },
  {
    "language": "Groovy",
    "code": "def selectionSort(list) {\n    def size = list.size()\n    for (int i = 0; i < size - 1; i++) {\n        def minIndex = i\n        for (int j = i + 1; j < size; j++) {\n            if (list[j] < list[minIndex]) minIndex = j\n        }\n        def temp = list[i]\n        list[i] = list[minIndex]\n        list[minIndex] = temp\n    }\n    return list\n}\ndef numbers = [64, 25, 12, 22, 11]\nprintln 'Sorted list: ' + selectionSort(numbers)"
  },
  {
    "language": "Groovy",
    "code": "def dijkstra(graph, start) {\n    def distances = [:].withDefault { Integer.MAX_VALUE }\n    distances[start] = 0\n    def visited = []\n    def queue = [start]\n    while (queue) {\n        def current = queue.min { distances[it] }\n        queue.remove(current)\n        visited << current\n        graph[current].each { vertex, weight ->\n            def alt = distances[current] + weight\n            if (alt < distances[vertex]) {\n                distances[vertex] = alt\n                queue << vertex\n            }\n        }\n    }\n    return distances\n}\ndef graph = [\n    A: [B: 5, C: 3],\n    B: [D: 7, C: 2],\n    C: [D: 8, E: 6],\n    D: [E: 9],\n    E: [:]\n]\ndef start = 'A'\nprintln 'Shortest distances from ' + start + ': ' + dijkstra(graph, start)"
  },
  {
    "language": "Groovy",
    "code": "class BinarySearchTree {\n    Node root\n    class Node {\n        int value\n        Node left, right\n        Node(int value) { this.value = value }\n    }\n    void insert(int value) { root = insertRec(root, value) }\n    Node insertRec(Node root, int value) {\n        if (root == null) return new Node(value)\n        if (value < root.value) root.left = insertRec(root.left, value)\n        else if (value > root.value) root.right = insertRec(root.right, value)\n        return root\n    }\n    void inOrder() { inOrderRec(root) }\n    void inOrderRec(Node root) {\n        if (root != null) {\n            inOrderRec(root.left)\n            print(root.value + ' ')\n            inOrderRec(root.right)\n        }\n    }\n}\ndef tree = new BinarySearchTree()\ntree.insert(50)\ntree.insert(30)\ntree.insert(20)\ntree.insert(40)\ntree.insert(70)\ntree.insert(60)\ntree.insert(80)\nprint 'Inorder traversal: '\ntree.inOrder()"
  },
  {
    "language": "Groovy",
    "code": "def matrixChainOrder(int p[]) {\n    def n = p.size() - 1\n    def m = new int[n][n], s = new int[n][n]\n    for (int i = 1; i < n; i++) m[i][i] = 0\n    for (int L = 2; L < n; L++) {\n        for (int i = 1; i < n - L + 1; i++) {\n            int j = i + L - 1\n            m[i][j] = Integer.MAX_VALUE\n            for (int k = i; k <= j - 1; k++) {\n                int cost = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]\n                if (cost < m[i][j]) {\n                    m[i][j] = cost\n                    s[i][j] = k\n                }\n            }\n        }\n    }\n    return [m, s]\n}\ndef p = [10, 20, 30, 40, 30]\nprintln 'Minimum number of multiplications: ' + matrixChainOrder(p)[0][1][p.size() - 1]"
  },
  {
    "language": "Groovy",
    "code": "def findLongestCommonSubsequence(String X, String Y) {\n    def m = X.size(), n = Y.size()\n    def L = new int[m + 1][n + 1]\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0) L[i][j] = 0\n            else if (X[i - 1] == Y[j - 1]) L[i][j] = L[i - 1][j - 1] + 1\n            else L[i][j] = Math.max(L[i - 1][j], L[i][j - 1])\n        }\n    }\n    def index = L[m][n], lcs = new char[index]\n    def i = m, j = n\n    while (i > 0 && j > 0) {\n        if (X[i - 1] == Y[j - 1]) {\n            lcs[--index] = X[i - 1]\n            i--\n            j--\n        } else if (L[i - 1][j] > L[i][j - 1]) i--\n        else j--\n    }\n    return new String(lcs)\n}\ndef X = 'AGGTAB'\ndef Y = 'GXTXAYB'\nprintln 'Longest Common Subsequence: ' + findLongestCommonSubsequence(X, Y)"
  },
  {
    "language": "Groovy",
    "code": "def longestIncreasingSubsequence(int arr[]) {\n    def n = arr.size()\n    def lis = new int[n]\n    lis[0] = 1\n    (1..n - 1).each { i ->\n        lis[i] = 1\n        (0..i - 1).each { j ->\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1) lis[i] = lis[j] + 1\n        }\n    }\n    return lis.max()\n}\ndef arr = [10, 22, 9, 33, 21, 50, 41, 60]\nprintln 'Length of Longest Increasing Subsequence: ' + longestIncreasingSubsequence(arr)"
  },
  {
    "language": "Groovy",
    "code": "def editDistance(String str1, String str2) {\n    def m = str1.size(), n = str2.size()\n    def dp = new int[m + 1][n + 1]\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) dp[i][j] = j\n            else if (j == 0) dp[i][j] = i\n            else if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1]\n            else dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1])\n        }\n    }\n    return dp[m][n]\n}\ndef str1 = 'sunday'\ndef str2 = 'saturday'\nprintln 'Edit Distance between strings: ' + editDistance(str1, str2)"
  },
  {
    "language": "Groovy",
    "code": "def knapsack(int W, int wt[], int val[], int n) {\n    def K = new int[n + 1][W + 1]\n    for (int i = 0; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            if (i == 0 || w == 0) K[i][w] = 0\n            else if (wt[i - 1] <= w) K[i][w] = Math.max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else K[i][w] = K[i - 1][w]\n        }\n    }\n    return K[n][W]\n}\ndef val = [60, 100, 120]\ndef wt = [10, 20, 30]\ndef W = 50\nprintln 'Maximum value in Knapsack: ' + knapsack(W, wt, val, val.size())"
  },
  {
    "language": "Groovy",
    "code": "def subsetSum(int arr[], int n, int sum) {\n    def subset = new boolean[n + 1][sum + 1]\n    for (int i = 0; i <= n; i++) subset[i][0] = true\n    for (int i = 1; i <= sum; i++) subset[0][i] = false\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) subset[i][j] = subset[i - 1][j]\n            else subset[i][j] = subset[i - 1][j] || subset[i - 1][j - arr[i - 1]]\n        }\n    }\n    return subset[n][sum]\n}\ndef arr = [3, 34, 4, 12, 5, 2]\nprintln 'Subset with sum 9 exists: ' + subsetSum(arr, arr.size(), 9)"
  },
  {
    "language": "Groovy",
    "code": "def maximumBipartiteMatching(int graph[][], int u, boolean seen[], int matchR[]) {\n    def m = graph.size(), n = graph[0].size()\n    (0..n - 1).each { v ->\n        if (graph[u][v] != 0 && !seen[v]) {\n            seen[v] = true\n            if (matchR[v] < 0 || maximumBipartiteMatching(graph, matchR[v], seen, matchR)) {\n                matchR[v] = u\n                return true\n            }\n        }\n    }\n    return false\n}\ndef maxBPM(int graph[][]) {\n    def m = graph.size(), n = graph[0].size(), result = 0\n    def matchR = new int[n]\n    matchR.fill(-1)\n    (0..m - 1).each { u ->\n        def seen = new boolean[n]\n        if (maximumBipartiteMatching(graph, u, seen, matchR)) result++\n    }\n    return result\n}\ndef graph = [[0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1]]\nprintln 'Maximum matching in Bipartite Graph: ' + maxBPM(graph)"
  },
  {
    "language": "Groovy",
    "code": "def travellingSalesmanProblem(int graph[][], int s) {\n    def V = graph.size()\n    def vertex = []\n    (0..V - 1).each { i ->\n        if (i != s) vertex.add(i)\n    }\n    def min_path = Integer.MAX_VALUE\n    while (true) {\n        def current_pathweight = 0\n        def k = s\n        (0..vertex.size() - 1).each { i ->\n            current_pathweight += graph[k][vertex[i]]\n            k = vertex[i]\n        }\n        current_pathweight += graph[k][s]\n        min_path = Math.min(min_path, current_pathweight)\n        def next_permutation = -1\n        (vertex.size() - 1).downto(0).each { i ->\n            if (i > 0 && vertex[i] > vertex[i - 1]) {\n                next_permutation = i\n                break\n            }\n        }\n        if (next_permutation == -1) break\n        def next_min = next_permutation\n        (vertex.size() - 1).downto(next_permutation).each { i ->\n            if (vertex[i] > vertex[next_permutation - 1] && vertex[i] < vertex[next_min]) next_min = i\n        }\n        def temp = vertex[next_permutation - 1]\n        vertex[next_permutation - 1] = vertex[next_min]\n        vertex[next_min] = temp\n        (next_permutation..(vertex.size() - 1)).sort().each { i ->\n            def temp = vertex[next_permutation]\n            vertex[next_permutation] = vertex[i]\n            vertex[i] = temp\n            next_permutation++\n        }\n    }\n    return min_path\n}\ndef graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ndef s = 0\nprintln 'Minimum Cost Hamiltonian Cycle: ' + travellingSalesmanProblem(graph, s)"
  },
  {
    "language": "Groovy",
    "code": "def variables() { def number = 42 def piValue = 3.14 def message = 'Hello' def isTrue = true } variables()"
  },
  {
    "language": "Groovy",
    "code": "def conditionalStatements() { def isTrue = true if (isTrue) { println 'It is true!' } else { println 'It is false!' } } conditionalStatements()"
  },
  {
    "language": "Groovy",
    "code": "def loops() { for (int i = 0; i < 5; i++) { println \"Count: $i\" } } loops()"
  },
  {
    "language": "Groovy",
    "code": "def whileLoop() { def count = 0 while (count < 5) { println \"Count: $count\" count++ } } whileLoop()"
  },
  {
    "language": "Groovy",
    "code": "def greet(name) { println \"Hello, $name!\" } greet('Alice')"
  },
  {
    "language": "Groovy",
    "code": "def list() { def fruits = ['Apple', 'Orange', 'Banana'] println fruits } list()"
  },
  {
    "language": "Groovy",
    "code": "def map() { def ages = [Alice: 25, Bob: 30, Charlie: 28] println ages } map()"
  },
  {
    "language": "Groovy",
    "code": "class Person { String name int age } def person = new Person(name: 'Alice', age: 25) println \"Name: ${person.name}, Age: ${person.age}\""
  },
  {
    "language": "Groovy",
    "code": "def fetchData() { def result = new groovy.concurrent.Promise() result.future.onComplete { println 'Data fetched!' } result.resolve() } fetchData() println 'Fetching data...'"
  },
  {
    "language": "Groovy",
    "code": "def set() { def numbers = [1, 2, 3, 4, 5] as Set println numbers } set()"
  },
  {
    "language": "Groovy",
    "code": "enum Status { PENDING, APPROVED, REJECTED } def applicationStatus = Status.APPROVED println \"Application Status: $applicationStatus\""
  },
  {
    "language": "Groovy",
    "code": "import java.util.Random def random = new Random() println \"Random number: ${random.nextInt(100)}\""
  },
  {
    "language": "Groovy",
    "code": "def userInput() { print 'Enter your name: ' def name = System.console().readLine() println \"Hello, $name!\" } userInput()"
  },
  {
    "language": "Groovy",
    "code": "def optionalArguments(name = 'Anonymous') { println \"Hello, $name!\" } optionalArguments('Alice') optionalArguments()"
  },
  {
    "language": "Groovy",
    "code": "class Bird { def fly() { println 'Flying!' } } class Sparrow extends Bird {} def sparrow = new Sparrow() sparrow.fly()"
  },
  {
    "language": "Groovy",
    "code": "String.metaClass.shout = { println \"${delegate.toUpperCase()}!!!\" } def message = 'hello' message.shout()"
  },
  {
    "language": "Groovy",
    "code": "def delayedPrint() { groovy.concurrent.Promise.delay { println 'Delayed print after 2 seconds' } } delayedPrint() println 'Printed immediately'"
  },
  {
    "language": "Groovy",
    "code": "def parallelExecution = { List items ->\n    def threads = items.collectParallel { item ->\n        Thread.start {\n            println(\"Processing $item on thread ${Thread.currentThread().name}\")\n            // Perform complex operations\n        }\n    }\n    threads*.join()\n}\nparallelExecution([1, 2, 3, 4, 5])"
  },
  {
    "language": "Groovy",
    "code": "def fibonacciSequence(int n) {\n    def fib = [0, 1]\n    (2..<n).each { fib << fib[-2] + fib[-1] }\n    return fib\n}\nprintln(fibonacciSequence(10))"
  },
  {
    "language": "Groovy",
    "code": "def asyncProcessing = { Closure closure ->\n    def result = null\n    def thread = Thread.start {\n        result = closure.call()\n    }\n    thread.join()\n    return result\n}\nprintln(asyncProcessing({\n    // Simulate time-consuming operation\n    Thread.sleep(3000)\n    return 'Async operation completed'\n}))"
  },
  {
    "language": "Groovy",
    "code": "def memoization = { Closure closure ->\n    def cache = [:].withDefault { key ->\n        def result = closure.call(key)\n        cache[key] = result\n        return result\n    }\n    return cache\n}\n// Usage:\ndef fib = memoization { n ->\n    n < 2 ? n : fib(n - 1) + fib(n - 2)\n}\nprintln(fib(10))"
  },
  {
    "language": "Groovy",
    "code": "def executeWithRetry = { Closure closure, int maxAttempts ->\n    def attempt = 0\n    while (attempt < maxAttempts) {\n        try {\n            return closure.call()\n        } catch (Exception e) {\n            println(\"Attempt $attempt failed: $e\")\n        }\n        attempt++\n    }\n    throw new RuntimeException(\"Max attempts reached\")\n}\n// Usage:\nexecuteWithRetry({\n    // Complex operation that might fail\n    if (Math.random() < 0.5) throw new RuntimeException(\"Failed\")\n    return 'Success'\n}, 3)"
  },
  {
    "language": "Groovy",
    "code": "def asyncParallelExecution = { List tasks ->\n    def results = tasks.collectParallel { task ->\n        Thread.start {\n            // Perform complex async task\n            // Store result in shared list or map\n        }\n    }\n    results*.join()\n    return results.collect { /* retrieve and process results */ }\n}\nasyncParallelExecution(['Task 1', 'Task 2', 'Task 3'])"
  },
  {
    "language": "Groovy",
    "code": "def processBigData = { List data ->\n    def batchSize = 1000\n    def results = []\n    data.each { item ->\n        // Process item and collect result\n        // Add to results list\n    }\n    return results\n}\n// Usage:\ndef bigData = /* load huge data set */\ndef processedData = processBigData(bigData)"
  },
  {
    "language": "Groovy",
    "code": "def complexSorting = { List items ->\n    // Implement a complex sorting algorithm\n    // e.g., Merge Sort, Quick Sort, etc.\n    return items.sort { a, b -> /* custom comparison logic */ }\n}\n// Usage:\ndef unsortedList = [5, 2, 7, 1, 9]\ndef sortedList = complexSorting(unsortedList)"
  },
  {
    "language": "Groovy",
    "code": "def transactionalProcessing = { Closure transaction ->\n    def transactionManager = /* retrieve transaction manager */\n    transactionManager.beginTransaction()\n    try {\n        def result = transaction.call()\n        transactionManager.commitTransaction()\n        return result\n    } catch (Exception e) {\n        transactionManager.rollbackTransaction()\n        throw e\n    }\n}\n// Usage:\ntransactionalProcessing({\n    // Perform a series of transactional operations\n    // Return the result\n})"
  },
  {
    "language": "Groovy",
    "code": "def customDSL = {\n    person {\n        name 'John Doe'\n        age 30\n        address {\n            street '123 Main St'\n            city 'Exampleville'\n        }\n    }\n}\n// Implement a DSL parser to interpret and execute this custom DSL"
  },
  {
    "language": "Groovy",
    "code": "def concurrentStreamProcessing = { List data ->\n    data.parallelStream().forEach { item ->\n        // Perform complex operations on each item concurrently\n    }\n}\n// Usage:\ndef data = ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5']\nconcurrentStreamProcessing(data)"
  },
  {
    "language": "Groovy",
    "code": "def distributedLocking = { Closure operation ->\n    def lock = DistributedLock.acquireLock('lockKey')\n    try {\n        operation()\n    } finally {\n        lock.release()\n    }\n}\n// Usage:\ndistributedLocking({ /* Perform a critical section of code */ })"
  },
  {
    "language": "Groovy",
    "code": "def eventDrivenArchitecture = {\n    def eventBus = new EventBus()\n    def subscriber = new Subscriber()\n    eventBus.subscribe(subscriber)\n    eventBus.publish(new Event())\n}\n// Implement an event-driven system"
  },
  {
    "language": "Groovy",
    "code": "def reactiveDatabaseAccess = {\n    def database = new ReactiveDatabase()\n    database.query('SELECT * FROM table').subscribe({ result ->\n        // Handle and process the query result reactively\n    })\n}\n// Implement reactive database access"
  },
  {
    "language": "Groovy",
    "code": "def machineLearningModel = {\n    def model = new MachineLearningModel()\n    model.train(trainingData)\n    return model.predict(testData)\n}\n// Implement a machine learning model"
  },
  {
    "language": "Groovy",
    "code": "def distributedMessaging = {\n    def messagingSystem = new DistributedMessaging()\n    messagingSystem.send('destination', 'message')\n    messagingSystem.receive('destination', { message ->\n        // Process received messages\n    })\n}\n// Implement distributed messaging"
  },
  {
    "language": "Groovy",
    "code": "def blockchainTransaction = {\n    def transaction = new BlockchainTransaction()\n    transaction.createTransaction(sender, receiver, amount)\n    transaction.mineBlock()\n}\n// Implement blockchain transaction logic"
  },
  {
    "language": "Groovy",
    "code": "def distributedTaskExecution = {\n    def task = new DistributedTask()\n    task.assignToCluster(cluster)\n    task.executeOnCluster()\n}\n// Implement distributed task execution"
  },
  {
    "language": "Groovy",
    "code": "def quantumComputingSimulation = {\n    def quantumComputer = new QuantumComputer()\n    quantumComputer.runSimulation()\n    return quantumComputer.getResults()\n}\n// Simulate quantum computing operations"
  },
  {
    "language": "Groovy",
    "code": "def geneticAlgorithm = {\n    def algorithm = new GeneticAlgorithm()\n    algorithm.initializePopulation()\n    algorithm.evolvePopulation()\n    return algorithm.getFittestIndividual()\n}\n// Implement a genetic algorithm"
  },
  {
    "language": "Groovy",
    "code": "def deepLearningModel = {\n    def model = new DeepLearningModel()\n    model.buildNeuralNetwork()\n    model.train(trainingData)\n    return model.predict(testData)\n}\n// Implement a deep learning model"
  },
  {
    "language": "Groovy",
    "code": "def distributedGraphProcessing = {\n    def graph = new DistributedGraph()\n    graph.loadNodesAndEdges()\n    graph.processWithMapReduce()\n}\n// Implement distributed graph processing"
  },
  {
    "language": "Groovy",
    "code": "def continuousIntegrationPipeline = {\n    def pipeline = new ContinuousIntegrationPipeline()\n    pipeline.runTests()\n    pipeline.buildartifacts()\n    pipeline.deployToProduction()\n}\n// Create a continuous integration pipeline"
  },
  {
    "language": "Groovy",
    "code": "def evolutionaryStrategy = {\n    def strategy = new EvolutionaryStrategy()\n    strategy.initializePopulation()\n    strategy.evolvePopulation()\n    return strategy.getFittestIndividual()\n}\n// Implement an evolutionary strategy"
  },
  {
    "language": "Groovy",
    "code": "def distributedFileSystem = {\n    def fileSystem = new DistributedFileSystem()\n    fileSystem.readFile('file.txt')\n    fileSystem.writeFile('file.txt', 'content')\n}\n// Implement a distributed file system"
  },
  {
    "language": "Groovy",
    "code": "def quantumCryptography = {\n    def cryptography = new QuantumCryptography()\n    cryptography.generateKeys()\n    cryptography.encryptMessage(message)\n}\n// Implement quantum cryptography operations"
  },
  {
    "language": "Groovy",
    "code": "def naturalLanguageProcessing = {\n    def nlpProcessor = new NLPProcessor()\n    nlpProcessor.analyzeText('text')\n    nlpProcessor.generateSummary('text')\n}\n// Implement natural language processing tasks"
  },
  {
    "language": "Groovy",
    "code": "def realTimeDataProcessing = {\n    def streamProcessor = new RealTimeDataProcessor()\n    streamProcessor.consumeStream('stream')\n    streamProcessor.processData()\n}\n// Implement real-time data processing"
  },
  {
    "language": "Groovy",
    "code": "def autonomousRobotics = {\n    def robot = new AutonomousRobot()\n    robot.navigateEnvironment()\n    robot.performTasks()\n}\n// Implement autonomous robotics functionalities"
  },
  {
    "language": "Groovy",
    "code": "def federatedLearning = {\n    def learningSystem = new FederatedLearningSystem()\n    learningSystem.initializeNodes()\n    learningSystem.trainModelWithFederation()\n}\n// Implement federated learning"
  },
  {
    "language": "Groovy",
    "code": "def chaosEngineeringAutomation = {\n    def automation = new ChaosEngineeringAutomation()\n    automation.injectFaultsRandomly()\n    automation.analyzeSystemBehavior()\n}\n// Automate chaos engineering for system testing"
  },
  {
    "language": "Groovy",
    "code": "def quantumErrorCorrection = {\n    def errorCorrection = new QuantumErrorCorrection()\n    errorCorrection.detectAndCorrectErrors()\n}\n// Implement quantum error correction mechanisms"
  },
  {
    "language": "Groovy",
    "code": "def selfDrivingCarSimulation = {\n    def simulation = new SelfDrivingCarSimulation()\n    simulation.generateVirtualEnvironment()\n    simulation.testAutonomousDrivingAlgorithms()\n}\n// Simulate self-driving car operations"
  },
  {
    "language": "Groovy",
    "code": "def distributedGenomicAnalysis = {\n    def genomicAnalyzer = new DistributedGenomicAnalyzer()\n    genomicAnalyzer.loadGenomicData()\n    genomicAnalyzer.analyzeWithParallelProcessing()\n}\n// Perform distributed analysis of genomic data"
  },
  {
    "language": "Groovy",
    "code": "def augmentedRealityRendering = {\n    def renderer = new AugmentedRealityRenderer()\n    renderer.loadARModels()\n    renderer.renderWithReal-timeTracking()\n}\n// Implement augmented reality rendering"
  },
  {
    "language": "Groovy",
    "code": "def quantumTeleportation = {\n    def teleporter = new QuantumTeleporter()\n    teleporter.prepareEntangledParticles()\n    teleporter.transferQuantumState()\n}\n// Simulate quantum teleportation process"
  },
  {
    "language": "Groovy",
    "code": "def autonomousDroneNavigation = {\n    def drone = new AutonomousDrone()\n    drone.planFlightPath()\n    drone.navigatetoDestination()\n}\n// Implement autonomous drone navigation"
  },
  {
    "language": "Groovy",
    "code": "def medicalImageProcessing = {\n    def imageProcessor = new MedicalImageProcessor()\n    imageProcessor.loadImages()\n    imageProcessor.applyImageAnalysis()\n}\n// Perform processing on medical images"
  },
  {
    "language": "Groovy",
    "code": "def distributedEnergyGrid = {\n    def energyGrid = new DistributedEnergyGrid()\n    energyGrid.monitorAndBalance()\n    energyGrid.optimizeDistribution()\n}\n// Manage and optimize distributed energy grids"
  },
  {
    "language": "Groovy",
    "code": "def chaosEngineering = {\n    def chaosEngine = new ChaosEngine()\n    chaosEngine.injectFaults(system)\n    chaosEngine.monitorAndReport()\n}\n// Implement chaos engineering for system resilience testing"
  },
  {
    "language": "Groovy",
    "code": "def regexExample() { def text = 'There are 123 apples' def pattern = /\\d+/ def matches = (text =~ pattern) matches.each { println \"Match: ${it}\" } } regexExample()"
  },
  {
    "language": "Groovy",
    "code": "def name = 'Alice'\nprintln 'Hello, $name!'"
  },
  {
    "language": "Groovy",
    "code": "int number = 7\nif (number % 2 == 0) {\n    println 'Even'\n} else {\n    println 'Odd'\n}"
  },
  {
    "language": "Groovy",
    "code": "int n = 5\nfor (int i = 1; i <= n; i++) {\n    println '*' * i\n}"
  },
  {
    "language": "Haskell",
    "code": "main :: IO () main = putStrLn \"Hello, World!\""
  },
  {
    "language": "Haskell",
    "code": "module ParallelExecution where\nimport Control.Parallel\n\nparallelExecution :: [IO ()] -> IO ()\nparallelExecution tasks = sequence_ tasks `par` return ()"
  },
  {
    "language": "Haskell",
    "code": "module GeneticAlgorithm where\nimport Control.Monad.Random\nimport Data.List\n\ntype Individual = [Bool]\ncrossover :: Individual -> Individual -> IO Individual\nmutation :: Individual -> IO Individual\nselection :: [Individual] -> IO Individual\ngeneticAlgorithm :: Int -> Int -> Int -> IO Individual"
  },
  {
    "language": "Haskell",
    "code": "module QuantumComputing where\nimport Quantum\n\nsimulateQuantumCircuit :: QuantumCircuit -> IO QuantumState\nrunQuantumAlgorithm :: QuantumAlgorithm -> IO QuantumResult"
  },
  {
    "language": "Haskell",
    "code": "module NaturalLanguageProcessing where\nimport Text.Parsec\n\nparseText :: String -> Either ParseError AST\nanalyzeText :: AST -> AnalysisResult"
  },
  {
    "language": "Haskell",
    "code": "module DistributedSystems where\nimport Network.Socket\n\ncreateSocket :: IO Socket\nsendData :: Socket -> String -> IO ()\nreceiveData :: Socket -> IO String"
  },
  {
    "language": "Haskell",
    "code": "module Concurrency where\nimport Control.Concurrent\n\nconcurrentExecution :: [IO ()] -> IO ()\nconcurrentExecution tasks = mapM_ (forkIO . void) tasks"
  },
  {
    "language": "Haskell",
    "code": "module NeuralNetwork where\nimport Numeric.LinearAlgebra\n\ncreateNeuralNetwork :: Int -> Int -> Int -> IO NeuralNetwork\ntrainNeuralNetwork :: NeuralNetwork -> TrainingData -> IO ()\npredictNeuralNetwork :: NeuralNetwork -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module QuantumErrorCorrection where\nimport QuantumError\n\ndetectErrors :: QuantumState -> Error\ncorrectErrors :: QuantumState -> Error -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module ChaosEngineering where\nimport System.Random\n\ninjectFaults :: System -> IO ()\nanalyzeSystemBehavior :: System -> IO SystemBehavior"
  },
  {
    "language": "Haskell",
    "code": "module Blockchain where\nimport Crypto.Hash\n\ncreateTransaction :: Wallet -> Wallet -> Amount -> IO Transaction\nmineBlock :: Blockchain -> IO ()"
  },
  {
    "language": "Haskell",
    "code": "module QuantumCryptography where\nimport Quantum\n\ngenerateKeys :: IO KeyPair\nencryptMessage :: Message -> Key -> IO EncryptedMessage"
  },
  {
    "language": "Haskell",
    "code": "module ReactiveProgramming where\nimport Reactive\n\nsubscribeToStream :: Stream -> (Event -> IO ()) -> IO Subscription\npublishToStream :: Stream -> Event -> IO ()"
  },
  {
    "language": "Haskell",
    "code": "module AutonomousRobotics where\nimport Robotics\n\nnavigateEnvironment :: Environment -> Robot -> IO ()\nperformTasks :: Robot -> [Task] -> IO ()"
  },
  {
    "language": "Haskell",
    "code": "module QuantumTeleportation where\nimport Quantum\n\nprepareEntangledParticles :: IO EntangledParticles\ntransferQuantumState :: EntangledParticles -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module DistributedGenomicAnalysis where\nimport Genomics\n\nloadGenomicData :: FilePath -> IO GenomicData\nanalyzeWithParallelProcessing :: GenomicData -> IO AnalysisResult"
  },
  {
    "language": "Haskell",
    "code": "module DistributedAI where\nimport AI\n\ntrainModel :: Model -> TrainingData -> IO TrainedModel\nloadModel :: FilePath -> IO Model\npredictWithModel :: TrainedModel -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module DistributedComputing where\nimport Network.Socket\n\ncreateSocket :: IO Socket\nsendData :: Socket -> String -> IO ()\nreceiveData :: Socket -> IO String\nperformComputation :: ComputationTask -> IO ComputationResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumAlgorithm where\nimport Quantum\n\nrunAlgorithm :: Algorithm -> IO AlgorithmResult\noptimizeAlgorithm :: Algorithm -> IO OptimizedAlgorithm"
  },
  {
    "language": "Haskell",
    "code": "module MachineLearning where\nimport AI\nimport Data.Matrix\n\ntrainModel :: Model -> TrainingData -> IO TrainedModel\npredictWithModel :: TrainedModel -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module IoTDevices where\nimport Network.Socket\n\ncollectSensorData :: Sensor -> IO SensorData\ntransmitData :: Socket -> SensorData -> IO ()\nreceiveCommand :: Socket -> IO Command"
  },
  {
    "language": "Haskell",
    "code": "module Cryptography where\nimport Crypto\n\nencryptData :: PlainData -> Key -> IO EncryptedData\ndecryptData :: EncryptedData -> Key -> IO PlainData"
  },
  {
    "language": "Haskell",
    "code": "module DataAnalysis where\nimport Statistics\n\nperformAnalysis :: Dataset -> AnalysisType -> IO AnalysisResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumSimulation where\nimport Quantum\n\nsimulateQuantumSystem :: QuantumSystem -> IO SimulatedSystem\nanalyzeSimulatedSystem :: SimulatedSystem -> IO SystemAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module ImageProcessing where\nimport Vision\n\nprocessImage :: Image -> ProcessingOptions -> IO ProcessedData"
  },
  {
    "language": "Haskell",
    "code": "module CompilerDesign where\nimport Compiler\n\ndesignCompiler :: LanguageSpecification -> IO Compiler\ncompileCode :: Compiler -> SourceCode -> IO ExecutableCode"
  },
  {
    "language": "Haskell",
    "code": "module Robotics where\nimport Control.Robotics\n\nperformTask :: Robot -> Task -> IO TaskResult\nsimulateEnvironment :: Environment -> Robot -> IO SimulationResult"
  },
  {
    "language": "Haskell",
    "code": "module FinancialAnalytics where\nimport Finance\n\nanalyzeMarket :: MarketData -> AnalysisType -> IO AnalysisResult\npredictStock :: StockData -> IO StockPrediction"
  },
  {
    "language": "Haskell",
    "code": "module Simulation where\nimport Control.Monad\n\nrunSimulation :: SimulationEnvironment -> Simulation -> IO SimulationResult\noptimizeSimulation :: Simulation -> IO OptimizedSimulation"
  },
  {
    "language": "Haskell",
    "code": "module QuantumErrorCorrection where\nimport Quantum\n\ndetectErrors :: QuantumState -> IO [Error]\ncorrectErrors :: QuantumState -> [Error] -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module CryptographicProtocols where\nimport Crypto\n\nperformHandshake :: Protocol -> IO HandshakeResult\nestablishSecureConnection :: HandshakeResult -> IO SecureConnection"
  },
  {
    "language": "Haskell",
    "code": "module DistributedControlSystems where\nimport ControlSystems\n\ncontrolSystem :: System -> IO ControlSystem\nsimulateControl :: ControlSystem -> Input -> IO Output\noptimizeControlSystem :: ControlSystem -> IO OptimizedControlSystem"
  },
  {
    "language": "Haskell",
    "code": "module QuantumEntanglement where\nimport Quantum\n\nprepareEntangledPair :: IO EntangledPair\ntransferEntangledState :: EntangledPair -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module BigDataAnalytics where\nimport Data.BigData\n\nprocessBigData :: BigDataSet -> IO ProcessedData\nanalyzeTrends :: ProcessedData -> IO TrendsAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module Cryptocurrency where\nimport Blockchain\n\nmineBlock :: Blockchain -> IO Block\nvalidateTransaction :: Transaction -> IO Bool"
  },
  {
    "language": "Haskell",
    "code": "module QuantumRouting where\nimport Quantum\n\nrouteQuantumData :: QuantumData -> IO RoutedData\nmanageQuantumNetwork :: QuantumNetwork -> IO ManagedNetwork"
  },
  {
    "language": "Haskell",
    "code": "module QuantumAnnealing where\nimport Quantum\n\nannealQuantumSystem :: QuantumSystem -> IO AnnealedSystem\noptimizeAnnealing :: AnnealedSystem -> IO OptimizedSystem"
  },
  {
    "language": "Haskell",
    "code": "module CompilerOptimization where\nimport Compiler\n\noptimizeCompiler :: Compiler -> IO OptimizedCompiler\nimproveCode :: OptimizedCompiler -> SourceCode -> IO ImprovedCode"
  },
  {
    "language": "Haskell",
    "code": "module AutonomousAgents where\nimport Agents\n\ncreateAgent :: AgentSpecification -> IO Agent\ntrainAgent :: Agent -> TrainingData -> IO TrainedAgent"
  },
  {
    "language": "Haskell",
    "code": "module QuantumCommunication where\nimport Quantum\n\nsendQuantumMessage :: QuantumMessage -> IO SentMessage\nreceiveQuantumMessage :: IO QuantumMessage"
  },
  {
    "language": "Haskell",
    "code": "module DistributedSearch where\nimport Network.Search\n\nsearchContent :: Query -> IO SearchResults\nindexContent :: Content -> IO Index"
  },
  {
    "language": "Haskell",
    "code": "module GenomeAnalysis where\nimport Genetics\n\nanalyzeGenome :: Genome -> IO AnalysisResult\ncompareGenomes :: Genome -> Genome -> IO GenomeComparison"
  },
  {
    "language": "Haskell",
    "code": "module QuantumOptimization where\nimport Quantum\n\noptimizeQuantumAlgorithm :: QuantumAlgorithm -> IO OptimizedAlgorithm\nimproveQuantumPerformance :: OptimizedAlgorithm -> IO ImprovedPerformance"
  },
  {
    "language": "Haskell",
    "code": "module DistributedRobotics where\nimport Robotics\n\ncoordinateRobots :: [Robot] -> IO CoordinatedRobots\nsimulateRoboticSwarm :: CoordinatedRobots -> IO SwarmSimulation"
  },
  {
    "language": "Haskell",
    "code": "module QuantumDataStorage where\nimport Quantum\n\nstoreQuantumData :: QuantumData -> IO StoredData\nretrieveQuantumData :: IO QuantumData"
  },
  {
    "language": "Haskell",
    "code": "module QuantumMetaProgramming where\nimport Quantum\n\nprogramQuantumComputers :: QuantumProgram -> IO ProgrammedComputers\nverifyQuantumCode :: ProgrammedComputers -> IO VerificationResult"
  },
  {
    "language": "Haskell",
    "code": "module QuantumEncryption where\nimport Quantum\n\nencryptData :: PlainData -> Key -> IO EncryptedData\ndecryptData :: EncryptedData -> Key -> IO PlainData"
  },
  {
    "language": "Haskell",
    "code": "module ComputationalBiology where\nimport Biology\n\nsimulateCellularProcesses :: Cell -> IO ProcessSimulation\nanalyzeGeneticSequences :: GeneticSequence -> IO SequenceAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module QuantumRouting where\nimport Quantum\n\nrouteQuantumData :: QuantumData -> IO RoutedData\nmanageQuantumNetwork :: QuantumNetwork -> IO ManagedNetwork"
  },
  {
    "language": "Haskell",
    "code": "module FinancialForecasting where\nimport Finance\n\nforecastMarket :: MarketData -> IO MarketForecast\nanalyzeTrends :: MarketData -> IO TrendsAnalysis"
  },
  {
    "language": "Haskell",
    "code": "module QuantumEntanglement where\nimport Quantum\n\ncreateEntangledPair :: IO EntangledPair\ntransferEntangledState :: EntangledPair -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module QuantumErrorCorrection where\nimport Quantum\n\ndetectErrors :: QuantumState -> IO [Error]\ncorrectErrors :: QuantumState -> [Error] -> IO QuantumState"
  },
  {
    "language": "Haskell",
    "code": "module DistributedSystems where\nimport Network.Socket\n\ncreateSocket :: IO Socket\nsendData :: Socket -> String -> IO ()\nreceiveData :: Socket -> IO String"
  },
  {
    "language": "Haskell",
    "code": "module QuantumNetworkSecurity where\nimport Quantum\n\nestablishSecureConnection :: QuantumNetwork -> IO SecureConnection\nmonitorNetwork :: SecureConnection -> IO NetworkMonitoring"
  },
  {
    "language": "Haskell",
    "code": "module CryptographicHashing where\nimport Crypto.Hash\n\nhashData :: PlainData -> IO HashedData\nverifyHash :: HashedData -> PlainData -> IO Bool"
  },
  {
    "language": "Haskell",
    "code": "module NeuralNetworkTraining where\nimport AI\n\ntrainNetwork :: NeuralNetwork -> TrainingData -> IO TrainedNetwork\npredictWithNetwork :: TrainedNetwork -> InputData -> IO OutputData"
  },
  {
    "language": "Haskell",
    "code": "module QuantumSimulation where\nimport Quantum\n\nsimulateQuantumSystem :: QuantumSystem -> IO SimulatedSystem\nanalyzeSimulatedSystem :: SimulatedSystem -> IO SystemAnalysis"
  },
  {
    "language": "Lisp",
    "code": "(defun hello-world () (format t \"Hello, World!\")) (hello-world)"
  },
  {
    "language": "Lisp",
    "code": "(defun variables () (let ((number 42) (piValue 3.14) (message \"Hello\") (isTrue t)) (format t \"Variables defined\"))) (variables)"
  },
  {
    "language": "Lisp",
    "code": "(defun parallel-processing (tasks)\n  (mapc #'sb-thread:make-thread tasks))"
  },
  {
    "language": "Lisp",
    "code": "(defun genetic-algorithm (population)\n  (loop\n    repeat generations\n    do (let* ((selected (selection population))\n             (offspring (crossover selected))\n             (mutated (mutation offspring)))\n         (setf population (replace-subseq population mutated\n                              :start1 (position (min-by fitness population) population)\n                              :end1 (position (max-by fitness population) population)))))\n  (min-by fitness population))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-computing (circuit)\n  (let ((state (initialize-quantum-state circuit)))\n    (loop for gate in circuit do\n      (apply-gate state gate))\n    state))"
  },
  {
    "language": "Lisp",
    "code": "(defun natural-language-processing (text)\n  (let ((parsed (parse-text text)))\n    (analyze-parsed-text parsed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-systems (tasks)\n  (loop for task in tasks do\n    (sb-thread:make-thread (lambda () (perform-task task)))))"
  },
  {
    "language": "Lisp",
    "code": "(defun concurrency (tasks)\n  (mapc #'sb-thread:make-thread tasks))"
  },
  {
    "language": "Lisp",
    "code": "(defun neural-network (input)\n  (let ((network (create-neural-network)))\n    (train-neural-network network input)\n    (predict-neural-network network input)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-error-correction (state)\n  (let ((errors (detect-errors state)))\n    (correct-errors state errors)))"
  },
  {
    "language": "Lisp",
    "code": "(defun chaos-engineering (system)\n  (inject-faults system)\n  (analyze-system-behavior system))"
  },
  {
    "language": "Lisp",
    "code": "(defun blockchain (transaction)\n  (create-transaction transaction)\n  (mine-block))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-cryptography (message)\n  (let ((keys (generate-keys)))\n    (encrypt-message message keys)))"
  },
  {
    "language": "Lisp",
    "code": "(defun reactive-programming (stream)\n  (subscribe-to-stream stream)\n  (publish-to-stream stream))"
  },
  {
    "language": "Lisp",
    "code": "(defun autonomous-robotics (tasks)\n  (loop for task in tasks do\n    (plan-task task)\n    (execute-task task)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-teleportation (state)\n  (let ((particles (prepare-entangled-particles)))\n    (transfer-quantum-state state particles)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-genomic-analysis (data)\n  (let ((analysis (analyze-genomic-data data)))\n    (process-analysis-in-parallel analysis)))"
  },
  {
    "language": "Lisp",
    "code": "(defun federated-learning (model)\n  (let ((nodes (initialize-nodes)))\n    (train-model-with-federation model nodes)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-entanglement (particles)\n  (let ((state (create-entangled-state particles)))\n    (transfer-state state)))"
  },
  {
    "language": "Lisp",
    "code": "(defun big-data-analytics (data)\n  (let ((processed (process-big-data data)))\n    (analyze-trends processed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-routing (data)\n  (let ((routed (route-quantum-data data)))\n    (manage-quantum-network routed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-annealing (system)\n  (let ((annealed (anneal-quantum-system system)))\n    (optimize-annealing annealed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun compiler-optimization (compiler)\n  (let ((optimized (optimize-compiler compiler)))\n    (improve-code optimized)))"
  },
  {
    "language": "Lisp",
    "code": "(defun autonomous-agents (agents)\n  (loop for agent in agents do\n    (create-agent agent)\n    (train-agent agent)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-communication (message)\n  (let ((sent (send-quantum-message message)))\n    (receive-quantum-message)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-search (query)\n  (let ((results (search-content query)))\n    (index-content results)))"
  },
  {
    "language": "Lisp",
    "code": "(defun genome-analysis (genome)\n  (let ((analysis (analyze-genome genome)))\n    (compare-genomes analysis)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-encryption (data)\n  (let ((encrypted (encrypt-data data)))\n    (decrypt-data encrypted)))"
  },
  {
    "language": "Lisp",
    "code": "(defun computational-biology (cell)\n  (let ((simulation (simulate-cellular-processes cell)))\n    (analyze-genetic-sequences simulation)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-routing (data)\n  (let ((routed (route-quantum-data data)))\n    (manage-quantum-network routed)))"
  },
  {
    "language": "Lisp",
    "code": "(defun financial-forecasting (market-data)\n  (let ((forecast (forecast-market market-data)))\n    (analyze-trends forecast)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-entanglement (particles)\n  (let ((state (create-entangled-state particles)))\n    (transfer-state state)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-error-correction (state)\n  (let ((errors (detect-errors state)))\n    (correct-errors state errors)))"
  },
  {
    "language": "Lisp",
    "code": "(defun distributed-systems (tasks)\n  (loop for task in tasks do\n    (perform-distributed-task task)))"
  },
  {
    "language": "Lisp",
    "code": "(defun quantum-network-security (network)\n  (let ((connection (establish-secure-connection network)))\n    (monitor-secure-connection connection)))"
  },
  {
    "language": "Lisp",
    "code": "(defun cryptographic-hashing (data)\n  (let ((hashed (hash-data data)))\n    (verify-hash hashed data)))"
  },
  {
    "language": "Lisp",
    "code": "(defun neural-network-training (network)\n  (let ((trained (train-network network)))\n    (predict-with-network trained)))"
  },
  {
    "language": "Lisp",
    "code": "(defun conditional-statements (isTrue) (if isTrue (format t \"It is true!\") (format t \"It is false!\"))) (conditional-statements t)"
  },
  {
    "language": "Lisp",
    "code": "(defun loops () (dotimes (i 5) (format t \"Count: ~A~%\" i))) (loops)"
  },
  {
    "language": "Lisp",
    "code": "(defun while-loop (count) (if (< count 5) (progn (format t \"Count: ~A~%\" count) (while-loop (+ count 1))))) (while-loop 0)"
  },
  {
    "language": "Lisp",
    "code": "(defun greet (name) (format t \"Hello, ~A!~%\" name)) (greet \"Alice\")"
  },
  {
    "language": "Lisp",
    "code": "(defun list-example () (let ((fruits '(\"Apple\" \"Orange\" \"Banana\"))) (print fruits))) (list-example)"
  },
  {
    "language": "Lisp",
    "code": "(defun map-example () (let ((ages '((Alice . 25) (Bob . 30) (Charlie . 28)))) (print ages))) (map-example)"
  },
  {
    "language": "Lisp",
    "code": "(defstruct person name age) (let ((person (make-person :name \"Alice\" :age 25))) (format t \"Name: ~A~%\" (person-name person)) (format t \"Age: ~A~%\" (person-age person)))"
  },
  {
    "language": "Lisp",
    "code": "(defun fetch-data () (format t \"Fetching data...~%\") (format t \"Data fetched!\")) (fetch-data)"
  },
  {
    "language": "Lisp",
    "code": "(defun set-example () (let ((numbers (list 1 2 3 4 5))) (print (remove-duplicates numbers)))) (set-example)"
  },
  {
    "language": "Lisp",
    "code": "(defparameter *status* '(pending approved rejected)) (let ((application-status (nth 1 *status*))) (format t \"Application Status: ~A~%\" application-status))"
  },
  {
    "language": "Lisp",
    "code": "(ql:quickload :cl-random) (let ((random-number (random:random 100))) (format t \"Random number: ~A~%\" random-number))"
  },
  {
    "language": "Lisp",
    "code": "(defun user-input () (format t \"Enter your name: \") (let ((name (read-line))) (format t \"Hello, ~A!~%\" name))) (user-input)"
  },
  {
    "language": "Lisp",
    "code": "(defun optional-arguments (&optional (name \"Anonymous\")) (format t \"Hello, ~A!~%\" name)) (optional-arguments \"Alice\") (optional-arguments)"
  },
  {
    "language": "Lisp",
    "code": "(defclass bird () ()) (defmethod fly ((bird bird)) (format t \"Flying!\")) (let ((sparrow (make-instance 'bird))) (fly sparrow))"
  },
  {
    "language": "Lisp",
    "code": "(defun shout (msg) (format t \"~A!!!~%\" (string-upcase msg))) (shout \"hello\")"
  },
  {
    "language": "Lisp",
    "code": "(defun delayed-print () (format t \"Printed immediately~%\") (sleep 2) (format t \"Delayed print after 2 seconds~%\")) (delayed-print)"
  },
  {
    "language": "Lisp",
    "code": "(ql:quickload :cl-ppcre) (let ((text \"There are 123 apples\") (matches (ppcre:all-matches-as-strings \"\\\\d+\" \"There are 123 apples\"))) (mapc #'(lambda (match) (format t \"Match: ~A~%\" match)) matches))"
  },
  {
    "language": "Lisp",
    "code": "(defun hello-world ()\n  (format t \"Hello, World!\"))\n(hello-world)"
  },
  {
    "language": "Lisp",
    "code": "(defun add (a b)\n  (+ a b))\n(print (add 3 5))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (i 5)\n  (format t \"Value: ~A~%\" i))"
  },
  {
    "language": "Lisp",
    "code": "(defparameter *names* '(\"Alice\" \"Bob\" \"Charlie\"))\n(mapc #'(lambda (name)\n          (format t \"Hello, ~A!~%\" name))\n      *names*)"
  },
  {
    "language": "Lisp",
    "code": "(defun concatenate (a b)\n  (format nil \"~A, ~A!\" a b))\n(println (concatenate \"Hello\" \"Alice\"))"
  },
  {
    "language": "Lisp",
    "code": "(defun calculate-area (radius)\n  (* 3.14 (* radius radius)))\n(print (calculate-area 7.0))"
  },
  {
    "language": "Lisp",
    "code": "(if (> 10 5)\n    (format t \"Number is greater than 5~%\")\n    (format t \"Number is less than or equal to 5~%\"))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (x 5)\n  (format t \"Value: ~A~%\" x))"
  },
  {
    "language": "Lisp",
    "code": "(mapcar #'(lambda (num)\n            (format t \"Number: ~A~%\" num))\n        '(1 2 3 4 5))"
  },
  {
    "language": "Lisp",
    "code": "(format t \"This is a Lisp program~%\")"
  },
  {
    "language": "Lisp",
    "code": "(defun greet (name)\n  (format t \"Hello, ~A!\" name))\n(greet \"Alice\")"
  },
  {
    "language": "Lisp",
    "code": "(defun is-even (n)\n  (= (mod n 2) 0))\n(print (is-even 7))"
  },
  {
    "language": "Lisp",
    "code": "(dotimes (i 5)\n  (dotimes (j (1+ i))\n    (format t \"*\")\n  )\n  (format t \"~%\"))"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func variables() { number := 42 piValue := 3.14 message := \"Hello\" isTrue := true fmt.Println(number, piValue, message, isTrue) } func main() { variables() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func conditionalStatements(isTrue bool) { if isTrue { fmt.Println(\"It is true!\") } else { fmt.Println(\"It is false!\") } } func main() { conditionalStatements(true) }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func loops() { for i := 0; i < 5; i++ { fmt.Println(\"Count:\", i) } } func main() { loops() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func whileLoop() { count := 0 for count < 5 { fmt.Println(\"Count:\", count) count++ } } func main() { whileLoop() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func greet(name string) { fmt.Println(\"Hello,\", name+\"!\") } func main() { greet(\"Alice\") }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func list() { fruits := []string{\"Apple\", \"Orange\", \"Banana\"} fmt.Println(fruits) } func main() { list() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func mapExample() { ages := map[string]int{\"Alice\": 25, \"Bob\": 30, \"Charlie\": 28} fmt.Println(ages) } func main() { mapExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" type Person struct { name string age int } func main() { person := Person{name: \"Alice\", age: 25} fmt.Println(\"Name:\", person.name, \"Age:\", person.age) }"
  },
  {
    "language": "Go",
    "code": "package main import ( \"fmt\" \"time\" ) func fetchData() { fmt.Println(\"Fetching data...\") time.Sleep(2 * time.Second) fmt.Println(\"Data fetched!\") } func main() { fetchData() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func set() { numbers := map[int]bool{1: true, 2: true, 3: true, 4: true, 5: true} fmt.Println(numbers) } func main() { set() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" type Status int const ( PENDING Status = iota APPROVED REJECTED ) func main() { applicationStatus := APPROVED fmt.Println(\"Application Status:\", applicationStatus) }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"math/rand\" func randomNumbers() { fmt.Println(\"Random number:\", rand.Intn(100)) } func main() { randomNumbers() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func userInput() { var name string fmt.Print(\"Enter your name: \") fmt.Scanln(&name) fmt.Println(\"Hello,\", name+\"!\") } func main() { userInput() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func optionalArguments(names ...string) { for _, name := range names { fmt.Println(\"Hello,\", name+\"!\") } } func main() { optionalArguments(\"Alice\", \"Bob\") optionalArguments() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func structs() { type Rectangle struct { width, height int } var rect Rectangle rect.width = 10 rect.height = 20 fmt.Println(\"Rectangle:\", rect) } func main() { structs() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" import \"os\" func fileIO() { file, err := os.Create(\"test.txt\") if err != nil { fmt.Println(\"Error creating file:\", err) return } defer file.Close() file.WriteString(\"Hello, Go!\") fmt.Println(\"File created and written to.\") } func main() { fileIO() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func deferExample() { defer fmt.Println(\"World!\") fmt.Println(\"Hello,\") } func main() { deferExample() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func panicRecover() { defer func() { if r := recover(); r != nil { fmt.Println(\"Recovered from panic:\", r) } }() panic(\"Panic occurred!\") } func main() { panicRecover() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func channels() { ch := make(chan int) go func() { ch <- 42 }() fmt.Println(\"Channel value:\", <-ch) } func main() { channels() }"
  },
  {
    "language": "Go",
    "code": "package main import \"fmt\" func selectExample() { ch1 := make(chan string) ch2 := make(chan string) go func() { ch1 <- \"Hello\" }() go func() { ch2 <- \"World\" }() select { case msg1 := <-ch1: fmt.Println(\"Received:\", msg1) case msg2 := <-ch2: fmt.Println(\"Received:\", msg2) } } func main() { selectExample() }"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, Go!\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(\"Square root of 16 is:\", math.Sqrt(16))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := add(3, 7)\n\tfmt.Println(\"Sum:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(i)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x int\n\tfmt.Println(\"Enter a number:\")\n\tfmt.Scan(&x)\n\tfmt.Println(\"You entered:\", x)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a, b int = 5, 10\n\tfmt.Printf(\"Before swap: a = %d, b = %d\\n\", a, b)\n\t// Swap logic\n\ta, b = b, a\n\tfmt.Printf(\"After swap: a = %d, b = %d\\n\", a, b)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar message = make(chan string)\n\tgo func() {\n\t\tmessage <- \"Hello, Go Concurrency!\"\n\t}()\n\treceivedMessage := <-message\n\tfmt.Println(receivedMessage)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfruits := []string{\"apple\", \"banana\", \"orange\"}\n\tfor index, fruit := range fruits {\n\t\tfmt.Printf(\"Index: %d, Fruit: %s\\n\", index, fruit)\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tconst pi = 3.14159\n\tfmt.Printf(\"Value of pi: %f\\n\", pi)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"Deferred statement 1\")\n\tdefer fmt.Println(\"Deferred statement 2\")\n\tfmt.Println(\"Main function\")\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar age int\n\tswitch {\n\tcase age < 18:\n\t\tfmt.Println(\"You are a minor.\")\n\tcase age >= 18 && age < 60:\n\t\tfmt.Println(\"You are an adult.\")\n\tdefault:\n\t\tfmt.Println(\"You are a senior citizen.\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcurrentHour := time.Now().Hour()\n\tif currentHour < 12 {\n\t\tfmt.Println(\"Good morning!\")\n\t} else if currentHour < 17 {\n\t\tfmt.Println(\"Good afternoon!\")\n\t} else {\n\t\tfmt.Println(\"Good evening!\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar x interface{}\n\tx = 42\n\tswitch x.(type) {\n\tcase int:\n\t\tfmt.Println(\"x is an integer\")\n\tcase string:\n\t\tfmt.Println(\"x is a string\")\n\tdefault:\n\t\tfmt.Println(\"x is of unknown type\")\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4, 5}\n\t// Doubling each element in the slice\n\tfor i := range numbers {\n\t\tnumbers[i] *= 2\n\t}\n\tfmt.Println(\"Doubled numbers:\", numbers)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Your code here\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateSum(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := calculateSum(10, 20)\n\tfmt.Println(\"Sum is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}\n\nfunc main() {\n\tresult := fibonacci(10)\n\tfmt.Println(\"Fibonacci of 10 is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc printTime() {\n\tfmt.Println(\"Current time:\", time.Now())\n}\n\nfunc main() {\n\t// Your code here\n\tprintTime()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc findMax(nums ...int) int {\n\tmax := nums[0]\n\tfor _, num := range nums {\n\t"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc reverseString(input string) string {\n\tchars := strings.Split(input, \"\")\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn strings.Join(chars, \"\")\n}\n\nfunc main() {\n\toriginal := \"Hello, Go!\"\n\treversed := reverseString(original)\n\tfmt.Printf(\"Original: %s, Reversed: %s\\n\", original, reversed)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateRandomNumber() int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(100)\n}\n\nfunc main() {\n\trandomNumber := generateRandomNumber()\n\tfmt.Println(\"Random Number:\", randomNumber)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc readFile(filename string) (string, error) {\n\tdata, err := os.ReadFile(filename)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}\n\nfunc main() {\n\tcontent, err := readFile(\"example.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"File content:\", content)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc convertStringToInt(input string) (int, error) {\n\tresult, err := strconv.Atoi(input)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn result, nil\n}\n\nfunc main() {\n\tstrNumber := \"42\"\n\tintNumber, err := convertStringToInt(strNumber)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting string to int:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Converted Int:\", intNumber)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc calculateFactorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * calculateFactorial(n-1)\n}\n\nfunc main() {\n\tresult := calculateFactorial(5)\n\tfmt.Println(\"Factorial of 5 is:\", result)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc calculateCircleArea(radius float64) float64 {\n\treturn math.Pi * math.Pow(radius, 2)\n}\n\nfunc main() {\n\tradius := 3.0\n\tarea := calculateCircleArea(radius)\n\tfmt.Printf(\"Circle area with radius %.2f: %.2f\\n\", radius, area)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n)\n\ntype Person struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tCity  string `json:\"city\"`\n}\n\nfunc main() {\n\tperson := Person{\"John Doe\", 30, \"New York\"}\n\tjsonData, err := json.Marshal(person)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"JSON Data:\", string(jsonData))\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc sleepAndPrint(message string, duration time.Duration) {\n\ttime.Sleep(duration)\n\tfmt.Println(message)\n}\n\nfunc main() {\n\tsleepAndPrint(\"Message 1\", 2*time.Second)\n\tsleepAndPrint(\"Message 2\", 1*time.Second)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc sortIntSlice(nums []int) {\n\tsort.Ints(nums)\n\tfmt.Println(\"Sorted Slice:\", nums)\n}\n\nfunc main() {\n\tnumbers := []int{5, 2, 8, 1, 9}\n\tsortIntSlice(numbers)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc formatNumberAsString(number int) string {\n\treturn strconv.FormatInt(int64(number), 2)\n}\n\nfunc main() {\n\tnumber := 42\n\tbinaryString := formatNumberAsString(number)\n\tfmt.Printf(\"Binary representation of %d: %s\\n\", number, binaryString)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleRequest)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc printTimePeriodically() {\n\tfor {\n\t\tfmt.Println(\"Current time:\", time.Now())\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}\n\nfunc main() {\n\tgo printTimePeriodically()\n\t// Your code here\n\ttime.Sleep(30 * time.Second)\n}"
  },
  {
    "language": "Erlang",
    "code": "module(hello). -export([world/0]). world() -> io:format(\"Hello, World!~n\")."
  },
  {
    "language": "Erlang",
    "code": "-module(parallel_processing).\n-export([execute_tasks/1]).\nexecute_tasks(Tasks) ->\n    lists:foreach(fun(Task) -> spawn(fun() -> Task() end) end, Tasks)."
  },
  {
    "language": "Erlang",
    "code": "-module(genetic_algorithm).\n-export([run_genetic_algorithm/1]).\nrun_genetic_algorithm(Population) ->\n    [select() || _ <- lists:seq(1, Generations)],\n    MinFitness = lists:min([fitness(Ind) || Ind <- Population]),\n    lists:max([fitness(Ind) || Ind <- Population, fitness(Ind) =:= MinFitness])."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_computing).\n-compile([export_all]).\nsimulate_quantum_system(Circuit) ->\n    State = initialize_quantum_state(Circuit),\n    simulate_gates(State, Circuit)."
  },
  {
    "language": "Erlang",
    "code": "-module(natural_language_processing).\n-compile([export_all]).\nprocess_text(Text) ->\n    Parsed = parse_text(Text),\n    analyze_parsed(Parsed)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_systems).\n-compile([export_all]).\nexecute_tasks(Tasks) ->\n    [spawn(fun() -> perform_task(Task) end) || Task <- Tasks]."
  },
  {
    "language": "Erlang",
    "code": "-module(concurrency).\n-compile([export_all]).\nexecute_tasks(Tasks) ->\n    [spawn(fun() -> Task() end) || Task <- Tasks]."
  },
  {
    "language": "Erlang",
    "code": "-module(neural_network).\n-compile([export_all]).\nprocess_input(Input) ->\n    Network = create_neural_network(),\n    train_network(Network, Input),\n    predict_network(Network, Input)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_error_correction).\n-compile([export_all]).\nerror_correction(State) ->\n    Errors = detect_errors(State),\n    correct_errors(State, Errors)."
  },
  {
    "language": "Erlang",
    "code": "-module(chaos_engineering).\n-compile([export_all]).\ninject_faults(System),\n    analyze_system_behavior(System)."
  },
  {
    "language": "Erlang",
    "code": "-module(blockchain).\n-compile([export_all]).\nexecute_transaction(Transaction) ->\n    create_transaction(Transaction),\n    mine_block()."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_cryptography).\n-compile([export_all]).\nsecure_communication(Message) ->\n    Keys = generate_keys(),\n    encrypt_message(Message, Keys)."
  },
  {
    "language": "Erlang",
    "code": "-module(reactive_programming).\n-compile([export_all]).\nsubscribe(Stream) ->\n    subscribe_to_stream(Stream).\n\npublish(Stream, Data) ->\n    publish_to_stream(Stream, Data)."
  },
  {
    "language": "Erlang",
    "code": "-module(autonomous_robotics).\n-compile([export_all]).\nnavigate(Task) ->\n    plan_task(Task),\n    execute_task(Task)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_teleportation).\n-compile([export_all]).\nteleport_state(State) ->\n    Particles = prepare_entangled_particles(),\n    transfer_quantum_state(State, Particles)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_genomic_analysis).\n-compile([export_all]).\nanalyze_data(Data) ->\n    Analysis = analyze_genomic_data(Data),\n    process_in_parallel(Analysis)."
  },
  {
    "language": "Erlang",
    "code": "-module(federated_learning).\n-compile([export_all]).\ntrain_model(Model) ->\n    Nodes = initialize_nodes(),\n    train_model_with_federation(Model, Nodes)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_entanglement).\n-compile([export_all]).\nentangle_particles(Particles) ->\n    State = create_entangled_state(Particles),\n    transfer_state(State)."
  },
  {
    "language": "Erlang",
    "code": "-module(big_data_analytics).\n-compile([export_all]).\nanalyze_data(Data) ->\n    Processed = process_big_data(Data),\n    analyze_trends(Processed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_routing).\n-compile([export_all]).\nroute_data(Data) ->\n    Routed = route_quantum_data(Data),\n    manage_quantum_network(Routed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_annealing).\n-compile([export_all]).\nanneal_system(System) ->\n    Annealed = anneal_quantum_system(System),\n    optimize_annealing(Annealed)."
  },
  {
    "language": "Erlang",
    "code": "-module(compiler_optimization).\n-compile([export_all]).\noptimize_compiler(Compiler) ->\n    Optimized = optimize_compiler(Compiler),\n    improve_code(Optimized)."
  },
  {
    "language": "Erlang",
    "code": "-module(autonomous_agents).\n-compile([export_all]).\noperate_agents(Agents) ->\n    lists:foreach(fun(Agent) ->\n        create_agent(Agent),\n        train_agent(Agent)\n    end, Agents)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_communication).\n-compile([export_all]).\ncommunicate(Message) ->\n    Sent = send_quantum_message(Message),\n    receive_quantum_message()."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_search).\n-compile([export_all]).\nsearch_content(Query) ->\n    Results = search_content(Query),\n    index_content(Results)."
  },
  {
    "language": "Erlang",
    "code": "-module(genome_analysis).\n-compile([export_all]).\nanalyze_genome(Genome) ->\n    Analysis = analyze_genome(Genome),\n    compare_genomes(Analysis)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_optimization).\n-compile([export_all]).\noptimize_quantum_algorithm(Algorithm) ->\n    Optimized = optimize_quantum_algorithm(Algorithm),\n    improve_quantum_performance(Optimized)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_robotics).\n-compile([export_all]).\ncoordinate_robots(Robots) ->\n    Coordinated = coordinate_robots(Robots),\n    simulate_robotic_swarm(Coordinated)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_data_storage).\n-compile([export_all]).\nstore_data(Data) ->\n    Stored = store_quantum_data(Data),\n    retrieve_quantum_data()."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_meta_programming).\n-compile([export_all]).\nprogram_computers(Program) ->\n    Programmed = program_quantum_computers(Program),\n    verify_quantum_code(Programmed)."
  },
  {
    "language": "Erlang",
    "code": "-module(fault_tolerance).\n-compile([export_all]).\napply_faults(System) ->\n    inject_faults(System),\n    monitor_system_behavior(System)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_ml).\n-compile([export_all]).\ntrain_model(Model) ->\n    Nodes = initialize_nodes(),\n    distribute_training(Model, Nodes)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_compression).\n-compile([export_all]).\ncompress_data(Data) ->\n    Compressed = quantum_compress(Data),\n    decompress_data(Compressed)."
  },
  {
    "language": "Erlang",
    "code": "-module(advanced_cryptography).\n-compile([export_all]).\nsecure_transaction(Transaction) ->\n    Keys = generate_secure_keys(),\n    encrypt_transaction(Transaction, Keys)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_realtime).\n-compile([export_all]).\nhandle_realtime_data(Data) ->\n    Distributed = distribute_realtime_data(Data),\n    analyze_realtime(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_simulation).\n-compile([export_all]).\nsimulate_quantum_process(Process) ->\n    Simulated = simulate_quantum(Process),\n    analyze_simulation(Simulated)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_energy).\n-compile([export_all]).\nmanage_energy(EnergyGrid) ->\n    Distributed = distribute_energy(EnergyGrid),\n    optimize_distribution(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_security).\n-compile([export_all]).\nensure_security(Message) ->\n    Encrypted = encrypt_message(Message),\n    ensure_encryption(Encrypted)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_analysis).\n-compile([export_all]).\nanalyze_data(Data) ->\n    Distributed = distribute_data(Data),\n    perform_analysis(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_telecommunications).\n-compile([export_all]).\ntransmit_data(Data) ->\n    Transmitted = transmit_quantum_data(Data),\n    receive_data(Transmitted)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_security).\n-compile([export_all]).\nsecure_system(System) ->\n    Secured = secure_distributed_system(System),\n    monitor_security(Secured)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_prediction).\n-compile([export_all]).\npredict_outcome(Data) ->\n    Prediction = predict_quantum_outcome(Data),\n    validate_prediction(Prediction)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_healthcare).\n-compile([export_all]).\nmanage_healthcare(Data) ->\n    Distributed = distribute_healthcare_data(Data),\n    optimize_healthcare(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_encryption).\n-compile([export_all]).\nencrypt_data(Data) ->\n    Encrypted = quantum_encrypt(Data),\n    decrypt_encrypted(Encrypted)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_recommendation).\n-compile([export_all]).\nrecommend_products(Users) ->\n    Recommendations = distribute_recommendations(Users),\n    collect_feedback(Recommendations)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_analysis).\n-compile([export_all]).\nanalyze_quantum_data(Data) ->\n    Analyzed = analyze_quantum(Data),\n    process_analysis(Analyzed)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_traffic_management).\n-compile([export_all]).\nmanage_traffic(Data) ->\n    Distributed = distribute_traffic_data(Data),\n    optimize_traffic_management(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_sensing).\n-compile([export_all]).\nmeasure_quantum_data(Data) ->\n    Measured = measure_quantum(Data),\n    analyze_measurement(Measured)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_collaboration).\n-compile([export_all]).\ncoordinate_teams(Teams) ->\n    Coordinated = coordinate_teams(Teams),\n    analyze_collaboration(Coordinated)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_simulation).\n-compile([export_all]).\nsimulate_quantum_process(Process) ->\n    Simulated = simulate_quantum(Process),\n    analyze_simulation(Simulated)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_logging).\n-compile([export_all]).\ncollect_logs(Logs) ->\n    Distributed = distribute_logs(Logs),\n    analyze_logs(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_reliability).\n-compile([export_all]).\nensure_reliability(System) ->\n    Reliable = ensure_quantum_reliability(System),\n    monitor_reliability(Reliable)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_marketing).\n-compile([export_all]).\nmarket_products(Products) ->\n    Distributed = distribute_marketing(Products),\n    analyze_effectiveness(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_data_transfer).\n-compile([export_all]).\ntransfer_data(Data) ->\n    Transferred = transfer_quantum_data(Data),\n    verify_transfer(Transferred)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_learning).\n-compile([export_all]).\nexecute_learning(Subjects) ->\n    Distributed = distribute_learning(Subjects),\n    evaluate_performance(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_pattern_recognition).\n-compile([export_all]).\nrecognize_patterns(Data) ->\n    Recognized = recognize_quantum_patterns(Data),\n    analyze_recognition(Recognized)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_weather_forecasting).\n-compile([export_all]).\npredict_weather(Data) ->\n    Predicted = distribute_weather_prediction(Data),\n    verify_predictions(Predicted)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_state_transfer).\n-compile([export_all]).\ntransfer_state(State) ->\n    Transferred = quantum_transfer_state(State),\n    validate_transfer(Transferred)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_security_monitoring).\n-compile([export_all]).\nmonitor_security(System) ->\n    Monitored = monitor_distributed_security(System),\n    analyze_security(Monitored)."
  },
  {
    "language": "Erlang",
    "code": "-module(quantum_resource_optimization).\n-compile([export_all]).\noptimize_resources(Resources) ->\n    Optimized = optimize_quantum_resources(Resources),\n    evaluate_optimization(Optimized)."
  },
  {
    "language": "Erlang",
    "code": "-module(distributed_customer_service).\n-compile([export_all]).\nmanage_customers(Customers) ->\n    Distributed = distribute_customer_service(Customers),\n    evaluate_satisfaction(Distributed)."
  },
  {
    "language": "Erlang",
    "code": "module(variables). -export([example/0]). example() -> Number = 42, PiValue = 3.14, Message = \"Hello\", IsTrue = true, io:format(\"~w ~w ~s I160, [Number, PiValue, Message, IsTrue])."
  },
  {
    "language": "Erlang",
    "code": "module(conditional). -export([statements/1]). statements(true) -> io:format(\"It is true!~n\"); statements(false) -> io:format(\"It is false!~n\")"
  },
  {
    "language": "Erlang",
    "code": "-module(loops). -export([example/0]). example() -> loops(0). loops(5) -> ok; loops(Count) -> io:format(\"Count: ~w~n\", [Count]), loops(Count + 1).'"
  },
  {
    "language": "Erlang",
    "code": "-module(while). -export([example/0]). example() -> while(0). while(5) -> ok; while(Count) -> io:format(\"Count: ~w~n\", [Count]), while(Count + 1).'"
  },
  {
    "language": "Erlang",
    "code": "-module(greet). -export([hello/1]). hello(Name) -> io:format(\"Hello, ~s!~n\", [Name]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(lists). -export([example/0]). example() -> List = [1, 2, 3, 4, 5], io:format(\"~w~n\", [List]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(maps). -export([example/0]). example() -> Map = #{alice => 25, bob => 30, charlie => 28}, io:format(\"~p~n\", [Map]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(person). -export([details/0]). details() -> Person = #{name => \"Alice\", age => 25}, io:format(\"Name: ~s, Age: ~w~n\", [maps:get(name, Person), maps:get(age, Person)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(delay). -export([wait/0]). wait() -> timer:sleep(2000), io:format(\"Waited for 2 seconds!~n\").'"
  },
  {
    "language": "Erlang",
    "code": "-module(set). -export([example/0]). example() -> Set = #{1 => true, 2 => true, 3 => true, 4 => true, 5 => true}, io:format(\"~p~n\", [Set]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(status). -export([example/0]). example() -> ApplicationStatus = approved, io:format(\"Application Status: ~p~n\", [ApplicationStatus]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(random). -export([example/0]). example() -> random:seed(erlang:system_time()), io:format(\"Random Number: ~w~n\", [random:uniform(100)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(user_input). -export([example/0]). example() -> io:format(\"Enter your name: \"), Name = io:get_line(\"\"), io:format(\"Hello, ~s!~n\", [string:strip(Name)]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(optional_args). -export([example/0]). example() -> optional_arguments(\"Alice\", \"Bob\"), optional_arguments(). optional_arguments() -> ok; optional_arguments(Names...) -> lists:foreach(fun(Name) -> io:format(\"Hello, ~s!~n\", [Name]) end, Names).'"
  },
  {
    "language": "Erlang",
    "code": "-module(rectangle). -export([example/0]). example() -> Rectangle = #{width => 10, height => 20}, io:format(\"Rectangle: ~p~n\", [Rectangle]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(file_io). -export([example/0]). example() -> {ok, File} = file:open(\"test.txt\", [write]), file:write(File, \"Hello, Erlang!\"), file:close(File), io:format(\"File created and written to.~n\").'"
  },
  {
    "language": "Erlang",
    "code": "-module(defer). -export([example/0]). example() -> spawn(fun() -> defer(\"World!\") end), io:format(\"Hello, \"). defer(Message) -> io:format(\"~s\", [Message]).'"
  },
  {
    "language": "Erlang",
    "code": "-module(panic_recover). -export([example/0]). example() -> try throw(panic) catch throw:panic -> io:format(\"Recovered from panic.~n\") end.'"
  },
  {
    "language": "Erlang",
    "code": "-module(channels). -export([example/0]). example() -> {Channel, _} = erlang:spawn_monitor(fun() -> Channel = erlang:monitor(process, spawn(fun() -> io:format(\"Hello, World!~n\") end)) end), receive {'DOWN', Channel, process, _, _} -> io:format(\"Channel terminated.~n\") after 3000 -> erlang:exit(Channel, kill), io:format(\"Channel killed.~n\") end.'"
  },
  {
    "language": "Lua",
    "code": "function iterateArray(arr) local i = 0 return function() i = i + 1 return arr[i] end end arr = {10, 20, 30, 40} iterator = iterateArray(arr) while true do local val = iterator() if val == nil then break end print(\"Value:\", val) end"
  },
  {
    "language": "Lua",
    "code": "Vector = {x = 0, y = 0} Vector.__add = function(v1, v2) return {x = v1.x + v2.x, y = v1.y + v2.y} end setmetatable(Vector, Vector) v1 = {x = 10, y = 20} v2 = {x = 30, y = 40} result = v1 + v2 print(\"Resultant Vector:\", result.x, result.y)"
  },
  {
    "language": "Lua",
    "code": "function outerFunction() local outerVar = 10 local function innerFunction() outerVar = outerVar + 5 return outerVar end return innerFunction end closure = outerFunction() print(\"Closure Value 1:\", closure()) print(\"Closure Value 2:\", closure())"
  },
  {
    "language": "Lua",
    "code": "function simpleCoroutine() for i = 1, 3 do coroutine.yield(i) end end co = coroutine.create(simpleCoroutine) while coroutine.status(co) ~= \"dead\" do status, value = coroutine.resume(co) print(\"Yielded value:\", value) end"
  },
  {
    "language": "Lua",
    "code": "function divide(a, b) assert(b ~= 0, \"Division by zero!\") return a / b end success, result = pcall(divide, 10, 0) if not success then print(\"Error:\", result) else print(\"Result:\", result) end"
  },
  {
    "language": "Lua",
    "code": "Dog = {sound = \"Woof!\"} function Dog:makeSound() print(self.sound) end myDog = {} setmetatable(myDog, Dog) myDog:makeSound()"
  },
  {
    "language": "Lua",
    "code": "function readFromFile(filename) local file = io.open(filename, \"r\") if not file then error(\"File not found or cannot be opened.\") end local content = file:read(\"*a\") file:close() return content end success, content = pcall(readFromFile, \"example.txt\") if success then print(\"File Content:\") print(content) else print(\"Error:\", content) end"
  },
  {
    "language": "Lua",
    "code": "module = {} function module.greet(name) print(\"Hello,\", name) end return module"
  },
  {
    "language": "Lua",
    "code": "text = \"Lua programming is awesome!\" words = {} for word in text:gmatch(\"%S+\") do table.insert(words, word) end for i, word in ipairs(words) do print(\"Word \" .. i .. \":\", word) end"
  },
  {
    "language": "Lua",
    "code": "function add(a, b) return a + b end function executeFunction(func, a, b) print(\"Result:\", func(a, b)) end executeFunction(add, 10, 20)"
  },
  {
    "language": "Lua",
    "code": "function generatorFunction() local i = 0 return function() i = i + 1 return i end end gen = generatorFunction() print(gen(), gen(), gen())"
  },
  {
    "language": "Lua",
    "code": "local function factorial(n) if n <= 1 then return 1 else return n * factorial(n - 1) end end print(\"Factorial of 5:\", factorial(5))"
  },
  {
    "language": "Lua",
    "code": "local function closureExample() local outerVar = 10 return function() outerVar = outerVar + 5 return outerVar end end closure = closureExample() print(\"Closure Value 1:\", closure()) print(\"Closure Value 2:\", closure())"
  },
  {
    "language": "Lua",
    "code": "local function reverseArray(arr) local reversed = {} for i = #arr, 1, -1 do table.insert(reversed, arr[i]) end return reversed end arr = {10, 20, 30, 40} reversedArr = reverseArray(arr) for i, val in ipairs(reversedArr) do print(\"Reversed[\" .. i .. \"]:\", val) end"
  },
  {
    "language": "Lua",
    "code": "local function isValidEmail(email) return email:match(\"^[%w%p]+@[%w%p]+%.%w%w%w?$\") ~= nil end emails = {\"example@email.com\", \"invalid-email\", \"another.example@email.co\"} for i, email in ipairs(emails) do print(\"Email \" .. i .. \":\", email, \"Valid:\", isValidEmail(email)) end"
  },
  {
    "language": "Lua",
    "code": "local function countOccurrences(text, pattern) local count = 0 for _ in text:gmatch(pattern) do count = count + 1 end return count end text = \"Lua is a scripting language, Lua is versatile\" pattern = \"Lua\" print(\"Occurrences of 'Lua':\", countOccurrences(text, pattern))"
  },
  {
    "language": "Lua",
    "code": "local function capitalizeWords(sentence) return sentence:gsub(\"(%w)(%w*)\", function(first, rest) return first:upper() .. rest:lower() end) end sentence = \"lua programming is fun\" print(\"Capitalized:\", capitalizeWords(sentence))"
  },
  {
    "language": "Lua",
    "code": "local function binarySearch(arr, target) local left, right = 1, #arr while left <= right do local mid = math.floor((left + right) / 2) if arr[mid] == target then return mid elseif arr[mid] < target then left = mid + 1 else right = mid - 1 end end return -1 end numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90} target = 60 print(\"Index of\", target, \":\", binarySearch(numbers, target))"
  },
  {
    "language": "Lua",
    "code": "local function memoize(func) local cache = {} return function(n) if not cache[n] then cache[n] = func(n) end return cache[n] end end function fibonacci(n) if n <= 2 then return 1 else return fibonacci(n - 1) + fibonacci(n - 2) end end fibonacci = memoize(fibonacci) print(\"Fibonacci(10):\", fibonacci(10))"
  },
  {
    "language": "Lua",
    "code": "local function parseJSON(jsonString) return load(\"return \" .. jsonString)() end jsonString = '{\"name\": \"Lua\", \"type\": \"Scripting Language\"}' parsedData = parseJSON(jsonString) for key, value in pairs(parsedData) do print(key .. \":\", value) end"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Hello World\nprint(\"Hello, World!\")\n\n-- Sample 2: Variables and arithmetic operations\nlocal a = 10\nlocal b = 5\nlocal sum = a + b\nlocal product = a * b\n\n-- Sample 3: Conditional statements\nif a > b then\n    print(\"a is greater than b\")\nelseif a < b then\n    print(\"a is less than b\")\nelse\n    print(\"a is equal to b\")\nend\n\n-- Sample 4: Loops\nfor i = 1, 5 do\n    print(\"Count: \" .. i)\nend\n\n-- Sample 5: Functions\nfunction greet(name)\n    print(\"Hello, \" .. name .. \"!\")\nend\n\ngreet(\"Lua\")\n\n-- Sample 6: Tables\nlocal person = {name = \"John\", age = 30, city = \"New York\"}\nprint(person.name .. \" is \" .. person.age .. \" years old from \" .. person.city)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Hello World\nprint(\"Hello, World!\")\n\n-- Sample 2: Variables and arithmetic operations\nlocal a = 10\nlocal b = 5\nlocal sum = a + b\nlocal product = a * b\n\n-- Sample 3: Conditional statements\nif a > b then\n    print(\"a is greater than b\")\nelseif a < b then\n    print(\"a is less than b\")\nelse\n    print(\"a is equal to b\")\nend\n\n-- Sample 4: Loops\nfor i = 1, 5 do\n    print(\"Count: \" .. i)\nend\n\n-- Sample 5: Functions\nfunction greet(name)\n    print(\"Hello, \" .. name .. \"!\")\nend\n\ngreet(\"Lua\")\n\n-- Sample 6: Tables\nlocal person = {name = \"John\", age = 30, city = \"New York\"}\nprint(person.name .. \" is \" .. person.age .. \" years old from \" .. person.city)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Hello World\nprint(\"Hello, World!\")\n\n-- Sample 2: Variables and arithmetic operations\nlocal a = 10\nlocal b = 5\nlocal sum = a + b\nlocal product = a * b\n\n-- Sample 3: Conditional statements\nif a > b then\n    print(\"a is greater than b\")\nelseif a < b then\n    print(\"a is less than b\")\nelse\n    print(\"a is equal to b\")\nend\n\n-- Sample 4: Loops\nfor i = 1, 5 do\n    print(\"Count: \" .. i)\nend\n\n-- Sample 5: Functions\nfunction greet(name)\n    print(\"Hello, \" .. name .. \"!\")\nend\n\ngreet(\"Lua\")\n\n-- Sample 6: Tables\nlocal person = {name = \"John\", age = 30, city = \"New York\"}\nprint(person.name .. \" is \" .. person.age .. \" years old from \" .. person.city)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Hello World\nprint(\"Hello, World!\")\n\n-- Sample 2: Variables and arithmetic operations\nlocal a = 10\nlocal b = 5\nlocal sum = a + b\nlocal product = a * b\n\n-- Sample 3: Conditional statements\nif a > b then\n    print(\"a is greater than b\")\nelseif a < b then\n    print(\"a is less than b\")\nelse\n    print(\"a is equal to b\")\nend\n\n-- Sample 4: Loops\nfor i = 1, 5 do\n    print(\"Count: \" .. i)\nend\n\n-- Sample 5: Functions\nfunction greet(name)\n    print(\"Hello, \" .. name .. \"!\")\nend\n\ngreet(\"Lua\")\n\n-- Sample 6: Tables\nlocal person = {name = \"John\", age = 30, city = \"New York\"}\nprint(person.name .. \" is \" .. person.age .. \" years old from \" .. person.city)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Sorting an Array\nlocal numbers = {4, 2, 8, 1, 6}\nprint(\"Original Array:\")\nfor _, v in ipairs(numbers) do\n    io.write(v .. \" \")\nend\n\ntable.sort(numbers)\nprint(\"\nSorted Array:\")\nfor _, v in ipairs(numbers) do\n    io.write(v .. \" \")\nend"
  },
  {
    "language": "Lua",
    "code": "-- Sample 2: Date and Time\nlocal os = require('os')\nprint(os.date(\"Today is %A, %B %d, %Y\"))\nprint(os.time())"
  },
  {
    "language": "Lua",
    "code": "-- Sample 3: Error Handling\nlocal status, result = pcall(function()\n    error(\"Oops! Something went wrong.\")\nend)\nif not status then\n    print(\"Error: \" .. result)\nend"
  },
  {
    "language": "Lua",
    "code": "-- Sample 4: Working with JSON\nlocal json = require('json')\nlocal data = {name = \"Lua\", version = \"5.4\"}\nlocal encoded = json.encode(data)\nprint(encoded)\nlocal decoded = json.decode(encoded)\nprint(decoded.name, decoded.version)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 5: Bitwise Operations\nlocal a = 5 -- 101\nlocal b = 3 -- 011\nprint(\"Bitwise AND: \" .. (a & b))\nprint(\"Bitwise OR: \" .. (a | b))\nprint(\"Bitwise XOR: \" .. (a ~ b))\nprint(\"Bitwise NOT: \" .. (~a))\nprint(\"Left Shift: \" .. (a << 1))\nprint(\"Right Shift: \" .. (a >> 1))"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Conway's Game of Life\nlocal function countNeighbors(grid, x, y)\n    local count = 0\n    for i = -1, 1 do\n        for j = -1, 1 do\n            if not (i == 0 and j == 0) then\n                local nx, ny = x + i, y + j\n                if grid[nx] and grid[nx][ny] then\n                    count = count + 1\n                end\n            end\n        end\n    end\n    return count\nend\n\n-- Simulation logic here\n-- ... (omitted for brevity)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 2: Genetic Algorithm\nlocal function createPopulation(size)\n    local population = {}\n    for i = 1, size do\n        local individual = {}\n        -- Generate individuals\n        -- ...\n        table.insert(population, individual)\n    end\n    return population\nend\n\n-- Genetic algorithm operations\n-- ... (omitted for brevity)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 3: Neural Network Implementation\nlocal function createNeuralNetwork(inputSize, hiddenSize, outputSize)\n    local neuralNetwork = {}\n    -- Initialize neural network structure\n    -- ...\n    return neuralNetwork\nend\n\n-- Neural network training and usage\n-- ... (omitted for brevity)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 4: Quantum Computing Simulation\nlocal function applyGate(qubit, gate)\n    -- Apply quantum gate operations\n    -- ...\nend\n\n-- Quantum computation simulation\n-- ... (omitted for brevity)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 5: Complex Data Structures\nlocal graph = {\n    nodes = {\n        {id = 1, label = \"Node A\"},\n        {id = 2, label = \"Node B\"},\n        -- More nodes\n    },\n    edges = {\n        {source = 1, target = 2, weight = 5},\n        -- More edges\n    }\n}\n\n-- Graph algorithms and operations\n-- ... (omitted for brevity)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 1: Parallel Processing\nlocal threads = {}\nfor i = 1, 4 do\n    threads[i] = coroutine.create(function()\n        -- Perform parallel tasks\n        -- ...\n    end)\n    coroutine.resume(threads[i])\nend"
  },
  {
    "language": "Lua",
    "code": "-- Sample 2: Audio Processing\nlocal audio = require('audio')\nlocal sound = audio.loadSound(\"example.wav\")\naudio.play(sound)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 3: Image Processing\nlocal image = require('image')\nlocal img = image.load(\"example.png\")\nimage.rotate(img, 90)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 4: Cryptography\nlocal crypto = require('crypto')\nlocal encrypted = crypto.encrypt(\"plaintext\", \"key\")\nlocal decrypted = crypto.decrypt(encrypted, \"key\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 5: GUI Application\nlocal gui = require('gui')\nlocal window = gui.createWindow()\nwindow.setTitle(\"Lua GUI\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 6: Augmented Reality\nlocal ar = require('ar')\nlocal scene = ar.createScene()\nscene.addObject(\"model.obj\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 7: Natural Language Processing\nlocal nlp = require('nlp')\nlocal text = \"Lua is a scripting language.\"\nnlp.analyzeSentiment(text)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 8: Robotics\nlocal robot = require('robot')\nrobot.moveForward()\nrobot.rotateLeft()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 9: Database Interaction\nlocal db = require('db')\nlocal connection = db.connect(\"database.db\")\ndb.query(connection, \"SELECT * FROM table\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 10: Blockchain Operations\nlocal blockchain = require('blockchain')\nblockchain.createBlock(\"data\", \"previousHash\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 11: Geospatial Analysis\nlocal geospatial = require('geospatial')\nlocal location = geospatial.getLocation()\ngeospatial.findNearest(location, \"restaurants\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 12: Signal Processing\nlocal signal = require('signal')\nlocal data = {1, 2, 3, 4, 5}\nsignal.fft(data)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 13: Virtual Reality\nlocal vr = require('vr')\nlocal environment = vr.createEnvironment()\nenvironment.loadScene(\"scene.vr\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 14: Quantum Algorithms\nlocal quantum = require('quantum')\nquantum.createQubits(3)\nquantum.applyGate(1, \"Hadamard\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 15: Machine Learning\nlocal ml = require('ml')\nlocal model = ml.createModel()\nml.train(model, dataset)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 16: Internet of Things (IoT)\nlocal iot = require('iot')\nlocal device = iot.connect(\"deviceID\")\niot.sendData(device, {temp = 25, humidity = 50})"
  },
  {
    "language": "Lua",
    "code": "-- Sample 17: Bioinformatics\nlocal bio = require('bio')\nlocal sequence = bio.loadSequence(\"DNA.txt\")\nbio.findMotifs(sequence)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 18: Game Development\nlocal game = require('game')\nlocal player = game.createPlayer()\nplayer.move(\"forward\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 19: Compiler Construction\nlocal compiler = require('compiler')\ncompiler.compile(\"source.lua\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 20: Simulating Physics\nlocal physics = require('physics')\nphysics.simulate(\"object\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 21: Computer Vision\nlocal vision = require('vision')\nlocal image = vision.captureImage()\nvision.detectObjects(image)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 22: Distributed Systems\nlocal distributed = require('distributed')\nlocal network = distributed.createNetwork()\ndistributed.sendData(network, \"Hello\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 23: Financial Calculations\nlocal finance = require('finance')\nlocal investment = finance.calculateROI(10000, 5, 10)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 24: Multi-threading\nlocal thread = require('thread')\nlocal worker = thread.createWorker()\nthread.execute(worker, function() print(\"Executing...\") end)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 25: Human-Machine Interface\nlocal hmi = require('hmi')\nlocal interface = hmi.createInterface()\nhmi.displayMessage(interface, \"Hello, Lua!\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 26: Recommender Systems\nlocal recommender = require('recommender')\nlocal suggestions = recommender.getRecommendations(userID)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 27: Genetic Programming\nlocal genetic = require('genetic')\nlocal solution = genetic.evolveSolution(parameters)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 28: Network Security\nlocal security = require('security')\nlocal encryptedData = security.encryptData(data, key)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 29: Augmented Intelligence\nlocal ai = require('ai')\nlocal decision = ai.makeDecision(context)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 30: Climate Modeling\nlocal climate = require('climate')\nlocal forecast = climate.generateForecast(location)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 31: Cyber-Physical Systems\nlocal cps = require('cps')\nlocal system = cps.createSystem()\ncps.executeSystem(system)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 32: Encryption Algorithms\nlocal encryption = require('encryption')\nlocal cipherText = encryption.encryptText(plainText, key)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 33: Virtual Assistants\nlocal assistant = require('assistant')\nlocal response = assistant.getResponse(userQuery)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 34: Gesture Recognition\nlocal gesture = require('gesture')\nlocal recognizedGesture = gesture.recognize(gestureData)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 35: Bio-inspired Computing\nlocal bioinspired = require('bioinspired')\nlocal optimizedSolution = bioinspired.optimize(problem)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 36: Quantum Cryptography\nlocal quantumcrypto = require('quantumcrypto')\nlocal secureData = quantumcrypto.encryptData(data, key)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 37: Neural Interfaces\nlocal neural = require('neural')\nlocal interface = neural.createInterface()\nneural.connect(interface, device)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 38: Urban Planning Simulations\nlocal urban = require('urban')\nlocal simulation = urban.simulateCity()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 39: Swarm Intelligence\nlocal swarm = require('swarm')\nlocal optimizedSolution = swarm.optimize(problem)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 40: Evolutionary Algorithms\nlocal evolutionary = require('evolutionary')\nlocal solution = evolutionary.evolveSolution(parameters)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 41: Satellite Image Processing\nlocal satellite = require('satellite')\nlocal image = satellite.captureImage()\nsatellite.analyzeImage(image)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 42: Cloud Computing\nlocal cloud = require('cloud')\nlocal instance = cloud.createInstance()\ncloud.deployApp(instance, \"myApp\")"
  },
  {
    "language": "Lua",
    "code": "-- Sample 43: Audio Synthesis\nlocal synth = require('synth')\nlocal sound = synth.generateSound(440, 2)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 44: Data Visualization\nlocal viz = require('viz')\nlocal data = viz.fetchData()\nviz.plotGraph(data)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 45: Cybersecurity Analysis\nlocal cybersecurity = require('cybersecurity')\nlocal report = cybersecurity.analyzeNetworkTraffic()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 46: Social Media Analytics\nlocal social = require('social')\nlocal posts = social.fetchPosts()\nsocial.analyzeSentiment(posts)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 47: Robotics Automation\nlocal robotics = require('robotics')\nlocal task = robotics.createTask()\nrobotics.executeTask(task)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 48: Game Engine Development\nlocal engine = require('engine')\nlocal game = engine.createGame(\"MyGame\")\nengine.runGame(game)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 49: Augmented Virtuality\nlocal av = require('av')\nlocal scene = av.createScene()\nav.addVirtualElements(scene)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 50: Financial Forecasting\nlocal forecasting = require('forecasting')\nlocal predictions = forecasting.predictStocks()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 51: Smart Home Automation\nlocal smarthome = require('smarthome')\nlocal device = smarthome.getDevice()\nsmarthome.controlDevice(device, 'on')"
  },
  {
    "language": "Lua",
    "code": "-- Sample 52: Quantum Computing Simulations\nlocal quantum = require('quantum')\nlocal simulation = quantum.simulateCircuit()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 53: Natural Language Generation\nlocal nlg = require('nlg')\nlocal text = nlg.generateText(100)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 54: Internet Security Testing\nlocal securitytesting = require('securitytesting')\nlocal result = securitytesting.runTests()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 55: Music Composition\nlocal music = require('music')\nlocal composition = music.composeMusic()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 56: Autonomous Vehicles\nlocal vehicle = require('vehicle')\nlocal car = vehicle.createVehicle()\nvehicle.autopilot(car)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 57: Language Translation\nlocal translation = require('translation')\nlocal translatedText = translation.translate('Hello', 'es')"
  },
  {
    "language": "Lua",
    "code": "-- Sample 58: Computational Chemistry\nlocal chemistry = require('chemistry')\nlocal molecule = chemistry.createMolecule()\nchemistry.simulateReaction(molecule)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 59: Audio Recognition\nlocal audioRecog = require('audioRecog')\nlocal voice = audioRecog.recordVoice()\naudioRecog.recognizeVoice(voice)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 60: Network Routing Optimization\nlocal routing = require('routing')\nlocal optimizedRoute = routing.optimizeRoute()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 61: Supply Chain Management\nlocal supplyChain = require('supplyChain')\nlocal analysis = supplyChain.analyzeChain()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 62: Remote Sensing Analysis\nlocal sensing = require('sensing')\nlocal data = sensing.collectData()\nsensing.analyzeData(data)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 63: Social Robotics\nlocal socialRobotics = require('socialRobotics')\nlocal interaction = socialRobotics.createInteraction()\nsocialRobotics.performInteraction(interaction)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 64: Cryptocurrency Trading\nlocal cryptoTrading = require('cryptoTrading')\nlocal tradeResult = cryptoTrading.executeTrade()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 65: Gesture-based Control\nlocal gestureControl = require('gestureControl')\nlocal gesture = gestureControl.captureGesture()\ngestureControl.executeGesture(gesture)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 66: Computational Physics\nlocal physicsComp = require('physicsComp')\nlocal simulation = physicsComp.simulateSystem()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 67: Data Mining\nlocal dataMining = require('dataMining')\nlocal patterns = dataMining.findPatterns()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 68: Humanoid Robotics\nlocal humanoid = require('humanoid')\nlocal robot = humanoid.createRobot()\nhumanoid.teachRobot(robot)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 69: Code Optimization\nlocal codeOptimization = require('codeOptimization')\nlocal optimizedCode = codeOptimization.optimize('source.lua')"
  },
  {
    "language": "Lua",
    "code": "-- Sample 70: Financial Risk Analysis\nlocal riskAnalysis = require('riskAnalysis')\nlocal riskScore = riskAnalysis.analyzeRisk()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 71: Virtual Reality Gaming\nlocal vrGaming = require('vrGaming')\nlocal game = vrGaming.loadGame()\nvrGaming.playGame(game)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 72: E-commerce Recommendation\nlocal ecomRec = require('ecomRec')\nlocal suggestions = ecomRec.getRecommendations(userID)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 73: Computational Neuroscience\nlocal neuroComp = require('neuroComp')\nlocal model = neuroComp.createModel()\nneuroComp.simulateModel(model)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 74: Sentiment Analysis\nlocal sentiment = require('sentiment')\nlocal analysis = sentiment.analyzeText('Great job!')"
  },
  {
    "language": "Lua",
    "code": "-- Sample 75: Robotics Control Systems\nlocal control = require('control')\nlocal system = control.createSystem()\ncontrol.executeSystem(system)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 76: Real-time Data Streaming\nlocal streaming = require('streaming')\nlocal data = streaming.streamData()\nstreaming.processData(data)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 77: Bio-inspired Robotics\nlocal bioRobotics = require('bioRobotics')\nlocal design = bioRobotics.designRobot()\nbioRobotics.simulateRobot(design)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 78: Computational Genomics\nlocal genomics = require('genomics')\nlocal sequence = genomics.loadSequence('DNA.txt')\ngenomics.analyzeSequence(sequence)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 79: Cognitive Computing\nlocal cognitive = require('cognitive')\nlocal system = cognitive.createSystem()\ncognitive.executeSystem(system)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 80: AI-driven Marketing\nlocal aiMarketing = require('aiMarketing')\nlocal campaign = aiMarketing.createCampaign()\naiMarketing.runCampaign(campaign)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 81: Biometric Authentication\nlocal biometric = require('biometric')\nlocal user = biometric.authenticateUser()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 82: Climate Prediction Modeling\nlocal climate = require('climate')\nlocal model = climate.buildModel()\nclimate.predict(model)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 83: Computational Linguistics\nlocal linguistics = require('linguistics')\nlocal analysis = linguistics.analyzeLanguage()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 84: Data Compression Algorithms\nlocal compression = require('compression')\nlocal compressedData = compression.compressData()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 85: Dynamic Memory Allocation\nlocal memory = require('memory')\nlocal allocatedMemory = memory.allocateMemory()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 86: Facial Recognition\nlocal facialRecog = require('facialRecog')\nlocal image = facialRecog.captureImage()\nfacialRecog.recognizeFace(image)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 87: Machine Learning Pipelines\nlocal mlPipelines = require('mlPipelines')\nlocal pipeline = mlPipelines.createPipeline()\nmlPipelines.executePipeline(pipeline)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 88: Network Anomaly Detection\nlocal anomalyDetection = require('anomalyDetection')\nlocal anomalies = anomalyDetection.detectAnomalies()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 89: Predictive Maintenance\nlocal predictiveMaintenance = require('predictiveMaintenance')\nlocal maintenancePlan = predictiveMaintenance.createPlan()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 90: Quantum Cryptography\nlocal quantumCrypto = require('quantumCrypto')\nlocal encryptedData = quantumCrypto.encryptData()\nquantumCrypto.decryptData(encryptedData)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 91: Reinforcement Learning\nlocal reinforcement = require('reinforcement')\nlocal agent = reinforcement.createAgent()\nreinforcement.trainAgent(agent)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 92: Robotic Vision Systems\nlocal vision = require('vision')\nlocal system = vision.setupSystem()\nvision.analyzeScene(system)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 93: Speech-to-Text Conversion\nlocal speechToText = require('speechToText')\nlocal audio = speechToText.recordAudio()\nspeechToText.convertToText(audio)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 94: Swarm Intelligence\nlocal swarmIntel = require('swarmIntel')\nlocal swarm = swarmIntel.createSwarm()\nswarmIntel.optimize(swarm)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 95: Time Series Forecasting\nlocal timeSeries = require('timeSeries')\nlocal forecast = timeSeries.makeForecast()"
  },
  {
    "language": "Lua",
    "code": "-- Sample 96: Unsupervised Learning\nlocal unsupervised = require('unsupervised')\nlocal model = unsupervised.createModel()\nunsupervised.trainModel(model)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 97: Video Processing\nlocal videoProcessing = require('videoProcessing')\nlocal video = videoProcessing.captureVideo()\nvideoProcessing.processVideo(video)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 98: Web Scraping\nlocal webScraping = require('webScraping')\nlocal data = webScraping.scrapeData()\nwebScraping.processData(data)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 99: Knowledge Graph Construction\nlocal knowledgeGraph = require('knowledgeGraph')\nlocal graph = knowledgeGraph.constructGraph()\nknowledgeGraph.queryGraph(graph)"
  },
  {
    "language": "Lua",
    "code": "-- Sample 100: 3D Modeling\nlocal modeling = require('modeling')\nlocal model = modeling.createModel()\nmodeling.renderModel(model)"
  },
  {
    "language": "Prolog",
    "code": "animal(cat). animal(dog). animal(elephant). size(elephant, big). size(cat, small). sound(cat, meow). sound(dog, bark)"
  },
  {
    "language": "Prolog",
    "code": "factorial(0, 1). factorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult."
  },
  {
    "language": "Prolog",
    "code": "edge(a, b). edge(b, c). edge(c, d). connected(X, Y) :- edge(X, Y). connected(X, Y) :- edge(X, Z), connected(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "parent(john, paul). parent(paul, mary). grandparent(X, Y) :- parent(X, Z), parent(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "triangle(A, B, C) :- A + B > C, A + C > B, B + C > A."
  },
  {
    "language": "Prolog",
    "code": "```even_length([]). even_length([_, _"
  },
  {
    "language": "Prolog",
    "code": "member(X, [X"
  },
  {
    "language": "Prolog",
    "code": "max(X, Y, Max) :- (X >= Y -> Max = X ; Max = Y)."
  },
  {
    "language": "Prolog",
    "code": "fib(0, 0). fib(1, 1). fib(N, Result) :- N > 1, Prev1 is N - 1, Prev2 is N - 2, fib(Prev1, Prev1Result), fib(Prev2, Prev2Result), Result is Prev1Result + Prev2Result."
  },
  {
    "language": "Prolog",
    "code": "append([], L, L). append([H"
  },
  {
    "language": "Prolog",
    "code": "map(_, [], []). map(P, [H"
  },
  {
    "language": "Prolog",
    "code": "merge([], L, L). merge(L, [], L). merge([X"
  },
  {
    "language": "Prolog",
    "code": "divisor(X, Y) :- Y > 1, Y1 is Y - 1, X mod Y =:= 0. divisors(X, Y, [Y"
  },
  {
    "language": "Prolog",
    "code": "prime(2). prime(X) :- X > 2, \\+ has_factor(X, 2). has_factor(N, M) :- N mod M =:= 0. has_factor(N, M) :- M * M < N, M2 is M + 1, has_factor(N, M2)."
  },
  {
    "language": "Prolog",
    "code": "partition(_, [], [], []). partition(Pivot, [H"
  },
  {
    "language": "Prolog",
    "code": "animal(cat), animal(dog), animal(elephant), size(elephant, big), size(cat, small), sound(cat, meow), sound(dog, bark), factorial(0, 1), factorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult, edge(a, b), edge(b, c), edge(c, d), connected(X, Y) :- edge(X, Y), connected(X, Y) :- edge(X, Z), connected(Z, Y), parent(john, paul), parent(paul, mary), grandparent(X, Y) :- parent(X, Z), parent(Z, Y), triangle(A, B, C) :- A + B > C, A + C > B, B + C > A, even_length([]), even_length([_, _ | Tail]) :- even_length(Tail), member(X, [X | _]), member(X, [_ | Tail]) :- member(X, Tail), max(X, Y, Max) :- (X >= Y -> Max = X ; Max = Y), fib(0, 0), fib(1, 1), fib(N, Result) :- N > 1, Prev1 is N - 1, Prev2 is N - 2, fib(Prev1, Prev1Result), fib(Prev2, Prev2Result), Result is Prev1Result + Prev2Result."
  },
  {
    "language": "Prolog",
    "code": "% Sample 101: Graph Traversal\nedge(a, b).\nedge(b, c).\npath(X, Y) :- edge(X, Y).\npath(X, Y) :- edge(X, Z), path(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 102: Sudoku Solver\nvalid([]).\nvalid([H|T]) :- fd_all_different(H), valid(T).\nsudoku(Puzzle, Solution) :- Solution = Puzzle, Puzzle = [S11, S12, S13, S14, S21, S22, S23, S24, S31, S32, S33, S34, S41, S42, S43, S44], fd_domain(Solution, 1, 4), Row1 = [S11, S12, S13, S14], Row2 = [S21, S22, S23, S24], Row3 = [S31, S32, S33, S34], Row4 = [S41, S42, S43, S44], Col1 = [S11, S21, S31, S41], Col2 = [S12, S22, S32, S42], Col3 = [S13, S23, S33, S43], Col4 = [S14, S24, S34, S44], Square1 = [S11, S12, S21, S22], Square2 = [S13, S14, S23, S24], Square3 = [S31, S32, S41, S42], Square4 = [S33, S34, S43, S44], valid([Row1, Row2, Row3, Row4, Col1, Col2, Col3, Col4, Square1, Square2, Square3, Square4])."
  },
  {
    "language": "Prolog",
    "code": "% Sample 103: Family Relationships\nfather(abe, homer).\nfather(homer, bart).\nfather(homer, lisa).\nfather(homer, maggie).\nmother(mona, homer).\nmother(marge, bart).\nmother(marge, lisa).\nmother(marge, maggie).\nancestor(X, Y) :- father(X, Y).\nancestor(X, Y) :- mother(X, Y).\ngrandfather(X, Y) :- father(X, Z), (father(Z, Y); mother(Z, Y))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 104: List Manipulation\nappend([], L, L).\nappend([H|T], L, [H|R]) :- append(T, L, R).\nmember(X, [X|_]).\nmember(X, [_|T]) :- member(X, T).\nreverse_list([], []).\nreverse_list([H|T], R) :- reverse_list(T, RT), append(RT, [H], R)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 105: Binary Search Tree\nbst_insert(nil, Val, bst(Val, nil, nil)).\nbst_insert(bst(Root, Left, Right), Val, bst(NewRoot, NewLeft, Right)) :- Val =< Root, bst_insert(Left, Val, bst(NewRoot, NewLeft, Right)).\nbst_insert(bst(Root, Left, Right), Val, bst(NewRoot, Left, NewRight)) :- Val > Root, bst_insert(Right, Val, bst(NewRoot, Left, NewRight)).\nbst_search(bst(Val, _, _), Val). % Base case for finding the value in the tree\nbst_search(nil, _):- false. % Base case for an empty tree\nbst_search(bst(Root, Left, _), Val) :- Val < Root, bst_search(Left, Val). % Search in the left subtree\nbst_search(bst(_, _, Right), Val) :- bst_search(Right, Val). % Search in the right subtree."
  },
  {
    "language": "Prolog",
    "code": "% Sample 106: Travel Planning\nflight(edirne, istanbul, 1).\nflight(istanbul, antalya, 2).\nflight(antalya, izmir, 2).\nflight(izmir, istanbul, 1).\nflight(istanbul, trabzon, 3).\nflight(trabzon, ankara, 2).\nflight(ankara, istanbul, 2).\nroute(X, Y, Cost) :- flight(X, Y, Cost).\nroute(X, Y, Cost) :- flight(X, Z, Cost1), route(Z, Y, Cost2), Cost is Cost1 + Cost2."
  },
  {
    "language": "Prolog",
    "code": "% Sample 107: Logic Puzzle Solver\nsolve_puzzle(Puzzle) :- Puzzle = [_, _, _, _, _], member(house(red, _, _, _, brit), Puzzle), member(house(_, _, _, dog, spaniard), Puzzle), member(house(green, _, coffee, _, ukrainian), Puzzle), member(house(_, tea, _, _, _), Puzzle), left_of(house(ivory, _, _, _, _), house(green, _, _, _, _), Puzzle), member(house(_, _, orchard_juice, _, _), Puzzle), member(house(_, _, _, snails, _), Puzzle), next_to(house(_, _, _, _, japanese), house(_, _, _, _, snails), Puzzle), next_to(house(_, _, _, fox, _), house(_, _, _, _, spanish), Puzzle), member(house(_, _, _, _, Zebra), Puzzle), member(house(yellow, _, _, _, _), Puzzle), member(house(_, _, water, _, _), Puzzle), solve_puzzle_aux(Puzzle).\n\nsolve_puzzle_aux([]).\nsolve_puzzle_aux([House | Puzzle]) :- solve_puzzle_aux(Puzzle), member(house(_, _, _, _, House), Puzzle).\n\nleft_of(A, B, List) :- append(_, [A, B | _], List)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 108: Database Querying\n:- dynamic(parent/2).\nparent(abe, homer).\nparent(homer, bart).\nparent(homer, lisa).\nparent(homer, maggie).\ngrandparent(X, Y) :- parent(X, Z), parent(Z, Y)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 109: Constraint Satisfaction Problem\n:- use_module(library(clpfd)).\ncoloring(Colors) :- Colors = [A, B, C, D], Colors ins 1..3, A #\\= B, A #\\= C, A #\\= D, B #\\= C, C #\\= D, label(Colors)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 110: Knowledge Representation\n:- dynamic(fact/2).\nfact(bird, can_fly).\nfact(bird, has_feathers).\nfact(penguin, cannot_fly).\nfact(penguin, has_feathers).\nfact(ostrich, cannot_fly).\nfact(ostrich, has_feathers)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 111: Expert System Rules\nhappy(X) :- exercise(X), good_food(X).\nexercise(john).\nexercise(peter).\ngood_food(john).\nsmart(Y) :- reads_books(Y), happy(Y).\nreads_books(john)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 112: Natural Language Processing\nsentence --> noun_phrase, verb_phrase.\nnoun_phrase --> determiner, noun.\nverb_phrase --> verb, noun_phrase.\ndeterminer --> [the].\ndeterminer --> [a].\nnoun --> [dog].\nnoun --> [cat].\nverb --> [chased].\nverb --> [ate]."
  },
  {
    "language": "Prolog",
    "code": "% Sample 113: Game Playing AI\n:- dynamic(board/1).\nboard([_, _, _, _, _, _, _, _, _]). % Representing the game board\nmove(X, Player) :- board(B), select_empty_spot(B, X), assert(board(X, Player)).\nselect_empty_spot([X | _], X) :- var(X).\nselect_empty_spot([_ | T], X) :- select_empty_spot(T, X)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 114: Neural Network Implementation\n:- use_module(library(neural_network)).\n:- dynamic example/2.\nexample([0, 0], 0).\nexample([0, 1], 1).\nexample([1, 0], 1).\nexample([1, 1], 0).\ncreate_network :- create_network([2, 3, 1]), train_network(1000)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 115: Expert System Inference\n:- dynamic(fact/2).\nfact(bird, can_fly).\nfact(bird, has_feathers).\nfact(penguin, cannot_fly).\nfact(penguin, has_feathers).\nfact(ostrich, cannot_fly).\nfact(ostrich, has_feathers).\nquery(X) :- fact(X, can_fly), fact(X, has_feathers), write('The '), write(X), write(' can fly and has feathers.').\nquery(X) :- fact(X, cannot_fly), fact(X, has_feathers), write('The '), write(X), write(' cannot fly but has feathers.')."
  },
  {
    "language": "Prolog",
    "code": "% Sample 116: Gene Expression Analysis\n:- dynamic(gene_expression/2).\ngene_expression(gene1, upregulated).\ngene_expression(gene2, downregulated).\ngene_expression(gene3, upregulated).\ngene_expression(gene4, unchanged).\nquery_upregulated_genes :- gene_expression(Gene, upregulated), write('Upregulated gene: '), write(Gene), nl, fail.\nquery_upregulated_genes."
  },
  {
    "language": "Prolog",
    "code": "% Sample 117: Bayesian Network Inference\n:- use_module(library(bayesian)).\nprobability_alarm :- prob(Alarm, [burglary(true), earthquake(false)], P), write('Probability of alarm given burglary and no earthquake: '), write(P), nl."
  },
  {
    "language": "Prolog",
    "code": "% Sample 118: Constraint Logic Programming\n:- use_module(library(clpfd)).\nmagic_square(3, Square) :- Square = [A, B, C, D, E, F, G, H, I], Square ins 1..9, all_different(Square), A+B+C #= S, D+E+F #= S, G+H+I #= S, A+D+G #= S, B+E+H #= S, C+F+I #= S, A+E+I #= S, C+E+G #= S, label(Square)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 119: Natural Language Understanding\nsentence --> noun_phrase, verb_phrase.\nnoun_phrase --> determiner, noun.\nverb_phrase --> verb, noun_phrase.\ndeterminer --> [the].\ndeterminer --> [a].\nnoun --> [dog].\nnoun --> [cat].\nverb --> [chased].\nverb --> [ate]."
  },
  {
    "language": "Prolog",
    "code": "% Sample 120: Decision Tree Learning\n:- use_module(library(dtree)).\ntrain_data(X) :- X = [class(a), attr1(1), attr2(2), attr3(3)].\ntrain_data(Y) :- Y = [class(b), attr1(2), attr2(3), attr3(1)].\ntrain_data(Z) :- Z = [class(a), attr1(3), attr2(1), attr3(2)].\nlearn_tree :- findall(Instance, train_data(Instance), Instances), learn_tree(Instances, Tree), write(Tree)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 121: Fuzzy Logic System\n:- use_module(library(fuzzy)).\n:- fuzzy_system(temperature_control).\nfuzzy_variable(temperature).\nlinguistic_value(temperature, cold, triangular(0, 10, 20)).\nlinguistic_value(temperature, warm, triangular(15, 25, 35)).\nlinguistic_value(temperature, hot, triangular(30, 40, 50)).\nrule_block(temperature_control, [if(temperature is cold) then(heat is high), if(temperature is warm) then(heat is medium), if(temperature is hot) then(heat is low)])."
  },
  {
    "language": "Prolog",
    "code": "% Sample 122: Natural Language Generation\nsentence --> noun_phrase, verb_phrase.\nnoun_phrase --> determiner, noun.\nverb_phrase --> verb, noun_phrase.\ndeterminer --> [the].\ndeterminer --> [a].\nnoun --> [dog].\nnoun --> [cat].\nverb --> [chased].\nverb --> [ate]."
  },
  {
    "language": "Prolog",
    "code": "% Sample 123: Expert System Rules\nrule(high_temperature, fever) :- body_temperature(X), X > 37.5.\nrule(coughing, cold) :- symptom(cough), symptom(sore_throat), not(rule(high_temperature, _)).\nrule(headache, flu) :- symptom(headache), symptom(fatigue), not(rule(coughing, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 124: Bayesian Network Inference\n:- use_module(library(bayesian)).\nprobability_alarm :- prob(Alarm, [burglary(true), earthquake(false)], P), write('Probability of alarm given burglary and no earthquake: '), write(P), nl."
  },
  {
    "language": "Prolog",
    "code": "% Sample 125: Genetic Algorithm Implementation\n:- use_module(library(genetic)).\ncost_fn([X, Y], Cost) :- Cost is (X-3)*(X-3) + (Y-4)*(Y-4).\ncreate_genome(X) :- length(X, 2), X ins 0..10.\ninitialize_population(100, 2, Population), genetic_algorithm(Population, cost_fn, selection_tournament, crossover_onepoint, mutate_flip, halt_max_generations(100))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 126: Database Querying\n:- dynamic(family/2).\nfamily(john, smith).\nfamily(mary, john).\nfamily(bob, smith).\nquery(X) :- family(X, smith), write(X), nl, fail."
  },
  {
    "language": "Prolog",
    "code": "% Sample 127: Decision Tree Learning\n:- use_module(library(dtree)).\ntrain_data(X) :- X = [class(a), attr1(1), attr2(2), attr3(3)].\ntrain_data(Y) :- Y = [class(b), attr1(2), attr2(3), attr3(1)].\ntrain_data(Z) :- Z = [class(a), attr1(3), attr2(1), attr3(2)].\nlearn_tree :- findall(Instance, train_data(Instance), Instances), learn_tree(Instances, Tree), write(Tree)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 128: Constraint Satisfaction Problem\n:- use_module(library(clpfd)).\nqueens(N, Qs) :- length(Qs, N), Qs ins 1..N, safe(Qs), all_distinct(Qs), labeling([ffc], Qs).\nsafe([]).\nsafe([Q|Qs]) :- safe(Qs, Q, 1), safe(Qs).\nsafe([], _, _).\nsafe([Q|Qs], Q0, D0) :- Q0 #\\= Q, abs(Q0 - Q) #\\= D0, D1 #= D0 + 1, safe(Qs, Q0, D1)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 129: Knowledge Base Manipulation\n:- dynamic(fact/2).\nfact(bird, can_fly).\nfact(bird, has_feathers).\nfact(penguin, cannot_fly).\nfact(penguin, has_feathers).\nfact(ostrich, cannot_fly).\nfact(ostrich, has_feathers).\nretract_fact(Fact) :- retract(fact(Fact, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 130: Graph Algorithms\n:- use_module(library(ugraphs)).\nvertices_edges_to_ugraph([a, b, c], [e(a, b), e(b, c)]). % Creating a graph\nreachable_nodes(Graph, Node, Reachable) :- reachable(Graph, Node, Reachable)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 131: Genetic Programming\n:- use_module(library(gp)).\neval(S, Val) :- atom_number(S, Val).\nmax_arity(2).\nprimitive_set([+, -, *, /]).\ngenerate_gp_tree(5, Tree), fitness(Tree, Fit)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 132: Semantic Web Querying\n:- use_module(library(semweb/rdf_db)).\nrdf_load('data.rdf'). % Loading RDF data\nquery_rdf(Subject, Predicate, Object) :- rdf(Subject, Predicate, Object)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 133: Natural Language Processing\nparse_sentence(Sentence) :- sentence(Sentence, []).\nsentence --> noun_phrase, verb_phrase.\nnoun_phrase --> determiner, noun.\nverb_phrase --> verb, noun_phrase.\ndeterminer --> [the].\ndeterminer --> [a].\nnoun --> [dog].\nnoun --> [cat].\nverb --> [chased].\nverb --> [ate]."
  },
  {
    "language": "Prolog",
    "code": "% Sample 134: Markov Decision Processes\n:- use_module(library(mdps)).\nstate(s1).\nstate(s2).\naction(a1).\naction(a2).\ntransition(s1, a1, s2, 0.8).\ntransition(s1, a1, s1, 0.2).\ntransition(s2, a2, s2, 0.9).\ntransition(s2, a2, s1, 0.1).\nreward(s1, a1, -2).\nreward(s2, a2, 10)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 135: Automated Theorem Proving\n:- use_module(library(clpfd)).\ntheorem_prover(Statement) :- Statement, write('The statement is provable.').\nStatement."
  },
  {
    "language": "Prolog",
    "code": "% Sample 136: Pattern Matching\nmatch(X, X) :- true.\nmatch(_, _) :- fail."
  },
  {
    "language": "Prolog",
    "code": "% Sample 137: Constraint Logic Programming\n:- use_module(library(clpfd)).\nmagic_square(3, Square) :- Square = [A, B, C, D, E, F, G, H, I], Square ins 1..9, all_different(Square), A+B+C #= S, D+E+F #= S, G+H+I #= S, A+D+G #= S, B+E+H #= S, C+F+I #= S, A+E+I #= S, C+E+G #= S, label(Square)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 138: Truth Maintenance System\n:- dynamic(fact/2).\nassert_fact(X, Y) :- assert(fact(X, Y)), assert(opposite(X, Z)), assert(fact(Z, _)), assert(opposite(Y, _)).\nretract_fact(X) :- retract(fact(X, Y)), retract(opposite(X, Z)), retract(fact(Z, _)), retract(opposite(Y, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 139: Cryptography Algorithms\n:- use_module(library(crypto)).\nencrypt_message(Message, Key, Encrypted) :- crypto_data_encrypt(Message, Key, Encrypted).\ndecrypt_message(Encrypted, Key, Decrypted) :- crypto_data_decrypt(Encrypted, Key, Decrypted)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 140: Network Routing Algorithms\n:- use_module(library(route)).\noptimize_route(Start, End, OptimalRoute) :- shortest_path(Start, End, OptimalRoute)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 121: Fuzzy Logic System\n:- use_module(library(fuzzy)).\n:- fuzzy_system(temperature_control).\nfuzzy_variable(temperature).\nlinguistic_value(temperature, cold, triangular(0, 10, 20)).\nlinguistic_value(temperature, warm, triangular(15, 25, 35)).\nlinguistic_value(temperature, hot, triangular(30, 40, 50)).\nrule_block(temperature_control, [if(temperature is cold) then(heat is high), if(temperature is warm) then(heat is medium), if(temperature is hot) then(heat is low)])."
  },
  {
    "language": "Prolog",
    "code": "% Sample 122: Natural Language Generation\nsentence --> noun_phrase, verb_phrase.\nnoun_phrase --> determiner, noun.\nverb_phrase --> verb, noun_phrase.\ndeterminer --> [the].\ndeterminer --> [a].\nnoun --> [dog].\nnoun --> [cat].\nverb --> [chased].\nverb --> [ate]."
  },
  {
    "language": "Prolog",
    "code": "% Sample 123: Expert System Rules\nrule(high_temperature, fever) :- body_temperature(X), X > 37.5.\nrule(coughing, cold) :- symptom(cough), symptom(sore_throat), not(rule(high_temperature, _)).\nrule(headache, flu) :- symptom(headache), symptom(fatigue), not(rule(coughing, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 124: Bayesian Network Inference\n:- use_module(library(bayesian)).\nprobability_alarm :- prob(Alarm, [burglary(true), earthquake(false)], P), write('Probability of alarm given burglary and no earthquake: '), write(P), nl."
  },
  {
    "language": "Prolog",
    "code": "% Sample 125: Genetic Algorithm Implementation\n:- use_module(library(genetic)).\ncost_fn([X, Y], Cost) :- Cost is (X-3)*(X-3) + (Y-4)*(Y-4).\ncreate_genome(X) :- length(X, 2), X ins 0..10.\ninitialize_population(100, 2, Population), genetic_algorithm(Population, cost_fn, selection_tournament, crossover_onepoint, mutate_flip, halt_max_generations(100))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 126: Database Querying\n:- dynamic(family/2).\nfamily(john, smith).\nfamily(mary, john).\nfamily(bob, smith).\nquery(X) :- family(X, smith), write(X), nl, fail."
  },
  {
    "language": "Prolog",
    "code": "% Sample 127: Decision Tree Learning\n:- use_module(library(dtree)).\ntrain_data(X) :- X = [class(a), attr1(1), attr2(2), attr3(3)].\ntrain_data(Y) :- Y = [class(b), attr1(2), attr2(3), attr3(1)].\ntrain_data(Z) :- Z = [class(a), attr1(3), attr2(1), attr3(2)].\nlearn_tree :- findall(Instance, train_data(Instance), Instances), learn_tree(Instances, Tree), write(Tree)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 128: Constraint Satisfaction Problem\n:- use_module(library(clpfd)).\nqueens(N, Qs) :- length(Qs, N), Qs ins 1..N, safe(Qs), all_distinct(Qs), labeling([ffc], Qs).\nsafe([]).\nsafe([Q|Qs]) :- safe(Qs, Q, 1), safe(Qs).\nsafe([], _, _).\nsafe([Q|Qs], Q0, D0) :- Q0 #\\= Q, abs(Q0 - Q) #\\= D0, D1 #= D0 + 1, safe(Qs, Q0, D1)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 129: Knowledge Base Manipulation\n:- dynamic(fact/2).\nfact(bird, can_fly).\nfact(bird, has_feathers).\nfact(penguin, cannot_fly).\nfact(penguin, has_feathers).\nfact(ostrich, cannot_fly).\nfact(ostrich, has_feathers).\nretract_fact(Fact) :- retract(fact(Fact, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 130: Graph Algorithms\n:- use_module(library(ugraphs)).\nvertices_edges_to_ugraph([a, b, c], [e(a, b), e(b, c)]). % Creating a graph\nreachable_nodes(Graph, Node, Reachable) :- reachable(Graph, Node, Reachable)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 131: Genetic Programming\n:- use_module(library(gp)).\neval(S, Val) :- atom_number(S, Val).\nmax_arity(2).\nprimitive_set([+, -, *, /]).\ngenerate_gp_tree(5, Tree), fitness(Tree, Fit)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 132: Semantic Web Querying\n:- use_module(library(semweb/rdf_db)).\nrdf_load('data.rdf'). % Loading RDF data\nquery_rdf(Subject, Predicate, Object) :- rdf(Subject, Predicate, Object)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 133: Natural Language Processing\nparse_sentence(Sentence) :- sentence(Sentence, []).\nsentence --> noun_phrase, verb_phrase.\nnoun_phrase --> determiner, noun.\nverb_phrase --> verb, noun_phrase.\ndeterminer --> [the].\ndeterminer --> [a].\nnoun --> [dog].\nnoun --> [cat].\nverb --> [chased].\nverb --> [ate]."
  },
  {
    "language": "Prolog",
    "code": "% Sample 134: Markov Decision Processes\n:- use_module(library(mdps)).\nstate(s1).\nstate(s2).\naction(a1).\naction(a2).\ntransition(s1, a1, s2, 0.8).\ntransition(s1, a1, s1, 0.2).\ntransition(s2, a2, s2, 0.9).\ntransition(s2, a2, s1, 0.1).\nreward(s1, a1, -2).\nreward(s2, a2, 10)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 135: Automated Theorem Proving\n:- use_module(library(clpfd)).\ntheorem_prover(Statement) :- Statement, write('The statement is provable.').\nStatement."
  },
  {
    "language": "Prolog",
    "code": "% Sample 136: Pattern Matching\nmatch(X, X) :- true.\nmatch(_, _) :- fail."
  },
  {
    "language": "Prolog",
    "code": "% Sample 137: Constraint Logic Programming\n:- use_module(library(clpfd)).\nmagic_square(3, Square) :- Square = [A, B, C, D, E, F, G, H, I], Square ins 1..9, all_different(Square), A+B+C #= S, D+E+F #= S, G+H+I #= S, A+D+G #= S, B+E+H #= S, C+F+I #= S, A+E+I #= S, C+E+G #= S, label(Square)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 138: Truth Maintenance System\n:- dynamic(fact/2).\nassert_fact(X, Y) :- assert(fact(X, Y)), assert(opposite(X, Z)), assert(fact(Z, _)), assert(opposite(Y, _)).\nretract_fact(X) :- retract(fact(X, Y)), retract(opposite(X, Z)), retract(fact(Z, _)), retract(opposite(Y, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 139: Cryptography Algorithms\n:- use_module(library(crypto)).\nencrypt_message(Message, Key, Encrypted) :- crypto_data_encrypt(Message, Key, Encrypted).\ndecrypt_message(Encrypted, Key, Decrypted) :- crypto_data_decrypt(Encrypted, Key, Decrypted)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 140: Network Routing Algorithms\n:- use_module(library(route)).\noptimize_route(Start, End, OptimalRoute) :- shortest_path(Start, End, OptimalRoute)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 141: Knowledge Representation\nfact(human, 'is a', 'mammal').\nfact(mammal, 'is a', 'animal').\nquery(X, Y, Z) :- fact(X, Y, Z), write(X), write(' '), write(Y), write(' '), write(Z), nl, fail."
  },
  {
    "language": "Prolog",
    "code": "% Sample 142: Game Playing Strategies\nmove(player1, Board) :- possible_move(Board, Move), make_move(Board, Move, NewBoard), assert(board(NewBoard)), retract(board(Board)).\nmove(player2, Board) :- possible_move(Board, Move), make_move(Board, Move, NewBoard), assert(board(NewBoard)), retract(board(Board))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 143: Set Operations\nunion([], L, L).\nunion([H|T], L, Result) :- member(H, L), union(T, L, Result).\nunion([H|T], L, [H|Result]) :- \\+ member(H, L), union(T, L, Result)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 144: Machine Learning Algorithms\n:- use_module(library(svm)).\ntrain_data(X) :- X = [class(1), attr1(1), attr2(2), attr3(3)].\ntrain_data(Y) :- Y = [class(-1), attr1(2), attr2(3), attr3(1)].\ntrain_data(Z) :- Z = [class(1), attr1(3), attr2(1), attr3(2)].\nsvm_train(TrainData, Model), svm_predict(Model, TestData, Predictions)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 145: Text Processingparse_text(Text) :- split_string(Text, ' ' , ' ', Words), write(Words)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 146: Temporal Reasoning\nschedule_event(Event) :- assert(event(Event, time(10, 00))), assert(event(Event, duration(2, hours))).\nevent_conflict(Event1, Event2) :- event(Event1, time(T1)), event(Event2, time(T2)), event(Event1, duration(D1)), event(Event2, duration(D2)), T1 < T2 + D2, T1 + D1 > T2."
  },
  {
    "language": "Prolog",
    "code": "% Sample 147: Geometric Computations\narea(circle(R), A) :- A is pi * R * R.\narea(rectangle(W, H), A) :- A is W * H.\narea(triangle(B, H), A) :- A is 0.5 * B * H."
  },
  {
    "language": "Prolog",
    "code": "% Sample 148: Constraint Solving\n:- use_module(library(clpfd)).\nsequence(A, B, C) :- A + B #= C, labeling([], [A, B, C])."
  },
  {
    "language": "Prolog",
    "code": "% Sample 149: Software Verification\n:- dynamic(assertion/2).\nverify_predicate(Predicate) :- call(Predicate), assert(assertion(Predicate, true))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 150: Natural Language Understanding\nunderstand_sentence(Sentence) :- parse_sentence(Sentence), process_sentence."
  },
  {
    "language": "Prolog",
    "code": "% Sample 151: Knowledge Reasoning\nreasoning_engine(Fact) :- rule(Fact, _), assert(Fact), fail.\nreasoning_engine(Fact) :- rule(Fact, Body), Body, reasoning_engine(Fact)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 152: Tree Data Structures\n:- dynamic(tree/2).\ninsert_tree(Key, Value) :- tree(Key, _), !, retract(tree(Key, _)), assert(tree(Key, Value)).\ninsert_tree(Key, Value) :- assert(tree(Key, Value))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 153: Social Network Analysis\n:- dynamic(connection/2).\nadd_connection(User1, User2) :- assert(connection(User1, User2)).\nremove_connection(User1, User2) :- retract(connection(User1, User2))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 154: Web Scraping\n:- use_module(library(http/http_client)).\n:- use_module(library(http/http_html_plugin)).\nfetch_html(URL) :- http_get(URL, Html, []), print(Html)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 155: Event Handling\n:- dynamic(event/1).\ntrigger_event(Event) :- assert(event(Event)).\nhandle_event(Event) :- event(Event), process_event(Event), retract(event(Event))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 156: Matrix Operations\ntranspose_matrix([], []).\ntranspose_matrix([F|Fs], Ts) :- transpose_matrix(F, [F|Fs], Ts).\ntranspose_matrix([], _, []).\ntranspose_matrix([_|Rs], Ms, [Ts|Tss]) :- lists_firsts_rests(Ms, Ts, Ms1), transpose_matrix(Rs, Ms1, Tss)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 157: Software Testing\n:- dynamic(test_case/1).\nrun_test_case(TestCase) :- call(TestCase), assert(passed(TestCase))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 158: Audio Signal Processing\n:- use_module(library(wave)).\nread_wave_file(File) :- read_wave_file(File, Data), write(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 159: Database Management\n:- dynamic(entry/2).\nadd_entry(Key, Value) :- assert(entry(Key, Value)).\nremove_entry(Key) :- retract(entry(Key, _))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 160: IoT Device Control\n:- dynamic(device/1).\ncontrol_device(Device, Action) :- device(Device), perform_action(Action)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 161: Robotics Control\n:- dynamic(robot/1).\nmove_robot(Robot, Direction) :- robot(Robot), perform_movement(Direction)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 162: Natural Language Generation\n:- dynamic(sentence/1).\ngenerate_sentence(Type) :- sentence(Type), build_sentence(Type)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 163: Database Query Optimization\n:- dynamic(query/2).\noptimize_query(Query) :- analyze_query(Query), apply_optimization(Query)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 164: Pattern Recognition\n:- dynamic(pattern/1).\ndetect_pattern(Data) :- identify_pattern(Data), process_pattern(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 165: Expert Systems\n:- dynamic(fact/1).\nconsult_expert_system(Rules) :- load_rules(Rules), infer_facts(Rules), evaluate_situation."
  },
  {
    "language": "Prolog",
    "code": "% Sample 166: Network Analysis\n:- dynamic(node/1).\nanalyze_network(Graph) :- examine_graph(Graph), determine_properties(Graph)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 167: Natural Language Processing\n:- dynamic(sentence/1).\nparse_input(Input) :- split_input(Input, Words), process_words(Words)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 168: Knowledge Representation\n:- dynamic(fact/2).\nadd_fact(Object, Property) :- assert(fact(Object, Property))."
  },
  {
    "language": "Prolog",
    "code": "% Sample 169: Data Visualization\n:- dynamic(data/1).\nvisualize_data(Data) :- plot_data(Data), display_visualization."
  },
  {
    "language": "Prolog",
    "code": "% Sample 170: Software Development\n:- dynamic(code/1).\nvalidate_code(Script) :- check_syntax(Script), analyze_logic(Script)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 171: Healthcare Systems\n:- dynamic(patient/2).\nmanage_patient_records(Patient) :- store_patient_information(Patient), update_medical_history(Patient)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 172: Natural Language Understanding\n:- dynamic(sentence/1).\nunderstand_input(Input) :- parse_input(Input), interpret_meaning."
  },
  {
    "language": "Prolog",
    "code": "% Sample 173: Game Development\n:- dynamic(game/1).\ncreate_game(Game) :- initialize_game(Game), start_game_loop(Game)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 174: Web Development\n:- dynamic(webpage/1).\nbuild_webpage(Page) :- create_page_structure(Page), design_user_interface(Page)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 175: Image Processing\n:- dynamic(image/1).\nprocess_image(Image) :- apply_filters(Image), enhance_features(Image)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 176: Financial Analysis\n:- dynamic(data/1).\nanalyze_financial_data(Data) :- compute_metrics(Data), generate_reports(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 177: Cloud Computing\n:- dynamic(instance/1).\nmanage_cloud_instance(Instance) :- allocate_resources(Instance), monitor_performance(Instance)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 178: Security Systems\n:- dynamic(system/1).\nprotect_system(System) :- implement_security_measures(System), detect_threats(System)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 179: Human-Computer Interaction\n:- dynamic(interaction/1).\nfacilitate_interaction(User) :- understand_user_behavior(User), adapt_interface(User)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 180: Machine Vision\n:- dynamic(data/1).\ninterpret_visual_data(Data) :- process_images(Data), recognize_patterns(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 181: Data Mining\n:- dynamic(data/1).\nmine_data(Data) :- extract_patterns(Data), analyze_trends(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 182: Augmented Reality\n:- dynamic(scene/1).\ncreate_augmented_reality(Scene) :- overlay_virtual_elements(Scene), render_augmented_view(Scene)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 183: Computational Linguistics\n:- dynamic(corpus/1).\nprocess_corpus(Corpus) :- tokenize_text(Corpus), derive_syntax(Corpus)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 184: Time Series Analysis\n:- dynamic(time_series/1).\nanalyze_time_series(Data) :- detect_patterns(Data), forecast_future_trends(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 185: Reinforcement Learning\n:- dynamic(agent/1).\ntrain_agent(Agent) :- define_environment(Agent), apply_policy_learning(Agent)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 186: Knowledge Discovery\n:- dynamic(data/1).\nexplore_data(Data) :- identify_hidden_patterns(Data), uncover_insights(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 187: Automated Planning\n:- dynamic(plan/1).\ngenerate_plan(Task) :- define_goals(Task), formulate_strategy(Task)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 188: Distributed Systems\n:- dynamic(network/1).\nmanage_network(Network) :- distribute_resources(Network), coordinate_operations(Network)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 189: Software Engineering\n:- dynamic(project/1).\nlead_project(Project) :- plan_development(Project), oversee_implementation(Project)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 190: Spatial Analysis\n:- dynamic(spacial_data/1).\nanalyze_spacial_data(Data) :- model_geographical_patterns(Data), predict_location_trends(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 191: Neuroinformatics\n:- dynamic(neural_data/1).\ninterpret_neural_data(Data) :- map_brain_activity(Data), simulate_neural_network(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 192: Quantum Information\n:- dynamic(qubit/1).\nprocess_qubits(Qubits) :- entangle_qubits(Qubits), perform_quantum_operations(Qubits)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 193: Evolutionary Computation\n:- dynamic(population/1).\nsimulate_evolution(Population) :- apply_selection(Population), drive_variation(Population)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 194: Computational Geometry\n:- dynamic(geometry/1).\nexplore_geometry(Data) :- calculate_distances(Data), determine_shapes(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 195: Information Retrieval\n:- dynamic(query/1).\nretrieve_information(Query) :- process_query(Query), fetch_relevant_data(Query)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 196: Mobile Computing\n:- dynamic(app/1).\ndevelop_mobile_app(App) :- design_interface(App), optimize_performance(App)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 197: Constraint Satisfaction\n:- dynamic(constraint/1).\nsatisfy_constraints(Problem) :- apply_restrictions(Problem), find_solution(Problem)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 198: Social Computing\n:- dynamic(social_data/1).\nanalyze_social_data(Data) :- extract_behaviors(Data), model_networks(Data)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 199: Cloud Services\n:- dynamic(service/1).\nmanage_cloud_service(Service) :- allocate_resources(Service), ensure_security(Service)."
  },
  {
    "language": "Prolog",
    "code": "% Sample 200: Data Science\n:- dynamic(dataset/1).\nstudy_dataset(Data) :- preprocess_data(Data), build_models(Data)."
  },
  {
    "language": "Scheme",
    "code": "(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (sum-of-squares a b) (+ (* a a) (* b b)))"
  },
  {
    "language": "Scheme",
    "code": "(define my-list '(1 2 3 4)) (car my-list) (cdr my-list)"
  },
  {
    "language": "Scheme",
    "code": "(define (fibonacci n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (power-of-two n) (expt 2 n))"
  },
  {
    "language": "Scheme",
    "code": "(define (sum-list lst) (if (null? lst) 0 (+ (car lst) (sum-list (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (square x) (* x x))"
  },
  {
    "language": "Scheme",
    "code": "(define (map f lst) (if (null? lst) '() (cons (f (car lst)) (map f (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (filter pred lst) (cond ((null? lst) '()) ((pred (car lst)) (cons (car lst) (filter pred (cdr lst)))) (else (filter pred (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": "(define (merge lst1 lst2) (cond ((null? lst1) lst2) ((null? lst2) lst1) ((< (car lst1) (car lst2)) (cons (car lst1) (merge (cdr lst1) lst2))) (else (cons (car lst2) (merge lst1 (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (gcd a b) (if (= b 0) a (gcd b (remainder a b))))"
  },
  {
    "language": "Scheme",
    "code": "(define (quicksort lst) (if (null? lst) '() (let ((pivot (car lst))) (append (quicksort (filter (lambda (x) (< x pivot)) (cdr lst))) (cons pivot (quicksort (filter (lambda (x) (>= x pivot)) (cdr lst))))))))"
  },
  {
    "language": "Scheme",
    "code": "(define (reverse lst) (define (reverse-iter lst result) (if (null? lst) result (reverse-iter (cdr lst) (cons (car lst) result)))) (reverse-iter lst '()))"
  },
  {
    "language": "Scheme",
    "code": "(define (make-counter) (let ((count 0)) (lambda () (set! count (+ count 1)) count)))"
  },
  {
    "language": "Scheme",
    "code": "(define (factorial n) (let loop ((n n) (acc 1)) (if (= n 0) acc (loop (- n 1) (* acc n)))))"
  },
  {
    "language": "Scheme",
    "code": "(define greeting \"Hello, \") (define name \"Alice\") (display (string-append greeting name))"
  },
  {
    "language": "Scheme",
    "code": "(define myList '(1 2 3 4)) (define myListReversed (reverse myList)) (define myListLength (length myList))"
  },
  {
    "language": "Scheme",
    "code": "(define (apply-twice func arg) (func (func arg))) (define (add-one x) (+ x 1)) (define result (apply-twice add-one 5))"
  },
  {
    "language": "Scheme",
    "code": "(+ 10 20) (- 50 30) (* 5 6) (/ 100 4)"
  },
  {
    "language": "Scheme",
    "code": "(define (is-even? n) (= (remainder n 2) 0)) (if (is-even? 10) (display \"Number is even\") (display \"Number is odd\"))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 1: Define a Function\n(define (add x y) (+ x y))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 2: Recursive Function\n(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 3: List Manipulation\n(define list-sample (list 1 2 3 4 5))\n(car list-sample)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 4: Define a Lambda Function\n((lambda (x) (+ x 10)) 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 5: Higher-Order Functions\n(define (apply-twice f x) (f (f x)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 6: Define a Macro\n(define-macro (when condition . body) `(if ,condition (begin ,@body)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 7: Define a Closure\n(define (make-counter)\n  (let ((count 0))\n    (lambda ()\n      (set! count (+ count 1))\n      count)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 8: Error Handling with 'error'\n(define (safe-divide x y)\n  (if (= y 0)\n      (error 'division-by-zero \"Attempt to divide by zero\")\n      (/ x y)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 9: Using 'map' Function\n(define (square x) (* x x))\n(map square '(1 2 3 4))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 10: Working with Strings\n(define str \"Hello, Scheme!\")\n(string-length str)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 11: Define a Recursive Fibonacci Function\n(define (fibonacci n)\n  (if (< n 2)\n      n\n      (+ (fibonacci (- n 1)) (fibonacci (- n 2)))) )"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 12: Working with Lists and 'cons'\n(define lst (cons 1 (cons 2 (cons 3 '()))))\n(cadr lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 13: Use of 'let' for Local Bindings\n(define (calculate)\n  (let ((a 10) (b 5))\n    (+ a b)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 14: Creating and Using Vectors\n(define vec (vector 1 2 3 4))\n(vector-ref vec 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 15: Working with Conditions and 'cond'\n(define (classify-age age)\n  (cond\n    ((<= age 12) 'child)\n    ((<= age 18) 'teenager)\n    (else 'adult)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 16: Using 'apply' for Function Application\n(define (add x y) (+ x y))\n(apply add '(3 5))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 17: Define a Procedure with Optional Arguments\n(define (greet . args)\n  (display \"Hello\")\n  (if (not (null? args)) (display (car args)))\n  (newline))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 18: Handling Multiple Expressions with 'begin'\n(define (mult-expressions x)\n  (begin\n    (display \"Value of x is \")\n    (display x)\n    (newline)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 19: Basic Arithmetic Operations\n(+ 5 3)\n(- 10 4)\n(* 3 7)\n(/ 20 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 20: Using 'define' to Create Constants\n(define pi 3.14159)\n(* pi 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 21: Recursive Factorial Function\n(define (factorial n)\n  (if (= n 0)\n      1\n      (* n (factorial (- n 1)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 22: Manipulating Strings\n(define str-length (string-length \"Hello, Scheme!\"))\n(substring \"Hello, Scheme!\" 0 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 23: Working with 'map' and Functions\n(define lst '(1 2 3 4 5))\n(define (double x) (* x 2))\n(map double lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 24: Defining a Higher-Order Function\n(define (apply-twice f x) (f (f x)))\n(define (square x) (* x x))\n(apply-twice square 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 25: Using 'filter' with Predicates\n(define lst '(1 2 3 4 5))\n(define (even? x) (= (remainder x 2) 0))\n(filter even? lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 26: Working with 'let*' for Sequential Bindings\n(define (calculate)\n  (let* ((a 10)\n         (b (+ a 5)))\n    (* a b)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 27: Creating and Manipulating Matrices\n(define matrix '((1 2 3) (4 5 6) (7 8 9)))\n(list-ref (list-ref matrix 1) 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 28: Using 'for-each' for Iteration\n(define lst '(1 2 3 4 5))\n(define (display-square x) (display (* x x)))\n(for-each display-square lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 29: Creating and Using Hash Tables\n(define ht (make-hash))\n(hash-set! ht 'key 'value)\n(hash-ref ht 'key)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 30: Working with 'quasiquote' and 'unquote'\n(define a 10)\n(define b 20)\n`(a ,a b ,(+ a b))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 21: Recursive Fibonacci Function with Memoization\n(define (fib-memo n)\n  (letrec ((fib-iter (lambda (n a b)\n                        (if (= n 0) a\n                            (fib-iter (- n 1) b (+ a b))))))\n    (fib-iter n 0 1)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 22: Implementing 'flatten' for Nested Lists\n(define (flatten lst)\n  (cond\n    ((null? lst) '())\n    ((not (pair? lst)) (list lst))\n    (else (append (flatten (car lst)) (flatten (cdr lst))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 23: Using 'case' for Multiple Conditions\n(define (classify-weather condition)\n  (case condition\n    ((\"sunny\" \"clear\") 'good)\n    ((\"rainy\" \"cloudy\") 'bad)\n    (else 'unknown)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 24: Working with 'eval' to Execute Code\n(define expr '(+ 2 3))\n(eval expr)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 25: Creating and Using Sets\n(define set1 (list->set '(1 2 3 4)))\n(define set2 (list->set '(3 4 5 6)))\n(set-union set1 set2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 26: Implementing 'zip' for Lists\n(define (zip lst1 lst2)\n  (cond\n    ((or (null? lst1) (null? lst2)) '())\n    (else (cons (list (car lst1) (car lst2))\n                (zip (cdr lst1) (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 27: Using 'define-syntax' to Create Macros\n(define-syntax my-cond\n  (syntax-rules ()\n    ((_ (else result ...))\n     (begin result ...))\n    ((_ (test result ...))\n     (if test\n         (begin result ...)\n         (my-cond (else result ...))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 28: Working with 'and' and 'or' Operators\n(define (check-age age)\n  (if (and (>= age 18) (<= age 60))\n      'eligible\n      'not-eligible))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 29: Using 'set!' to Modify Variables\n(define counter 0)\n(set! counter (+ counter 1))\ncounter"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 30: Creating a Simple Recursive Procedure\n(define (countdown n)\n  (if (= n 0)\n      'done\n      (begin\n        (display n)\n        (newline)\n        (countdown (- n 1))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 1: Define a Recursive Fibonacci Function\n(define (fibonacci n)\n  (if (< n 2)\n      n\n      (+ (fibonacci (- n 1)) (fibonacci (- n 2)))) )"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 2: Working with Lists and 'cons'\n(define lst (cons 1 (cons 2 (cons 3 '()))))\n(cadr lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 3: Use of 'let' for Local Bindings\n(define (calculate)\n  (let ((a 10) (b 5))\n    (+ a b)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 4: Creating and Using Vectors\n(define vec (vector 1 2 3 4))\n(vector-ref vec 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 5: Working with Conditions and 'cond'\n(define (classify-age age)\n  (cond\n    ((<= age 12) 'child)\n    ((<= age 18) 'teenager)\n    (else 'adult)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 6: Using 'apply' for Function Application\n(define (add x y) (+ x y))\n(apply add '(3 5))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 7: Define a Procedure with Optional Arguments\n(define (greet . args)\n  (display \"Hello\")\n  (if (not (null? args)) (display (car args)))\n  (newline))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 8: Handling Multiple Expressions with 'begin'\n(define (mult-expressions x)\n  (begin\n    (display \"Value of x is \")\n    (display x)\n    (newline)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 9: Basic Arithmetic Operations\n(+ 5 3)\n(- 10 4)\n(* 3 7)\n(/ 20 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 10: Using 'define' to Create Constants\n(define pi 3.14159)\n(* pi 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 11: Recursive Factorial Function\n(define (factorial n)\n  (if (= n 0)\n      1\n      (* n (factorial (- n 1)))) )"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 12: Manipulating Strings\n(define str-length (string-length \"Hello, Scheme!\"))\n(substring \"Hello, Scheme!\" 0 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 13: Working with 'map' and Functions\n(define lst '(1 2 3 4 5))\n(define (double x) (* x 2))\n(map double lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 14: Defining a Higher-Order Function\n(define (apply-twice f x) (f (f x)))\n(define (square x) (* x x))\n(apply-twice square 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 15: Using 'filter' with Predicates\n(define lst '(1 2 3 4 5))\n(define (even? x) (= (remainder x 2) 0))\n(filter even? lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 16: Working with 'let*' for Sequential Bindings\n(define (calculate)\n  (let* ((a 10)\n         (b (+ a 5)))\n    (* a b)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 17: Creating and Manipulating Matrices\n(define matrix '((1 2 3) (4 5 6) (7 8 9)))\n(list-ref (list-ref matrix 1) 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 18: Using 'for-each' for Iteration\n(define lst '(1 2 3 4 5))\n(define (display-square x) (display (* x x)))\n(for-each display-square lst)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 19: Creating and Using Hash Tables\n(define ht (make-hash))\n(hash-set! ht 'key 'value)\n(hash-ref ht 'key)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 20: Working with 'quasiquote' and 'unquote'\n(define a 10)\n(define b 20)\n`(a ,a b ,(+ a b))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 21: Recursive Fibonacci Function with Memoization\n(define (fib-memo n)\n  (letrec ((fib-iter (lambda (n a b)\n                        (if (= n 0) a\n                            (fib-iter (- n 1) b (+ a b))))))\n    (fib-iter n 0 1)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 22: Implementing 'flatten' for Nested Lists\n(define (flatten lst)\n  (cond\n    ((null? lst) '())\n    ((not (pair? lst)) (list lst))\n    (else (append (flatten (car lst)) (flatten (cdr lst))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 23: Using 'case' for Multiple Conditions\n(define (classify-weather condition)\n  (case condition\n    ((\"sunny\" \"clear\") 'good)\n    ((\"rainy\" \"cloudy\") 'bad)\n    (else 'unknown)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 24: Working with 'eval' to Execute Code\n(define expr '(+ 2 3))\n(eval expr)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 25: Creating and Using Sets\n(define set1 (list->set '(1 2 3 4)))\n(define set2 (list->set '(3 4 5 6)))\n(set-union set1 set2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 26: Implementing 'zip' for Lists\n(define (zip lst1 lst2)\n  (cond\n    ((or (null? lst1) (null? lst2)) '())\n    (else (cons (list (car lst1) (car lst2))\n                (zip (cdr lst1) (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 27: Using 'define-syntax' to Create Macros\n(define-syntax my-cond\n  (syntax-rules ()\n    ((_ (else result ...))\n     (begin result ...))\n    ((_ (test result ...))\n     (if test\n         (begin result ...)\n         (my-cond (else result ...))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 28: Working with 'and' and 'or' Operators\n(define (check-age age)\n  (if (and (>= age 18) (<= age 60))\n      'eligible\n      'not-eligible))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 29: Using 'set!' to Modify Variables\n(define counter 0)\n(set! counter (+ counter 1))\ncounter"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 30: Creating a Simple Recursive Procedure\n(define (countdown n)\n  (if (= n 0)\n      'done\n      (begin\n        (display n)\n        (newline)\n        (countdown (- n 1))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 31: Implementing 'reduce' for List Operations\n(define (my-reduce func init lst)\n  (if (null? lst)\n      init\n      (func (car lst) (my-reduce func init (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 32: Using 'do' for Iterative Operations\n(define (sum-from-to start end)\n  (do ((i start (+ i 1))\n       (sum 0 (+ sum i)))\n      ((> i end) sum)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 33: Working with 'quasiquote' and 'unquote-splicing'\n(define a '(1 2))\n(define b '(3 4))\n`(,@a ,@b)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 34: Implementing 'partition' for Lists\n(define (partition lst pred)\n  (list (filter pred lst) (filter (lambda (x) (not (pred x))) lst)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 35: Using 'define-record-type' for Custom Data Structures\n(define-record-type point\n  (make-point x y)\n  point?\n  (x point-x)\n  (y point-y))\n(define p (make-point 3 4))\n(point-x p)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 36: Implementing 'member?' to Check List Membership\n(define (member? x lst)\n  (cond\n    ((null? lst) #f)\n    ((equal? x (car lst)) #t)\n    (else (member? x (cdr lst))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 37: Using 'string-append' for String Operations\n(define str (string-append \"Hello,\" \" Scheme!\"))\n(substring str 0 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 38: Creating and Using 'letrec' for Recursive Definitions\n(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))\n         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))))\n  (even? 10))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 39: Implementing 'last' to Retrieve Last Element of a List\n(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 40: Using 'call/cc' for Continuations\n(define (test-cc)\n  (call/cc (lambda (k)\n             (* 5 (k 3)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 41: Using 'values' for Multiple Return Values\n(define (divide-numbers a b)\n  (if (= b 0)\n      (values #f \"Cannot divide by zero\")\n      (values (/ a b) \"Division successful\")))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 42: Implementing 'any?' to Check if Any Element Satisfies Predicate\n(define (any? pred lst)\n  (if (null? lst)\n      #f\n      (or (pred (car lst)) (any? pred (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 43: Using 'make-promise' and 'force' for Lazy Evaluation\n(define p (make-promise (lambda () (display \"Evaluated!\") 42)))\n(force p)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 44: Implementing 'interleave' for Lists\n(define (interleave lst1 lst2)\n  (if (or (null? lst1) (null? lst2))\n      '()\n      (cons (car lst1) (cons (car lst2) (interleave (cdr lst1) (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 45: Using 'guard' for Error Handling\n(define (divide a b)\n  (guard (error (else #f))\n    (/ a b)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 46: Implementing 'make-matrix' for Matrix Operations\n(define (make-matrix rows cols init)\n  (build-list rows (lambda (_) (build-list cols (lambda (_) init)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 41: Using 'values' for Multiple Return Values\n(define (divide-numbers a b)\n  (if (= b 0)\n      (values #f \"Cannot divide by zero\")\n      (values (/ a b) \"Division successful\")))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 42: Implementing 'any?' to Check if Any Element Satisfies Predicate\n(define (any? pred lst)\n  (if (null? lst)\n      #f\n      (or (pred (car lst)) (any? pred (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 43: Using 'make-promise' and 'force' for Lazy Evaluation\n(define p (make-promise (lambda () (display \"Evaluated!\") 42)))\n(force p)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 44: Implementing 'interleave' for Lists\n(define (interleave lst1 lst2)\n  (if (or (null? lst1) (null? lst2))\n      '()\n      (cons (car lst1) (cons (car lst2) (interleave (cdr lst1) (cdr lst2))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 45: Using 'guard' for Error Handling\n(define (divide a b)\n  (guard (error (else #f))\n    (/ a b)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 46: Implementing 'make-matrix' for Matrix Operations\n(define (make-matrix rows cols init)\n  (build-list rows (lambda (_) (build-list cols (lambda (_) init)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 47: Using 'enum-set' for Enumerated Sets\n(define weekdays (enum-set 'monday 'tuesday 'wednesday 'thursday 'friday))\n(enum-set-check weekdays 'monday)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 48: Implementing 'remove-duplicates' for Lists\n(define (remove-duplicates lst)\n  (cond\n    ((null? lst) '())\n    ((member? (car lst) (cdr lst)) (remove-duplicates (cdr lst)))\n    (else (cons (car lst) (remove-duplicates (cdr lst))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 49: Using 'for' for Iteration\n(define (print-numbers n)\n  (for ((i n))\n    (display i)\n    (newline)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 50: Implementing 'shuffle' for Lists\n(define (shuffle lst)\n  (letrec ((len (length lst)))\n    (if (= len 0) '()\n        (let* ((idx (random len))\n               (elem (list-ref lst idx)))\n          (cons elem (shuffle (append (take lst idx) (drop lst (+ idx 1))))))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 31: Implementing 'reduce' for List Operations\n(define (my-reduce func init lst)\n  (if (null? lst)\n      init\n      (func (car lst) (my-reduce func init (cdr lst)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 32: Using 'do' for Iterative Operations\n(define (sum-from-to start end)\n  (do ((i start (+ i 1))\n       (sum 0 (+ sum i)))\n      ((> i end) sum)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 33: Working with 'quasiquote' and 'unquote-splicing'\n(define a '(1 2))\n(define b '(3 4))\n`(,@a ,@b)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 34: Implementing 'partition' for Lists\n(define (partition lst pred)\n  (list (filter pred lst) (filter (lambda (x) (not (pred x))) lst)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 35: Using 'define-record-type' for Custom Data Structures\n(define-record-type point\n  (make-point x y)\n  point?\n  (x point-x)\n  (y point-y))\n(define p (make-point 3 4))\n(point-x p)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 36: Implementing 'member?' to Check List Membership\n(define (member? x lst)\n  (cond\n    ((null? lst) #f)\n    ((equal? x (car lst)) #t)\n    (else (member? x (cdr lst))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 37: Using 'string-append' for String Operations\n(define str (string-append \"Hello,\" \" Scheme!\"))\n(substring str 0 5)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 38: Creating and Using 'letrec' for Recursive Definitions\n(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))\n         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))))\n  (even? 10))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 39: Implementing 'last' to Retrieve Last Element of a List\n(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 40: Using 'call/cc' for Continuations\n(define (test-cc)\n  (call/cc (lambda (k)\n             (* 5 (k 3)))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 41: Using 'case-lambda' for Multiple Procedures\n(define (operations . args)\n  (case-lambda\n    ((x) (* x x))\n    ((x y) (+ x y))\n    ((x y z) (- (* x y) z))\n    (else 'invalid-arguments)))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 42: Working with 'make-vector' for Vectors\n(define vec (make-vector 3 #f))\n(vector-set! vec 1 'hello)\n(vector-ref vec 1)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 43: Using 'and-let*' for Sequential Conditions\n(define (check-range a b c)\n  (and-let* ((greater-a? (> a 10))\n             (less-b? (< b 20))\n             (positive-c? (> c 0)))\n    'all-conditions-satisfied))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 44: Implementing 'flatten-tree' for Nested Lists\n(define (flatten-tree tree)\n  (cond\n    ((null? tree) '())\n    ((not (pair? tree)) (list tree))\n    (else (append (flatten-tree (car tree)) (flatten-tree (cdr tree))))))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 45: Using 'match' for Pattern Matching\n(define (match-example x)\n  (match x\n    [(list a b c) (+ a b c)]\n    [(list a b c . rest) (+ a b c (length rest))]\n    [(list 'a x) (* x x)]\n    [_ 'no-match]))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 46: Implementing 'list-tail' for List Manipulation\n(define lst '(1 2 3 4 5))\n(list-tail lst 2)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 47: Using 'define-values' for Multiple Value Definitions\n(define-values (x y) (values 10 20))\n(* x y)"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 48: Implementing 'remove' for List Operations\n(define (remove-item item lst)\n  (filter (lambda (x) (not (= x item))) lst))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 49: Using 'let-syntax' to Define Macros\n(let-syntax ((double (syntax-rules () ((_ x) (* x 2)))))\n  (double 5))"
  },
  {
    "language": "Scheme",
    "code": ";; Sample 50: Implementing 'prime?' to Check Prime Numbers\n(define (prime? n)\n  (define (check-divisors d)\n    (cond\n      ((> d (sqrt n)) #t)\n      ((= (remainder n d) 0) #f)\n      (else (check-divisors (+ d 1)))))\n  (if (< n 2) #f (check-divisors 2)))"
  },
  {
    "language": "TCL",
    "code": "set greeting \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "puts \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "for {set i 0} {$i < 5} {incr i} { puts \"Iteration: $i\" }"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} foreach item $myList { puts $item }"
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] llength $numbers"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 3; expr {$x + $y}"
  },
  {
    "language": "TCL",
    "code": "set fruits {apple banana cherry} lsearch -exact $fruits banana"
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] lsort -integer $numbers"
  },
  {
    "language": "TCL",
    "code": "set sentence \"This is a sentence.\" set words [split $sentence] lindex $words 2"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 10; if {$x > $y} { puts \"x is greater than y\" } else { puts \"x is less than or equal to y\" }"
  },
  {
    "language": "TCL",
    "code": "proc add {a b} { return [expr {$a + $b}] } add 5 3"
  },
  {
    "language": "TCL",
    "code": "set colors {red green blue} lrange $colors 0 1"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} lsearch $myList banana"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} linsert $myList end \"orange\""
  },
  {
    "language": "TCL",
    "code": "set numbers [list 1 2 3 4 5] lreverse $numbers"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 10; expr {$x * $y}"
  },
  {
    "language": "TCL",
    "code": "set sentence \"This is a sentence.\" set words [split $sentence] llength $words"
  },
  {
    "language": "TCL",
    "code": "set myList {apple banana cherry} lrange $myList 0 1"
  },
  {
    "language": "TCL",
    "code": "set x 5; set y 3; expr {$x % $y}"
  },
  {
    "language": "TCL",
    "code": "# Sample 1: Printing Hello World\nputs \"Hello, World!\""
  },
  {
    "language": "TCL",
    "code": "# Sample 2: Variable Assignment and Printing\nset greeting \"Hello\"\nputs \"$greeting, World!\""
  },
  {
    "language": "TCL",
    "code": "# Sample 3: Working with Lists\nset my_list {apple banana cherry}\nputs [lindex $my_list 1]"
  },
  {
    "language": "TCL",
    "code": "# Sample 4: Conditional Statements\nset num 10\nif {$num > 0} {\n    puts \"Positive\"\n} else {\n    puts \"Non-positive\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 5: Looping with 'foreach'\nset numbers {1 2 3 4 5}\nforeach num $numbers {\n    puts \"Number: $num\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 6: Creating Procedures\nproc greet {name} {\n    puts \"Hello, $name!\"\n}\ngreet \"Alice\""
  },
  {
    "language": "TCL",
    "code": "# Sample 7: File I/O Operations\nset file [open \"example.txt\" w]\nputs $file \"This is a sample text.\"\nclose $file"
  },
  {
    "language": "TCL",
    "code": "# Sample 8: Using 'incr' for Incrementing Variables\nset counter 0\nincr counter\nputs $counter"
  },
  {
    "language": "TCL",
    "code": "# Sample 9: Working with Arrays\narray set details {name Alice age 30 city \"New York\"}\nputs $details(name)"
  },
  {
    "language": "TCL",
    "code": "# Sample 10: String Manipulation\nset text \"TCL is awesome!\"\nputs [string toupper $text]"
  },
  {
    "language": "TCL",
    "code": "# Sample 11: Using 'clock' for Date and Time Operations\nset current_time [clock format [clock seconds] -format %H:%M:%S]\nputs $current_time"
  },
  {
    "language": "TCL",
    "code": "# Sample 12: Working with Regular Expressions\nset text \"TCL123 is interesting\"\nif {[regexp {TCL\\d+} $text]} {\n    puts \"Pattern found\"\n} else {\n    puts \"Pattern not found\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 13: Error Handling with 'catch'\nset value 10\nif {[catch {set result [expr $value / 0]} errorMsg]} {\n    puts \"Error: $errorMsg\"\n} else {\n    puts $result\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 14: Using 'expr' for Arithmetic Operations\nset x 10\nset y 20\nset result [expr $x + $y]\nputs $result"
  },
  {
    "language": "TCL",
    "code": "# Sample 15: Executing External Commands\nset output [exec ls -l]\nputs $output"
  },
  {
    "language": "TCL",
    "code": "# Sample 16: Manipulating File Paths\nset filename \"file.txt\"\nset filepath [file join /path/to/directory $filename]\nputs $filepath"
  },
  {
    "language": "TCL",
    "code": "# Sample 17: Using 'binary' for Binary Data Operations\nset data [binary format H* 48656C6C6F20576F726C64]\nputs $data"
  },
  {
    "language": "TCL",
    "code": "# Sample 18: Creating Widgets with 'tkinter'\npackage require Tk\nset w [tk::button .b -text \"Click Me\"]\npack .b"
  },
  {
    "language": "TCL",
    "code": "# Sample 19: Creating Custom Procedures\nproc factorial {n} {\n    if {$n <= 1} {\n        return 1\n    }\n    return [expr $n * [factorial [expr $n - 1]]]\n}\nputs [factorial 5]"
  },
  {
    "language": "TCL",
    "code": "# Sample 20: Using 'switch' for Multiple Conditions\nset fruit apple\nswitch $fruit {\n    apple {puts \"It's an apple.\"}\n    banana {puts \"It's a banana.\"}\n    default {puts \"Unknown fruit.\"}\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 1: Recursive Factorial Calculation\nproc factorial {n} {\n    if {$n == 0 || $n == 1} {\n        return 1\n    }\n    return [expr {$n * [factorial [expr $n - 1]]}]\n}\nputs [factorial 5]"
  },
  {
    "language": "TCL",
    "code": "# Sample 2: GUI using Tkinter\npackage require Tk\nbutton .b -text \"Click Me\" -command {puts \"Button Clicked\"}\npack .b"
  },
  {
    "language": "TCL",
    "code": "# Sample 3: Handling Lists and Searching\nset data {apple orange banana}\nset search_result [lsearch $data orange]\nputs $search_result"
  },
  {
    "language": "TCL",
    "code": "# Sample 4: Regular Expression Matching and Substitution\nset text \"TCL scripting language\"\nif {[regexp {TCL} $text]} {\n    set modified_text [regsub {TCL} $text \"Python\" text]\n    puts $modified_text\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 5: Handling Errors and Exceptions\nproc divide {a b} {\n    if {$b == 0} {\n        error \"Division by zero\"\n    }\n    return [expr {$a / $b}]\n}\ntry {\n    puts [divide 10 0]\n} trap {DIVIDE_BY_ZERO} errMsg {\n    puts \"Error: $errMsg\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 6: File Operations and Manipulation\nset filename \"sample.txt\"\nset file [open $filename w]\nputs $file \"This is a sample text.\"\nclose $file\nfile copy $filename \"backup/$filename\""
  },
  {
    "language": "TCL",
    "code": "# Sample 7: Generating Unique Identifiers\nset uuid [exec uuidgen]\nputs $uuid"
  },
  {
    "language": "TCL",
    "code": "# Sample 8: Working with Binary Data\nset data [binary format I* 123 456]\nputs $data"
  },
  {
    "language": "TCL",
    "code": "# Sample 9: Managing Time and Date\nset current_time [clock format [clock seconds] -format %Y-%m-%d %H:%M:%S]\nputs $current_time"
  },
  {
    "language": "TCL",
    "code": "# Sample 10: Using 'namespace' for Scope Management\nnamespace eval Math {\n    proc square {x} {\n        return [expr $x * $x]\n    }\n}\nputs [Math::square 5]"
  },
  {
    "language": "TCL",
    "code": "# Sample 11: Complex List Manipulation\nset list1 {1 2 3 4 5}\nset list2 {3 4 5 6 7}\nset intersect [lsort [lsearch -all -inline -exact $list1 {*}$list2]]\nputs $intersect"
  },
  {
    "language": "TCL",
    "code": "# Sample 12: Creating Procedures with Optional Parameters\nproc greet {name {greeting \"Hello\"}} {\n    puts \"$greeting, $name!\"\n}\ngreet \"Alice\" \"Hi\""
  },
  {
    "language": "TCL",
    "code": "# Sample 13: Data Encryption and Decryption\npackage require tls\nset data \"SecretMessage123\"\nset key \"my_secret_key\"\nset encrypted_data [tls::aes::ecb -key $key -encrypt $data]\nset decrypted_data [tls::aes::ecb -key $key -decrypt $encrypted_data]\nputs $decrypted_data"
  },
  {
    "language": "TCL",
    "code": "# Sample 14: Working with Threads\npackage require Thread\nset sharedVar 0\nthread::create {\n    incr sharedVar\n    puts \"Inside thread: $sharedVar\"\n}\nputs \"Outside thread: $sharedVar\""
  },
  {
    "language": "TCL",
    "code": "# Sample 15: String Manipulation and Formatting\nset text \"TCL is interesting\"\nset modified_text [string map {TCL Python interesting fascinating} $text]\nputs $modified_text"
  },
  {
    "language": "TCL",
    "code": "# Sample 16: Sorting Algorithms\nproc insertion_sort {arr} {\n    for {set i 1} {$i < [llength $arr]} {incr i} {\n        set key [lindex $arr $i]\n        set j [expr {$i - 1}]\n        while {$j >= 0 && [lindex $arr $j] > $key} {\n            set arr [lreplace $arr $j+1 $j $arr]\n            incr j -1\n        }\n        set arr [lreplace $arr $j+1 $j+1 $key]\n    }\n    return $arr\n}\nset list_to_sort {5 3 8 1 9}\nputs [insertion_sort $list_to_sort]"
  },
  {
    "language": "TCL",
    "code": "# Sample 17: Interacting with External Processes\nset output [exec ls -l]\nputs $output"
  },
  {
    "language": "TCL",
    "code": "# Sample 18: Error Handling and Logging\nproc perform_operation {a b} {\n    if {$b == 0} {\n        return -code error \"Division by zero\"\n    }\n    set result [expr {$a / $b}]\n    puts \"Result: $result\"\n    return $result\n}\nif {[catch {perform_operation 10 0} errMsg]} {\n    puts \"Error: $errMsg\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 19: Regular Expression Matching\nset text \"The quick brown fox jumps over the lazy dog\"\nif {[regexp {\\m\\w{3}\\M} $text match]} {\n    puts $match\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 20: Using 'switch' for Multiple Conditions\nset fruit apple\nswitch $fruit {\n    apple {puts \"It's an apple.\"}\n    banana {puts \"It's a banana.\"}\n    default {puts \"Unknown fruit.\"}\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 21: Recursive Fibonacci Series\nproc fibonacci {n} {\n    if {$n <= 1} {\n        return $n\n    }\n    return [expr {[fibonacci [expr $n - 1]] + [fibonacci [expr $n - 2]]}]\n}\nputs [fibonacci 8]"
  },
  {
    "language": "TCL",
    "code": "# Sample 22: Managing Objects with Object-Oriented Concepts\noo::class create Person {\n    variable name\n    constructor {n} {\n        set name $n\n    }\n    method introduce {} {\n        puts \"My name is $name\"\n    }\n}\nPerson create p1 Alice\np1 introduce"
  },
  {
    "language": "TCL",
    "code": "# Sample 23: Object-Oriented Programming with Methods and Properties\noo::class create Circle {\n    variable radius\n    constructor {r} {\n        set radius $r\n    }\n    method area {} {\n        return [expr {3.14159 * $radius * $radius}]\n    }\n}\nCircle create c1 5\nputs [c1 area]"
  },
  {
    "language": "TCL",
    "code": "# Sample 24: Using 'expr' for Mathematical Expressions\nset x 10\nset y 20\nset result [expr {$x + $y}]\nputs $result"
  },
  {
    "language": "TCL",
    "code": "# Sample 25: File Management and Manipulation\nset filename \"file.txt\"\nset file [open $filename w]\nputs $file \"Sample text\"\nclose $file\nfile copy $filename \"backup/$filename\""
  },
  {
    "language": "TCL",
    "code": "# Sample 26: Handling Binary Data Operations\nset data [binary format H* 48656C6C6F20576F726C64]\nputs $data"
  },
  {
    "language": "TCL",
    "code": "# Sample 27: Manipulating File Paths\nset filename \"file.txt\"\nset filepath [file join /path/to/directory $filename]\nputs $filepath"
  },
  {
    "language": "TCL",
    "code": "# Sample 28: Working with Tk Widgets\npackage require Tk\nset w [ttk::button .b -text \"Click Me\"]\npack .b"
  },
  {
    "language": "TCL",
    "code": "# Sample 29: Custom Procedures for Factorial Calculation\nproc factorial {n} {\n    if {$n == 0 || $n == 1} {\n        return 1\n    }\n    return [expr {$n * [factorial [expr $n - 1]]}]\n}\nputs [factorial 5]"
  },
  {
    "language": "TCL",
    "code": "# Sample 30: Using 'catch' for Error Handling\nset value 10\nif {[catch {set result [expr $value / 0]} errorMsg]} {\n    puts \"Error: $errorMsg\"\n} else {\n    puts $result\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 31: Creating and Using Procedures\nproc greet {name} {\n    puts \"Hello, $name!\"\n}\ngreet \"Alice\""
  },
  {
    "language": "TCL",
    "code": "# Sample 32: Implementing 'string map' for String Manipulation\nset text \"TCL Programming is fun!\"\nset modified_text [string map {TCL Python fun exciting} $text]\nputs $modified_text"
  },
  {
    "language": "TCL",
    "code": "# Sample 33: Using 'binary' for Binary Data Manipulation\nset data [binary format H* 48656C6C6F20576F726C64]\nputs $data"
  },
  {
    "language": "TCL",
    "code": "# Sample 34: Managing Time and Date with 'clock'\nset current_time [clock format [clock seconds] -format %H:%M:%S]\nputs $current_time"
  },
  {
    "language": "TCL",
    "code": "# Sample 35: Implementing 'namespace' for Organizing Code\nnamespace eval Math {\n    proc square {x} {\n        return [expr $x * $x]\n    }\n}\nputs [Math::square 5]"
  },
  {
    "language": "TCL",
    "code": "# Sample 36: Working with Regular Expressions\nset text \"TCL123 is interesting\"\nif {[regexp {TCL\\d+} $text]} {\n    puts \"Pattern found\"\n} else {\n    puts \"Pattern not found\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 37: Error Handling with 'try' and 'on' Statements\nproc divide {a b} {\n    if {$b == 0} {\n        error \"Division by zero\"\n    }\n    return [expr {$a / $b}]\n}\ntry {\n    puts [divide 10 0]\n} on error errMsg {\n    puts \"Error: $errMsg\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 38: Using 'foreach' for Iteration\nset numbers {1 2 3 4 5}\nforeach num $numbers {\n    puts \"Number: $num\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Sample 39: Generating Random Numbers\nset random_num [expr {int(rand() * 100)}]\nputs $random_num"
  },
  {
    "language": "TCL",
    "code": "# Sample 40: Performing Linear Regression\nproc linear_regression {x_values y_values} {\n    set n [llength $x_values]\n    set sum_x 0\n    set sum_y 0\n    set sum_xy 0\n    set sum_x_squared 0\n    foreach x $x_values y $y_values {\n        incr sum_x $x\n        incr sum_y $y\n        incr sum_xy [expr {$x * $y}]\n        incr sum_x_squared [expr {$x * $x}]\n    }\n    set slope [expr {($n * $sum_xy - $sum_x * $sum_y) / ($n * $sum_x_squared - $sum_x * $sum_x)}]\n    set intercept [expr {($sum_y - $slope * $sum_x) / $n}]\n    return [list $slope $intercept]\n}\nset xs {1 2 3 4 5}\nset ys {2 4 6 8 10}\nputs [linear_regression $xs $ys]"
  },
  {
    "language": "TCL",
    "code": "# Sample 31: Creating and Managing Threads\npackage require Thread\nset sharedVar 0\nthread::create {\n    incr sharedVar\n    puts \"Inside thread: $sharedVar\"\n}\nputs \"Outside thread: $sharedVar\""
  },
  {
    "language": "TCL",
    "code": "# Sample 32: Using 'string map' for String Replacements\nset text \"TCL is a scripting language\"\nset modified_text [string map {TCL Python scripting programming} $text]\nputs $modified_text"
  },
  {
    "language": "TCL",
    "code": "# Sample 33: Handling Binary Data with 'binary'\nset data [binary format H* 48656C6C6F20576F726C64]\nset reversed_data [binary format H* [binary scan $data H* data]]\nputs $reversed_data"
  },
  {
    "language": "TCL",
    "code": "# Sample 34: Creating and Using Widgets in Tk\npackage require Tk\nset w [ttk::button .b -text \"Click Me\"]\npack .b"
  },
  {
    "language": "TCL",
    "code": "# Sample 35: Handling Lists and Sorting\nset fruits {apple orange banana}\nputs [lsort -dictionary $fruits]"
  },
  {
    "language": "TCL",
    "code": "# Sample 36: Managing Resources with 'fileevent'\nset file [open \"file.txt\" r]\nfileevent $file readable {\n    gets $file line\n    puts \"Read: $line\"\n}\nvwait forever"
  },
  {
    "language": "TCL",
    "code": "# Sample 37: Parsing and Handling XML Data\npackage require dom\nset xml_data {<book><title>TCL Programming</title><author>John Doe</author></book>}\ndom parse $xml_data book\nputs [book attribute title]"
  },
  {
    "language": "TCL",
    "code": "# Sample 38: Generating Random Numbers\nset random_num [expr {int(rand() * 100)}]\nputs $random_num"
  },
  {
    "language": "TCL",
    "code": "# Sample 39: Using 'clock' for Time Operations\nset current_time [clock format [clock seconds] -format %H:%M:%S]\nputs $current_time"
  },
  {
    "language": "TCL",
    "code": "# Sample 40: Encrypting and Decrypting Data\npackage require tls\nset data \"SecretMessage123\"\nset key \"my_secret_key\"\nset encrypted_data [tls::aes::ecb -key $key -encrypt $data]\nset decrypted_data [tls::aes::ecb -key $key -decrypt $encrypted_data]\nputs $decrypted_data"
  },
  {
    "language": "SmallTalk",
    "code": "Object subclass: Person [ | name age | initialize [ name := ''. age := 0. ] setName: aName [ name := aName. ] setAge: anAge [ age := anAge. ] getName [ ^name ] getAge [ ^age ] ]; person := (Person new setName: 'Alice'; setAge: 30; yourself); Transcript show: 'Name: ', (person getName), '. Age: ', (person getAge asString), '.'."
  },
  {
    "language": "SmallTalk",
    "code": "Object subclass: BankAccount [ | balance | initialize [ balance := 0. ] deposit: amount [ balance := balance + amount. ^'Deposit successful.' ] withdraw: amount [ | message | message := (balance >= amount) ifTrue: [ balance := balance - amount. 'Withdrawal successful: ', amount asString ] ifFalse: ['Insufficient funds.'] ^message ] checkBalance [ ^balance ] ]; account := BankAccount new. account deposit: 100. Transcript show: 'Balance after deposit: ', (account checkBalance) asString; cr. withdrawalMessage := account withdraw: 50. Transcript show: withdrawalMessage; cr. withdrawalMessage := account withdraw: 80. Transcript show: withdrawalMessage; cr. Transcript show: 'Final balance: ', (account checkBalance) asString; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript\n    show: 'Hello, world!';\n    cr."
  },
  {
    "language": "SmallTalk",
    "code": "| numbers |\nnumbers := #(1 2 3 4 5).\nnumbers do: [:each | Transcript show: each asString; cr]."
  },
  {
    "language": "SmallTalk",
    "code": "(1 to: 5) collect: [:each | each squared]."
  },
  {
    "language": "SmallTalk",
    "code": "| person |\nperson := Dictionary new.\nperson at: 'name' put: 'Alice'.\nperson at: 'age' put: 30."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript show: (Date today) asString; cr."
  },
  {
    "language": "SmallTalk",
    "code": "| circle |\ncircle := EllipseMorph new.\ncircle openInWorld.\ncircle color: Color blue."
  },
  {
    "language": "SmallTalk",
    "code": "| worker |\nworker := Worker new.\nworker work."
  },
  {
    "language": "SmallTalk",
    "code": "| car |\ncar := Car new.\ncar drive: 100."
  },
  {
    "language": "SmallTalk",
    "code": "| rectangle |\nrectangle := Rectangle origin: 0@0 corner: 100@100."
  },
  {
    "language": "SmallTalk",
    "code": "(1 to: 10) do: [:i |\n    Transcript show: i asString; cr.\n]."
  },
  {
    "language": "SmallTalk",
    "code": "Transcript show: 'I love Smalltalk!'; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Cursor wait showWhile: [Sensor anyButtonPressed]."
  },
  {
    "language": "SmallTalk",
    "code": "| s |\ns := 'Hello, world!'.\ns at: 2 put: $a.\nTranscript show: s; cr."
  },
  {
    "language": "SmallTalk",
    "code": "Display restoreAfter: [\n    Transcript show: 'Smalltalk is fun!'; cr.\n]."
  },
  {
    "language": "SmallTalk",
    "code": "| animal |\nanimal := 'Dog'.\nanimal, ' is a friendly pet.'."
  },
  {
    "language": "SmallTalk",
    "code": "Sensor waitButton."
  },
  {
    "language": "SmallTalk",
    "code": "('Smalltalk' copyFrom: 3 to: 6) reverse."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 201: Object Creation\"\n| car |\ncar := Car new. car startEngine."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 202: Message Passing\"\n| calculator |\ncalculator := Calculator new. calculator add: 5 to: 10."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 203: Class Definition\"\nObject subclass: #Person\n    instanceVariableNames: 'name age';\n    addSelector: #initialize withMethod: [ :name :age | self name: name. self age: age ];\n    addSelector: #name: withMethod: [ :n | name := n ];\n    addSelector: #age: withMethod: [ :a | age := a ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 204: Polymorphism\"\nDog subclass: #Dalmatian\n    bark\n        [ Transcript show: 'Woof! Woof!' ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 205: Inheritance\"\nRectangle subclass: #Square\n    instanceVariableNames: 'side';\n    addSelector: #initialize withMethod: [ :s | side := s ];\n    addSelector: #area withMethod: [ side * side ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 206: Encapsulation\"\nObject subclass: #BankAccount\n    instanceVariableNames: 'balance';\n    addSelector: #initialize withMethod: [ :b | balance := b ];\n    addSelector: #deposit: withMethod: [ :amount | balance := balance + amount ];\n    addSelector: #withdraw: withMethod: [ :amount | balance := balance - amount ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 207: Iteration\"\n5 timesRepeat: [ Transcript show: 'Hello World'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 208: Collections - Array\"\n| numbers |\nnumbers := #(1 2 3 4 5). numbers do: [ :each | Transcript show: each; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 209: Collections - Dictionary\"\n| dictionary |\ndictionary := Dictionary new. dictionary at: 'key' put: 'value'. Transcript show: (dictionary at: 'key'); cr."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 210: Error Handling\"\n[ | result |\n    result := 10 / 0. Transcript show: result; cr ]\n        on: ZeroDivide\n        do: [ :ex | Transcript show: 'Division by zero error!'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 211: File Handling\"\n| file |\nfile := FileStream newFileNamed: 'example.txt'. file nextPutAll: 'Hello, Smalltalk!'. file close."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 212: GUI Development\"\n| window |\nwindow := StandardSystemView new.\nwindow addLabel: 'Hello World!' translated."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 213: Multithreading\"\n[ | thread |\n    thread := [ 10 timesRepeat: [ :i | Transcript show: i; cr ]. ] fork. thread waitFor. Transcript show: 'Thread finished!'; cr ] fork."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 214: Networking\"\n| client |\nclient := Socket newTCP. client connectTo: 'localhost' port: 8080."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 215: Regular Expressions\"\n'Regex Sample' matchRegex: 'Sample'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 216: Database Connectivity\"\n| connection |\nconnection := DBConnection new. connection connectTo: 'localhost' database: 'myDB'. connection execute: 'SELECT * FROM myTable'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 217: XML Processing\"\n| xmlDocument |\nxmlDocument := XMLDocument new. xmlDocument parseFromString: '<book><title>Smalltalk Programming</title></book>'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 218: Serialization\"\n| serializedObject |\nserializedObject := Object new serialize."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 219: Reflection\"\n| obj |\nobj := Object new. obj class. obj respondsTo: #yourSelector."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 220: Unit Testing\"\n| testCase |\ntestCase := TestCase new. testCase test: [ 5 + 5 assert: 10 ]. testCase run."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 221: Lambda Expressions\"\n| lambda |\nlambda := [ :x :y | x + y ]. lambda value: 5 value: 10."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 222: Date and Time\"\n| currentDate |\ncurrentDate := Date today."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 223: Mathematical Functions\"\n| result |\nresult := (4 raisedTo: 3) sqrt."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 224: Type Conversion\"\n| numberString number |\nnumberString := '42'. number := numberString asNumber."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 225: Sorting\"\n| numbers |\nnumbers := #(5 2 9 1 7). numbers asSortedCollection sort."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 226: Set Operations\"\n| set1 set2 unionSet |\nset1 := #(1 2 3 4). set2 := #(3 4 5 6). unionSet := set1 asSet, set2 asSet."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 227: GUI Widgets\"\n| window button |\nwindow := StandardSystemView new.\nbutton := window addButton. button label: 'Click Me!'; action: [ Transcript show: 'Button clicked!'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 228: Object Serialization\"\n| object stream |\nobject := 42. stream := RWBinaryOrTextStream on: (ByteArray new: 100).\nstream nextPut: object. stream contents."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 229: Error Reporting\"\n[ | result |\n    result := 5 / 0. result ] on: Error do: [ :ex | ex displayNl ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 230: Event Handling\"\n| eventListener |\neventListener := EventListener new. eventListener on: #buttonClick do: [ :event | Transcript show: 'Button clicked!'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 231: Regular File Operations\"\n| file |\nfile := FileStream newFileNamed: 'sample.txt'. file nextPutAll: 'This is a sample text.'. file close."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 232: Binary File Operations\"\n| binaryFile |\nbinaryFile := FileStream newFileNamed: 'binary.bin'. binaryFile nextPut: 255. binaryFile close."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 233: GUI Customization\"\n| window button |\nwindow := StandardSystemView new.\nbutton := window addButton. button label: 'Submit'; extent: 100@50; color: Color blue."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 234: Dynamic Class Creation\"\n| newClass |\nnewClass := Object subclass: #DynamicClass.\nnewClass class compile: 'myMethod ^ ''Dynamic Method'''. DynamicClass new myMethod."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 235: Text Processing\"\n| text |\ntext := 'Smalltalk is amazing!'. text findString: 'is'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 236: Block Closure\"\n| closure |\nclosure := [ :x | x squared ]. closure value: 5."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 237: Collection Iteration\"\n| numbers |\nnumbers := #(10 20 30 40). numbers do: [ :each | Transcript show: each; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 238: MIME Types\"\n| mimeType |\nmimeType := 'application/json'. mimeType asMIMEType."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 239: URL Handling\"\n| url |\nurl := 'https://example.com'. url asURI."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 240: User Input\"\n| input |\ninput := UIManager default request: 'Enter your name:' initialAnswer: ''. Transcript show: input; cr."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 241: Working with Colors\"\n| myColor |\nmyColor := Color red."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 242: Sending Emails\"\n| email |\nemail := MailMessage empty. email to: 'recipient@example.com'; from: 'sender@example.com'; subject: 'Hello'; text: 'Smalltalk email!'; send."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 243: List Operations\"\n| myList |\nmyList := List with: 'apple' with: 'banana' with: 'orange'. myList add: 'grapes'. myList remove: 'banana'. myList at: 1."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 244: Defining Protocols\"\nProtocol subclass: #MyProtocol\n    instanceVariableNames: ''\n    classVariableNames: ''\n    poolDictionaries: ''\n    category: 'CustomProtocolCategory'"
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 245: Stack Operations\"\n| myStack |\nmyStack := Stack new. myStack push: 'Apple'; push: 'Orange'; pop."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 246: Arithmetic Operations\"\n5 + 10."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 247: String Operations\"\n'Hello, ' , 'Smalltalk!'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 248: Reading Keyboard Input\"\n| userInput |\nuserInput := FileStream stdin nextLine."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 249: Calendar Manipulation\"\n| date |\ndate := Date today. date dayOfWeek; month; year."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 250: Random Number Generation\"\n| randomNum |\nrandomNum := Random new. randomNum next."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 251: Working with Symbols\"\n#mySymbol."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 252: String Formatting\"\nString streamContents: [ :stream | stream nextPutAll: 'Smalltalk'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 253: Accessing Environment Variables\"\n| envVar |\nenvVar := SmalltalkImage current getSystemAttribute: 1."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 254: XML DOM Parsing\"\n| xmlParser xmlDocument |\nxmlParser := XMLDOMParser new. xmlDocument := xmlParser parseDocumentFrom: '<root><item>Smalltalk</item></root>'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 255: JSON Parsing\"\n| jsonString jsonObject |\njsonString := '{\"name\": \"Smalltalk\", \"year\": 1972}'. jsonObject := (JsonObject fromString: jsonString) asDictionary."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 256: CSV File Handling\"\n| csvFile |\ncsvFile := CSVReader on: 'data.csv'. csvFile next."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 257: Semaphore Operations\"\n| semaphore |\nsemaphore := Semaphore new. semaphore critical: [ Transcript show: 'Semaphore critical section.'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 258: Working with Graphics\"\n| canvas |\ncanvas := Display newCanvas: 400@300. canvas fillRectangle: (0@0 extent: 100@50) color: Color red."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 259: File Existence Check\"\n| fileName |\nfileName := 'myfile.txt'. FileDirectory default includesKey: fileName."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 260: Sound Playback\"\n| soundPlayer |\nsoundPlayer := SoundPlayer new. soundPlayer playSound: 'soundfile.wav'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 261: Environment Interaction\"\nSmalltalkImage current saveSession."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 262: HTTP Requests\"\n| httpRequest |\nhttpRequest := HTTPClient httpGet: 'https://api.example.com/data'. httpRequest contents."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 263: User Authentication\"\n| loginService |\nloginService := AuthenticationService new. loginService authenticateUser: 'username' withPassword: 'password'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 264: Remote Method Invocation\"\n| remoteObject |\nremoteObject := DistributedSystem remoteObjectNamed: 'MyRemoteObject'. remoteObject invokeMethod: #doSomething."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 265: Configuration Management\"\n| configurationManager |\nconfigurationManager := ConfigurationManager new. configurationManager setConfiguration: 'setting' withValue: 'value'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 266: Memory Management\"\n| memoryManager object |\nmemoryManager := MemoryManager new. object := Object new. memoryManager deallocate: object."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 267: Aspect-Oriented Programming\"\n| aspectManager |\naspectManager := AspectManager new. aspectManager addAspect: #logging before: [ :method | Transcript show: 'Logging...'; cr ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 268: Internationalization\"\n| languageTranslator |\nlanguageTranslator := LanguageTranslator new. languageTranslator translate: 'Bonjour' to: 'English'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 269: Working with Trees\"\n| tree |\ntree := Tree new. tree add: 5. tree add: 10. tree includes: 10."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 270: Regular Grid Generation\"\n| gridGenerator grid |\ngridGenerator := GridGenerator new. grid := gridGenerator generateGridOfSize: 10."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 271: Automated Testing\"\n| testRunner |\ntestRunner := TestRunner new. testRunner runTest: MyTestCase new."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 272: Data Compression\"\n| compressedData |\ncompressedData := 'some data' compress."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 273: Data Decompression\"\n| decompressedData |\ndecompressedData := 'some compressed data' decompress."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 274: Genetic Algorithms\"\n| geneticAlgorithm |\ngeneticAlgorithm := GeneticAlgorithm new. geneticAlgorithm evolvePopulation."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 275: Working with Matrices\"\n| matrix |\nmatrix := Matrix rows: { {1. 2. 3.}. {4. 5. 6.}. {7. 8. 9.} }. matrix at: 2 at: 3."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 276: Natural Language Processing\"\n| nlpProcessor |\nnlpProcessor := NLPProcessor new. nlpProcessor analyzeText: 'Smalltalk is great!'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 277: Data Encryption\"\n| encryptedData |\nencryptedData := 'sensitive info' encrypt."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 278: Data Decryption\"\n| decryptedData |\ndecryptedData := 'encrypted info' decrypt."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 279: Graph Algorithms\"\n| graph |\ngraph := Graph new. graph addNode: 'A'. graph addNode: 'B'. graph addEdgeFrom: 'A' to: 'B'. graph shortestPathFrom: 'A' to: 'B'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 280: Web Scraping\"\n| webScraper |\nwebScraper := WebScraper new. webScraper scrapeWebsite: 'https://example.com'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 281: Statistical Analysis\"\n| statisticalAnalyzer |\nstatisticalAnalyzer := StatisticalAnalyzer new. statisticalAnalyzer analyzeData: #(#1 #2 #3 #4 #5)."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 282: Fuzzy Logic\"\n| fuzzyLogicEngine |\nfuzzyLogicEngine := FuzzyLogicEngine new. fuzzyLogicEngine evaluate: 0.7."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 283: Natural Language Generation\"\n| nlgEngine |\nnlgEngine := NLGEngine new. nlgEngine generateText: 10."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 284: Audio Processing\"\n| audioProcessor |\naudioProcessor := AudioProcessor new. audioProcessor processAudio: 'audioFile.wav'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 285: Gesture Recognition\"\n| gestureRecognizer |\ngestureRecognizer := GestureRecognizer new. gestureRecognizer recognizeGesture: 'swipeRight'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 286: Parallel Computing\"\n| parallelProcessor |\nparallelProcessor := ParallelProcessor new. parallelProcessor runParallelTask."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 287: Simulation Modeling\"\n| simulationModel |\nsimulationModel := SimulationModel new. simulationModel simulate: 'traffic'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 288: Data Preprocessing\"\n| dataProcessor |\ndataProcessor := DataProcessor new. dataProcessor preprocessData: 'rawData'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 289: Version Control\"\n| versionControl |\nversionControl := VersionControl new. versionControl commit: 'fileChanges'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 290: Object Cloning\"\n| clonedObject |\nclonedObject := originalObject copy."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 291: Image Processing\"\n| imageProcessor |\nimageProcessor := ImageProcessor new. imageProcessor processImage: 'imageFile.jpg'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 292: Remote Procedure Call\"\n| rpcService |\nrpcService := RPCService new. rpcService callProcedure: 'procedureName'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 293: Blockchain Transactions\"\n| blockchainTransaction |\nblockchainTransaction := BlockchainTransaction new. blockchainTransaction initiateTransaction: 'sender' to: 'recipient' amount: 100."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 294: Network Analysis\"\n| networkAnalyzer |\nnetworkAnalyzer := NetworkAnalyzer new. networkAnalyzer analyzeNetwork: 'networkData'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 295: Mathematical Optimization\"\n| optimizer |\noptimizer := Optimizer new. optimizer optimizeFunction: 'f(x) = x^2'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 296: Robotics Simulations\"\n| roboticsSimulator |\nroboticsSimulator := RoboticsSimulator new. roboticsSimulator simulateRobot: 'robotModel'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 297: System Debugging\"\n| debugger |\ndebugger := SystemDebugger new. debugger debugSystem: 'system'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 298: Knowledge Representation\"\n| knowledgeBase |\nknowledgeBase := KnowledgeBase new. knowledgeBase representKnowledge: 'ontology'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 299: Data Synchronization\"\n| dataSynchronizer |\ndataSynchronizer := DataSynchronizer new. dataSynchronizer synchronizeData: 'local' with: 'remote'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 300: Gesture Control\"\n| gestureController |\ngestureController := GestureController new. gestureController controlDevice: 'device' withGesture: 'swipeUp'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 301: File Handling\"\n| fileHandler |\nfileHandler := FileHandler new. fileHandler openFile: 'file.txt'. fileHandler readFileContents."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 302: Data Visualization\"\n| visualizationTool |\nvisualizationTool := VisualizationTool new. visualizationTool visualizeData: 'dataSet'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 303: Workflow Automation\"\n| workflowManager |\nworkflowManager := WorkflowManager new. workflowManager automateWorkflow: 'taskList'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 304: Distributed Computing\"\n| distributedProcessor |\ndistributedProcessor := DistributedProcessor new. distributedProcessor processDistributedData: 'dataSet'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 305: Data Filtering\"\n| dataFilter |\ndataFilter := DataFilter new. dataFilter filterData: 'rawData' withCriteria: 'criteria'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 306: Cryptographic Hashing\"\n| hashFunction |\nhashFunction := HashFunction new. hashFunction generateHash: 'inputData'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 307: Neural Network Training\"\n| neuralNetwork |\nneuralNetwork := NeuralNetwork new. neuralNetwork trainNetwork: 'trainingData'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 308: Object Serialization\"\n| serializedObject |\nserializedObject := 'object' serialize."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 309: Data Analysis\"\n| dataAnalyzer |\ndataAnalyzer := DataAnalyzer new. dataAnalyzer analyze: 'dataSet'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 310: Natural Language Understanding\"\n| nluEngine |\nnluEngine := NLUEngine new. nluEngine understandLanguage: 'text'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 311: Task Scheduling\"\n| taskScheduler |\ntaskScheduler := TaskScheduler new. taskScheduler scheduleTask: 'task' at: 'time'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 312: Database Connection\"\n| databaseConnection |\ndatabaseConnection := DatabaseConnection new. databaseConnection connectToDatabase: 'dbName'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 313: Data Normalization\"\n| dataNormalizer |\ndataNormalizer := DataNormalizer new. dataNormalizer normalizeData: 'rawData'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 314: Speech Recognition\"\n| speechRecognizer |\nspeechRecognizer := SpeechRecognizer new. speechRecognizer recognizeSpeech: 'audioData'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 315: Data Validation\"\n| dataValidator |\ndataValidator := DataValidator new. dataValidator validateData: 'dataSet'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 316: Code Profiling\"\n| codeProfiler |\ncodeProfiler := CodeProfiler new. codeProfiler profileCode: 'method'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 317: Email Parsing\"\n| emailParser |\nemailParser := EmailParser new. emailParser parseEmail: 'emailContents'."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 318: Error Handling\"\n[ | result |\n    result := 5 / 0. result ] on: Error do: [ :ex | ex displayNl ]."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 319: Genetic Programming\"\n| geneticProgram |\ngeneticProgram := GeneticProgram new. geneticProgram evolveProgram."
  },
  {
    "language": "SmallTalk",
    "code": "\" Sample 320: Data Serialization\"\n| serializedData |\nserializedData := 'data' serialize."
  },
  {
    "language": "R",
    "code": "# Create a data frame\ndata <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(data)\n\n# Subset based on conditions\nselected_data <- subset(data, Age > 25)\n\n# Print the subset\nprint(selected_data)"
  },
  {
    "language": "R",
    "code": "# Create a function that calculates factorial\nfactorial <- function(n) {\n    if (n == 0) {\n        return(1)\n    } else {\n        return(n * factorial(n - 1))\n    }\n}\n\n# Call the function\nresult <- factorial(5)\nprint(result)\n\n# Utilize ggplot2 package for plotting\nrequire(ggplot2)\n\n# Create sample data\ndata <- data.frame(\n    x = 1:10,\n    y = rnorm(10)\n)\n\n# Plot using ggplot2\nggplot(data, aes(x=x, y=y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Function to print elements of a list\nprint_list <- function(my_list) {\n    for (element in my_list) {\n        print(element)\n    }\n}\n\n# Create a list\nmy_list <- list(name = \"John\", age = 30, city = \"New York\")\n\n# Print elements of the list\nprint_list(my_list)\n\n# Function accepting and printing unspecified arguments\nprint_arguments <- function(...) {\n    for (arg in list(...)) {\n        print(arg)\n    }\n}\n\n# Call the function with different arguments\nprint_arguments(\"Hello\", 10, TRUE)"
  },
  {
    "language": "R",
    "code": "# Create a data frame\nstudents <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(students)\n\n# Extract specific columns\nages <- students$Age\ngrades <- students$Grade\n\n# Print extracted columns\nprint(ages)\nprint(grades)"
  },
  {
    "language": "R",
    "code": "# Function to check if a number is even\nis_even <- function(num) {\n    if (num %% 2 == 0) {\n        return(TRUE)\n    } else {\n        return(FALSE)\n    }\n}\n\n# Check numbers for evenness\nprint(is_even(5))\nprint(is_even(10))"
  },
  {
    "language": "R",
    "code": "# Loop to create a list of squares\nsquares <- c()\nfor (i in 1:10) {\n    squares[i] <- i^2\n}\n\n# Print the list of squares\nprint(squares)\n\n# Function to calculate sum of a list\ncalculate_sum <- function(nums) {\n    sum <- 0\n    for (num in nums) {\n        sum <- sum + num\n    }\n    return(sum)\n}\n\n# Calculate sum of a list of numbers\nresult <- calculate_sum(1:10)\nprint(result)"
  },
  {
    "language": "R",
    "code": "# Generating random data\nset.seed(123)\ndata <- data.frame(\n    x = 1:100,\n    y = rnorm(100)\n)\n\n# Scatter plot using base R graphics\nplot(data$x, data$y, main = \"Random Data Scatter Plot\", xlab = \"X-axis\", ylab = \"Y-axis\")"
  },
  {
    "language": "R",
    "code": "# Create a data frame\nstudents <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28),\n    Grade = c(\"A\", \"B\", \"C\")\n)\n\n# Display the data frame\nprint(students)\n\n# Subset based on conditions\nselected_students <- subset(students, Age > 25)\n\n# Print the subset\nprint(selected_students)"
  },
  {
    "language": "R",
    "code": "# Create a function that prints 'Hello' n times\nprint_hello <- function(n){\n    for (i in 1:n){\n        print(\"Hello\")\n    }\n}\n\n# Call the function\nprint_hello(3)\n\n# Utilize ggplot2 package for plotting\nrequire(ggplot2)\n\n# Create sample data\ndata <- data.frame(\n    x = 1:10,\n    y = rnorm(10)\n)\n\n# Plot using ggplot2\nggplot(data, aes(x=x, y=y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Function to accept and print unspecified arguments\nprint_arguments <- function(...){\n    for (arg in list(...)){\n        print(arg)\n    }\n}\n\n# Call the function with different arguments\nprint_arguments(\"Hello\", 10, TRUE)"
  },
  {
    "language": "R",
    "code": "# Function to calculate factorial with error handling\nfactorial <- function(n) {\n    if (n < 0) {\n        stop(\"Factorial not defined for negative numbers.\")\n    }\n    if (n == 0) {\n        return(1)\n    } else {\n        return(n * factorial(n - 1))\n    }\n}\n\n# Get user input for factorial calculation\nuser_input <- as.integer(readline(\"Enter a number to calculate its factorial: \"))\nresult <- factorial(user_input)\nprint(paste(\"Factorial of\", user_input, \"is\", result))"
  },
  {
    "language": "R",
    "code": "# Apply function to calculate square of elements in a vector\nvector <- c(1, 2, 3, 4, 5)\nsquared_vector <- sapply(vector, function(x) x^2)\nprint(squared_vector)\n\n# Apply function to a data frame\ndata <- data.frame(\n    A = c(1, 2, 3),\n    B = c(4, 5, 6),\n    C = c(7, 8, 9)\n)\nmean_values <- apply(data, 2, mean)\nprint(mean_values)"
  },
  {
    "language": "R",
    "code": "# String concatenation and substring\nstring1 <- \"Hello\"\nstring2 <- \"World!\"\nconcatenated <- paste(string1, string2)\nsubstring <- substr(concatenated, start = 3, stop = 8)\nprint(concatenated)\nprint(substring)\n\n# Checking string containment\ntext <- \"This is a sample text.\"\nif (\"sample\" %in% strsplit(text, \" \")[[1]]) {\n    print(\"String 'sample' found in text.\")\n} else {\n    print(\"String 'sample' not found in text.\")\n}"
  },
  {
    "language": "R",
    "code": "# Create matrices\nmatrix1 <- matrix(1:9, nrow = 3)\nmatrix2 <- matrix(9:1, nrow = 3)\n\n# Matrix multiplication\nresult_matrix <- matrix1 %*% matrix2\nprint(result_matrix)\n\n# Matrix transpose\ntransposed_matrix <- t(matrix1)\nprint(transposed_matrix)"
  },
  {
    "language": "R",
    "code": "# Write data to a CSV file\ndata <- data.frame(\n    Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    Age = c(25, 30, 28)\n)\nwrite.csv(data, \"output.csv\")\n\n# Read data from a CSV file\nread_data <- read.csv(\"output.csv\")\nprint(read_data)"
  },
  {
    "language": "R",
    "code": "# Generating random data\nset.seed(123)\ndata1 <- data.frame(\n    x = 1:50,\n    y = rnorm(50, mean = 0, sd = 1)\n)\ndata2 <- data.frame(\n    x = 1:50,\n    y = rnorm(50, mean = 2, sd = 1)\n)\n\n# Plotting multiple graphs\npar(mfrow = c(1, 2))  # Arrange plots in a 1x2 grid\nplot(data1$x, data1$y, main = \"Random Data 1\")\nplot(data2$x, data2$y, main = \"Random Data 2\")"
  },
  {
    "language": "R",
    "code": "# Using lapply to apply a function to elements of a list\nmy_list <- list(1:5, 6:10, 11:15)\n\nsquared_lists <- lapply(my_list, function(x) x^2)\nprint(squared_lists)"
  },
  {
    "language": "R",
    "code": "# Creating matrices\nmatrix1 <- matrix(1:9, nrow = 3)\nmatrix2 <- matrix(9:1, nrow = 3)\n\n# Element-wise matrix operations\nelementwise_sum <- matrix1 + matrix2\nelementwise_product <- matrix1 * matrix2\n\nprint(elementwise_sum)\nprint(elementwise_product)"
  },
  {
    "language": "R",
    "code": "# Create a factor vector\ngrades <- factor(c(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\"))\n\n# Display unique levels of the factor\nprint(levels(grades))\n\n# Convert factor to numeric\nnumeric_grades <- as.numeric(grades)\nprint(numeric_grades)"
  },
  {
    "language": "R",
    "code": "# Getting current date and time\ncurrent_date <- Sys.Date()\ncurrent_time <- Sys.time()\n\nprint(current_date)\nprint(current_time)"
  },
  {
    "language": "R",
    "code": "# Sample 1: Hello World\nprint('Hello, world!')"
  },
  {
    "language": "R",
    "code": "# Sample 2: Variable Declaration\nx <- 10\ny <- 'Hello'"
  },
  {
    "language": "R",
    "code": "# Sample 3: Arithmetic Operations\na <- 5\nb <- 3\nsum <- a + b\nproduct <- a * b"
  },
  {
    "language": "R",
    "code": "# Sample 4: Conditional Statements\nif (x > 5) {\n  print('x is greater than 5')\n} else {\n  print('x is less than or equal to 5')\n}"
  },
  {
    "language": "R",
    "code": "# Sample 5: Loops\nfor (i in 1:5) {\n  print(i)\n}"
  },
  {
    "language": "R",
    "code": "# Sample 6: Functions\nmy_function <- function(a, b) {\n  return(a + b)\n}\nresult <- my_function(3, 4)"
  },
  {
    "language": "R",
    "code": "# Sample 7: Lists\nmy_list <- list('apple', 'banana', 'orange')"
  },
  {
    "language": "R",
    "code": "# Sample 8: Data Frames\nmy_data <- data.frame(\n  Name = c('Alice', 'Bob', 'Charlie'),\n  Age = c(25, 30, 28),\n  Salary = c(50000, 60000, 55000)\n)"
  },
  {
    "language": "R",
    "code": "# Sample 9: Reading CSV Files\ndata <- read.csv('data.csv')"
  },
  {
    "language": "R",
    "code": "# Sample 10: Plotting Data\nplot(data$X, data$Y, main='Scatter Plot', xlab='X-axis', ylab='Y-axis')"
  },
  {
    "language": "R",
    "code": "# Sample 11: Statistical Analysis\nsummary(data)\ncor(data$X, data$Y)"
  },
  {
    "language": "R",
    "code": "# Sample 12: Data Manipulation\nsubset_data <- subset(data, X > 10 & Y < 20)\nnew_data <- transform(data, Z = X + Y)"
  },
  {
    "language": "R",
    "code": "# Sample 13: Writing to CSV Files\nwrite.csv(new_data, file='new_data.csv')"
  },
  {
    "language": "R",
    "code": "# Sample 14: Matrix Operations\nmatrix_a <- matrix(1:9, nrow=3)\nmatrix_b <- matrix(9:1, nrow=3)\nmatrix_c <- matrix_a %*% matrix_b"
  },
  {
    "language": "R",
    "code": "# Sample 15: Random Number Generation\nrandom_numbers <- runif(10)"
  },
  {
    "language": "R",
    "code": "# Sample 16: Time Series Analysis\ntime_series <- ts(data$Y, start=c(2022, 1), frequency=12)\nforecast <- forecast(time_series)"
  },
  {
    "language": "R",
    "code": "# Sample 17: Machine Learning with caret Library\nlibrary(caret)\nmodel <- train(Y ~ ., data=data, method='lm')"
  },
  {
    "language": "R",
    "code": "# Sample 18: Regular Expressions\nstring <- 'Hello, R programming!'\nmatches <- grep('R', string, value=TRUE)"
  },
  {
    "language": "R",
    "code": "# Sample 19: Web Scraping with rvest Library\nlibrary(rvest)\nurl <- 'https://example.com'\npage <- read_html(url)"
  },
  {
    "language": "R",
    "code": "# Sample 20: API Requests with httr Library\nlibrary(httr)\nresponse <- GET('https://api.example.com/data')"
  },
  {
    "language": "R",
    "code": "# Sample 21: Data Cleaning\nna_removed <- na.omit(data)\noutliers_removed <- data[!data$X %in% outliers, ]"
  },
  {
    "language": "R",
    "code": "# Sample 22: Hierarchical Clustering\nhierarchical_cluster <- hclust(dist(data), method='ward.D')"
  },
  {
    "language": "R",
    "code": "# Sample 23: Principal Component Analysis\npca_result <- prcomp(data[,1:4], scale=TRUE)"
  },
  {
    "language": "R",
    "code": "# Sample 24: K-Means Clustering\nkmeans_result <- kmeans(data[,1:3], centers=3)"
  },
  {
    "language": "R",
    "code": "# Sample 25: Support Vector Machines\nlibrary(e1071)\nsvm_model <- svm(Y ~ ., data=data, kernel='linear', cost=10, gamma=0.1)"
  },
  {
    "language": "R",
    "code": "# Sample 26: Decision Trees with rpart Library\nlibrary(rpart)\ndt_model <- rpart(Y ~ ., data=data, method='class')"
  },
  {
    "language": "R",
    "code": "# Sample 27: Neural Networks with nnet Library\nlibrary(nnet)\nnn_model <- nnet(Y ~ ., data=data, size=5, maxit=100)"
  },
  {
    "language": "R",
    "code": "# Sample 28: Time Series Forecasting with forecast Library\nlibrary(forecast)\nforecast_result <- forecast(time_series, h=12)"
  },
  {
    "language": "R",
    "code": "# Sample 29: Association Rule Mining with arules Library\nlibrary(arules)\nassociation_rules <- apriori(data, parameter=list(support=0.1, confidence=0.8))"
  },
  {
    "language": "R",
    "code": "# Sample 30: Natural Language Processing with tm Library\nlibrary(tm)\ncorpus <- Corpus(VectorSource(text_data))\npreprocessed_corpus <- tm_map(corpus, content_transformer(tolower))"
  },
  {
    "language": "R",
    "code": "# Sample 31: Survival Analysis with survival Library\nlibrary(survival)\nsurvival_model <- coxph(Surv(time, status) ~ age + sex, data=survival_data)"
  },
  {
    "language": "R",
    "code": "# Sample 32: Bayesian Analysis with rstan Library\nlibrary(rstan)\nmodel <- stan_model(model_code = 'model {\n  // Bayesian model specification\n}')"
  },
  {
    "language": "R",
    "code": "# Sample 33: Geospatial Analysis with sf Library\nlibrary(sf)\nmap_data <- st_read('shapefile.shp')"
  },
  {
    "language": "R",
    "code": "# Sample 34: Anomaly Detection\nlibrary(dbscan)\nanomaly_clusters <- dbscan(data, eps=0.5, minPts=5)"
  },
  {
    "language": "R",
    "code": "# Sample 35: Text Sentiment Analysis with textblob Library\nlibrary(textblob)\npositive_sentiment <- sentiment(text_data) > 0"
  },
  {
    "language": "R",
    "code": "# Sample 36: Image Processing with imager Library\nlibrary(imager)\nimage_data <- load.image('image.jpg')"
  },
  {
    "language": "R",
    "code": "# Sample 37: Markov Chain Monte Carlo with MCMCpack Library\nlibrary(MCMCpack)\nmcmc_result <- MCMCmetrop1R(f = function(x) { /* function definition */ }, theta.init = 0)"
  },
  {
    "language": "R",
    "code": "# Sample 38: Time Series Decomposition\nlibrary(forecast)\ndecomposition <- decompose(time_series)"
  },
  {
    "language": "R",
    "code": "# Sample 39: Customer Segmentation\nlibrary(factoextra)\nsegmentation_result <- fviz_cluster(kmeans_result, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 40: Data Imputation\nlibrary(VIM)\nimputed_data <- kNN(data, k=5)"
  },
  {
    "language": "R",
    "code": "# Sample 41: Image Classification with keras Library\nlibrary(keras)\nmodel <- keras_model_sequential()"
  },
  {
    "language": "R",
    "code": "# Sample 42: Stock Price Prediction\nlibrary(quantmod)\ngetSymbols('AAPL', from='2022-01-01', to='2022-12-31')\nmodel <- Arima(Cl(AAPL), order=c(1,1,1))"
  },
  {
    "language": "R",
    "code": "# Sample 43: Network Analysis with igraph Library\nlibrary(igraph)\nnetwork <- graph_from_data_frame(edge_list, directed=TRUE)\nplot(network)"
  },
  {
    "language": "R",
    "code": "# Sample 44: Natural Language Generation\nlibrary(nlp)\ngenerated_text <- generate_text(corpus, length=100)"
  },
  {
    "language": "R",
    "code": "# Sample 45: Data Encryption\nlibrary(openssl)\nencrypted_data <- openssl_encrypt(data, key='my_key', cipher='aes-256-cbc')"
  },
  {
    "language": "R",
    "code": "# Sample 46: Data Decryption\nlibrary(openssl)\ndecrypted_data <- openssl_decrypt(encrypted_data, key='my_key', cipher='aes-256-cbc')"
  },
  {
    "language": "R",
    "code": "# Sample 47: Web Scraping with RSelenium Library\nlibrary(RSelenium)\ndriver <- rsDriver()\nremDr <- driver$client\nremDr$navigate('https://example.com')"
  },
  {
    "language": "R",
    "code": "# Sample 48: API Requests with jsonlite Library\nlibrary(jsonlite)\nresponse <- fromJSON('https://api.example.com/data')"
  },
  {
    "language": "R",
    "code": "# Sample 49: Bayesian Networks\nlibrary(bnlearn)\nbayesian_network <- bn.fit(network_structure, data)"
  },
  {
    "language": "R",
    "code": "# Sample 50: Text Summarization\nlibrary(textTinyR)\nsummary <- textSummary(text_data)"
  },
  {
    "language": "R",
    "code": "# Sample 51: Hyperparameter Tuning with caret Library\nlibrary(caret)\ntuned_model <- train(Y ~ ., data=data, method='lm', tuneGrid=data.frame(.lambda=seq(0.01, 1, by=0.01)))"
  },
  {
    "language": "R",
    "code": "# Sample 52: Data Compression\nlibrary(lz4)\ncompressed_data <- lz4_compress(data)"
  },
  {
    "language": "R",
    "code": "# Sample 53: Audio Processing with tuneR Library\nlibrary(tuneR)\naudio_data <- readWave('audio.wav')"
  },
  {
    "language": "R",
    "code": "# Sample 54: Gesture Recognition\nlibrary(rARToolKit)\ngesture_detected <- detectGesture(video_stream)"
  },
  {
    "language": "R",
    "code": "# Sample 55: Parallel Computing\nlibrary(parallel)\ncl <- makeCluster(4)\nparallel_result <- parLapply(cl, data, function(x) { /* perform computation */ })"
  },
  {
    "language": "R",
    "code": "# Sample 56: Simulation Modeling with SimInf Library\nlibrary(SimInf)\nsimulation_result <- sim_model(model, time=100)"
  },
  {
    "language": "R",
    "code": "# Sample 57: Data Preprocessing with dplyr Library\nlibrary(dplyr)\npreprocessed_data <- data %>%\n  filter(!is.na(X)) %>%\n  select(-Y)"
  },
  {
    "language": "R",
    "code": "# Sample 58: Version Control with git2r Library\nlibrary(git2r)\nrepo <- repository('path/to/repo')\ncommits <- repository_commits(repo)"
  },
  {
    "language": "R",
    "code": "# Sample 59: Object Cloning\ncloned_object <- copy(original_object)"
  },
  {
    "language": "R",
    "code": "# Sample 60: Image Processing with magick Library\nlibrary(magick)\nimage_data <- image_read('image.jpg')"
  },
  {
    "language": "R",
    "code": "# Sample 61: Latent Dirichlet Allocation\nlibrary(topicmodels)\nlda_model <- LDA(data, k=5)"
  },
  {
    "language": "R",
    "code": "# Sample 62: Time Series Forecasting with prophet Library\nlibrary(prophet)\nprophet_model <- prophet(dataframe)"
  },
  {
    "language": "R",
    "code": "# Sample 63: Natural Language Processing with quanteda Library\nlibrary(quanteda)\ndocuments <- corpus(data, text_field='text')\nprocessed_documents <- tokens(documents) %>% tokens_remove('\\p{P}', valuetype='regex')"
  },
  {
    "language": "R",
    "code": "# Sample 64: Genetic Algorithms with GA Library\nlibrary(GA)\nga_result <- ga(type='real-valued', fitness=function(x) { /* fitness function */ }, lower=c(0, 0), upper=c(10, 10))$solution"
  },
  {
    "language": "R",
    "code": "# Sample 65: Bayesian Optimization with mlrMBO Library\nlibrary(mlrMBO)\nbo_result <- smoof::makeSingleObjectiveFunction( /* objective function */) %>% mbo()"
  },
  {
    "language": "R",
    "code": "# Sample 66: Spatial Analysis with sp Library\nlibrary(sp)\nspatial_data <- SpatialPointsDataFrame(coords=data[, c('lon', 'lat')], data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 67: Time Series Decomposition with stlplus Library\nlibrary(stlplus)\ndecomposition_result <- stlplus(data$series, t.window=12, s.window='periodic')"
  },
  {
    "language": "R",
    "code": "# Sample 68: Image Segmentation with EBImage Library\nlibrary(EBImage)\nsegmented_image <- channel(data$image, 'red') > 150"
  },
  {
    "language": "R",
    "code": "# Sample 69: Linear Programming with lpSolve Library\nlibrary(lpSolve)\nlp_result <- lp(direction='max', objective.in=c(30, 20), const.mat=data.matrix(matrix(c(3, 4, 2, 1), nrow=2)), const.dir=c('<=', '<='), const.rhs=c(240, 150))"
  },
  {
    "language": "R",
    "code": "# Sample 70: Data Fusion with fusedPCA Library\nlibrary(fusedPCA)\nfusion_result <- fusedPCA(list(data1, data2))"
  },
  {
    "language": "R",
    "code": "# Sample 71: Recommendation Systems with recommenderlab Library\nlibrary(recommenderlab)\nrecommender_model <- Recommender(data, method='IBCF')"
  },
  {
    "language": "R",
    "code": "# Sample 72: Latent Semantic Analysis with text2vec Library\nlibrary(text2vec)\nlsa_model <- LSA$new(n_vocab = 10000)\nlsa_model$fit_transform(data)"
  },
  {
    "language": "R",
    "code": "# Sample 73: Graphical User Interface with shiny Library\nlibrary(shiny)\nui <- fluidPage(titlePanel('My App'), sidebarLayout(sidebarPanel(), mainPanel()))\nserver <- function(input, output) { /* server logic */ }\nshinyApp(ui = ui, server = server)"
  },
  {
    "language": "R",
    "code": "# Sample 74: Association Rule Mining with arulesViz Library\nlibrary(arulesViz)\nplot(rules, method='grouped')"
  },
  {
    "language": "R",
    "code": "# Sample 75: Web Scraping with rvest and xml2 Libraries\nlibrary(rvest)\nlibrary(xml2)\npage <- read_html('https://example.com')\nlinks <- page %>% html_nodes('a') %>% html_attr('href')"
  },
  {
    "language": "R",
    "code": "# Sample 76: Nonparametric Regression with np Library\nlibrary(np)\nnp_model <- npregbw(Y ~ X1 + X2, data=data, regtype='ll')"
  },
  {
    "language": "R",
    "code": "# Sample 77: Causal Inference with causaleffect Library\nlibrary(causaleffect)\ncausal_model <- ce_ols(Y ~ X, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 78: Visualization with ggplot2 Library\nlibrary(ggplot2)\nggplot(data, aes(x=X, y=Y)) + geom_point()"
  },
  {
    "language": "R",
    "code": "# Sample 79: Event Prediction with survival Analysis\nlibrary(survival)\nevent_model <- coxph(Surv(time, event) ~ X1 + X2, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 80: Natural Language Processing with tm and topicmodels Libraries\nlibrary(tm)\ncorpus <- Corpus(VectorSource(text_data))\nprocessed_corpus <- tm_map(corpus, content_transformer(tolower))\ndtm <- DocumentTermMatrix(processed_corpus)\nlda_model <- LDA(dtm, k=5)"
  },
  {
    "language": "R",
    "code": "# Sample 81: Bayesian Structural Time Series with CausalImpact Library\nlibrary(CausalImpact)\nimpact_result <- CausalImpact(data, pre.period=c(1, n))"
  },
  {
    "language": "R",
    "code": "# Sample 82: Longitudinal Data Analysis\nlibrary(nlme)\nlme_model <- lme(Y ~ X1 + X2, random=~1|group, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 83: Text Clustering with tm and text2vec Libraries\nlibrary(tm)\nlibrary(text2vec)\ncorpus <- Corpus(VectorSource(text_data))\nprocessed_corpus <- tm_map(corpus, content_transformer(tolower))\ndtm <- DocumentTermMatrix(processed_corpus)\nvocab <- create_vocabulary(itoken(processed_corpus))\nvectorizer <- vocab_vectorizer(vocab)\nX <- create_dtm(itoken(processed_corpus), vectorizer)"
  },
  {
    "language": "R",
    "code": "# Sample 84: Cross-validation with caret Library\nlibrary(caret)\ncv_model <- train(Y ~ ., data=data, method='lm', trControl=trainControl(method='cv', number=5))"
  },
  {
    "language": "R",
    "code": "# Sample 85: Reinforcement Learning with ReinforcementLearning Library\nlibrary(ReinforcementLearning)\nagent <- ReinforcementAgent$new()\nagent$learn(data)"
  },
  {
    "language": "R",
    "code": "# Sample 86: Text Analysis with quanteda and tm Libraries\nlibrary(quanteda)\nlibrary(tm)\ncorpus <- corpus(data, text_field='text')\nprocessed_corpus <- tokens(documents) %>% tokens_remove('\\p{P}', valuetype='regex')\ndtm <- DocumentTermMatrix(processed_corpus)\nfindAssocs(dtm, terms = 'word', corlimit = 0.5)"
  },
  {
    "language": "R",
    "code": "# Sample 87: Data Resampling with rsample Library\nlibrary(rsample)\nsplits <- initial_split(data, prop=0.7)\ntrain_data <- training(splits)\ntest_data <- testing(splits)"
  },
  {
    "language": "R",
    "code": "# Sample 88: Survival Analysis with survminer Library\nlibrary(survminer)\nggsurvplot(survfit(Surv(time, status) ~ X, data=data), data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 89: Deep Learning with keras and TensorFlow Libraries\nlibrary(keras)\nmodel <- keras_model_sequential()"
  },
  {
    "language": "R",
    "code": "# Sample 90: Markov Chain Monte Carlo with rstanarm Library\nlibrary(rstanarm)\nmodel <- stan_glm(Y ~ X1 + X2, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 91: Dimensionality Reduction with Rtsne Library\nlibrary(Rtsne)\nreduced_data <- Rtsne(data, dims=2)"
  },
  {
    "language": "R",
    "code": "# Sample 92: Geographic Data Visualization with leaflet Library\nlibrary(leaflet)\nmap <- leaflet() %>% addTiles() %>% addMarkers(lng=data$lon, lat=data$lat)"
  },
  {
    "language": "R",
    "code": "# Sample 93: Multilevel Modeling with lme4 Library\nlibrary(lme4)\nmm_model <- lmer(Y ~ X1 + X2 + (1|group), data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 94: Feature Selection with Boruta Library\nlibrary(Boruta)\nboruta_result <- Boruta(Y ~ ., data=data, doTrace=0)"
  },
  {
    "language": "R",
    "code": "# Sample 95: Bayesian Analysis with brms Library\nlibrary(brms)\nmodel <- brm(Y ~ X1 + X2 + (1|group), data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 96: Time Series Anomaly Detection\nlibrary(TSclust)\nanomalies <- tso(data, types='trend', control=TSclustControl(minsize=3))"
  },
  {
    "language": "R",
    "code": "# Sample 97: Graph Database Operations with igraph Library\nlibrary(igraph)\ngraph <- graph_from_data_frame(edge_list)\nclusters <- clusters(graph)"
  },
  {
    "language": "R",
    "code": "# Sample 98: Automated Machine Learning with H2O Library\nlibrary(h2o)\nh2o.init()\nh2o_model <- h2o.estimator( /* model parameters */ )"
  },
  {
    "language": "R",
    "code": "# Sample 99: Natural Language Generation with rnn Library\nlibrary(rnn)\nmodel <- trainRNN( /* training data */ )"
  },
  {
    "language": "R",
    "code": "# Sample 100: Stream Processing with streamR Library\nlibrary(streamR)\nstream_data <- openStream(url)"
  },
  {
    "language": "R",
    "code": "# Sample 101: Unsupervised Learning with dbscan Library\nlibrary(dbscan)\ncluster_result <- dbscan(data, eps=0.5, minPts=5)"
  },
  {
    "language": "R",
    "code": "# Sample 102: Bayesian Networks with gRain Library\nlibrary(gRain)\nbn_model <- grain(data, nodes=c('A', 'B', 'C'), arcs=c('A->B', 'C->B'), states=list(A=c('low', 'high'), B=c('yes', 'no'), C=c('red', 'blue')))"
  },
  {
    "language": "R",
    "code": "# Sample 103: Interactive Visualizations with plotly Library\nlibrary(plotly)\nplot <- plot_ly(data, x=~X, y=~Y, type='scatter', mode='markers')"
  },
  {
    "language": "R",
    "code": "# Sample 104: Survival Analysis with coxphf Library\nlibrary(coxphf)\ncoxphf_model <- coxphf(Surv(time, status) ~ X1 + X2, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 105: Structural Equation Modeling with lavaan Library\nlibrary(lavaan)\nsem_model <- sem(model, data=data)"
  },
  {
    "language": "R",
    "code": "# Sample 106: Imbalanced Data Handling with ROSE Library\nlibrary(ROSE)\nbalanced_data <- ROSE(Y ~ ., data=data)$data"
  },
  {
    "language": "R",
    "code": "# Sample 107: Genetic Algorithms with GA Library\nlibrary(GA)\nga_result <- ga(type='binary', fitness=function(x) { /* fitness function */ }, nBits=10, maxiter=100)"
  },
  {
    "language": "R",
    "code": "# Sample 108: Text Analytics with textmineR Library\nlibrary(textmineR)\ntext_analysis <- tm_term_stats(corpus, stopwords='english')"
  },
  {
    "language": "R",
    "code": "# Sample 109: Ensemble Learning with caretEnsemble Library\nlibrary(caretEnsemble)\nensemble_model <- caretList(Y ~ ., data=data, trControl=trainControl(method='cv', number=5))"
  },
  {
    "language": "R",
    "code": "# Sample 110: Anomaly Detection with anomalize Library\nlibrary(anomalize)\nanomaly_result <- time_decompose(data) %>% anomalize(remainder)"
  },
  {
    "language": "D",
    "code": "immutable int x = 5;\nimmutable string message = \"Hello, D!\";"
  },
  {
    "language": "D",
    "code": "pure int square(int x) {\n    return x * x;\n}"
  },
  {
    "language": "D",
    "code": "nothrow void doSomething() {\n    // Code that doesn't throw exceptions\n}"
  },
  {
    "language": "D",
    "code": "@safe {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n}'"
  },
  {
    "language": "D",
    "code": "@trusted void unsafeOperation() {\n    // Unsafe operations here\n}'"
  },
  {
    "language": "D",
    "code": "@system {\n    // Low-level system operations here\n}'"
  },
  {
    "language": "D",
    "code": "final class FinalClass {\n    // Class members and methods\n}"
  },
  {
    "language": "D",
    "code": "void modify(ref int x) {\n    x *= 2;\n}"
  },
  {
    "language": "D",
    "code": "void foo() {\n    scope int x = 10;\n    // x is valid only within this scope\n}"
  },
  {
    "language": "D",
    "code": "void modify(inout int x) {\n    x += 5;\n}"
  },
  {
    "language": "D",
    "code": "lazy int result = complexCalculation();"
  },
  {
    "language": "D",
    "code": "pure nothrow @safe int calculate(int x, int y) {\n    return x + y;\n}"
  },
  {
    "language": "D",
    "code": "nothrow pure int multiply(int a, int b) {\n    return a * b;\n}"
  },
  {
    "language": "D",
    "code": "@trusted void unsafeOperation() {\n    // Perform unsafe operations here\n}'"
  },
  {
    "language": "D",
    "code": "@safe immutable int[] createImmutableArray() {\n    return [1, 2, 3, 4, 5];\n}'"
  },
  {
    "language": "D",
    "code": "@system void systemOperation() {\n    // Perform system-level operations here\n}'"
  },
  {
    "language": "D",
    "code": "void increment(ref int x) {\n    x++;\n}"
  },
  {
    "language": "D",
    "code": "void process(inout int x) {\n    x *= 2;\n}"
  },
  {
    "language": "D",
    "code": "@safe immutable string greeting = \"Hello, World!\";'"
  },
  {
    "language": "D",
    "code": "// Example 21: Simple TCP Server with vibe.d\nimport vibe.d;\nimport std.stdio;\n\nvoid handleClient(TCPConnection conn) {\n    conn.write(\"Hello from the server!\");\n    conn.close();\n}\n\nvoid startServer() {\n    listenTCP(8080, &handleClient);\n    writeln(\"Server started at port 8080\");\n    runEventLoop();\n}\n\nvoid main() {\n    startServer();\n}"
  },
  {
    "language": "D",
    "code": "// Example 22: Generating Fibonacci Sequence using Generator\nimport std.stdio;\n\nvoid fibonacciGenerator(ulong terms) {\n    ulong a = 0, b = 1;\n    foreach (i; 0 .. terms) {\n        write(a, \" \");\n        auto temp = a;\n        a = b;\n        b += temp;\n    }\n}\n\nvoid main() {\n    ulong terms = 10;\n    writeln(\"Fibonacci sequence of \", terms, \" terms:\");\n    fibonacciGenerator(terms);\n}"
  },
  {
    "language": "D",
    "code": "// Example 23: Basic Exception Handling\nimport std.stdio;\nimport core.exception;\n\nvoid main() {\n    try {\n        throw new Exception(\"This is an exception\");\n    } catch (Exception e) {\n        writeln(\"Caught exception: \", e.msg);\n    }\n}"
  },
  {
    "language": "D",
    "code": "// Example 24: Finding Factorial using Recursion\nimport std.stdio;\n\nulong factorial(ulong n) {\n    return n <= 1 ? 1 : n * factorial(n - 1);\n}\n\nvoid main() {\n    ulong num = 5;\n    writeln(\"Factorial of \", num, \" is \", factorial(num));\n}"
  },
  {
    "language": "D",
    "code": "// Example 25: Using Static Arrays\nimport std.stdio;\n\nvoid main() {\n    int[5] numbers = [1, 2, 3, 4, 5];\n    writeln(\"Elements in the array:\", numbers);\n}"
  },
  {
    "language": "D",
    "code": "// Example 26: Base64 Encoding and Decoding\nimport std.stdio;\nimport std.base64;\n\nvoid main() {\n    string original = \"Hello, Base64!\";\n    string encoded = encodeBase64(original);\n    writeln(\"Encoded: \", encoded);\n    string decoded = decodeBase64(encoded);\n    writeln(\"Decoded: \", decoded);\n}"
  },
  {
    "language": "D",
    "code": "// Example 27: Finding GCD (Greatest Common Divisor)\nimport std.stdio;\n\nulong gcd(ulong a, ulong b) {\n    while (b != 0) {\n        auto temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nvoid main() {\n    ulong num1 = 12;\n    ulong num2 = 18;\n    writeln(\"GCD of \", num1, \" and \", num2, \" is \", gcd(num1, num2));\n}"
  },
  {
    "language": "D",
    "code": "// Example 28: Working with Bitwise Operations\nimport std.stdio;\n\nvoid main() {\n    int num1 = 5;\n    int num2 = 3;\n    writeln(\"Bitwise AND: \", num1 & num2);\n    writeln(\"Bitwise OR: \", num1 | num2);\n    writeln(\"Bitwise XOR: \", num1 ^ num2);\n}"
  },
  {
    "language": "D",
    "code": "// Example 29: Using D's Standard Library DateTime\nimport std.stdio;\nimport std.datetime;\n\nvoid main() {\n    auto currentTime = Clock.currTime();\n    writeln(\"Current date and time: \", currentTime);\n}"
  },
  {
    "language": "D",
    "code": "// Example 30: Basic Template Usage in D\nimport std.stdio;\n\ntemplate Swap(T) {\n    void swap(ref T a, ref T b) {\n        T temp = a;\n        a = b;\n        b = temp;\n    }\n}\n\nvoid main() {\n    int x = 5, y = 10;\n    writeln(\"Before swap: x = \", x, \", y = \", y);\n    Swap!int.swap(x, y);\n    writeln(\"After swap: x = \", x, \", y = \", y);\n}"
  },
  {
    "language": "D",
    "code": "// Example 31: Using Associative Arrays\nimport std.stdio;\n\nvoid main() {\n    int[string] ages;\n    ages[\"Alice\"] = 25;\n    ages[\"Bob\"] = 30;\n    ages[\"Charlie\"] = 28;\n    writeln(\"Bob's age: \", ages[\"Bob\"]);\n}"
  },
  {
    "language": "D",
    "code": "// Example 32: Linear Search\nimport std.stdio;\n\nint linearSearch(int[] arr, int target) {\n    foreach (i, value; arr) {\n        if (value == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid main() {\n    int[] numbers = [10, 20, 30, 40, 50];\n    int target = 30;\n    writeln(\"Index of \", target, \" is \", linearSearch(numbers, target));\n}"
  },
  {
    "language": "D",
    "code": "// Example 33: Using Ranges in D\nimport std.stdio;\nimport std.range;\n\nvoid main() {\n    int[] numbers = [1, 2, 3, 4, 5];\n    auto squared = numbers.map!(a => a * a);\n    writeln(\"Squared numbers: \", squared);\n}"
  },
  {
    "language": "D",
    "code": "// Example 34: Enumerations in D\nimport std.stdio;\n\nenum Color { RED, GREEN, BLUE };\n\nvoid main() {\n    Color selectedColor = Color.GREEN;\n    writeln(\"Selected color: \", selectedColor);\n}"
  },
  {
    "language": "D",
    "code": "// Example 35: Formatting Strings in D\nimport std.stdio;\n\nvoid main() {\n    int age = 25;\n    string name = \"Alice\";\n    writeln(\"Name: \", name, \", Age: \", age);\n}"
  },
  {
    "language": "D",
    "code": "// Example 36: Using D's Standard Library Math Functions\nimport std.stdio;\nimport std.math;\n\nvoid main() {\n    double value = 4.5;\n    writeln(\"Square root of \", value, \" is \", sqrt(value));\n}"
  },
  {
    "language": "D",
    "code": "// Example 37: Manipulating Strings in D\nimport std.stdio;\n\nvoid main() {\n    string text = \"Hello, World!\";\n    writeln(\"Length of the string: \", text.length);\n    writeln(\"Substring: \", text[0..5]);\n    writeln(\"Uppercase: \", text.toUpper);\n}"
  },
  {
    "language": "D",
    "code": "// Example 38: Random Number Generation in D\nimport std.stdio;\nimport std.random;\n\nvoid main() {\n    int randomNum = uniform(1, 10);\n    writeln(\"Random number between 1 and 10: \", randomNum);\n}"
  },
  {
    "language": "D",
    "code": "// Example 39: Using Tuples in D\nimport std.stdio;\n\nvoid main() {\n    auto person = tuple(\"Alice\", 25, \"New York\");\n    writeln(\"Person: \", person);\n}"
  },
  {
    "language": "D",
    "code": "// Example 40: Set Operations in D\nimport std.stdio;\nimport std.algorithm;\n\nvoid main() {\n    int[] set1 = [1, 2, 3, 4, 5];\n    int[] set2 = [4, 5, 6, 7, 8];\n    auto intersection = set1.setIntersection(set2);\n    auto unionSet = set1.setUnion(set2);\n    writeln(\"Intersection: \", intersection);\n    writeln(\"Union: \", unionSet);\n}"
  },
  {
    "language": "D",
    "code": "// Example 41: Multi-threading in D\nimport std.stdio;\nimport core.thread;\n\nvoid workerThread() {\n    writeln(\"Worker thread running\");\n    Thread.sleep(1.seconds);\n    writeln(\"Worker thread completed\");\n}\n\nvoid main() {\n    writeln(\"Main thread started\");\n    auto t = spawn(&workerThread);\n    t.join;\n    writeln(\"Main thread completed\");\n}"
  },
  {
    "language": "D",
    "code": "// Example 42: Using External Libraries (e.g., libcurl)\nimport std.stdio;\nimport std.process;\n\nvoid main() {\n    auto result = execute([\"curl\", \"-X\", \"GET\", \"https://api.example.com\"]);\n    writeln(\"API Response: \", result.output);\n}"
  },
  {
    "language": "D",
    "code": "// Example 43: Memory Management in D\nimport std.stdio;\n\nvoid main() {\n    int* ptr = new int;\n    *ptr = 10;\n    writeln(\"Value stored at memory address \", ptr, \" is \", *ptr);\n    delete ptr;\n}"
  },
  {
    "language": "D",
    "code": "// Example 44: Database Interaction with D\nimport std.stdio;\nimport std.database;\n\nvoid main() {\n    auto db = connectMySQL(\"localhost\", \"username\", \"password\", \"database\");\n    auto result = db.executeSQL(\"SELECT * FROM table\");\n    writeln(\"Database query result: \", result);\n}"
  },
  {
    "language": "D",
    "code": "// Example 45: Using Custom Structs\nimport std.stdio;\n\nstruct Point {\n    int x;\n    int y;\n}\n\nvoid main() {\n    Point p;\n    p.x = 5;\n    p.y = 10;\n    writeln(\"Point coordinates: (\", p.x, \", \", p.y, \")\");\n}"
  },
  {
    "language": "D",
    "code": "// Example 46: Implementing a Simple Lexer\nimport std.stdio;\n\nenum TokenType {\n    INTEGER,\n    PLUS,\n    MINUS,\n    EOF\n}\n\nstruct Token {\n    TokenType type;\n    string value;\n}\n\nvoid main() {\n    // Lexer logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 47: Using D's Metaprogramming Capabilities\nimport std.stdio;\n\nenum myVar = 10;\nvoid main() {\n    writeln(\"Value of myVar: \", myVar);\n}"
  },
  {
    "language": "D",
    "code": "// Example 48: Implementing a Binary Tree\nimport std.stdio;\n\nstruct Node {\n    int value;\n    Node* left;\n    Node* right;\n}\n\nvoid main() {\n    // Binary tree implementation here\n}"
  },
  {
    "language": "D",
    "code": "// Example 49: Using D's UDP Networking\nimport std.stdio;\nimport std.socket;\n\nvoid main() {\n    // UDP networking logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 50: Creating a Basic GUI with GtkD\nimport std.stdio;\nimport gtk.Main;\nimport gtk.Label;\n\nvoid main() {\n    Main.init;\n    auto window = new MainWindow(\"Hello, GtkD\");\n    auto label = new Label(\"This is a label\");\n    window.add(label);\n    window.showAll;\n    Main.run;\n}"
  },
  {
    "language": "D",
    "code": "// Example 51: Using D's WebSocket Library\nimport std.stdio;\nimport vibe.stream.memory;\nimport vibe.stream.operations;\n\nvoid main() {\n    // WebSocket logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 52: Image Processing in D\nimport std.stdio;\nimport std.algorithm;\nimport std.array;\n\nvoid main() {\n    // Image processing logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 53: Creating a Custom Exception Class\nimport std.stdio;\nimport core.exception;\n\nclass CustomException : Exception {\n    this(string msg) { super(msg); }\n}\n\nvoid main() {\n    // Using CustomException here\n}"
  },
  {
    "language": "D",
    "code": "// Example 54: Using D's XML Library\nimport std.stdio;\nimport std.xml;\n\nvoid main() {\n    // XML processing logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 55: Generating QR Codes in D\nimport std.stdio;\nimport qrcodegen;\n\nvoid main() {\n    // QR code generation logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 56: Parsing Command Line Arguments in D\nimport std.stdio;\nimport std.getopt;\n\nvoid main(string[] args) {\n    // Command line argument parsing logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 57: Using D's `std.regex`\nimport std.stdio;\nimport std.regex;\n\nvoid main() {\n    // Regular expression usage here\n}"
  },
  {
    "language": "D",
    "code": "// Example 58: Implementing a Simple Calculator\nimport std.stdio;\n\nvoid main() {\n    // Simple calculator implementation here\n}"
  },
  {
    "language": "D",
    "code": "// Example 59: Using D's `std.algorithm` for Advanced Data Manipulation\nimport std.stdio;\nimport std.algorithm;\n\nvoid main() {\n    // Advanced data manipulation using std.algorithm\n}"
  },
  {
    "language": "D",
    "code": "// Example 60: Cryptography in D\nimport std.stdio;\nimport std.digest;\n\nvoid main() {\n    // Cryptography logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 61: Using D's `std.socket` for Network Communication\nimport std.stdio;\nimport std.socket;\n\nvoid main() {\n    // Network communication logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 62: Creating a Basic Web Server with vibe.d\nimport std.stdio;\nimport vibe.d;\n\nvoid main() {\n    // Web server logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 63: Working with Matrices and Linear Algebra in D\nimport std.stdio;\nimport mir.ndslice;\n\nvoid main() {\n    // Matrix operations and linear algebra in D\n}"
  },
  {
    "language": "D",
    "code": "// Example 64: Using D's `std.conv` for Data Conversion\nimport std.stdio;\nimport std.conv;\n\nvoid main() {\n    // Data conversion using std.conv\n}"
  },
  {
    "language": "D",
    "code": "// Example 65: Implementing a Hash Table\nimport std.stdio;\n\nvoid main() {\n    // Hash table implementation\n}"
  },
  {
    "language": "D",
    "code": "// Example 66: Using D's `std.parallelism` for Parallel Processing\nimport std.stdio;\nimport std.parallelism;\n\nvoid main() {\n    // Parallel processing logic here\n}"
  },
  {
    "language": "D",
    "code": "// Example 67: Working with Binary Files in D\nimport std.stdio;\nimport std.file;\n\nvoid main() {\n    // Binary file handling logic\n}"
  },
  {
    "language": "D",
    "code": "// Example 68: Creating a Custom Data Structure\nimport std.stdio;\n\nvoid main() {\n    // Custom data structure implementation\n}"
  },
  {
    "language": "D",
    "code": "// Example 69: Using D's `std.net.curl` for HTTP Requests\nimport std.stdio;\nimport std.net.curl;\n\nvoid main() {\n    // HTTP request logic using std.net.curl\n}"
  },
  {
    "language": "D",
    "code": "// Example 70: Implementing a PriorityQueue\nimport std.stdio;\n\nvoid main() {\n    // PriorityQueue implementation\n}"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Hello, Bash!\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor i in {1..5}; do\n\techo $i\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction greet() {\n\techo \"Welcome, $1!\"\n}\n\ngreet \"John\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nread -p \"Enter your name: \" name\n\necho \"Hello, $name!\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nif [ -f \"file.txt\" ]; then\n\techo \"File exists.\"\nelse\n\techo \"File does not exist.\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nnumbers=(1 2 3 4 5)\nfor num in \"${numbers[@]}\"; do\n\techo $num\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction swap() {\n\tlocal temp=$1\n\tlocal x=$2\n\tlocal y=$3\n\teval $1=$y $2=$x\n}\n\na=5\nb=10\nswap temp a b\necho \"After swapping: a=$a, b=$b\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nwhile true; do\n\techo \"Infinite loop...\"\n\tsleep 1\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction calculate_sum() {\n\tlocal result=$(( $1 + $2 ))\n\techo \"Sum is: $result\"\n}\n\ncalculate_sum 10 20"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfile=\"example.txt\"\nif [ -e $file ]; then\n\techo \"File exists: $file\"\nelse\n\techo \"File does not exist: $file\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor (( i=0; i<5; i++ )); do\n\techo $i\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nif [ $# -eq 0 ]; then\n\techo \"No arguments provided.\"\nelse\n\techo \"Arguments: $@\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nhour=$(date +%H)\nif [ $hour -lt 12 ]; then\n\techo \"Good morning!\"\nelif [ $hour -lt 17 ]; then\n\techo \"Good afternoon!\"\nelse\n\techo \"Good evening!\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfor file in *.txt; do\n\techo \"Processing file: $file\"\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Number of arguments: $#\"\necho \"Argument 1: $1\"\necho \"Argument 2: $2\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction factorial() {\n\tif [ $1 -eq 0 ]; then\n\t\techo 1\n\telse\n\t\techo $(( $1 * $(factorial $(( $1 - 1 ))) ))\n\tfi\n}\n\nresult=$(factorial 5)\necho \"Factorial of 5 is: $result\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Current date: $(date)\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\necho \"Running command: ls -l\"\nls -l"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\narray=(\"apple\" \"banana\" \"orange\")\nfor fruit in \"${array[@]}\"; do\n\techo $fruit\n\tdone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\nfunction greet_user() {\n\tlocal name=$1\n\techo \"Hello, $name!\"\n}\n\ngreet_user \"Alice\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Simple function and usage\nfunction greet() {\n\techo \"Hello, $1!\"\n}\n\ngreet \"World\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Reading user input and conditional statements\nread -p \"Enter a number: \" num\nif [ $num -gt 0 ]; then\n\techo \"Number is positive\"\nelse\n\techo \"Number is non-positive\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Arrays and loops\nfruits=(\"apple\" \"banana\" \"orange\")\nfor fruit in \"${fruits[@]}\"; do\n\techo \"Fruit: $fruit\"\ndone"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Functions with return values\nfunction add() {\n\tlocal result=$(( $1 + $2 ))\n\techo $result\n}\n\nsum=$(add 10 20)\necho \"Sum is: $sum\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Command substitution and file manipulation\nfiles=$(ls *.txt)\necho \"Text files: $files\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using sed for text manipulation\necho \"Hello, World!\" | sed 's/World/Universe/'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Arithmetic operations\nresult=$((5 * 3 + 2))\necho \"Result: $result\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Process management and background tasks\nfunction long_running_task() {\n\techo \"Task started\"\n\tsleep 5\n\techo \"Task completed\"\n}\n\nlong_running_task &\n\necho \"Main script continues\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Reading and parsing a CSV file\nwhile IFS=',' read -r name age city; do\n\techo \"Name: $name, Age: $age, City: $city\"\ndone < data.csv"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Associative arrays\ndeclare -A colors\n\ncolors[red]=\"#FF0000\"\ncolors[green]=\"#00FF00\"\ncolors[blue]=\"#0000FF\"\n\necho \"Red: ${colors[red]}\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Advanced string manipulation\nstring=\"Hello, World!\"\nsubstring=${string:7:5}\necho \"Substring: $substring\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Pattern matching and regular expressions\nstring=\"apple\"\nif [[ $string =~ ^[aeiou] ]]; then\n\techo \"$string starts with a vowel\"\nelse\n\techo \"$string does not start with a vowel\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using awk for text processing\necho \"John,Doe,30\" | awk -F\",\" '{print \"Name: \" $1 \" \" $2, \"Age: \" $3}'"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Generating a random password\nlength=8\npassword=$(openssl rand -base64 12 | tr -dc 'a-zA-Z0-9' | head -c $length)\necho \"Random Password: $password\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Advanced if-else condition\nnum=15\nif ((num < 10)); then\n\techo \"Number is less than 10\"\nelif ((num >= 10 && num < 20)); then\n\techo \"Number is between 10 and 19\"\nelse\n\techo \"Number is 20 or greater\"\nfi"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Function with default parameter\nfunction greet() {\n\tlocal name=${1:-\"Guest\"}\n\techo \"Hello, $name!\"\n}\n\ngreet\n"
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Sending HTTP request using curl\nresponse=$(curl -s https://api.example.com/data)\necho \"Response: $response\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Using jq to process JSON data\njson='{\"name\": \"John\", \"age\": 25}'\nname=$(echo $json | jq -r '.name')\necho \"Name: $name\""
  },
  {
    "language": "Bash",
    "code": "#!/bin/bash\n\n# Trapping signals in a script\nfunction cleanup() {\n\techo \"Cleaning up...\"\n}\n\ntrap cleanup EXIT\n\necho \"Script is running...\""
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees;"
  },
  {
    "language": "SQL",
    "code": "SELECT first_name, last_name FROM users WHERE age > 30;"
  },
  {
    "language": "SQL",
    "code": "SELECT product_name, price FROM products ORDER BY price DESC LIMIT 5;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_orders FROM orders;"
  },
  {
    "language": "SQL",
    "code": "SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department;"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO customers (first_name, last_name, email) VALUES ('John', 'Doe', 'john@example.com');"
  },
  {
    "language": "SQL",
    "code": "UPDATE products SET price = price * 1.1 WHERE category = 'Electronics';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM users WHERE last_login < '2023-01-01';"
  },
  {
    "language": "SQL",
    "code": "CREATE TABLE IF NOT EXISTS employees (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100),\n    age INT,\n    department VARCHAR(100)\n);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE products ADD COLUMN stock INT DEFAULT 0;"
  },
  {
    "language": "SQL",
    "code": "SELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_customers FROM customers WHERE country = 'USA';"
  },
  {
    "language": "SQL",
    "code": "SELECT order_date, SUM(total_amount) AS revenue FROM orders GROUP BY order_date;"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(age) AS avg_age FROM users WHERE gender = 'Female';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (101, 205, 3);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET department = 'HR' WHERE department = 'Admin';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM products WHERE stock = 0;"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_lastname ON users(last_name);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN city VARCHAR(50);"
  },
  {
    "language": "SQL",
    "code": "SELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;"
  },
  {
    "language": "SQL",
    "code": "SELECT COUNT(*) AS total_customers FROM customers WHERE country = 'USA';"
  },
  {
    "language": "SQL",
    "code": "SELECT order_date, SUM(total_amount) AS revenue FROM orders GROUP BY order_date;"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(age) AS avg_age FROM users WHERE gender = 'Female';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (101, 205, 3);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET department = 'HR' WHERE department = 'Admin';"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM products WHERE stock = 0;"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_lastname ON users(last_name);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN city VARCHAR(50);"
  },
  {
    "language": "SQL",
    "code": "SELECT first_name, last_name, email FROM users WHERE department IN ('Sales', 'Marketing');"
  },
  {
    "language": "SQL",
    "code": "SELECT AVG(salary) AS avg_salary FROM employees WHERE department = 'HR';"
  },
  {
    "language": "SQL",
    "code": "SELECT customer_id, COUNT(order_id) AS total_orders FROM orders GROUP BY customer_id HAVING total_orders > 5;"
  },
  {
    "language": "SQL",
    "code": "SELECT product_name, price FROM products WHERE LOWER(product_name) LIKE '%phone%';"
  },
  {
    "language": "SQL",
    "code": "INSERT INTO orders (customer_id, product_id, quantity) VALUES (105, 210, 2), (106, 215, 1);"
  },
  {
    "language": "SQL",
    "code": "UPDATE employees SET salary = salary * 1.1 WHERE age > 40;"
  },
  {
    "language": "SQL",
    "code": "DELETE FROM users WHERE last_login < DATE_SUB(NOW(), INTERVAL 6 MONTH);"
  },
  {
    "language": "SQL",
    "code": "CREATE INDEX idx_category ON products(category);"
  },
  {
    "language": "SQL",
    "code": "ALTER TABLE customers ADD COLUMN state VARCHAR(50) AFTER city;"
  },
  {
    "language": "SQL",
    "code": "DROP INDEX IF EXISTS idx_lastname ON users;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 1: Selecting Data from a Table\nSELECT * FROM users;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 2: Filtering Data with WHERE Clause\nSELECT * FROM products WHERE price > 50;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 3: Joining Tables\nSELECT orders.order_id, orders.date, customers.name\nFROM orders\nINNER JOIN customers ON orders.customer_id = customers.customer_id;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 4: Aggregating Data with GROUP BY\nSELECT category, SUM(quantity) AS total_quantity\nFROM products\nGROUP BY category;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 5: Ordering Results\nSELECT * FROM products ORDER BY price DESC;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 6: Using Subqueries\nSELECT name, age\nFROM employees\nWHERE department_id IN (SELECT department_id FROM departments WHERE location = 'New York');"
  },
  {
    "language": "SQL",
    "code": "-- Sample 7: Inserting Data into a Table\nINSERT INTO customers (name, email) VALUES ('John Doe', 'john@example.com');"
  },
  {
    "language": "SQL",
    "code": "-- Sample 8: Updating Records\nUPDATE products SET price = price * 1.1 WHERE category = 'Electronics';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 9: Deleting Records\nDELETE FROM orders WHERE order_date < '2023-01-01';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 10: Using LIMIT for Pagination\nSELECT * FROM users ORDER BY registration_date DESC LIMIT 10 OFFSET 20;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 11: Renaming Columns\nSELECT customer_id AS ID, name AS CustomerName, email AS EmailAddress FROM customers;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 12: Using DISTINCT to Retrieve Unique Values\nSELECT DISTINCT category FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 13: Counting Rows\nSELECT COUNT(*) AS total_orders FROM orders;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 14: Calculating Aggregated Values\nSELECT AVG(price) AS average_price, MAX(price) AS max_price, MIN(price) AS min_price FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 15: Filtering NULL Values\nSELECT * FROM employees WHERE manager_id IS NULL;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 16: Using CASE Statements\nSELECT product_name, quantity, CASE WHEN quantity > 10 THEN 'High' ELSE 'Low' END AS inventory_status FROM inventory;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 17: Using HAVING with GROUP BY\nSELECT category, COUNT(*) AS total_products FROM products GROUP BY category HAVING COUNT(*) > 5;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 18: Combining Conditions\nSELECT * FROM customers WHERE age > 25 AND city = 'New York';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 19: Retrieving Data using LIKE Operator\nSELECT * FROM products WHERE product_name LIKE 'Apple%';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 20: Using EXISTS Operator\nSELECT * FROM suppliers WHERE EXISTS (SELECT * FROM products WHERE suppliers.supplier_id = products.supplier_id);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 21: Using UNION to Combine Results\nSELECT product_name FROM table1 UNION SELECT product_name FROM table2;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 22: Creating Views\nCREATE VIEW high_inventory AS SELECT * FROM products WHERE quantity > 100;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 23: Altering Table Structure\nALTER TABLE employees ADD COLUMN phone_number VARCHAR(15);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 24: Dropping Views\nDROP VIEW IF EXISTS high_inventory;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 25: Using Joins with Multiple Conditions\nSELECT * FROM orders JOIN customers ON orders.customer_id = customers.customer_id AND orders.date = customers.last_order_date;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 26: Performing Aggregations after Filtering\nSELECT category, SUM(price) AS total_price FROM products WHERE price > 50 GROUP BY category;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 27: Using CASE in UPDATE Statements\nUPDATE employees SET salary = CASE WHEN experience > 5 THEN salary * 1.1 ELSE salary * 1.05 END;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 28: Using CTEs (Common Table Expressions)\nWITH high_price_products AS (SELECT * FROM products WHERE price > 100) SELECT * FROM high_price_products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 29: Pivot Table using CASE and GROUP BY\nSELECT\n    name,\n    SUM(CASE WHEN month = 'January' THEN revenue END) AS Jan,\n    SUM(CASE WHEN month = 'February' THEN revenue END) AS Feb\nFROM sales GROUP BY name;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 30: Using ROW_NUMBER() for Pagination\nSELECT customer_id, name, ROW_NUMBER() OVER (ORDER BY registration_date) AS row_num FROM customers;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 31: Self-Join to Find Hierarchical Data\nSELECT e.employee_id, e.name, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 32: Handling NULL Values with COALESCE\nSELECT product_name, COALESCE(discount_price, price) AS final_price FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 33: Using JSON Functions (if supported)\nSELECT JSON_VALUE(details, '$.name') AS name FROM orders;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 34: Performing Window Functions\nSELECT product_name, price, SUM(price) OVER (PARTITION BY category) AS category_total FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 35: Finding Duplicate Rows\nSELECT name, email, COUNT(*) AS duplicates FROM customers GROUP BY name, email HAVING COUNT(*) > 1;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 36: Using Stored Procedures\nCREATE PROCEDURE sp_get_customer (IN cust_id INT)\nBEGIN\n    SELECT * FROM customers WHERE customer_id = cust_id;\nEND;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 37: Using Triggers\nCREATE TRIGGER before_insert BEFORE INSERT ON employees FOR EACH ROW BEGIN\n    SET NEW.joining_date = NOW();\nEND;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 38: Query to Find Nth Highest Salary\nSELECT salary FROM employees ORDER BY salary DESC LIMIT 1 OFFSET n-1;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 39: Using XML Functions (if supported)\nSELECT XMLQUERY('for $i in /books/book return $i/title' PASSING details RETURNING CONTENT) AS title FROM orders;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 40: Using ROLLUP for Subtotals\nSELECT department, SUM(sales) AS total_sales FROM transactions GROUP BY ROLLUP(department);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 41: Using LIKE with Patterns\nSELECT * FROM products WHERE product_name LIKE '%shirt%';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 42: Using NOT Operator\nSELECT * FROM customers WHERE NOT city = 'New York';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 43: Using BETWEEN for Range Queries\nSELECT * FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 44: Using EXISTS with Subqueries\nSELECT * FROM employees e WHERE EXISTS (SELECT 1 FROM orders o WHERE o.employee_id = e.employee_id);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 45: Using UNION ALL to Combine Results\nSELECT product_name FROM table1 UNION ALL SELECT product_name FROM table2;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 46: Using CROSS JOIN for Cartesian Products\nSELECT c.name AS customer_name, p.product_name FROM customers c CROSS JOIN products p;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 47: Using SQL Functions (e.g., CONCAT, DATE)\nSELECT CONCAT(first_name, ' ', last_name) AS full_name, DATE_FORMAT(join_date, '%Y-%m-%d') AS formatted_date FROM employees;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 48: Using CASE in SELECT Statement\nSELECT product_name, CASE WHEN quantity > 0 THEN 'In Stock' ELSE 'Out of Stock' END AS stock_status FROM inventory;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 49: Using FULL OUTER JOIN\nSELECT customers.customer_id, customers.name, orders.order_id FROM customers FULL OUTER JOIN orders ON customers.customer_id = orders.customer_id;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 50: Using COALESCE to Handle NULL Values\nSELECT product_name, COALESCE(discounted_price, price) AS final_price FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 51: Finding Rows with NULL Values\nSELECT * FROM table_name WHERE column_name IS NULL;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 52: Using LIMIT for Top N Records\nSELECT * FROM employees ORDER BY salary DESC LIMIT 5;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 53: Finding Records with Aggregate Functions\nSELECT department, COUNT(*) AS total_employees FROM employees GROUP BY department HAVING COUNT(*) > 5;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 54: Using JOIN with Multiple Tables\nSELECT customers.name, orders.order_id, products.product_name FROM customers JOIN orders ON customers.customer_id = orders.customer_id JOIN products ON orders.product_id = products.product_id;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 55: Using ORDER BY with Multiple Columns\nSELECT * FROM sales ORDER BY year DESC, quarter ASC, revenue DESC;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 56: Using Subqueries for Calculations\nSELECT employee_id, salary, (SELECT AVG(salary) FROM employees) AS average_salary FROM employees;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 57: Using LIKE and ESCAPE for Special Characters\nSELECT * FROM products WHERE product_name LIKE '%%' ESCAPE '\\';"
  },
  {
    "language": "SQL",
    "code": "-- Sample 58: Using EXCEPT to Find Differences\nSELECT product_name FROM table1 EXCEPT SELECT product_name FROM table2;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 59: Using LAG() for Analytical Queries\nSELECT order_id, product_id, quantity, LAG(quantity) OVER (ORDER BY order_id) AS prev_quantity FROM order_details;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 60: Using LEAD() for Analytical Queries\nSELECT order_id, product_id, quantity, LEAD(quantity) OVER (ORDER BY order_id) AS next_quantity FROM order_details;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 61: Using STRING_AGG() for String Concatenation\nSELECT category, STRING_AGG(product_name, ', ') AS products_list FROM products GROUP BY category;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 62: Using RANK() for Analytical Queries\nSELECT product_name, price, RANK() OVER (PARTITION BY category ORDER BY price DESC) AS rank FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 63: Using DENSE_RANK() for Analytical Queries\nSELECT product_name, price, DENSE_RANK() OVER (PARTITION BY category ORDER BY price DESC) AS dense_rank FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 64: Using NTILE() for Data Distribution\nSELECT product_name, price, NTILE(4) OVER (ORDER BY price) AS price_quartile FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 65: Using CUBE for Grouping Sets\nSELECT department, SUM(sales) AS total_sales FROM transactions GROUP BY CUBE(department);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 66: Using ROLLUP for Partial Subtotals\nSELECT department, SUM(sales) AS total_sales FROM transactions GROUP BY ROLLUP(department);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 67: Using GROUPING SETS\nSELECT department, country, SUM(sales) AS total_sales FROM transactions GROUP BY GROUPING SETS ((department), (country), ());"
  },
  {
    "language": "SQL",
    "code": "-- Sample 68: Using PERCENT_RANK() for Analytical Queries\nSELECT product_name, price, PERCENT_RANK() OVER (ORDER BY price) AS percent_rank FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 69: Using CUME_DIST() for Analytical Queries\nSELECT product_name, price, CUME_DIST() OVER (ORDER BY price) AS cumulative_distribution FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 70: Using FIRST_VALUE() for Analytical Queries\nSELECT product_name, price, FIRST_VALUE(product_name) OVER (ORDER BY price) AS first_product FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 71: Using LAST_VALUE() for Analytical Queries\nSELECT product_name, price, LAST_VALUE(product_name) OVER (ORDER BY price ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_product FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 72: Using ROWS BETWEEN in Window Functions\nSELECT product_name, price, SUM(price) OVER (ORDER BY price ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_sum FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 73: Using RANGE BETWEEN in Window Functions\nSELECT product_name, price, AVG(price) OVER (ORDER BY price RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS avg_price FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 74: Using PERCENTILE_DISC() for Percentile Calculation\nSELECT product_name, price, PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY price) AS median_price FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 75: Using PERCENTILE_CONT() for Continuous Percentile\nSELECT product_name, price, PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY price) AS p90_price FROM products;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 76: Using CHECK Constraints in Table Creation\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    salary DECIMAL CHECK (salary > 0)\n);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 77: Using DEFAULT Values in Table Creation\nCREATE TABLE customers (\n    customer_id INT PRIMARY KEY,\n    name VARCHAR(50),\n    status VARCHAR(10) DEFAULT 'Active'\n);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 78: Using TRUNCATE TABLE Statement\nTRUNCATE TABLE table_name;"
  },
  {
    "language": "SQL",
    "code": "-- Sample 79: Using MERGE Statement for Upsert\nMERGE INTO target_table AS t\nUSING source_table AS s ON t.id = s.id\nWHEN MATCHED THEN\n    UPDATE SET t.column = s.column\nWHEN NOT MATCHED THEN\n    INSERT (column1, column2) VALUES (value1, value2);"
  },
  {
    "language": "SQL",
    "code": "-- Sample 80: Using ROW_NUMBER() for Pagination\nSELECT * FROM employees ORDER BY hire_date OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;"
  },
  {
    "language": "D",
    "code": "// Sample 1: Hello World Program\nimport std.stdio;\nvoid main() {\n    writeln(\"Hello, World!\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 2: Variable Declaration and Assignment\nint a = 5;\nfloat b = 3.14;\nstring message = \"Hello\";"
  },
  {
    "language": "D",
    "code": "// Sample 3: Simple Function\nint square(int x) {\n    return x * x;\n}\nint result = square(5);"
  },
  {
    "language": "D",
    "code": "// Sample 4: Working with Arrays\nint[] numbers = [1, 2, 3, 4, 5];\nint sum = 0;\nforeach (num; numbers) {\n    sum += num;\n}"
  },
  {
    "language": "D",
    "code": "// Sample 5: Using Classes and Objects\nclass Person {\n    string name;\n    int age;\n    this(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\nPerson person = new Person(\"Alice\", 30);"
  },
  {
    "language": "D",
    "code": "// Sample 6: File Input and Output\nimport std.stdio;\nvoid main() {\n    File file = File(\"example.txt\", \"w\");\n    file.writeln(\"Writing to a file\");\n    file.close();\n}"
  },
  {
    "language": "D",
    "code": "// Sample 7: Using Enums\nenum Color {\n    Red,\n    Green,\n    Blue\n}\nColor selectedColor = Color.Red;"
  },
  {
    "language": "D",
    "code": "// Sample 8: Using Structs\nstruct Point {\n    int x;\n    int y;\n}\nPoint p;\np.x = 5;\np.y = 10;"
  },
  {
    "language": "D",
    "code": "// Sample 9: Conditional Statements\nint number = 10;\nif (number > 0) {\n    writeln(\"Positive number\");\n} else if (number < 0) {\n    writeln(\"Negative number\");\n} else {\n    writeln(\"Zero\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 10: Using Templates\ntemplate Max(T) {\n    T max(T a, T b) {\n        return a > b ? a : b;\n    }\n}\nint maxNumber = Max!int.max(5, 10);"
  },
  {
    "language": "D",
    "code": "// Sample 11: Exception Handling\ntry {\n    int result = 10 / 0;\n} catch (Exception e) {\n    writeln(\"Error: Division by zero\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 12: Using foreach with Index\nint[] numbers = [1, 2, 3, 4, 5];\nforeach (index, value; numbers) {\n    writeln(\"Index: \", index, \", Value: \", value);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 13: Using do-while Loop\nint count = 0;\ndo {\n    writeln(count);\n    count++;\n} while (count < 5);"
  },
  {
    "language": "D",
    "code": "// Sample 14: Using do-while Loop\nint count = 0;\ndo {\n    writeln(count);\n    count++;\n} while (count < 5);"
  },
  {
    "language": "D",
    "code": "// Sample 15: Using immutable Variables\nimmutable int immutableVar = 10;\nimmutable string message = \"Immutable variable\";"
  },
  {
    "language": "D",
    "code": "// Sample 16: Using Associative Arrays\nimport std.stdio;\nvoid main() {\n    int[string] ages;\n    ages[\"Alice\"] = 30;\n    ages[\"Bob\"] = 25;\n    writeln(ages[\"Alice\"]);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 17: Using Ternary Operator\nint x = 5;\nstring result = x > 0 ? \"Positive\" : \"Negative or Zero\";"
  },
  {
    "language": "D",
    "code": "// Sample 18: Using Static Arrays\nint[3] numbers = [1, 2, 3];"
  },
  {
    "language": "D",
    "code": "// Sample 19: Using Inheritance\nclass Animal {\n    void makeSound() {\n        writeln(\"Some sound\");\n    }\n}\nclass Dog : Animal {\n    override void makeSound() {\n        writeln(\"Bark\");\n    }\n}\nAnimal animal = new Dog();\nanimal.makeSound();"
  },
  {
    "language": "D",
    "code": "// Sample 20: Using UDAs (User-Defined Attributes)\n@safe\nvoid safeFunction() {\n    // Safe code\n}"
  },
  {
    "language": "D",
    "code": "// Sample 21: Using BigInt for Large Integers\nimport std.bigint;\nBigInt big = 12345678901234567890;"
  },
  {
    "language": "D",
    "code": "// Sample 22: Using UDAs with Parameters\n@system(\"Windows\")\nvoid windowsFunction() {\n    // Windows-specific code\n}"
  },
  {
    "language": "D",
    "code": "// Sample 23: Using AA Literals\nimport std.stdio;\nvoid main() {\n    int[string] ages = [\"Alice\": 30, \"Bob\": 25];\n    writeln(ages[\"Alice\"]);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 24: Using Lazy Initialization\nlazy int lazyVar = 10;"
  },
  {
    "language": "D",
    "code": "// Sample 25: Using Nullable Types\nint? nullableVar = 5;\nif (nullableVar !is null) {\n    writeln(\"Value is not null\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 26: Using Alias This\nstruct Point {\n    int x;\n    int y;\n    alias x this;\n}\nPoint p;\np = 5;"
  },
  {
    "language": "D",
    "code": "// Sample 27: Using CTFE (Compile-Time Function Execution)\nint square(int x) {\n    return x * x;\n}\nenum result = square(5);"
  },
  {
    "language": "D",
    "code": "// Sample 28: Using Unit Tests\nimport std.datetime;\nvoid testDateTime() {\n    assert(DateTime.currCentury == 21);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 29: Using OpDispatch for Operator Overloading\nstruct Vector {\n    int x, y;\n    Vector opBinary(string op)(Vector v) if (op == \"+\") {\n        return Vector(x + v.x, y + v.y);\n    }\n}\nVector v1 = Vector(1, 2);\nVector v2 = Vector(3, 4);\nVector result = v1 + v2;"
  },
  {
    "language": "D",
    "code": "// Sample 30: Using Contracts\nint divide(int a, int b) in {\n    assert(b != 0);\n} out {\n    assert(return * b == a);\n} body {\n    return a / b;\n}"
  },
  {
    "language": "D",
    "code": "// Sample 31: Using Version Blocks\nversion (Windows) {\n    // Windows-specific code\n}"
  },
  {
    "language": "D",
    "code": "// Sample 32: Using Meta Programming with Mixins\nmixin template Print(int value) {\n    pragma(msg, \"Value is: \", value);\n}\nvoid main() {\n    mixin Print!(42);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 33: Using IIFEs (Immediately Invoked Function Expressions)\nint result = (() { return 10 * 2; })();"
  },
  {
    "language": "D",
    "code": "// Sample 34: Using Shared Libraries\nextern (C) {\n    void someFunction() {\n        // C function implementation\n    }\n}"
  },
  {
    "language": "D",
    "code": "// Sample 35: Using Closures\nint closure() {\n    int counter = 0;\n    return (){ return counter++; };\n}\nauto func = closure();\nwriteln(func());"
  },
  {
    "language": "D",
    "code": "// Sample 36: Using Template Constraints\nstruct Container(T) if (isNumeric!T) {\n    T value;\n}\nContainer!int container;"
  },
  {
    "language": "D",
    "code": "// Sample 37: Using opIndex for Custom Indexing\nstruct CustomArray {\n    int[10] internalArray;\n    int opIndex(size_t index) const {\n        return internalArray[index];\n    }\n}\nCustomArray arr;\nint value = arr[5];"
  },
  {
    "language": "D",
    "code": "// Sample 38: Using opApply for Iteration\nstruct MyRange {\n    int front() { /* implementation */ }\n    bool empty() { /* implementation */ }\n    void popFront() { /* implementation */ }\n    int opApply(int delegate(int) dg) {\n        int result;\n        while (!empty()) {\n            result = dg(front());\n            popFront();\n        }\n        return result;\n    }\n}\nMyRange range;\nint sum = 0;\nrange.opApply((int value) { sum += value; return 0; });"
  },
  {
    "language": "D",
    "code": "// Sample 41: Using Classes and Objects\nclass Person {\n    string name;\n    int age;\n    this(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    void greet() {\n        writeln(\"Hello, I'm \", name);\n    }\n}\nPerson person = new Person(\"Alice\", 30);\nperson.greet();"
  },
  {
    "language": "D",
    "code": "// Sample 42: Using Templates for Generic Programming\nstruct Pair(T, U) {\n    T first;\n    U second;\n    this(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\nPair!int stringPair = Pair!int(\"Hello\", 5);\nimport std.stdio;\nwriteln(stringPair.first, \" - \", stringPair.second);"
  },
  {
    "language": "D",
    "code": "// Sample 43: File I/O Operations\nimport std.file;\nstring content = readText(\"input.txt\");\nwrite(\"output.txt\", content);"
  },
  {
    "language": "D",
    "code": "// Sample 44: Using Enumerations\nenum Color { Red, Green, Blue }\nColor color = Color.Red;\nimport std.stdio;\nwriteln(color);"
  },
  {
    "language": "D",
    "code": "// Sample 45: Working with Arrays\nint[] numbers = [1, 2, 3, 4, 5];\nimport std.algorithm;\nauto sum = reduce(numbers, 0, (a, b) => a + b);\nimport std.stdio;\nwriteln(\"Sum: \", sum);"
  },
  {
    "language": "D",
    "code": "// Sample 46: Using Destructuring\nauto tuple = tuple(\"Alice\", 30);\nstring name;\nint age;\ntie(name, age) = tuple;\nimport std.stdio;\nwriteln(name, \" - \", age);"
  },
  {
    "language": "D",
    "code": "// Sample 47: Using Exceptions\ntry {\n    int result = 10 / 0;\n} catch (Exception e) {\n    import std.stdio;\n    writeln(\"Error: Division by zero\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 48: Using Ranges\nimport std.range;\nauto range = iota(5, 10);\nimport std.stdio;\nforeach (num; range) {\n    writeln(num);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 49: Using Associative Arrays\nimport std.stdio;\nint[string] ages;\nages[\"Alice\"] = 30;\nages[\"Bob\"] = 25;\nwriteln(ages[\"Alice\"]);"
  },
  {
    "language": "D",
    "code": "// Sample 50: Using the `static foreach` Loop\nimport std.stdio;\nforeach (i; 0 .. 5)\n{\n    static if (i % 2 == 0)\n        writeln(i, \" is even\");\n    else\n        writeln(i, \" is odd\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 1: Hello World Program\nimport std.stdio;\nvoid main() {\n    writeln(\"Hello, World!\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 2: Variable Declaration and Assignment\nint a = 5;\nfloat b = 3.14;\nstring message = \"Hello\";"
  },
  {
    "language": "D",
    "code": "// Sample 3: Simple Function\nint square(int x) {\n    return x * x;\n}\nint result = square(5);"
  },
  {
    "language": "D",
    "code": "// Sample 4: Working with Arrays\nint[] numbers = [1, 2, 3, 4, 5];\nint sum = 0;\nforeach (num; numbers) {\n    sum += num;\n}"
  },
  {
    "language": "D",
    "code": "// Sample 5: Using Classes and Objects\nclass Person {\n    string name;\n    int age;\n    this(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\nPerson person = new Person(\"Alice\", 30);"
  },
  {
    "language": "D",
    "code": "// Sample 6: File Input and Output\nimport std.stdio;\nvoid main() {\n    File file = File(\"example.txt\", \"w\");\n    file.writeln(\"Writing to a file\");\n    file.close();\n}"
  },
  {
    "language": "D",
    "code": "// Sample 7: Using Enums\nenum Color {\n    Red,\n    Green,\n    Blue\n}\nColor selectedColor = Color.Red;"
  },
  {
    "language": "D",
    "code": "// Sample 8: Using Structs\nstruct Point {\n    int x;\n    int y;\n}\nPoint p;\np.x = 5;\np.y = 10;"
  },
  {
    "language": "D",
    "code": "// Sample 9: Conditional Statements\nint number = 10;\nif (number > 0) {\n    writeln(\"Positive number\");\n} else if (number < 0) {\n    writeln(\"Negative number\");\n} else {\n    writeln(\"Zero\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 10: Using Templates\ntemplate Max(T) {\n    T max(T a, T b) {\n        return a > b ? a : b;\n    }\n}\nint maxNumber = Max!int.max(5, 10);"
  },
  {
    "language": "D",
    "code": "// Sample 11: Exception Handling\ntry {\n    int result = 10 / 0;\n} catch (Exception e) {\n    writeln(\"Error: Division by zero\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 12: Using foreach with Index\nint[] numbers = [1, 2, 3, 4, 5];\nforeach (index, value; numbers) {\n    writeln(\"Index: \", index, \", Value: \", value);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 13: Using do-while Loop\nint count = 0;\ndo {\n    writeln(count);\n    count++;\n} while (count < 5);"
  },
  {
    "language": "D",
    "code": "// Sample 14: Using do-while Loop\nint count = 0;\ndo {\n    writeln(count);\n    count++;\n} while (count < 5);"
  },
  {
    "language": "D",
    "code": "// Sample 15: Using immutable Variables\nimmutable int immutableVar = 10;\nimmutable string message = \"Immutable variable\";"
  },
  {
    "language": "D",
    "code": "// Sample 16: Using Associative Arrays\nimport std.stdio;\nvoid main() {\n    int[string] ages;\n    ages[\"Alice\"] = 30;\n    ages[\"Bob\"] = 25;\n    writeln(ages[\"Alice\"]);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 17: Using Ternary Operator\nint x = 5;\nstring result = x > 0 ? \"Positive\" : \"Negative or Zero\";"
  },
  {
    "language": "D",
    "code": "// Sample 18: Using Static Arrays\nint[3] numbers = [1, 2, 3];"
  },
  {
    "language": "D",
    "code": "// Sample 19: Using Inheritance\nclass Animal {\n    void makeSound() {\n        writeln(\"Some sound\");\n    }\n}\nclass Dog : Animal {\n    override void makeSound() {\n        writeln(\"Bark\");\n    }\n}\nAnimal animal = new Dog();\nanimal.makeSound();"
  },
  {
    "language": "D",
    "code": "// Sample 20: Using UDAs (User-Defined Attributes)\n@safe\nvoid safeFunction() {\n    // Safe code\n}"
  },
  {
    "language": "D",
    "code": "// Sample 21: Using BigInt for Large Integers\nimport std.bigint;\nBigInt big = 12345678901234567890;"
  },
  {
    "language": "D",
    "code": "// Sample 22: Using UDAs with Parameters\n@system(\"Windows\")\nvoid windowsFunction() {\n    // Windows-specific code\n}"
  },
  {
    "language": "D",
    "code": "// Sample 23: Using AA Literals\nimport std.stdio;\nvoid main() {\n    int[string] ages = [\"Alice\": 30, \"Bob\": 25];\n    writeln(ages[\"Alice\"]);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 24: Using Lazy Initialization\nlazy int lazyVar = 10;"
  },
  {
    "language": "D",
    "code": "// Sample 25: Using Nullable Types\nint? nullableVar = 5;\nif (nullableVar !is null) {\n    writeln(\"Value is not null\");\n}"
  },
  {
    "language": "D",
    "code": "// Sample 26: Using Alias This\nstruct Point {\n    int x;\n    int y;\n    alias x this;\n}\nPoint p;\np = 5;"
  },
  {
    "language": "D",
    "code": "// Sample 27: Using CTFE (Compile-Time Function Execution)\nint square(int x) {\n    return x * x;\n}\nenum result = square(5);"
  },
  {
    "language": "D",
    "code": "// Sample 28: Using Unit Tests\nimport std.datetime;\nvoid testDateTime() {\n    assert(DateTime.currCentury == 21);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 29: Using OpDispatch for Operator Overloading\nstruct Vector {\n    int x, y;\n    Vector opBinary(string op)(Vector v) if (op == \"+\") {\n        return Vector(x + v.x, y + v.y);\n    }\n}\nVector v1 = Vector(1, 2);\nVector v2 = Vector(3, 4);\nVector result = v1 + v2;"
  },
  {
    "language": "D",
    "code": "// Sample 30: Using Contracts\nint divide(int a, int b) in {\n    assert(b != 0);\n} out {\n    assert(return * b == a);\n} body {\n    return a / b;\n}"
  },
  {
    "language": "D",
    "code": "// Sample 31: Using Version Blocks\nversion (Windows) {\n    // Windows-specific code\n}"
  },
  {
    "language": "D",
    "code": "// Sample 32: Using Meta Programming with Mixins\nmixin template Print(int value) {\n    pragma(msg, \"Value is: \", value);\n}\nvoid main() {\n    mixin Print!(42);\n}"
  },
  {
    "language": "D",
    "code": "// Sample 33: Using IIFEs (Immediately Invoked Function Expressions)\nint result = (() { return 10 * 2; })();"
  },
  {
    "language": "D",
    "code": "// Sample 34: Using Shared Libraries\nextern (C) {\n    void someFunction() {\n        // C function implementation\n    }\n}"
  },
  {
    "language": "D",
    "code": "// Sample 35: Using Closures\nint closure() {\n    int counter = 0;\n    return (){ return counter++; };\n}\nauto func = closure();\nwriteln(func());"
  },
  {
    "language": "D",
    "code": "// Sample 36: Using Template Constraints\nstruct Container(T) if (isNumeric!T) {\n    T value;\n}\nContainer!int container;"
  },
  {
    "language": "D",
    "code": "// Sample 37: Using opIndex for Custom Indexing\nstruct CustomArray {\n    int[10] internalArray;\n    int opIndex(size_t index) const {\n        return internalArray[index];\n    }\n}\nCustomArray arr;\nint value = arr[5];"
  },
  {
    "language": "D",
    "code": "// Sample 38: Using opApply for Iteration\nstruct MyRange {\n    int front() { /* implementation */ }\n    bool empty() { /* implementation */ }\n    void popFront() { /* implementation */ }\n    int opApply(int delegate(int) dg) {\n        int result;\n        while (!empty()) {\n            result = dg(front());\n            popFront();\n        }\n        return result;\n    }\n}\nMyRange range;\nint sum = 0;\nrange.opApply((int value) { sum += value; return 0; });"
  },
  {
    "language": "D",
    "code": "// Sample 41: Using Classes and Objects\nclass Person {\n    string name;\n    int age;\n    this(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    void greet() {\n        writeln(\"Hello, I'm \", name);\n    }\n}\nPerson person = new Person(\"Alice\", 30);\nperson.greet();"
  },
  {
    "language": "D",
    "code": "// Sample 42: Using Templates for Generic Programming\nstruct Pair(T, U) {\n    T first;\n    U second;\n    this(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\nPair!int stringPair = Pair!int(\"Hello\", 5);\nimport std.stdio;\nwriteln(stringPair.first, \" - \", stringPair.second);"
  },
  {
    "language": "D",
    "code": "// Sample 43: File I/O Operations\nimport std.file;\nstring content = readText(\"input.txt\");\nwrite(\"output.txt\", content);"
  },
  {
    "language": "D",
    "code": "// Sample 44: Using Enumerations\nenum Color { Red, Green, Blue }\nColor color = Color.Red;\nimport std.stdio;\nwriteln(color);"
  },
  {
    "language": "D",
    "code": "// Sample 45: Working with Arrays\nint[] numbers = [1, 2, 3, 4, 5];\nimport std.algorithm;\nauto sum = reduce(numbers, 0, (a, b) => a + b);\nimport std.stdio;\nwriteln(\"Sum: \", sum);"
  },
  {
    "language": "D",
    "code": "// Sample 46: Using Destructuring\nauto tuple = tuple(\"Alice\", 30);\nstring name;\nint age;\ntie(name, age) = tuple;\nimport std.stdio;\nwriteln(name, \" - \", age);"
  },
  {
    "language": "D",
    "code": "// Sample 47: Using Exceptions\ntry {\n    int result = 10 / 0;\n} catch (Exception e) {\n    import std.stdio;\n    writeln(\"Error: Division by zero\");\n}"
  },
  {
    "language": "TCL",
    "code": "# Working with JSON data using 'json' package\npackage require json\nset data {\"name\": \"John\", \"age\": 25}\nset jsonData [json::json2dict $data]\nputs \"Name: $jsonData(name), Age: $jsonData(age)\""
  },
  {
    "language": "TCL",
    "code": "# Working with XML data using 'dom' package\npackage require dom\nset xmlData \"<person><name>John</name><age>30</age></person>\"\nset xmlDoc [dom parse $xmlData]\nset name [$xmlDoc selectNodes {/person/name}]\nset age [$xmlDoc selectNodes {/person/age}]\nputs \"Name: [$name]\", \"Age: [$age]\""
  },
  {
    "language": "TCL",
    "code": "# Using 'http' package for HTTP requests\npackage require http\nset url \"https://api.example.com/data\"\\set response [http::geturl $url]\nset data [http::data $response]\nhttp::cleanup $response\nputs \"Response: $data\""
  },
  {
    "language": "TCL",
    "code": "# Working with SQLite database using 'sqlite3' package\npackage require sqlite3\nset db [sqlite3 db example.db]\n$db eval {\n    CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);\n    INSERT INTO users (name, age) VALUES ('Alice', 28), ('Bob', 35);\n}\nset result [$db eval {SELECT * FROM users}]\nputs \"Database Result: $result\"\n$db close"
  },
  {
    "language": "TCL",
    "code": "# Using 'csv' package to read and write CSV files\npackage require csv\nset csvData \"name,age\nAlice,25\nBob,30\"\nset records [csv::parse $csvData]\nputs \"CSV Records: $records\"\nset csvContent [csv::format $records]\nputs \"CSV Content: $csvContent\""
  },
  {
    "language": "TCL",
    "code": "# Working with regular expressions using 'regexp' package\nset text \"Tcl is a scripting language\"\nif {[regexp {scripting} $text]} {\n    puts \"Text contains 'scripting'\"\n} else {\n    puts \"Text does not contain 'scripting'\"\n}"
  },
  {
    "language": "TCL",
    "code": "# Using 'struct::stack' package for stack operations\npackage require struct::stack\nset stack [struct::stack]\n$stack push 1\n$stack push 2\n$stack push 3\nputs \"Top element of the stack: [$stack top]\""
  },
  {
    "language": "TCL",
    "code": "# Performing base64 encoding and decoding using 'base64' package\npackage require base64\nset originalText \"Hello, World!\"\nset encodedText [base64::encode $originalText]\nset decodedText [base64::decode $encodedText]\nputs \"Encoded Text: $encodedText\"\nputs \"Decoded Text: $decodedText\""
  },
  {
    "language": "TCL",
    "code": "# Using 'Tk' package for creating a simple GUI\npackage require Tk\n\n# Create a simple window\nwm title . \"Tk GUI\"\nlabel .label -text \"Hello, Tk!\" -font {Helvetica 16 bold}\npack .label -padx 20 -pady 20"
  },
  {
    "language": "TCL",
    "code": "# Creating and using a custom 'math' package\npackage provide math 1.0\n\nnamespace eval ::math {\n    proc add {a b} {\n        expr {$a + $b}\n    }\n    proc subtract {a b} {\n        expr {$a - $b}\n    }\n}\n\nputs \"Sum: [::math::add 5 3]\""
  },
  {
    "language": "TCL",
    "code": "# Using 'Tktable' package for creating a table in Tk GUI\npackage require Tk\npackage require Tktable\n\n# Create a table\ntable .table -rows 3 -cols 3\n.table put 0 0 \"Name\"\n.table put 0 1 \"Age\"\n.table put 1 0 \"Alice\"\n.table put 1 1 25\n.table put 2 0 \"Bob\"\n.table put 2 1 30\npack .table -padx 20 -pady 20"
  },
  {
    "language": "TCL",
    "code": "# Parallel processing with 'thread' package\npackage require thread\nset result [thread::send -async [thread::create] {\n    set x 5\n    set y 10\n    expr {$x + $y}\n}]\nthread::wait\nputs \"Result: $result\""
  },
  {
    "language": "TCL",
    "code": "# Generating Fibonacci sequence using recursion\nproc fibonacci {n} {\n    if {$n == 0} {\n        return 0\n    } elseif {$n == 1} {\n        return 1\n    } else {\n        return [expr {[fibonacci [expr $n - 1]] + [fibonacci [expr $n - 2]]}]\n    }\n}\nset fib_sequence [list]\nfor {set i 0} {$i < 10} {incr i} {\n    lappend fib_sequence [fibonacci $i]\n}\nputs \"Fibonacci Sequence: $fib_sequence\""
  },
  {
    "language": "TCL",
    "code": "# Matrix multiplication using nested loops\nproc matrix_multiply {matrix1 matrix2} {\n    set result {}\n    for {set i 0} {$i < [llength $matrix1]} {incr i} {\n        set row {}\n        for {set j 0} {$j < [llength [lindex $matrix2 0]]} {incr j} {\n            set sum 0\n            for {set k 0} {$k < [llength [lindex $matrix1 0]]} {incr k} {\n                set sum [expr {$sum + [lindex $matrix1 $i $k] * [lindex $matrix2 $k $j]}]\n            }\n            lappend row $sum\n        }\n        lappend result $row\n    }\n    return $result\n}\nset matrix1 {{1 2} {3 4}}\nset matrix2 {{5 6} {7 8}}\nset result_matrix [matrix_multiply $matrix1 $matrix2]\nputs \"Result Matrix: $result_matrix\""
  },
  {
    "language": "TCL",
    "code": "# Creating a simple web server using 'http' package\npackage require http\nhttp::config -reuseaddr true\nset server [http::create -type command -handler {\n    proc handle_request {sock addr port} {\n        set response \"HTTP/1.0 200 OK\nContent-type: text/html\n\n<html><body><h1>Hello, World!</h1></body></html>\"\n        puts $sock $response\n        flush $sock\n        close $sock\n    }\n} -port 8080]\nputs \"Web server running on port 8080\""
  },
  {
    "language": "TCL",
    "code": "# Creating and using a custom 'matrix' package\npackage provide matrix 1.0\n\nnamespace eval ::matrix {\n    proc multiply {matrix1 matrix2} {\n        set result {}\n        for {set i 0} {$i < [llength $matrix1]} {incr i} {\n            set row {}\n            for {set j 0} {$j < [llength [lindex $matrix2 0]]} {incr j} {\n                set sum 0\n                for {set k 0} {$k < [llength [lindex $matrix1 0]]} {incr k} {\n                    set sum [expr {$sum + [lindex $matrix1 $i $k] * [lindex $matrix2 $k $j]}]\n                }\n                lappend row $sum\n            }\n            lappend result $row\n        }\n        return $result\n    }\n}\n\nset matrix1 {{1 2} {3 4}}\nset matrix2 {{5 6} {7 8}}\nset result_matrix [::matrix::multiply $matrix1 $matrix2]\nputs \"Result Matrix: $result_matrix\""
  },
  {
    "language": "TCL",
    "code": "# Creating a simple chat server using 'socket' package\npackage require socket\n\nproc handle_client {sock addr port} {\n    fileevent $sock readable [list handle_read $sock]\n}\n\nproc handle_read {sock} {\n    set data [read $sock]\n    puts \"Received: $data\"\n    puts $sock \"Server received: $data\"\n    flush $sock\n}\n\nset server_socket [socket -server handle_client 12345]\nputs \"Chat server running on port 12345\""
  },
  {
    "language": "TCL",
    "code": "# Creating a simple genetic algorithm\nset target \"Hello, World!\"\nset population_size 100\nset mutation_rate 0.01\n\nproc generate_random_string {length} {\n    set result \"\"\n    for {set i 0} {$i < $length} {incr i} {\n        append result [format %c [expr {rand() * 94 + 32}]]\n    }\n    return $result\n}\n\nproc calculate_fitness {individual target} {\n    set fitness 0\n    for {set i 0} {$i < [string length $target]} {incr i} {\n        if {[string index $individual $i] eq [string index $target $i]} {\n            incr fitness\n        }\n    }\n    return $fitness\n}\n\nproc crossover {parent1 parent2} {\n    set midpoint [expr {int(rand() * [string length $parent1])}]\n    set child [string range $parent1 0 $midpoint][string range $parent2 $midpoint end]\n    return $child\n}\n\nproc mutate {child mutation_rate} {\n    set mutated \"\"\n    foreach char [split $child {}] {\n        if {rand() < $mutation_rate} {\n            append mutated [format %c [expr {rand() * 94 + 32}]]\n        } else {\n            append mutated $char\n        }\n    }\n    return $mutated\n}\n\nset population [list]\nfor {set i 0} {$i < $population_size} {incr i} {\n    lappend population [generate_random_string [string length $target]]\n}\n\nwhile {1} {\n    set fitness_scores [list]\n    foreach individual $population {\n        lappend fitness_scores [calculate_fitness $individual $target]\n    }\n\n    set max_fitness [lindex $fitness_scores [lsearch -max $fitness_scores 0]]\n    set max_fitness_individual [lindex $population [lsearch $fitness_scores $max_fitness]]\n\n    if {$max_fitness == [string length $target]} {\n        puts \"Solution found: $max_fitness_individual\"\n        break\n    }\n\n    set mating_pool [list]\n    for {set i 0} {$i < $population_size} {incr i} {\n        set partner1 [lindex $population [expr {int(rand() * $population_size)}]]\n        set partner2 [lindex $population [expr {int(rand() * $population_size)}]]\n        set parent1 [lindex $population [lsearch $fitness_scores [calculate_fitness $partner1 $target]]]\n        set parent2 [lindex $population [lsearch $fitness_scores [calculate_fitness $partner2 $target]]]\n        set child [mutate [crossover $parent1 $parent2] $mutation_rate]\n        lappend mating_pool $child\n    }\n\n    set population $mating_pool\n}\n"
  },
  {
    "language": "TCL",
    "code": "# Using 'Expect' for automation\npackage require Expect\n\nset username \"your_username\"\nset password \"your_password\"\nset hostname \"remote_server\"\n\nspawn ssh $username@$hostname\nexpect \"password:\"\nsend \"$password\\r\"\nexpect \"$username@$hostname\"\nsend \"ls -l\\r\"\nexpect \"$username@$hostname\"\nputs \"Command output: $expect_out(buffer)\"\nclose"
  },
  {
    "language": "TCL",
    "code": "# Solving the N-Queens problem using backtracking\nproc print_board {board} {\n    for {set i 0} {$i < [llength $board]} {incr i} {\n        set row [lindex $board $i]\n        puts [join [lreplace $row $i $i {Q}] \" \"]\n    }\n    puts \"\"\n}\n\nproc is_safe {board row col} {\n    # Check if there is a queen in the same column\n    for {set i 0} {$i < $row} {incr i} {\n        if {[lindex $board $i] eq $col} {\n            return 0\n        }\n    }\n\n    # Check if there is a queen in the upper-left diagonal\n    for {set i $row set j $col} {$i >= 0 && $j >= 0} {incr i -1; incr j -1} {\n        if {[lindex $board $i] eq $j} {\n            return 0\n        }\n    }\n\n    # Check if there is a queen in the lower-left diagonal\n    for {set i $row set j $col} {$i >= 0 && $j < [llength $board]} {incr i -1; incr j} {\n        if {[lindex $board $i] eq $j} {\n            return 0\n        }\n    }\n\n    return 1\n}\n\nproc solve_nqueens {board row} {\n    if {$row == [llength $board]} {\n        # All queens are placed successfully\n        print_board $board\n    } else {\n        for {set i 0} {$i < [llength $board]} {incr i} {\n            if {[is_safe $board $row $i]} {\n                set new_board [lreplace $board $row $row $i]\n                solve_nqueens $new_board [expr $row + 1]\n            }\n        }\n    }\n}\n\nset board {0 0 0 0 0 0 0 0}\nsolve_nqueens $board 0"
  },
  {
    "language": "TCL",
    "code": "# Using 'snack' package for creating a simple GUI with sound\npackage require snack\n\n# Create a simple window with a button\nbutton .b -text \"Play Sound\" -command {\n    snack::sound s\n    s configure -file [tk_getOpenFile -filetypes {{Wave files {.wav}} {All file {*}}}] -format wav\n    s play\n}\npack .b -padx 20 -pady 20"
  }
]